declare module "wix-events.v2" {
  interface EventGuest {
      /** Guest ID. */
      _id?: string | null;
      /** Event ID. */
      eventId?: string | null;
      /** RSVP ID. <br/> <br/> **Note:** Only applicable when `guestType` is `RSVP`. */
      rsvpId?: string | null;
      /** Order number. <br/> <br/> **Note:** Only applicable when `guestType` is `BUYER` or `TICKET_HOLDER`. */
      orderNumber?: string | null;
      /** Ticket number. <br/> <br/> **Note:** Only applicable when `guestType` is `TICKET_HOLDER`. */
      ticketNumber?: string | null;
      /** List of names, numbers, and definition IDs for each ticket. */
      tickets?: TicketDetails$2[];
      /** Guest's contact ID. See [Contacts API](https://dev.wix.com/api/rest/contacts/contacts/contacts-v4) for more details. */
      contactId?: string | null;
      /** Guest details. <br/> <br/> Returned only when the `guestDetails` fieldset is sent in the request. */
      guestDetails?: GuestDetails$2;
      /** Attendance status. The attendance status updates based on status values in an RSVP object (for RSVP events) or in an Order object (for ticketed events). For more information read [this article](https://dev.wix.com/docs/rest/business-solutions/events/event-guests/guest-attendance-status-mapping). <br/> <br/> **Note:** For `guestType` `BUYER` or `TICKET_HOLDER` the `IN_WAITLIST` value is not applicable. */
      attendanceStatus?: AttendanceStatus;
      /** Secondary language code in [ISO 639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format. Used when the event ticket should be translated into another language. */
      secondaryLanguageCode?: string | null;
      /** Date and time the guest was created in `yyyy-mm-ddThh:mm:sssZ` format. */
      _createdDate?: Date | null;
      /** Date and time the guest was updated in `yyyy-mm-ddThh:mm:sssZ` format. */
      _updatedDate?: Date | null;
      /** Date and time of guest's latest attendance status update. */
      attendanceStatusUpdatedDate?: Date | null;
      /** Site member ID. */
      memberId?: string | null;
      /** Guest type. */
      guestType?: GuestType;
      /** Locale in [IETF BCP 47](https://en.wikipedia.org/wiki/IETF_language_tag) format. Used when the event date and time on a ticket should be formatted into another locale. */
      locale?: string | null;
      /**
       * Number of total guests in an event (registered guests + additional ones).
       * @readonly
       */
      totalGuests?: number | null;
      /**
       * Revision number, which increments by 1 each time the guest is updated.
       * @readonly
       */
      revision?: string | null;
  }
  interface TicketDetails$2 {
      /** Ticket number. */
      number?: string;
      /** Ticket definition ID. */
      definitionId?: string | null;
      /** Ticket name. */
      name?: string | null;
      /**
       * Ticket guest details.
       * @internal
       */
      guestDetails?: TicketGuestDetails;
  }
  interface TicketGuestDetails {
      /** The login details for the guest to access the online conference event. */
      onlineConferencingLogin?: OnlineConferencingLogin$5;
      /** First name. */
      firstName?: string | null;
      /** Last name. */
      lastName?: string | null;
  }
  interface OnlineConferencingLogin$5 {
      /**
       * Link URL to the online conference.
       * @readonly
       */
      link?: string;
      /**
       * Password for the online conference.
       * @readonly
       */
      password?: string | null;
  }
  interface GuestDetails$2 {
      /** Email. */
      email?: string | null;
      /** First name. */
      firstName?: string | null;
      /** Last name. */
      lastName?: string | null;
      /** Form response. */
      formResponse?: FormResponse$5;
      /** Whether the guest has checked into the event. */
      checkedIn?: boolean;
      /** The login details for the guest to access the online conference event. */
      onlineConferencingLogin?: OnlineConferencingLogin$5;
      /** Phone extracted from form response. If multiples phone inputs are present, first one is returned. */
      phone?: string | null;
      /** Address extracted from form response. If multiples address inputs are present, first one is returned. */
      address?: string | null;
  }
  interface FormResponse$5 {
      inputValues?: InputValue$5[];
  }
  interface InputValue$5 {
      inputName?: string;
      value?: string;
      values?: string[];
      /**
       * Int or floating point number value.
       * @internal
       */
      number?: number | null;
      /**
       * Date/time value.
       * @internal
       */
      dateTime?: Date | null;
      /**
       * Address type value.
       * @internal
       */
      address?: FormattedAddress$5;
  }
  interface FormattedAddress$5 {
      /** One line address representation. */
      formatted?: string;
      /** Address components (optional). */
      address?: Address$a;
  }
  /** Physical address */
  interface Address$a extends AddressStreetOneOf$a {
      /** Street name and number. */
      streetAddress?: StreetAddress$a;
      /** Main address line, usually street and number as free text. */
      addressLine1?: string | null;
      /** Country code. */
      country?: string | null;
      /** Subdivision shorthand. Usually, a short code (2 or 3 letters) that represents a state, region, prefecture, or province. e.g. NY */
      subdivision?: string | null;
      /** City name. */
      city?: string | null;
      /** Zip/postal code. */
      postalCode?: string | null;
      /** Free text providing more detailed address info. Usually contains Apt, Suite, and Floor. */
      addressLine2?: string | null;
      /**
       * A string containing the full address of this location.
       * @internal
       */
      formatted?: string | null;
      /**
       * Coordinates of the physical address.
       * @internal
       */
      location?: AddressLocation$a;
      /**
       * Country full name.
       * @internal
       */
      countryFullname?: string | null;
      /**
       * Subdivision full name.
       * @internal
       */
      subdivisionFullname?: string | null;
      /**
       * Multi-level subdivisions from top to bottom.
       * @internal
       */
      subdivisions?: Subdivision$a[];
  }
  /** @oneof */
  interface AddressStreetOneOf$a {
      /** Street name and number. */
      streetAddress?: StreetAddress$a;
      /** Main address line, usually street and number as free text. */
      addressLine?: string | null;
  }
  interface StreetAddress$a {
      /** Street number. */
      number?: string;
      /** Street name. */
      name?: string;
      /**
       * Apartment number.
       * @internal
       */
      apt?: string;
      /**
       * Optional address line 1
       * @internal
       */
      formattedAddressLine?: string | null;
  }
  interface AddressLocation$a {
      /** Address latitude. */
      latitude?: number | null;
      /** Address longitude. */
      longitude?: number | null;
  }
  interface Subdivision$a {
      /** Short subdivision code. */
      code?: string;
      /** Subdivision full name. */
      name?: string;
      /**
       * Subdivision level
       * @internal
       */
      type?: SubdivisionType$a;
      /**
       * Free text description of subdivision type.
       * @internal
       */
      typeInfo?: string | null;
      /**
       * Standard organizations details (e.g. ISO).
       * @internal
       */
      standardDetails?: StandardDetails$5;
  }
  enum SubdivisionType$a {
      UNKNOWN_SUBDIVISION_TYPE = "UNKNOWN_SUBDIVISION_TYPE",
      /** State */
      ADMINISTRATIVE_AREA_LEVEL_1 = "ADMINISTRATIVE_AREA_LEVEL_1",
      /** County */
      ADMINISTRATIVE_AREA_LEVEL_2 = "ADMINISTRATIVE_AREA_LEVEL_2",
      /** City/town */
      ADMINISTRATIVE_AREA_LEVEL_3 = "ADMINISTRATIVE_AREA_LEVEL_3",
      /** Neighborhood/quarter */
      ADMINISTRATIVE_AREA_LEVEL_4 = "ADMINISTRATIVE_AREA_LEVEL_4",
      /** Street/block */
      ADMINISTRATIVE_AREA_LEVEL_5 = "ADMINISTRATIVE_AREA_LEVEL_5",
      /** ADMINISTRATIVE_AREA_LEVEL_0. Indicates the national political entity, and is typically the highest order type returned by the Geocoder. */
      COUNTRY = "COUNTRY"
  }
  /** Subdivision Concordance values */
  interface StandardDetails$5 {
      /** subdivision iso-3166-2 code according to [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). e.g. US-NY, GB-SCT, NO-30 */
      iso31662?: string | null;
  }
  enum AttendanceStatus {
      /** Not attending. */
      NOT_ATTENDING = "NOT_ATTENDING",
      /** Attending. */
      ATTENDING = "ATTENDING",
      /** In a waiting list. */
      IN_WAITLIST = "IN_WAITLIST"
  }
  enum GuestType {
      /** An invited guest, no ticket necessary. */
      RSVP = "RSVP",
      /** The guest who bought the ticket. */
      BUYER = "BUYER",
      /** The guest for whom the ticket was bought. */
      TICKET_HOLDER = "TICKET_HOLDER"
  }
  interface GuestCountUpdated {
      /** Guest. */
      guest?: EventGuest;
      /** Guest count updates. */
      guestCountUpdates?: GuestCountUpdate[];
  }
  interface GuestCountUpdate {
      /** Attendance status. */
      attendanceStatus?: AttendanceStatus;
      /** Total guest count change. */
      totalGuestsDelta?: number;
      /** Guest count change. */
      countDelta?: number;
  }
  interface MemberEventStatusUpdated {
      /** Event id. */
      eventId?: string | null;
      /** Member id. */
      memberId?: string | null;
      /** Member event status. */
      status?: MemberEventStatusUpdatedEventType;
  }
  enum MemberEventStatusUpdatedEventType {
      /**
       * Triggered every time a guest with a specified member ID is added to the event.
       * This event can also be triggered if an existing guest changed their member ID.
       */
      MEMBER_JOINED = "MEMBER_JOINED",
      /**
       * Triggered every time a guest with a specified member ID is removed from the event.
       * This event can also be triggered if an existing guest changed their member ID.
       */
      MEMBER_LEFT = "MEMBER_LEFT",
      /**
       * Triggered every time a guest with a specified member ID whose status is `ATTENDING` is added to the event.
       * This event can also be triggered if an existing guest changed their member ID or changed their status to `ATTENDING`.
       */
      ATTENDING_MEMBER_JOINED = "ATTENDING_MEMBER_JOINED",
      /**
       * Triggered when the last guest with a specified member ID is removed from the event or their status changes to `ATTENDING`.
       * Once triggered there are no more attending guests with a specified member ID in the event.
       * This event can also be triggered if the last existing guest changed their member ID or their status to `NOT_ATTENDING`.
       */
      LAST_ATTENDING_MEMBER_LEFT = "LAST_ATTENDING_MEMBER_LEFT"
  }
  interface ContactEventStatusUpdated {
      /** Event id. */
      eventId?: string | null;
      /** Contact id. */
      contactId?: string | null;
      /** Contact event status. */
      status?: EventType$5;
  }
  enum EventType$5 {
      /**
       * Triggered every time a guest with a specified contact ID is added to the event.
       * This event can also be triggered if an existing guest changed their contact ID.
       */
      CONTACT_JOINED = "CONTACT_JOINED",
      /**
       * Triggered every time a guest with a specified contact ID is removed from the event.
       * This event can also be triggered if an existing guest changed their contact ID.
       */
      CONTACT_LEFT = "CONTACT_LEFT",
      /**
       * Triggred when the last guest with a specified contact ID is removed from the event.
       * Once triggered there are no more guests with a specified contact ID in the event.
       * This event can also be triggered if the last existing guest changed their contact ID.
       */
      LAST_CONTACT_LEFT = "LAST_CONTACT_LEFT"
  }
  interface GuestCheckedIn {
      /** Event guest */
      guest?: EventGuest;
      /** Event details */
      eventDetails?: EventDetails$1;
  }
  interface EventDetails$1 {
      /**
       * Event title.
       * @readonly
       */
      title?: string | null;
      /**
       * Event short description.
       * @readonly
       */
      shortDescription?: string | null;
      /**
       * Event location.
       * @readonly
       */
      location?: Location$7;
      /**
       * Event date  and time settings.
       * @readonly
       */
      dateAndTimeSettings?: DateAndTimeSettings$2;
      /**
       * Event page URL components.
       * @readonly
       */
      eventPageUrl?: string;
      /**
       * Event status.
       * @readonly
       */
      status?: Status$8;
  }
  interface Location$7 {
      /** Location name. This value is displayed instead of the address when the location is defined as TBD by setting the `locationTbd` property to `true`. */
      name?: string | null;
      /** Location type. */
      type?: LocationType$7;
      /** Exact location address. */
      address?: CommonAddress$4;
      /** Whether the event location is TBD. */
      locationTbd?: boolean | null;
  }
  enum LocationType$7 {
      /** Unknown location type. */
      UNKNOWN_LOCATION = "UNKNOWN_LOCATION",
      /** Event is on-site at a specific physical location. */
      VENUE = "VENUE",
      /** Event is online, such as a virtual video conference. */
      ONLINE = "ONLINE"
  }
  /** Physical address */
  interface CommonAddress$4 extends CommonAddressStreetOneOf$4 {
      /** Street address. */
      streetAddress?: CommonStreetAddress$4;
      /** Primary address information (street and building number). */
      addressLine1?: string | null;
      /** 2-letter country code in [ISO-3166 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2#Officially_assigned_code_elements) format. */
      country?: string | null;
      /** Code for a subdivision (such as state, prefecture, or province) in [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). */
      subdivision?: string | null;
      /** City name. */
      city?: string | null;
      /** Zip or postal code. */
      postalCode?: string | null;
      /** Secondary address information (suite or apartment number and room number). */
      addressLine2?: string | null;
      /**
       * A string containing the full address of this location.
       * @internal
       */
      formatted?: string | null;
      /**
       * Coordinates of the physical address.
       * @internal
       */
      location?: CommonAddressLocation$4;
      /**
       * Country full name.
       * @internal
       */
      countryFullname?: string | null;
      /**
       * Subdivision full name.
       * @internal
       */
      subdivisionFullname?: string | null;
      /**
       * Multi-level subdivisions from top to bottom.
       * @internal
       */
      subdivisions?: CommonSubdivision$4[];
  }
  /** @oneof */
  interface CommonAddressStreetOneOf$4 {
      /** Street address. */
      streetAddress?: CommonStreetAddress$4;
      /** Primary address information (street and building number). */
      addressLine?: string | null;
  }
  interface CommonStreetAddress$4 {
      /** Street number. */
      number?: string;
      /** Street name. */
      name?: string;
      /**
       * Apartment number.
       * @internal
       */
      apt?: string;
      /**
       * Optional address line 1
       * @internal
       */
      formattedAddressLine?: string | null;
  }
  interface CommonAddressLocation$4 {
      /** Address latitude coordinates. */
      latitude?: number | null;
      /** Address longitude coordinates. */
      longitude?: number | null;
  }
  interface CommonSubdivision$4 {
      /** Short subdivision code. */
      code?: string;
      /** Subdivision full name. */
      name?: string;
      /**
       * Subdivision level
       * @internal
       */
      type?: SubdivisionSubdivisionType$2;
      /**
       * Free text description of subdivision type.
       * @internal
       */
      typeInfo?: string | null;
  }
  enum SubdivisionSubdivisionType$2 {
      UNKNOWN_SUBDIVISION_TYPE = "UNKNOWN_SUBDIVISION_TYPE",
      /** State */
      ADMINISTRATIVE_AREA_LEVEL_1 = "ADMINISTRATIVE_AREA_LEVEL_1",
      /** County */
      ADMINISTRATIVE_AREA_LEVEL_2 = "ADMINISTRATIVE_AREA_LEVEL_2",
      /** City/town */
      ADMINISTRATIVE_AREA_LEVEL_3 = "ADMINISTRATIVE_AREA_LEVEL_3",
      /** Neighborhood/quarter */
      ADMINISTRATIVE_AREA_LEVEL_4 = "ADMINISTRATIVE_AREA_LEVEL_4",
      /** Street/block */
      ADMINISTRATIVE_AREA_LEVEL_5 = "ADMINISTRATIVE_AREA_LEVEL_5",
      /** ADMINISTRATIVE_AREA_LEVEL_0. Indicates the national political entity, and is typically the highest order type returned by the Geocoder. */
      COUNTRY = "COUNTRY"
  }
  interface DateAndTimeSettings$2 {
      /** Whether the event date and time are TBD. */
      dateAndTimeTbd?: boolean | null;
      /** Message that is displayed when time and date is TBD. */
      dateAndTimeTbdMessage?: string | null;
      /** Event start date. */
      startDate?: Date | null;
      /** Event end date. */
      endDate?: Date | null;
      /** Event time zone ID in the [TZ database](https://www.iana.org/time-zones) format. */
      timeZoneId?: string | null;
      /** Whether the end date is hidden in the formatted date and time. */
      hideEndDate?: boolean | null;
      /** Whether the time zone is displayed in the formatted schedule. */
      showTimeZone?: boolean | null;
      /**
       * Repeating event status.
       * @readonly
       */
      recurrenceStatus?: RecurrenceStatusStatus$2;
      /** Event repetitions. */
      recurringEvents?: Recurrences$7;
      /** Formatted date and time settings. */
      formatted?: Formatted$2;
  }
  enum RecurrenceStatusStatus$2 {
      /** Unknown recurrance status. */
      UNKNOWN_STATUS = "UNKNOWN_STATUS",
      /** Event happens only once and can last multiple days. */
      ONE_TIME = "ONE_TIME",
      /** A series of events that repeat. */
      RECURRING = "RECURRING",
      /** Next event in a schedule of recurring events. */
      RECURRING_UPCOMING = "RECURRING_UPCOMING",
      /** Latest event that ended in a schedule of recurring events. */
      RECURRING_RECENTLY_ENDED = "RECURRING_RECENTLY_ENDED",
      /** Latest canceled event in a schedule of recurring events */
      RECURRING_RECENTLY_CANCELED = "RECURRING_RECENTLY_CANCELED"
  }
  interface Recurrences$7 {
      /** Individual event dates. */
      individualEventDates?: Occurrence$7[];
      /**
       * Recurring event category ID.
       * @readonly
       */
      categoryId?: string | null;
  }
  interface Occurrence$7 {
      /** Event start date. */
      startDate?: Date | null;
      /** Event end date. */
      endDate?: Date | null;
      /** Event time zone ID in the [TZ database](https://www.iana.org/time-zones) format. */
      timeZoneId?: string | null;
      /** Whether the time zone is displayed in a formatted schedule. */
      showTimeZone?: boolean;
  }
  interface Formatted$2 {
      /**
       * Formatted date and time representation. <br>
       * Example of formatting when an event lasts multiple days and is in the UTC time zone: `September 1, 2015 at 10:20 AM – September 5, 2015 at 12:14 PM`. <br>
       * Example of formatting when an event lasts 1 day and is in the GMT+2 time zone: `February 1, 2018, 12:10 – 2:50 PM GMT+2`.
       * @readonly
       */
      dateAndTime?: string | null;
      /**
       * Formatted start date of the event. Empty for TBD schedules.
       * @readonly
       */
      startDate?: string | null;
      /**
       * Formatted start time of the event. Empty for TBD schedules.
       * @readonly
       */
      startTime?: string | null;
      /**
       * Formatted end date of the event. Empty for TBD schedules or when the end date is hidden.
       * @readonly
       */
      endDate?: string | null;
      /**
       * Formatted end time of the event. Empty for TBD schedules or when the end date is hidden.
       * @readonly
       */
      endTime?: string | null;
  }
  enum Status$8 {
      /** Unknown event status. */
      UNKNOWN_EVENT_STATUS = "UNKNOWN_EVENT_STATUS",
      /** Event is published and scheduled to start. */
      UPCOMING = "UPCOMING",
      /** Event has started. */
      STARTED = "STARTED",
      /** Event has ended. */
      ENDED = "ENDED",
      /** Event is canceled. */
      CANCELED = "CANCELED",
      /** Event is not public. */
      DRAFT = "DRAFT"
  }
  interface NotifyGuestAction {
      /** Event guest. */
      guest?: EventGuest;
      /** Task context. */
      taskContext?: TaskContext;
  }
  interface TaskContext {
      /** Task id. */
      _id?: string | null;
      /** Notify action type. */
      type?: NotifyActionType;
      /** Timing. Used for EVENT_STARTS */
      timing?: Timing;
      /** Event context. */
      event?: EventDetails$1;
      /** Order context. */
      order?: OrderDetails;
  }
  enum NotifyActionType {
      UNKNOWN = "UNKNOWN",
      EMAIL = "EMAIL",
      AUTOMATION_TRIGGER = "AUTOMATION_TRIGGER",
      PUSH = "PUSH",
      EVENT_CANCELED = "EVENT_CANCELED",
      EVENT_STARTS = "EVENT_STARTS",
      ORDER_CANCELED = "ORDER_CANCELED"
  }
  enum Timing {
      /** Unknown event start time. */
      UNKNOWN_TIMING = "UNKNOWN_TIMING",
      /** Instant. */
      NOW = "NOW",
      /** 24 hours prior. */
      STARTS_IN_1_DAY = "STARTS_IN_1_DAY",
      /** 3 days prior. */
      STARTS_IN_3_DAYS = "STARTS_IN_3_DAYS",
      /** 7 days prior. */
      STARTS_IN_1_WEEK = "STARTS_IN_1_WEEK",
      /** 1 hour prior. */
      STARTS_IN_1_HOUR = "STARTS_IN_1_HOUR",
      /** 30 minutes prior. */
      STARTS_IN_30_MINUTES = "STARTS_IN_30_MINUTES",
      /** 2 hours prior. */
      STARTS_IN_2_HOURS = "STARTS_IN_2_HOURS"
  }
  interface OrderDetails {
      /** Order status */
      orderStatus?: OrderStatus$3;
      /** Invoice */
      invoice?: Invoice$2;
  }
  enum OrderStatus$3 {
      /** Order status not available for this request fieldset. */
      NA_ORDER_STATUS = "NA_ORDER_STATUS",
      /** Order is confirmed and payment isn't required. */
      FREE = "FREE",
      /** Order is paid for but the payment gateway has suspended the payment. */
      PENDING = "PENDING",
      /** Order is paid via a payment gateway. */
      PAID = "PAID",
      /** Order is confirmed but must be paid via offline payment. Status needs to be manually updated to `PAID`. */
      OFFLINE_PENDING = "OFFLINE_PENDING",
      /** Order is awaiting payment at the cashier. */
      INITIATED = "INITIATED",
      /** Order is canceled. */
      CANCELED = "CANCELED",
      /** Order payment is declined. */
      DECLINED = "DECLINED",
      /** Order payment is authorized. */
      AUTHORIZED = "AUTHORIZED",
      /** Order payment is voided. */
      VOIDED = "VOIDED",
      /** Order is partially paid with less than the total amount. */
      PARTIALLY_PAID = "PARTIALLY_PAID"
  }
  interface Invoice$2 {
      items?: Item$3[];
      /**
       * Total cart amount.
       * @deprecated
       */
      total?: Money$8;
      /** Discount applied to cart. */
      discount?: Discount$2;
      /** Tax applied to cart. */
      tax?: Tax$2;
      /** Total cart amount before discount, tax, and fees. */
      subTotal?: Money$8;
      /**
       * Total amount of cart after discount, tax, and fees.
       * Grand total is calculated in the following order:
       * 1. Total prices of all items in the cart are calculated.
       * 2. Discount is subtracted from the cart (if applicable).
       * 3. Tax is added (if applicable).
       * 4. Wix ticket service fee is added.
       */
      grandTotal?: Money$8;
      /**
       * Fees applied to the cart.
       * @readonly
       */
      fees?: Fee$2[];
      /** Total revenue, excluding fees. (Taxes and payment provider fees are not deducted). */
      revenue?: Money$8;
      /** URL to invoice preview. Returned only if order is paid. */
      previewUrl?: string | null;
  }
  interface Item$3 {
      /** Unique line item ID. */
      _id?: string;
      /** Line item quantity. */
      quantity?: number;
      /** Line item name. */
      name?: string;
      /** Line item price. */
      price?: Money$8;
      /** Total price for line items. Always equal to price * quantity. */
      total?: Money$8;
      /** Discount applied to the line item. */
      discount?: Discount$2;
      /** Tax applied to the item. */
      tax?: Tax$2;
      /**
       * Fees applied to the item.
       * @readonly
       */
      fees?: Fee$2[];
  }
  interface Money$8 {
      /**
       * *Deprecated:** Use `value` instead.
       * @deprecated
       */
      amount?: string;
      /** ISO 4217 format of the currency e.g., `USD`. */
      currency?: string;
      /** Monetary amount. Decimal string with a period as a decimal separator (e.g., 3.99). Optionally, starts with a single (-), to indicate that the amount is negative. */
      value?: string | null;
  }
  interface Discount$2 {
      /** Total discount amount. */
      amount?: Money$8;
      /** Total charge after applied discount. */
      afterDiscount?: Money$8;
      /**
       * Discount coupon code.
       * @deprecated
       */
      code?: string;
      /**
       * Discount coupon name.
       * @deprecated
       */
      name?: string;
      /**
       * Discount coupon ID.
       * @deprecated
       */
      couponId?: string;
      /** Discount items. */
      discounts?: DiscountItem$2[];
  }
  interface DiscountItem$2 extends DiscountItemDiscountOneOf$2 {
      /** Coupon discount. */
      coupon?: CouponDiscount$2;
      /** Pricing plan discount. */
      paidPlan?: PaidPlanDiscount$2;
      /** Total discount amount. */
      amount?: Money$8;
  }
  /** @oneof */
  interface DiscountItemDiscountOneOf$2 {
      /** Coupon discount. */
      coupon?: CouponDiscount$2;
      /** Pricing plan discount. */
      paidPlan?: PaidPlanDiscount$2;
  }
  interface CouponDiscount$2 {
      /** Discount coupon name. */
      name?: string;
      /** Discount coupon code. */
      code?: string;
      /** Discount coupon ID. */
      couponId?: string;
  }
  interface PaidPlanDiscount$2 extends PaidPlanDiscountDiscountOneOf$2 {
      /** Discount by percentage applied to tickets. */
      percentDiscount?: PercentDiscount$2;
      /** Name of pricing plan. */
      name?: string;
  }
  /** @oneof */
  interface PaidPlanDiscountDiscountOneOf$2 {
      /** Discount by percentage applied to tickets. */
      percentDiscount?: PercentDiscount$2;
  }
  interface PercentDiscount$2 {
      /** Percent rate. */
      rate?: string;
      /** Number of discounted tickets. */
      quantityDiscounted?: number;
  }
  interface Tax$2 {
      /** Tax type. */
      type?: TaxType$6;
      /**
       * Tax name.
       * @readonly
       */
      name?: string;
      /** Tax rate. */
      rate?: string;
      /** Taxable amount. */
      taxable?: Money$8;
      /** Total tax amount. */
      amount?: Money$8;
  }
  enum TaxType$6 {
      /** Tax is included in the ticket price. */
      INCLUDED = "INCLUDED",
      /** Tax is added to the order at the checkout. */
      ADDED = "ADDED",
      /** Tax is added to the final total at the checkout. */
      ADDED_AT_CHECKOUT = "ADDED_AT_CHECKOUT"
  }
  interface Fee$2 {
      /** Fee identifier. */
      name?: FeeName$2;
      /** How fee is calculated. */
      type?: FeeType$3;
      /**
       * Fee rate.
       * @readonly
       */
      rate?: string;
      /** Total amount of fee charges. */
      amount?: Money$8;
  }
  enum FeeName$2 {
      /** Wix ticket service fee charges applied to the line item. */
      WIX_FEE = "WIX_FEE"
  }
  enum FeeType$3 {
      /** Fee is added to the ticket price at checkout. */
      FEE_ADDED = "FEE_ADDED",
      /** Seller absorbs the fee. It is deducted from the ticket price. */
      FEE_INCLUDED = "FEE_INCLUDED",
      /** Fee is added to the ticket price at checkout. */
      FEE_ADDED_AT_CHECKOUT = "FEE_ADDED_AT_CHECKOUT"
  }
  interface GuestEventCanceled {
      /** Event guest. */
      guest?: EventGuest;
      /** Event context. */
      event?: EventDetails$1;
  }
  interface GuestEventStarts {
      /** Event guest. */
      guest?: EventGuest;
      /** Event context. */
      event?: EventDetails$1;
      /** Timing */
      timing?: Timing;
  }
  interface GuestOrderCanceled {
      /** Event guest. */
      guest?: EventGuest;
      /** Event context. */
      event?: EventDetails$1;
      /** Order context. */
      order?: OrderDetails;
  }
  interface DomainEvent$9 extends DomainEventBodyOneOf$9 {
      createdEvent?: EntityCreatedEvent$9;
      updatedEvent?: EntityUpdatedEvent$9;
      deletedEvent?: EntityDeletedEvent$9;
      actionEvent?: ActionEvent$9;
      /**
       * Unique event ID.
       * Allows clients to ignore duplicate webhooks.
       */
      _id?: string;
      /**
       * Assumes actions are also always typed to an entity_type
       * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
       */
      entityFqdn?: string;
      /**
       * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
       * This is although the created/updated/deleted notion is duplication of the oneof types
       * Example: created/updated/deleted/started/completed/email_opened
       */
      slug?: string;
      /** ID of the entity associated with the event. */
      entityId?: string;
      /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
      eventTime?: Date | null;
      /**
       * Whether the event was triggered as a result of a privacy regulation application
       * (for example, GDPR).
       */
      triggeredByAnonymizeRequest?: boolean | null;
      /** If present, indicates the action that triggered the event. */
      originatedFrom?: string | null;
      /**
       * A sequence number defining the order of updates to the underlying entity.
       * For example, given that some entity was updated at 16:00 and than again at 16:01,
       * it is guaranteed that the sequence number of the second update is strictly higher than the first.
       * As the consumer, you can use this value to ensure that you handle messages in the correct order.
       * To do so, you will need to persist this number on your end, and compare the sequence number from the
       * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
       */
      entityEventSequence?: string | null;
  }
  /** @oneof */
  interface DomainEventBodyOneOf$9 {
      createdEvent?: EntityCreatedEvent$9;
      updatedEvent?: EntityUpdatedEvent$9;
      deletedEvent?: EntityDeletedEvent$9;
      actionEvent?: ActionEvent$9;
  }
  interface EntityCreatedEvent$9 {
      entityAsJson?: string;
      /**
       * Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity
       * @internal
       */
      triggeredByUndelete?: boolean | null;
      /** Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity */
      restoreInfo?: RestoreInfo$9;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface RestoreInfo$9 {
      deletedDate?: Date | null;
  }
  interface EntityUpdatedEvent$9 {
      /**
       * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
       * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
       * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
       */
      currentEntityAsJson?: string;
      /**
       * This field is currently part of the of the EntityUpdatedEvent msg, but scala/node libraries which implements the domain events standard
       * wont populate it / have any reference to it in the API.
       * The main reason for it is that fetching the old entity from the DB will have a performance hit on an update operation so unless truly needed,
       * the developer should send only the new (current) entity.
       * An additional reason is not wanting to send this additional entity over the wire (kafka) since in some cases it can be really big
       * Developers that must reflect the old entity will have to implement their own domain event sender mechanism which will follow the DomainEvent proto message.
       * @internal
       * @deprecated
       */
      previousEntityAsJson?: string | null;
      /**
       * WIP - This property will hold both names and previous values of the updated fields of the entity.
       * For more details please see [adr](https://docs.google.com/document/d/1PdqsOM20Ph2HAkmx8zvUnzzk3Sekp3BR9h34wSvsRnI/edit#heading=h.phlw87mh2imx) or [issue](https://github.com/wix-private/nile-tracker/issues/363)
       * @internal
       */
      modifiedFields?: Record<string, any>;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface EntityDeletedEvent$9 {
      /**
       * Indicates if the entity is sent to trash-bin. only available when trash-bin is enabled
       * @internal
       */
      movedToTrash?: boolean | null;
      /** Entity that was deleted */
      deletedEntityAsJson?: string | null;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface ActionEvent$9 {
      bodyAsJson?: string;
  }
  interface MessageEnvelope$d {
      /** App instance ID. */
      instanceId?: string | null;
      /** Event type. */
      eventType?: string;
      /** The identification type and identity data. */
      identity?: IdentificationData$d;
      /** Stringify payload. */
      data?: string;
  }
  interface IdentificationData$d extends IdentificationDataIdOneOf$d {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
      /** @readonly */
      identityType?: WebhookIdentityType$d;
  }
  /** @oneof */
  interface IdentificationDataIdOneOf$d {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
  }
  enum WebhookIdentityType$d {
      UNKNOWN = "UNKNOWN",
      ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
      MEMBER = "MEMBER",
      WIX_USER = "WIX_USER",
      APP = "APP"
  }
  interface QueryEventGuestsRequest {
      /** Query options. See [API Query Language](https://dev.wix.com/api/rest/getting-started/api-query-language) for more details. */
      query: QueryV2$8;
      /** Predefined sets of fields to return. */
      fields?: RequestedFieldsEnumRequestedFields[];
  }
  interface QueryV2$8 extends QueryV2PagingMethodOneOf$8 {
      /** Paging options to limit and skip the number of items. */
      paging?: Paging$9;
      /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
      cursorPaging?: CursorPaging$7;
      /** Filter object in the following format: <br/> `"filter" : { "fieldName1": "value1", "fieldName2":{"$operator":"value2"} }`. <br/> <br/> **Example:** <br/> `"filter" : { "eventId": "sd3f-jhds-4fs77", "ticketNumber": {"$startsWith":"478"} }` <br/> <br/> See [supported fields and operators](https://dev.wix.com/api/rest/wix-events/wix-events/filter-and-sort) for more information. */
      filter?: Record<string, any> | null;
      /** Sort object in the following format: <br/> `[{"fieldName":"sortField1"},{"fieldName":"sortField2","direction":"DESC"}]` <br/> <br/> **Example:** <br/> `[{"fieldName":"createdDate","direction":"DESC"}]` <br/> <br/> See [supported fields](https://dev.wix.com/api/rest/wix-events/wix-events/filter-and-sort) for more information. */
      sort?: Sorting$a[];
      /**
       * Currently the only supported fieldset is `guestDetails`. The `WIX_EVENTS.READ_GUESTS_DETAILS` permission is required to access the guest details. <br/> <br/> See [field projection](https://dev.wix.com/api/rest/getting-started/field-projection) for more information.
       * @deprecated Currently the only supported fieldset is `guestDetails`. The `WIX_EVENTS.READ_GUESTS_DETAILS` permission is required to access the guest details. <br/> <br/> See [field projection](https://dev.wix.com/api/rest/getting-started/field-projection) for more information.
       * @replacedBy fields
       * @targetRemovalDate 2024-06-30
       */
      fieldsets?: string[];
  }
  /** @oneof */
  interface QueryV2PagingMethodOneOf$8 {
      /** Paging options to limit and skip the number of items. */
      paging?: Paging$9;
      /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
      cursorPaging?: CursorPaging$7;
  }
  interface Sorting$a {
      /** Name of the field to sort by. */
      fieldName?: string;
      /** Sort order. */
      order?: SortOrder$a;
      /**
       * When `field_name` is a property of repeated field that is marked as `MATCH_ITEMS` and sort should be done by
       * a specific element from a collection, filter can/should be provided to ensure correct sort value is picked.
       *
       * If multiple filters are provided, they are combined with AND operator.
       *
       * Example:
       * Given we have document like {"id": "1", "nestedField": [{"price": 10, "region": "EU"}, {"price": 20, "region": "US"}]}
       * and `nestedField` is marked as `MATCH_ITEMS`, to ensure that sorting is done by correct region, filter should be
       * { fieldName: "nestedField.price", "select_items_by": [{"nestedField.region": "US"}] }
       * @internal
       */
      selectItemsBy?: Record<string, any>[] | null;
  }
  enum SortOrder$a {
      ASC = "ASC",
      DESC = "DESC"
  }
  interface Paging$9 {
      /** Number of items to load. */
      limit?: number | null;
      /** Number of items to skip in the current sort order. */
      offset?: number | null;
  }
  interface CursorPaging$7 {
      /** Maximum number of items to return in the results. */
      limit?: number | null;
      /**
       * Pointer to the next or previous page in the list of results.
       *
       * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
       * Not relevant for the first request.
       */
      cursor?: string | null;
  }
  enum RequestedFieldsEnumRequestedFields {
      /** Unknown requested field. */
      UNKNOWN_REQUESTED_FIELD = "UNKNOWN_REQUESTED_FIELD",
      /** Returns `guestDetails` and `tickets`. */
      GUEST_DETAILS = "GUEST_DETAILS",
      /** Returns `totalGuests`. */
      GUEST_TOTAL = "GUEST_TOTAL"
  }
  interface QueryEventGuestsResponse {
      /** List of guests. */
      guests?: EventGuest[];
      /** Metadata for the paginated results. */
      pagingMetadata?: PagingMetadataV2$9;
  }
  interface PagingMetadataV2$9 {
      /** Number of items returned in the response. */
      count?: number | null;
      /** Offset that was requested. */
      offset?: number | null;
      /** Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set. */
      total?: number | null;
      /** Flag that indicates the server failed to calculate the `total` field. */
      tooManyToCount?: boolean | null;
      /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
      cursors?: Cursors$a;
  }
  interface Cursors$a {
      /** Cursor string pointing to the next page in the list of results. */
      next?: string | null;
      /** Cursor pointing to the previous page in the list of results. */
      prev?: string | null;
  }
  interface StreamEventGuestsRequest {
      /** Filter. */
      filter?: Record<string, any> | null;
      /** Task context. */
      taskContext?: TaskContext;
  }
  interface Empty$6 {
  }
  interface SecondaryLanguagesRequest {
      /** Guest event id. */
      eventId?: string;
  }
  interface SecondaryLanguagesResponse {
      /** Aggregated guests secondary languages. */
      secondaryLanguages?: string[];
      /** Aggregated guests languages. */
      languages?: Language[];
  }
  interface Language {
      /** Guest language. */
      language?: string | null;
      /** Guest locale. */
      locale?: string | null;
  }
  interface RsvpCreated$2 {
      /** RSVP created timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Site language when RSVP created */
      language?: string | null;
      /** Notifications silenced for this domain event. */
      silent?: boolean | null;
      /**
       * Locale in which Rsvp was created.
       * @internal
       */
      locale?: string | null;
      /** Event ID. */
      eventId?: string;
      /** RSVP ID. */
      rsvpId?: string;
      /** Contact ID associated with this RSVP. */
      contactId?: string;
      /** Member ID associated with this RSVP. */
      memberId?: string | null;
      /** Guest first name. */
      firstName?: string;
      /** Guest last name. */
      lastName?: string;
      /** Guest email. */
      email?: string;
      /** RSVP form response. */
      rsvpForm?: FormResponse$5;
      /** RSVP response status. */
      status?: RsvpStatus$3;
      /** List of all guests. */
      guests?: Guest$4[];
      /** URL and password to online conference */
      onlineConferencingLogin?: OnlineConferencingLogin$5;
  }
  enum RsvpStatus$3 {
      YES = "YES",
      NO = "NO",
      WAITING = "WAITING"
  }
  interface Guest$4 {
      /** Index in the RSVP guest list. */
      index?: number;
      /** Guest full name. */
      fullName?: string;
      /** Guest check-in. */
      checkIn?: CheckIn$4;
      /** Unique guest ID per RSVP. */
      _id?: number;
  }
  interface CheckIn$4 {
      /** Time of check-in */
      created?: Date | null;
  }
  interface RsvpUpdated$2 {
      /** RSVP updated timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Site language when RSVP created */
      language?: string | null;
      /** Locale in which Rsvp was created. */
      locale?: string | null;
      /** Event ID. */
      eventId?: string;
      /** RSVP ID. */
      rsvpId?: string;
      /** Contact ID associated with this RSVP. */
      contactId?: string;
      /** Member ID associated with this RSVP. */
      memberId?: string | null;
      /** RSVP created timestamp. */
      created?: Date | null;
      /** Guest first name. */
      firstName?: string;
      /** Guest last name. */
      lastName?: string;
      /** Guest email. */
      email?: string;
      /** RSVP form response. */
      rsvpForm?: FormResponse$5;
      /** RSVP response status. */
      status?: RsvpStatus$3;
      /** List of the guests. */
      guests?: Guest$4[];
      /** URL and password to online conference */
      onlineConferencingLogin?: OnlineConferencingLogin$5;
      /** Notifications silenced for this domain event. */
      silent?: boolean | null;
  }
  interface RsvpDeleted$1 {
      /** RSVP deleted timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Event ID. */
      eventId?: string;
      /** RSVP ID. */
      rsvpId?: string;
      /** Contact ID associated with this RSVP. */
      contactId?: string;
      /** Member ID associated with this RSVP. */
      memberId?: string | null;
      /** Whether RSVP was anonymized by GDPR delete. */
      anonymized?: boolean;
  }
  interface OrderConfirmed$2 {
      /** Order confirmation timestamp in ISO UTC. */
      timestamp?: Date | null;
      /** Site language when Order initiated */
      language?: string | null;
      /** Notifications silenced for this domain event. */
      silent?: boolean | null;
      /** Locale in which Order was created. */
      locale?: string | null;
      /** Event ID. */
      eventId?: string;
      /** Unique order number. */
      orderNumber?: string;
      /** Contact ID associated with this order. */
      contactId?: string;
      /** Member ID associated with this order. */
      memberId?: string | null;
      /**
       * Order created timestamp
       * @readonly
       */
      created?: Date | null;
      /** Buyer first name. */
      firstName?: string;
      /** Buyer last name. */
      lastName?: string;
      /** Buyer email address. */
      email?: string;
      /** Checkout form response. */
      checkoutForm?: FormResponse$5;
      /** Order status. */
      status?: OrderStatus$3;
      /** Payment method used for paid tickets purchase, i.e. "payPal", "creditCard", etc. */
      method?: string | null;
      /** Tickets (generated after payment). */
      tickets?: Ticket$3[];
      /** Invoice. */
      invoice?: Invoice$2;
      /** Reservation ID associated with this order. */
      reservationId?: string;
  }
  interface Ticket$3 {
      /** Unique issued ticket number. */
      ticketNumber?: string;
      /** Ticket definition ID. */
      ticketDefinitionId?: string;
      /** Ticket check-in. */
      checkIn?: CheckIn$4;
      /** Ticket price. */
      price?: Money$8;
      /** Whether ticket is archived. */
      archived?: boolean;
      /** Guest first name. */
      firstName?: string | null;
      /** Guest last name. */
      lastName?: string | null;
      /** Guest email. */
      email?: string | null;
      /** Contact ID associated with this ticket. */
      contactId?: string | null;
      /** Whether ticket is confirmed */
      confirmed?: boolean;
      /** Member ID associated with this ticket. */
      memberId?: string | null;
      /** Ticket form response (only assigned tickets contain separate forms). */
      form?: FormResponse$5;
      /** Ticket name. */
      ticketName?: string;
      /** Anonymized tickets no longer contain personally identifiable information (PII). */
      anonymized?: boolean;
      /** URL and password to online conference */
      onlineConferencingLogin?: OnlineConferencingLogin$5;
  }
  interface OrderUpdated$2 {
      /** Order updated timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Site language when Order initiated */
      language?: string | null;
      /** Locale in which Order was created. */
      locale?: string | null;
      /** Event ID. */
      eventId?: string;
      /** Unique order number. */
      orderNumber?: string;
      /** Contact ID associated with this order. */
      contactId?: string;
      /** Member ID associated with this order. */
      memberId?: string | null;
      /**
       * Order created timestamp.
       * @readonly
       */
      created?: Date | null;
      /**
       * Order updated timestamp.
       * @readonly
       */
      updated?: Date | null;
      /** Buyer first name. */
      firstName?: string;
      /** Buyer last name. */
      lastName?: string;
      /** Buyer email. */
      email?: string;
      /** Checkout form response. */
      checkoutForm?: FormResponse$5;
      /** Whether order is confirmed - occurs once payment gateway processes the payment and funds reach merchant's account. */
      confirmed?: boolean;
      /** Order status. */
      status?: OrderStatus$3;
      /** Payment method used for paid tickets purchase, i.e. "payPal", "creditCard", etc. */
      method?: string | null;
      /** Tickets generated after payment. */
      tickets?: Ticket$3[];
      /** Whether order was archived and excluded from results. */
      archived?: boolean;
      /** Whether event was triggered by GDPR delete request. */
      triggeredByAnonymizeRequest?: boolean;
  }
  interface OrderDeleted$1 {
      /** Order deleted timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Event ID. */
      eventId?: string;
      /** Unique order number. */
      orderNumber?: string;
      /** Contact ID associated with this order */
      contactId?: string;
      /** Member ID associated with this order. */
      memberId?: string | null;
      /**
       * Order created timestamp.
       * @readonly
       */
      created?: Date | null;
      /**
       * Order updated timestamp.
       * @readonly
       */
      updated?: Date | null;
      /** Whether order was anonymized by GDPR delete. */
      anonymized?: boolean;
      /** Order type. */
      orderType?: OrderType$1;
      /** Whether event was triggered by GDPR delete request. */
      triggeredByAnonymizeRequest?: boolean;
      /** Tickets generated after payment. */
      tickets?: Ticket$3[];
  }
  enum OrderType$1 {
      /** Buyer form is used for all tickets. */
      UNASSIGNED_TICKETS = "UNASSIGNED_TICKETS",
      /** Each order ticket has its own form. */
      ASSIGNED_TICKETS = "ASSIGNED_TICKETS"
  }
  interface EventDeleted$5 {
      /** Event deleted timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Event ID. */
      eventId?: string;
      /** Event title. */
      title?: string;
      /** Event creator user ID. */
      userId?: string | null;
      /**
       * Event categories.
       * @internal
       */
      categories?: string[];
  }
  interface Task {
      key?: TaskKey;
      executeAt?: Date | null;
      payload?: string | null;
  }
  interface TaskKey {
      appId?: string;
      instanceId?: string;
      subjectId?: string | null;
  }
  interface ListGuestListPreviewsRequest {
      /** Event ids. */
      eventIds: string[];
      /** Cursor paging. */
      cursorPaging?: CursorPaging$7;
      /** Requested fields. */
      fields?: RequestedFields$3[];
  }
  enum RequestedFields$3 {
      /** Unknown requested field. */
      UNKNOWN_REQUESTED_FIELD = "UNKNOWN_REQUESTED_FIELD",
      /** Member guests. */
      MEMBER_GUESTS = "MEMBER_GUESTS",
      /** Waitlist count. */
      WAITLIST_COUNT = "WAITLIST_COUNT"
  }
  interface ListGuestListPreviewsResponse {
      /** List of guests. */
      previews?: GuestListPreview[];
      /** Metadata for the paginated results. */
      pagingMetadata?: PagingMetadataV2$9;
  }
  interface GuestListPreview {
      /** Event id. */
      eventId?: string;
      /** Latest attending members. */
      latestAttendingMembers?: EventGuests$1;
      /** Attending guests count. */
      attending?: GuestCount;
      /** Waiting guests count. */
      inWaitlist?: GuestCount;
      /** Not attending guests count. */
      notAttending?: GuestCount;
  }
  interface EventGuests$1 {
      guests?: EventGuest[];
  }
  interface GuestCount {
      /** Total guest count. For Rsvp Event every RSVP guest and additional guest count, for Ticketed Event count of TICKET_HOLDER */
      totalEventGuests?: number;
      /** EventGuest count (RSVP, TICKET_HOLDER, BUYER); */
      count?: number;
  }
  interface UpdateGuestRequest {
      /** Updated guest */
      guest?: EventGuest;
      /** Guest revision */
      revision?: string | null;
  }
  interface UpdateGuestResponse {
      /** Updated guest */
      guest?: EventGuest;
  }
  /**
   * Creates a query to retrieve a list of guests.
   *
   *
   * The `queryGuests()` function builds a query to retrieve a list of guests and returns a [GuestsQueryBuilder](https://www.wix.com/velo/reference/wix-events-v2/guests/guestsquerybuilder) object.
   *
   * The returned object contains the query definition which is typically used to run the query using the `find()` function.
   *
   * You can refine the query by chaining `GuestsQueryBuilder` functions onto the query. `GuestsQueryBuilder` functions enable you to sort, filter, and control the results that `queryGuests.find()` returns.
   *
   * The query runs with the following `GuestsQueryBuilder` defaults that you can override:
   *
   * - [`skip(0)`](https://www.wix.com/velo/reference/wix-events-v2/guests/guestsquerybuilder/skipto)
   * - [`limit(50)`](https://www.wix.com/velo/reference/wix-events-v2/guests/guestsquerybuilder/limit)
   * - [`descending("_createdDate")`](https://www.wix.com/velo/reference/wix-events-v2/guests/guestsquerybuilder/descending)
   *
   * The functions that are chained to `queryGuests()` are applied in the order they are called. For example, if you apply `ascending ('_createdDate')` and then `descending ('_updatedDate')`, the results are sorted first by the created date and then, if there are multiple results with the same date, the items are sorted by the updated date.
   *
   * The table below shows which `GuestsQueryBuilder` functions are supported for `queryGuests()`. You can only use one filter function for each property. Only the first filter will work if a property is used in more than one filter.
   * @public
   * @permissionId WIX_EVENTS.READ_GUESTS
   * @adminMethod
   */
  function queryGuests(options?: QueryEventGuestsOptions): GuestsQueryBuilder;
  interface QueryEventGuestsOptions {
      /** Predefined sets of fields to return. */
      fields?: RequestedFieldsEnumRequestedFields[] | undefined;
  }
  interface QueryCursorResult$7 {
      cursors: Cursors$a;
      hasNext: () => boolean;
      hasPrev: () => boolean;
      length: number;
      pageSize: number;
  }
  interface GuestsQueryResult extends QueryCursorResult$7 {
      items: EventGuest[];
      query: GuestsQueryBuilder;
      next: () => Promise<GuestsQueryResult>;
      prev: () => Promise<GuestsQueryResult>;
  }
  interface GuestsQueryBuilder {
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       */
      eq: (propertyName: '_id' | 'eventId' | 'rsvpId' | 'orderNumber' | 'ticketNumber' | 'contactId' | 'guestDetails.checkedIn' | 'attendanceStatus' | 'secondaryLanguageCode' | '_createdDate' | '_updatedDate' | 'attendanceStatusUpdatedDate' | 'memberId' | 'guestType', value: any) => GuestsQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       */
      ne: (propertyName: '_id' | 'eventId' | 'rsvpId' | 'orderNumber' | 'ticketNumber' | 'contactId' | 'guestDetails.checkedIn' | 'attendanceStatus' | 'secondaryLanguageCode' | '_createdDate' | '_updatedDate' | 'attendanceStatusUpdatedDate' | 'memberId' | 'guestType', value: any) => GuestsQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       */
      ge: (propertyName: '_createdDate' | '_updatedDate' | 'attendanceStatusUpdatedDate', value: any) => GuestsQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       */
      gt: (propertyName: '_createdDate' | '_updatedDate' | 'attendanceStatusUpdatedDate', value: any) => GuestsQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       */
      le: (propertyName: '_createdDate' | '_updatedDate' | 'attendanceStatusUpdatedDate', value: any) => GuestsQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       */
      lt: (propertyName: '_createdDate' | '_updatedDate' | 'attendanceStatusUpdatedDate', value: any) => GuestsQueryBuilder;
      in: (propertyName: '_id' | 'eventId' | 'rsvpId' | 'orderNumber' | 'ticketNumber' | 'contactId' | 'attendanceStatus' | 'secondaryLanguageCode' | '_createdDate' | '_updatedDate' | 'attendanceStatusUpdatedDate' | 'memberId' | 'guestType', value: any) => GuestsQueryBuilder;
      exists: (propertyName: '_id' | 'eventId' | 'rsvpId' | 'orderNumber' | 'ticketNumber' | 'tickets' | 'contactId' | 'guestDetails.checkedIn' | 'secondaryLanguageCode' | '_createdDate' | '_updatedDate' | 'attendanceStatusUpdatedDate' | 'memberId', value: boolean) => GuestsQueryBuilder;
      /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments. */
      ascending: (...propertyNames: Array<'_createdDate' | '_updatedDate' | 'attendanceStatusUpdatedDate'>) => GuestsQueryBuilder;
      /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments. */
      descending: (...propertyNames: Array<'_createdDate' | '_updatedDate' | 'attendanceStatusUpdatedDate'>) => GuestsQueryBuilder;
      /** @param limit - Number of items to return, which is also the `pageSize` of the results object. */
      limit: (limit: number) => GuestsQueryBuilder;
      /** @param cursor - A pointer to specific record */
      skipTo: (cursor: string) => GuestsQueryBuilder;
      find: () => Promise<GuestsQueryResult>;
  }
  /**
   * Returns a list of guest list summaries per event.
   * @param eventIds - Event ids.
   * @internal
   * @documentationMaturity preview
   * @requiredField eventIds
   * @permissionId WIX_EVENTS.READ_GUESTS
   * @adminMethod
   */
  function listGuestListPreviews(eventIds: string[], options?: ListGuestListPreviewsOptions): Promise<ListGuestListPreviewsResponse>;
  interface ListGuestListPreviewsOptions {
      /** Cursor paging. */
      cursorPaging?: CursorPaging$7;
      /** Requested fields. */
      fields?: RequestedFields$3[];
  }
  
  type eventsGuestsV1Guest_universal_d_EventGuest = EventGuest;
  type eventsGuestsV1Guest_universal_d_TicketGuestDetails = TicketGuestDetails;
  type eventsGuestsV1Guest_universal_d_AttendanceStatus = AttendanceStatus;
  const eventsGuestsV1Guest_universal_d_AttendanceStatus: typeof AttendanceStatus;
  type eventsGuestsV1Guest_universal_d_GuestType = GuestType;
  const eventsGuestsV1Guest_universal_d_GuestType: typeof GuestType;
  type eventsGuestsV1Guest_universal_d_GuestCountUpdated = GuestCountUpdated;
  type eventsGuestsV1Guest_universal_d_GuestCountUpdate = GuestCountUpdate;
  type eventsGuestsV1Guest_universal_d_MemberEventStatusUpdated = MemberEventStatusUpdated;
  type eventsGuestsV1Guest_universal_d_MemberEventStatusUpdatedEventType = MemberEventStatusUpdatedEventType;
  const eventsGuestsV1Guest_universal_d_MemberEventStatusUpdatedEventType: typeof MemberEventStatusUpdatedEventType;
  type eventsGuestsV1Guest_universal_d_ContactEventStatusUpdated = ContactEventStatusUpdated;
  type eventsGuestsV1Guest_universal_d_GuestCheckedIn = GuestCheckedIn;
  type eventsGuestsV1Guest_universal_d_NotifyGuestAction = NotifyGuestAction;
  type eventsGuestsV1Guest_universal_d_TaskContext = TaskContext;
  type eventsGuestsV1Guest_universal_d_NotifyActionType = NotifyActionType;
  const eventsGuestsV1Guest_universal_d_NotifyActionType: typeof NotifyActionType;
  type eventsGuestsV1Guest_universal_d_Timing = Timing;
  const eventsGuestsV1Guest_universal_d_Timing: typeof Timing;
  type eventsGuestsV1Guest_universal_d_OrderDetails = OrderDetails;
  type eventsGuestsV1Guest_universal_d_GuestEventCanceled = GuestEventCanceled;
  type eventsGuestsV1Guest_universal_d_GuestEventStarts = GuestEventStarts;
  type eventsGuestsV1Guest_universal_d_GuestOrderCanceled = GuestOrderCanceled;
  type eventsGuestsV1Guest_universal_d_QueryEventGuestsRequest = QueryEventGuestsRequest;
  type eventsGuestsV1Guest_universal_d_RequestedFieldsEnumRequestedFields = RequestedFieldsEnumRequestedFields;
  const eventsGuestsV1Guest_universal_d_RequestedFieldsEnumRequestedFields: typeof RequestedFieldsEnumRequestedFields;
  type eventsGuestsV1Guest_universal_d_QueryEventGuestsResponse = QueryEventGuestsResponse;
  type eventsGuestsV1Guest_universal_d_StreamEventGuestsRequest = StreamEventGuestsRequest;
  type eventsGuestsV1Guest_universal_d_SecondaryLanguagesRequest = SecondaryLanguagesRequest;
  type eventsGuestsV1Guest_universal_d_SecondaryLanguagesResponse = SecondaryLanguagesResponse;
  type eventsGuestsV1Guest_universal_d_Language = Language;
  type eventsGuestsV1Guest_universal_d_Task = Task;
  type eventsGuestsV1Guest_universal_d_TaskKey = TaskKey;
  type eventsGuestsV1Guest_universal_d_ListGuestListPreviewsRequest = ListGuestListPreviewsRequest;
  type eventsGuestsV1Guest_universal_d_ListGuestListPreviewsResponse = ListGuestListPreviewsResponse;
  type eventsGuestsV1Guest_universal_d_GuestListPreview = GuestListPreview;
  type eventsGuestsV1Guest_universal_d_GuestCount = GuestCount;
  type eventsGuestsV1Guest_universal_d_UpdateGuestRequest = UpdateGuestRequest;
  type eventsGuestsV1Guest_universal_d_UpdateGuestResponse = UpdateGuestResponse;
  const eventsGuestsV1Guest_universal_d_queryGuests: typeof queryGuests;
  type eventsGuestsV1Guest_universal_d_QueryEventGuestsOptions = QueryEventGuestsOptions;
  type eventsGuestsV1Guest_universal_d_GuestsQueryResult = GuestsQueryResult;
  type eventsGuestsV1Guest_universal_d_GuestsQueryBuilder = GuestsQueryBuilder;
  const eventsGuestsV1Guest_universal_d_listGuestListPreviews: typeof listGuestListPreviews;
  type eventsGuestsV1Guest_universal_d_ListGuestListPreviewsOptions = ListGuestListPreviewsOptions;
  namespace eventsGuestsV1Guest_universal_d {
    export {
      eventsGuestsV1Guest_universal_d_EventGuest as EventGuest,
      TicketDetails$2 as TicketDetails,
      eventsGuestsV1Guest_universal_d_TicketGuestDetails as TicketGuestDetails,
      OnlineConferencingLogin$5 as OnlineConferencingLogin,
      GuestDetails$2 as GuestDetails,
      FormResponse$5 as FormResponse,
      InputValue$5 as InputValue,
      FormattedAddress$5 as FormattedAddress,
      Address$a as Address,
      AddressStreetOneOf$a as AddressStreetOneOf,
      StreetAddress$a as StreetAddress,
      AddressLocation$a as AddressLocation,
      Subdivision$a as Subdivision,
      SubdivisionType$a as SubdivisionType,
      StandardDetails$5 as StandardDetails,
      eventsGuestsV1Guest_universal_d_AttendanceStatus as AttendanceStatus,
      eventsGuestsV1Guest_universal_d_GuestType as GuestType,
      eventsGuestsV1Guest_universal_d_GuestCountUpdated as GuestCountUpdated,
      eventsGuestsV1Guest_universal_d_GuestCountUpdate as GuestCountUpdate,
      eventsGuestsV1Guest_universal_d_MemberEventStatusUpdated as MemberEventStatusUpdated,
      eventsGuestsV1Guest_universal_d_MemberEventStatusUpdatedEventType as MemberEventStatusUpdatedEventType,
      eventsGuestsV1Guest_universal_d_ContactEventStatusUpdated as ContactEventStatusUpdated,
      EventType$5 as EventType,
      eventsGuestsV1Guest_universal_d_GuestCheckedIn as GuestCheckedIn,
      EventDetails$1 as EventDetails,
      Location$7 as Location,
      LocationType$7 as LocationType,
      CommonAddress$4 as CommonAddress,
      CommonAddressStreetOneOf$4 as CommonAddressStreetOneOf,
      CommonStreetAddress$4 as CommonStreetAddress,
      CommonAddressLocation$4 as CommonAddressLocation,
      CommonSubdivision$4 as CommonSubdivision,
      SubdivisionSubdivisionType$2 as SubdivisionSubdivisionType,
      DateAndTimeSettings$2 as DateAndTimeSettings,
      RecurrenceStatusStatus$2 as RecurrenceStatusStatus,
      Recurrences$7 as Recurrences,
      Occurrence$7 as Occurrence,
      Formatted$2 as Formatted,
      Status$8 as Status,
      eventsGuestsV1Guest_universal_d_NotifyGuestAction as NotifyGuestAction,
      eventsGuestsV1Guest_universal_d_TaskContext as TaskContext,
      eventsGuestsV1Guest_universal_d_NotifyActionType as NotifyActionType,
      eventsGuestsV1Guest_universal_d_Timing as Timing,
      eventsGuestsV1Guest_universal_d_OrderDetails as OrderDetails,
      OrderStatus$3 as OrderStatus,
      Invoice$2 as Invoice,
      Item$3 as Item,
      Money$8 as Money,
      Discount$2 as Discount,
      DiscountItem$2 as DiscountItem,
      DiscountItemDiscountOneOf$2 as DiscountItemDiscountOneOf,
      CouponDiscount$2 as CouponDiscount,
      PaidPlanDiscount$2 as PaidPlanDiscount,
      PaidPlanDiscountDiscountOneOf$2 as PaidPlanDiscountDiscountOneOf,
      PercentDiscount$2 as PercentDiscount,
      Tax$2 as Tax,
      TaxType$6 as TaxType,
      Fee$2 as Fee,
      FeeName$2 as FeeName,
      FeeType$3 as FeeType,
      eventsGuestsV1Guest_universal_d_GuestEventCanceled as GuestEventCanceled,
      eventsGuestsV1Guest_universal_d_GuestEventStarts as GuestEventStarts,
      eventsGuestsV1Guest_universal_d_GuestOrderCanceled as GuestOrderCanceled,
      DomainEvent$9 as DomainEvent,
      DomainEventBodyOneOf$9 as DomainEventBodyOneOf,
      EntityCreatedEvent$9 as EntityCreatedEvent,
      RestoreInfo$9 as RestoreInfo,
      EntityUpdatedEvent$9 as EntityUpdatedEvent,
      EntityDeletedEvent$9 as EntityDeletedEvent,
      ActionEvent$9 as ActionEvent,
      MessageEnvelope$d as MessageEnvelope,
      IdentificationData$d as IdentificationData,
      IdentificationDataIdOneOf$d as IdentificationDataIdOneOf,
      WebhookIdentityType$d as WebhookIdentityType,
      eventsGuestsV1Guest_universal_d_QueryEventGuestsRequest as QueryEventGuestsRequest,
      QueryV2$8 as QueryV2,
      QueryV2PagingMethodOneOf$8 as QueryV2PagingMethodOneOf,
      Sorting$a as Sorting,
      SortOrder$a as SortOrder,
      Paging$9 as Paging,
      CursorPaging$7 as CursorPaging,
      eventsGuestsV1Guest_universal_d_RequestedFieldsEnumRequestedFields as RequestedFieldsEnumRequestedFields,
      eventsGuestsV1Guest_universal_d_QueryEventGuestsResponse as QueryEventGuestsResponse,
      PagingMetadataV2$9 as PagingMetadataV2,
      Cursors$a as Cursors,
      eventsGuestsV1Guest_universal_d_StreamEventGuestsRequest as StreamEventGuestsRequest,
      Empty$6 as Empty,
      eventsGuestsV1Guest_universal_d_SecondaryLanguagesRequest as SecondaryLanguagesRequest,
      eventsGuestsV1Guest_universal_d_SecondaryLanguagesResponse as SecondaryLanguagesResponse,
      eventsGuestsV1Guest_universal_d_Language as Language,
      RsvpCreated$2 as RsvpCreated,
      RsvpStatus$3 as RsvpStatus,
      Guest$4 as Guest,
      CheckIn$4 as CheckIn,
      RsvpUpdated$2 as RsvpUpdated,
      RsvpDeleted$1 as RsvpDeleted,
      OrderConfirmed$2 as OrderConfirmed,
      Ticket$3 as Ticket,
      OrderUpdated$2 as OrderUpdated,
      OrderDeleted$1 as OrderDeleted,
      OrderType$1 as OrderType,
      EventDeleted$5 as EventDeleted,
      eventsGuestsV1Guest_universal_d_Task as Task,
      eventsGuestsV1Guest_universal_d_TaskKey as TaskKey,
      eventsGuestsV1Guest_universal_d_ListGuestListPreviewsRequest as ListGuestListPreviewsRequest,
      RequestedFields$3 as RequestedFields,
      eventsGuestsV1Guest_universal_d_ListGuestListPreviewsResponse as ListGuestListPreviewsResponse,
      eventsGuestsV1Guest_universal_d_GuestListPreview as GuestListPreview,
      EventGuests$1 as EventGuests,
      eventsGuestsV1Guest_universal_d_GuestCount as GuestCount,
      eventsGuestsV1Guest_universal_d_UpdateGuestRequest as UpdateGuestRequest,
      eventsGuestsV1Guest_universal_d_UpdateGuestResponse as UpdateGuestResponse,
      eventsGuestsV1Guest_universal_d_queryGuests as queryGuests,
      eventsGuestsV1Guest_universal_d_QueryEventGuestsOptions as QueryEventGuestsOptions,
      eventsGuestsV1Guest_universal_d_GuestsQueryResult as GuestsQueryResult,
      eventsGuestsV1Guest_universal_d_GuestsQueryBuilder as GuestsQueryBuilder,
      eventsGuestsV1Guest_universal_d_listGuestListPreviews as listGuestListPreviews,
      eventsGuestsV1Guest_universal_d_ListGuestListPreviewsOptions as ListGuestListPreviewsOptions,
    };
  }
  
  interface NotificationConfig {
      /** Event ID. */
      _id?: string | null;
      /** Represents the current state of an item. Each time the item is modified, its `revision` changes. for an update operation to succeed, you MUST pass the latest revision. */
      revision?: string | null;
      /**
       * Represents the time this NotificationConfig was created.
       * @readonly
       */
      _createdDate?: Date | null;
      /**
       * Represents the time this NotificationConfig was last updated.
       * @readonly
       */
      _updatedDate?: Date | null;
      /** Rsvp confirmation. */
      rsvpConfirmation?: EmailNotificationConfig;
      /** New spots available. */
      newSpotsAvailable?: EmailNotificationConfig;
      /** Event cancelation. */
      eventCancelation?: EmailNotificationConfig;
      /** Event reminder. */
      upcomingEventReminder?: EmailNotificationConfig;
      /** Order confirmation. */
      orderConfirmation?: EmailNotificationConfig;
      /** Ticket confirmation. */
      ticketConfirmation?: EmailNotificationConfig;
      /** Invoice. */
      invoice?: EmailNotificationConfig;
      /** Order confirmation with tickets link. */
      orderConfirmationWithTicketsLink?: EmailNotificationConfig;
  }
  interface EmailNotificationConfig {
      /**
       * Predefined id of the notification type.
       * @readonly
       */
      notificationType?: EmailNotificationType;
      /** Email template values. */
      template?: EmailTemplate;
      /**
       * Desired timing of the notification in hours respectfully to event start time.
       * For example if value is 0 then notification is sent at the start of the event.
       */
      reminderTime?: EmailNotificationReminderTime;
      /** When true the notification will be sent when certain trigger occurs. */
      sendingEnabled?: boolean | null;
  }
  enum EmailNotificationType {
      /** Default value. This value is unused. */
      UNKNOWN_NOTIFICATION_TYPE = "UNKNOWN_NOTIFICATION_TYPE",
      /** Triggered when site user RSVP to the event. */
      EMAIL_RSVP_CONFIRMATION = "EMAIL_RSVP_CONFIRMATION",
      /** Triggered for waiting guests when additional RSVP spots appears in the fully booked event. */
      EMAIL_NEW_SPOTS_AVAILABLE = "EMAIL_NEW_SPOTS_AVAILABLE",
      /** Triggered when event is canceled. */
      EMAIL_EVENT_CANCELATION = "EMAIL_EVENT_CANCELATION",
      /** Triggered before the event start time. */
      EMAIL_UPCOMING_EVENT_REMINDER = "EMAIL_UPCOMING_EVENT_REMINDER",
      /** Triggered when site user creates Order. */
      EMAIL_ORDER_CONFIRMATION = "EMAIL_ORDER_CONFIRMATION",
      /** Triggered when resending ticket to ticket holder. */
      EMAIL_TICKET_CONFIRMATION = "EMAIL_TICKET_CONFIRMATION",
      /** Triggered when sending invoice. Currently only `enabled` flag update is supported. */
      EMAIL_INVOICE = "EMAIL_INVOICE",
      /** Triggered when order confirmation sending is delayed. Tickets are accessible via link. */
      EMAIL_ORDER_CONFIRMATION_WITH_TICKETS_LINK = "EMAIL_ORDER_CONFIRMATION_WITH_TICKETS_LINK"
  }
  interface EmailTemplate {
      /** Email subject. */
      subject?: string | null;
      /** Plain text message body. */
      body?: string | null;
      /** Description link visibility and display text */
      descriptionLink?: Link$1;
      /** Calendar link visibility and display text */
      calendarLink?: Link$1;
      /** Online conferencing link visibility and display text */
      onlineConferencingLink?: Link$1;
      /** When true the tickets are attached to the order confirmation email. */
      includeTickets?: boolean | null;
  }
  interface Link$1 {
      /** When true the link is added to the email. */
      display?: boolean | null;
      /** Text of the link. */
      linkText?: string | null;
  }
  enum EmailNotificationReminderTime {
      /** Default value. This value is unused. */
      UNKNOWN_REMINDER_TIME = "UNKNOWN_REMINDER_TIME",
      /** Notification is sent instantly */
      INSTANT = "INSTANT",
      /** 24 hours prior */
      BEFORE_1_DAY = "BEFORE_1_DAY",
      /** 3 days prior */
      BEFORE_3_DAYS = "BEFORE_3_DAYS",
      /** 7 days prior */
      BEFORE_1_WEEK = "BEFORE_1_WEEK",
      /** 1 hour prior */
      BEFORE_1_HOUR = "BEFORE_1_HOUR",
      /** 30 minutes prior */
      BEFORE_30_MINUTES = "BEFORE_30_MINUTES"
  }
  interface TriggerNotificationRequest extends TriggerNotificationRequestNotificationOneOf, TriggerNotificationRequestGuestsOneOf {
      /** Email notification type */
      emailNotificationType?: EmailNotificationType;
      /** Push notification type */
      pushNotificationType?: PushNotificationType;
      /** Rsvp guest info */
      rsvpGuest?: RsvpGuest;
      /** Order guest info */
      orderGuest?: OrderGuest;
      /** Event guests info */
      eventGuests?: EventGuests;
      /** Ticket guests info */
      ticketGuest?: TicketGuest;
  }
  /** @oneof */
  interface TriggerNotificationRequestNotificationOneOf {
      /** Email notification type */
      emailNotificationType?: EmailNotificationType;
      /** Push notification type */
      pushNotificationType?: PushNotificationType;
  }
  /** @oneof */
  interface TriggerNotificationRequestGuestsOneOf {
      /** Rsvp guest info */
      rsvpGuest?: RsvpGuest;
      /** Order guest info */
      orderGuest?: OrderGuest;
      /** Event guests info */
      eventGuests?: EventGuests;
      /** Ticket guests info */
      ticketGuest?: TicketGuest;
  }
  enum PushNotificationType {
      /** This is default value. This value is unused. */
      UNKNOWN_PUSH_TYPE = "UNKNOWN_PUSH_TYPE",
      /** Triggered when event is updated. */
      PUSH_EVENT_UPDATED = "PUSH_EVENT_UPDATED",
      /** Triggered when event is canceled. */
      PUSH_EVENT_CANCELATION = "PUSH_EVENT_CANCELATION",
      /** Triggered before the event start time. */
      PUSH_UPCOMING_EVENT_REMINDER = "PUSH_UPCOMING_EVENT_REMINDER",
      /** Triggered when event is created. */
      PUSH_EVENT_CREATED = "PUSH_EVENT_CREATED"
  }
  /** Single guest associated to the RSVP */
  interface RsvpGuest {
      /** Event id */
      eventId?: string;
      /** Rsvp id */
      rsvpId?: string;
  }
  /** Single guest associated to the Order */
  interface OrderGuest {
      /** Event id */
      eventId?: string;
      /** Order number */
      orderNumber?: string;
  }
  /** All event guest from RSVPs and Orders */
  interface EventGuests {
      /** Event id */
      eventId?: string;
  }
  /** Multiple guests associated to Tickets */
  interface TicketGuest {
      /** Event id */
      eventId?: string;
      /** Order number */
      orderNumber?: string | null;
      /** Ticket numbers must be from the same order only. */
      ticketNumber?: string[];
  }
  interface TriggerNotificationResponse {
  }
  interface RsvpCreated$1 {
      /** RSVP created timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Site language when RSVP created */
      language?: string | null;
      /** Notifications silenced for this domain event. */
      silent?: boolean | null;
      /**
       * Locale in which Rsvp was created.
       * @internal
       */
      locale?: string | null;
      /** Event ID. */
      eventId?: string;
      /** RSVP ID. */
      rsvpId?: string;
      /** Contact ID associated with this RSVP. */
      contactId?: string;
      /** Member ID associated with this RSVP. */
      memberId?: string | null;
      /** Guest first name. */
      firstName?: string;
      /** Guest last name. */
      lastName?: string;
      /** Guest email. */
      email?: string;
      /** RSVP form response. */
      rsvpForm?: FormResponse$4;
      /** RSVP response status. */
      status?: RsvpStatus$2;
      /** List of all guests. */
      guests?: Guest$3[];
      /** URL and password to online conference */
      onlineConferencingLogin?: OnlineConferencingLogin$4;
  }
  interface FormResponse$4 {
      inputValues?: InputValue$4[];
  }
  interface InputValue$4 {
      inputName?: string;
      value?: string;
      values?: string[];
      /**
       * Int or floating point number value.
       * @internal
       */
      number?: number | null;
      /**
       * Date/time value.
       * @internal
       */
      dateTime?: Date | null;
      /**
       * Address type value.
       * @internal
       */
      address?: FormattedAddress$4;
  }
  interface FormattedAddress$4 {
      /** One line address representation. */
      formatted?: string;
      /** Address components (optional). */
      address?: CommonAddress$3;
  }
  /** Physical address */
  interface CommonAddress$3 extends CommonAddressStreetOneOf$3 {
      /** Street name and number. */
      streetAddress?: CommonStreetAddress$3;
      /** Main address line, usually street and number as free text. */
      addressLine1?: string | null;
      /** Country code. */
      country?: string | null;
      /** Subdivision shorthand. Usually, a short code (2 or 3 letters) that represents a state, region, prefecture, or province. e.g. NY */
      subdivision?: string | null;
      /** City name. */
      city?: string | null;
      /** Zip/postal code. */
      postalCode?: string | null;
      /** Free text providing more detailed address info. Usually contains Apt, Suite, and Floor. */
      addressLine2?: string | null;
      /**
       * A string containing the full address of this location.
       * @internal
       */
      formatted?: string | null;
      /**
       * Coordinates of the physical address.
       * @internal
       */
      location?: CommonAddressLocation$3;
      /**
       * Country full name.
       * @internal
       */
      countryFullname?: string | null;
      /**
       * Subdivision full name.
       * @internal
       */
      subdivisionFullname?: string | null;
      /**
       * Multi-level subdivisions from top to bottom.
       * @internal
       */
      subdivisions?: CommonSubdivision$3[];
  }
  /** @oneof */
  interface CommonAddressStreetOneOf$3 {
      /** Street name and number. */
      streetAddress?: CommonStreetAddress$3;
      /** Main address line, usually street and number as free text. */
      addressLine?: string | null;
  }
  interface CommonStreetAddress$3 {
      /** Street number. */
      number?: string;
      /** Street name. */
      name?: string;
      /**
       * Apartment number.
       * @internal
       */
      apt?: string;
      /**
       * Optional address line 1
       * @internal
       */
      formattedAddressLine?: string | null;
  }
  interface CommonAddressLocation$3 {
      /** Address latitude. */
      latitude?: number | null;
      /** Address longitude. */
      longitude?: number | null;
  }
  interface CommonSubdivision$3 {
      /** Short subdivision code. */
      code?: string;
      /** Subdivision full name. */
      name?: string;
      /**
       * Subdivision level
       * @internal
       */
      type?: SubdivisionType$9;
      /**
       * Free text description of subdivision type.
       * @internal
       */
      typeInfo?: string | null;
      /**
       * Standard organizations details (e.g. ISO).
       * @internal
       */
      standardDetails?: StandardDetails$4;
  }
  enum SubdivisionType$9 {
      UNKNOWN_SUBDIVISION_TYPE = "UNKNOWN_SUBDIVISION_TYPE",
      /** State */
      ADMINISTRATIVE_AREA_LEVEL_1 = "ADMINISTRATIVE_AREA_LEVEL_1",
      /** County */
      ADMINISTRATIVE_AREA_LEVEL_2 = "ADMINISTRATIVE_AREA_LEVEL_2",
      /** City/town */
      ADMINISTRATIVE_AREA_LEVEL_3 = "ADMINISTRATIVE_AREA_LEVEL_3",
      /** Neighborhood/quarter */
      ADMINISTRATIVE_AREA_LEVEL_4 = "ADMINISTRATIVE_AREA_LEVEL_4",
      /** Street/block */
      ADMINISTRATIVE_AREA_LEVEL_5 = "ADMINISTRATIVE_AREA_LEVEL_5",
      /** ADMINISTRATIVE_AREA_LEVEL_0. Indicates the national political entity, and is typically the highest order type returned by the Geocoder. */
      COUNTRY = "COUNTRY"
  }
  /** Subdivision Concordance values */
  interface StandardDetails$4 {
      /** subdivision iso-3166-2 code according to [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). e.g. US-NY, GB-SCT, NO-30 */
      iso31662?: string | null;
  }
  enum RsvpStatus$2 {
      YES = "YES",
      NO = "NO",
      WAITING = "WAITING"
  }
  interface Guest$3 {
      /** Index in the RSVP guest list. */
      index?: number;
      /** Guest full name. */
      fullName?: string;
      /** Guest check-in. */
      checkIn?: CheckIn$3;
      /** Unique guest ID per RSVP. */
      _id?: number;
  }
  interface CheckIn$3 {
      /** Time of check-in */
      created?: Date | null;
  }
  interface OnlineConferencingLogin$4 {
      /**
       * Link URL to the online conference.
       * @readonly
       */
      link?: string;
      /**
       * Password for the online conference.
       * @readonly
       */
      password?: string | null;
  }
  interface Empty$5 {
  }
  interface RsvpUpdated$1 {
      /** RSVP updated timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Site language when RSVP created */
      language?: string | null;
      /** Locale in which Rsvp was created. */
      locale?: string | null;
      /** Event ID. */
      eventId?: string;
      /** RSVP ID. */
      rsvpId?: string;
      /** Contact ID associated with this RSVP. */
      contactId?: string;
      /** Member ID associated with this RSVP. */
      memberId?: string | null;
      /** RSVP created timestamp. */
      created?: Date | null;
      /** Guest first name. */
      firstName?: string;
      /** Guest last name. */
      lastName?: string;
      /** Guest email. */
      email?: string;
      /** RSVP form response. */
      rsvpForm?: FormResponse$4;
      /** RSVP response status. */
      status?: RsvpStatus$2;
      /** List of the guests. */
      guests?: Guest$3[];
      /** URL and password to online conference */
      onlineConferencingLogin?: OnlineConferencingLogin$4;
      /** Notifications silenced for this domain event. */
      silent?: boolean | null;
  }
  interface DomainEvent$8 extends DomainEventBodyOneOf$8 {
      createdEvent?: EntityCreatedEvent$8;
      updatedEvent?: EntityUpdatedEvent$8;
      deletedEvent?: EntityDeletedEvent$8;
      actionEvent?: ActionEvent$8;
      /**
       * Unique event ID.
       * Allows clients to ignore duplicate webhooks.
       */
      _id?: string;
      /**
       * Assumes actions are also always typed to an entity_type
       * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
       */
      entityFqdn?: string;
      /**
       * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
       * This is although the created/updated/deleted notion is duplication of the oneof types
       * Example: created/updated/deleted/started/completed/email_opened
       */
      slug?: string;
      /** ID of the entity associated with the event. */
      entityId?: string;
      /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
      eventTime?: Date | null;
      /**
       * Whether the event was triggered as a result of a privacy regulation application
       * (for example, GDPR).
       */
      triggeredByAnonymizeRequest?: boolean | null;
      /** If present, indicates the action that triggered the event. */
      originatedFrom?: string | null;
      /**
       * A sequence number defining the order of updates to the underlying entity.
       * For example, given that some entity was updated at 16:00 and than again at 16:01,
       * it is guaranteed that the sequence number of the second update is strictly higher than the first.
       * As the consumer, you can use this value to ensure that you handle messages in the correct order.
       * To do so, you will need to persist this number on your end, and compare the sequence number from the
       * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
       */
      entityEventSequence?: string | null;
  }
  /** @oneof */
  interface DomainEventBodyOneOf$8 {
      createdEvent?: EntityCreatedEvent$8;
      updatedEvent?: EntityUpdatedEvent$8;
      deletedEvent?: EntityDeletedEvent$8;
      actionEvent?: ActionEvent$8;
  }
  interface EntityCreatedEvent$8 {
      entityAsJson?: string;
      /**
       * Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity
       * @internal
       */
      triggeredByUndelete?: boolean | null;
      /** Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity */
      restoreInfo?: RestoreInfo$8;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface RestoreInfo$8 {
      deletedDate?: Date | null;
  }
  interface EntityUpdatedEvent$8 {
      /**
       * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
       * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
       * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
       */
      currentEntityAsJson?: string;
      /**
       * This field is currently part of the of the EntityUpdatedEvent msg, but scala/node libraries which implements the domain events standard
       * wont populate it / have any reference to it in the API.
       * The main reason for it is that fetching the old entity from the DB will have a performance hit on an update operation so unless truly needed,
       * the developer should send only the new (current) entity.
       * An additional reason is not wanting to send this additional entity over the wire (kafka) since in some cases it can be really big
       * Developers that must reflect the old entity will have to implement their own domain event sender mechanism which will follow the DomainEvent proto message.
       * @internal
       * @deprecated
       */
      previousEntityAsJson?: string | null;
      /**
       * WIP - This property will hold both names and previous values of the updated fields of the entity.
       * For more details please see [adr](https://docs.google.com/document/d/1PdqsOM20Ph2HAkmx8zvUnzzk3Sekp3BR9h34wSvsRnI/edit#heading=h.phlw87mh2imx) or [issue](https://github.com/wix-private/nile-tracker/issues/363)
       * @internal
       */
      modifiedFields?: Record<string, any>;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface EntityDeletedEvent$8 {
      /**
       * Indicates if the entity is sent to trash-bin. only available when trash-bin is enabled
       * @internal
       */
      movedToTrash?: boolean | null;
      /** Entity that was deleted */
      deletedEntityAsJson?: string | null;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface ActionEvent$8 {
      bodyAsJson?: string;
  }
  interface EventUpdated$3 {
      /** Event update timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Event ID. */
      eventId?: string;
      /** Event location. */
      location?: Location$6;
      /** Event schedule configuration. */
      scheduleConfig?: ScheduleConfig$6;
      /** Event title. */
      title?: string;
      /**
       * Whether schedule configuration was updated.
       * @deprecated
       */
      scheduleConfigUpdated?: boolean;
      /**
       * The set of properties which were updated. For example 'title' or 'location'
       * @internal
       */
      fields?: string[];
      /**
       * Whether event has opened new spots with this update.
       * @internal
       */
      newSpotsOpened?: boolean | null;
      /** Updated event */
      event?: Event$4;
  }
  interface Location$6 {
      /** Location name. */
      name?: string | null;
      /** Location map coordinates. */
      coordinates?: MapCoordinates$6;
      /** Single line address representation. */
      address?: string | null;
      /** Location type. */
      type?: LocationType$6;
      /**
       * Full address derived from formatted single line `address`.
       * When `full_address` is used to create or update the event, deprecated `address` and `coordinates` are ignored.
       * If provided `full_address` has empty `formatted_address` or `coordinates`, it will be auto-completed using Atlas service.
       *
       * Migration notes:
       * - `full_address.formatted_address` is equivalent to `address`.
       * - `full_address.geocode` is equivalent to `coordinates`.
       */
      fullAddress?: Address$9;
      /**
       * Defines event location as TBD (To Be Determined).
       * When event location is not yet defined, `name` is displayed instead of location address.
       * `coordinates`, `address`, `type` and `full_address` are not required when location is TBD.
       */
      tbd?: boolean | null;
  }
  interface MapCoordinates$6 {
      /** Latitude. */
      lat?: number;
      /** Longitude. */
      lng?: number;
  }
  enum LocationType$6 {
      VENUE = "VENUE",
      ONLINE = "ONLINE"
  }
  /** Physical address */
  interface Address$9 extends AddressStreetOneOf$9 {
      /** a break down of the street to number and street name */
      streetAddress?: StreetAddress$9;
      /** Main address line (usually street and number) as free text */
      addressLine1?: string | null;
      /** country code */
      country?: string | null;
      /** subdivision (usually state or region) code according to ISO 3166-2 */
      subdivision?: string | null;
      /** city name */
      city?: string | null;
      /** zip/postal code */
      postalCode?: string | null;
      /** Free text providing more detailed address info. Usually contains Apt, Suite, Floor */
      addressLine2?: string | null;
      /** A string containing the human-readable address of this location */
      formatted?: string | null;
      /** coordinates of the physical address */
      location?: AddressLocation$9;
      /** country full-name */
      countryFullname?: string | null;
      /** multi-level subdivisions from top to bottom */
      subdivisions?: Subdivision$9[];
  }
  /** @oneof */
  interface AddressStreetOneOf$9 {
      /** a break down of the street to number and street name */
      streetAddress?: StreetAddress$9;
      /** Main address line (usually street and number) as free text */
      addressLine?: string | null;
  }
  interface StreetAddress$9 {
      /** street number */
      number?: string;
      /** street name */
      name?: string;
      /**
       * apartment number
       * @internal
       */
      apt?: string;
  }
  interface AddressLocation$9 {
      /** address latitude coordinates */
      latitude?: number | null;
      /** address longitude coordinates */
      longitude?: number | null;
  }
  interface Subdivision$9 {
      /** subdivision short code */
      code?: string;
      /** subdivision full-name */
      name?: string;
      /**
       * subdivision level
       * @internal
       */
      type?: SubdivisionType$9;
      /**
       * free text description of subdivision type
       * @internal
       */
      typeInfo?: string | null;
  }
  interface ScheduleConfig$6 {
      /**
       * Defines event as TBD (To Be Determined) schedule.
       * When event time is not yet defined, TBD message is displayed instead of event start and end times.
       * `startDate`, `endDate` and `timeZoneId` are not required when schedule is TBD.
       */
      scheduleTbd?: boolean;
      /** TBD message. */
      scheduleTbdMessage?: string | null;
      /** Event start timestamp. */
      startDate?: Date | null;
      /** Event end timestamp. */
      endDate?: Date | null;
      /** Event time zone ID in TZ database format, e.g., `EST`, `America/Los_Angeles`. */
      timeZoneId?: string | null;
      /** Whether end date is hidden in the formatted schedule. */
      endDateHidden?: boolean;
      /** Whether time zone is displayed in formatted schedule. */
      showTimeZone?: boolean;
      /** Event recurrences. */
      recurrences?: Recurrences$6;
  }
  interface Recurrences$6 {
      /** Event occurrences. */
      occurrences?: Occurrence$6[];
      /**
       * Recurring event category ID.
       * @readonly
       */
      categoryId?: string | null;
      /**
       * Recurrence status.
       * @readonly
       */
      status?: Status$7;
  }
  interface Occurrence$6 {
      /** Event start timestamp. */
      startDate?: Date | null;
      /** Event end timestamp. */
      endDate?: Date | null;
      /** Event time zone ID in TZ database format, e.g., `EST`, `America/Los_Angeles`. */
      timeZoneId?: string | null;
      /** Whether time zone is displayed in formatted schedule. */
      showTimeZone?: boolean;
  }
  enum Status$7 {
      /** Event occurs only once. */
      ONE_TIME = "ONE_TIME",
      /** Event is recurring. */
      RECURRING = "RECURRING",
      /** Marks the next upcoming occurrence of the recurring event. */
      RECURRING_NEXT = "RECURRING_NEXT",
      /** Marks the most recent ended occurrence of the recurring event. */
      RECURRING_LAST_ENDED = "RECURRING_LAST_ENDED",
      /** Marks the most recent canceled occurrence of the recurring event. */
      RECURRING_LAST_CANCELED = "RECURRING_LAST_CANCELED"
  }
  interface Event$4 {
      /**
       * Event ID.
       * @readonly
       */
      _id?: string;
      /** Event location. */
      location?: Location$6;
      /** Event scheduling. */
      scheduling?: Scheduling$4;
      /** Event title. */
      title?: string;
      /** Event description. */
      description?: string;
      /** Rich-text content displayed in Wix UI - "About Event" section (HTML). */
      about?: string;
      /** Main event image. */
      mainImage?: string;
      /** Event slug URL (generated from event title). */
      slug?: string;
      /** ISO 639-1 language code of the event (used in content translations). */
      language?: string;
      /** Event creation timestamp. */
      created?: Date | null;
      /** Event modified timestamp. */
      modified?: Date | null;
      /** Event status. */
      status?: EventStatus$6;
      /** RSVP or ticketing registration details. */
      registration?: Registration$4;
      /** "Add to calendar" URLs. */
      calendarLinks?: CalendarLinks$6;
      /** Event page URL components. */
      eventPageUrl?: SiteUrl$4;
      /** Event registration form. */
      form?: Form$4;
      /** Event dashboard summary of RSVP / ticket sales. */
      dashboard?: Dashboard$6;
      /** Instance ID of the site where event is hosted. */
      instanceId?: string;
      /** Guest list configuration. */
      guestListConfig?: GuestListConfig$4;
      /** Event creator user ID. */
      userId?: string;
      /** Event discussion feed. For internal use. */
      feed?: Feed$4;
      /** Online conferencing details. */
      onlineConferencing?: OnlineConferencing$4;
      /** SEO settings. */
      seoSettings?: SeoSettings$4;
      /** Assigned contacts label key. */
      assignedContactsLabel?: string | null;
      /** Agenda details. */
      agenda?: Agenda$4;
      /** Categories this event is assigned to. */
      categories?: Category$5[];
      /** Visual settings for event. */
      eventDisplaySettings?: EventDisplaySettings$4;
      /**
       * @internal
       * @readonly
       */
      customizableTickets?: boolean | null;
      /**
       * Labelling related data.
       * @internal
       */
      labellingSettings?: LabellingSettings$4;
  }
  interface Scheduling$4 {
      /** Schedule configuration. */
      config?: ScheduleConfig$6;
      /** Formatted schedule representation. */
      formatted?: string;
      /** Formatted start date of the event (empty for TBD schedules). */
      startDateFormatted?: string;
      /** Formatted start time of the event (empty for TBD schedules). */
      startTimeFormatted?: string;
      /** Formatted end date of the event (empty for TBD schedules or when end date is hidden). */
      endDateFormatted?: string;
      /** Formatted end time of the event (empty for TBD schedules or when end date is hidden). */
      endTimeFormatted?: string;
  }
  enum EventStatus$6 {
      /** Event is public and scheduled to start */
      SCHEDULED = "SCHEDULED",
      /** Event has started */
      STARTED = "STARTED",
      /** Event has ended */
      ENDED = "ENDED",
      /** Event was canceled */
      CANCELED = "CANCELED",
      /** Event is not public and needs to be published */
      DRAFT = "DRAFT"
  }
  interface Registration$4 {
      /** Event type. */
      type?: EventType$4;
      /** Event registration status. */
      status?: RegistrationStatus$4;
      /** RSVP collection details. */
      rsvpCollection?: RsvpCollection$4;
      /** Ticketing details. */
      ticketing?: Ticketing$4;
      /** External registration details. */
      external?: ExternalEvent$4;
      /** Types of users allowed to register. */
      restrictedTo?: VisitorType$4;
      /** Initial event type which was set when creating an event. */
      initialType?: EventType$4;
  }
  enum EventType$4 {
      /** Type not available for this request fieldset */
      NA_EVENT_TYPE = "NA_EVENT_TYPE",
      /** Registration via RSVP */
      RSVP = "RSVP",
      /** Registration via ticket purchase */
      TICKETS = "TICKETS",
      /** External registration */
      EXTERNAL = "EXTERNAL",
      /** Registration not available */
      NO_REGISTRATION = "NO_REGISTRATION"
  }
  enum RegistrationStatus$4 {
      /** Registration status is not applicable */
      NA_REGISTRATION_STATUS = "NA_REGISTRATION_STATUS",
      /** Registration to event is closed */
      CLOSED = "CLOSED",
      /** Registration to event is closed manually */
      CLOSED_MANUALLY = "CLOSED_MANUALLY",
      /** Registration is open via RSVP */
      OPEN_RSVP = "OPEN_RSVP",
      /** Registration to event waitlist is open via RSVP */
      OPEN_RSVP_WAITLIST = "OPEN_RSVP_WAITLIST",
      /** Registration is open via ticket purchase */
      OPEN_TICKETS = "OPEN_TICKETS",
      /** Registration is open via external URL */
      OPEN_EXTERNAL = "OPEN_EXTERNAL",
      /** Registration will be open via RSVP */
      SCHEDULED_RSVP = "SCHEDULED_RSVP"
  }
  interface RsvpCollection$4 {
      /** RSVP collection configuration. */
      config?: RsvpCollectionConfig$4;
  }
  interface RsvpCollectionConfig$4 {
      /** Defines the supported RSVP statuses. */
      rsvpStatusOptions?: RsvpStatusOptions$4;
      /**
       * Total guest limit available to register to the event.
       * Additional guests per RSVP are counted towards total guests.
       */
      limit?: number | null;
      /** Whether a waitlist is opened when total guest limit is reached, allowing guests to create RSVP with WAITING RSVP status. */
      waitlist?: boolean;
      /** Registration start timestamp. */
      startDate?: Date | null;
      /** Registration end timestamp. */
      endDate?: Date | null;
  }
  enum RsvpStatusOptions$4 {
      /** Only YES RSVP status is available for RSVP registration */
      YES_ONLY = "YES_ONLY",
      /** YES and NO RSVP status options are available for the registration */
      YES_AND_NO = "YES_AND_NO"
  }
  interface Ticketing$4 {
      /**
       * Deprecated.
       * @deprecated
       */
      lowestPrice?: string | null;
      /**
       * Deprecated.
       * @deprecated
       */
      highestPrice?: string | null;
      /** Currency used in event transactions. */
      currency?: string | null;
      /** Ticketing configuration. */
      config?: TicketingConfig$4;
      /**
       * Price of lowest priced ticket.
       * @readonly
       */
      lowestTicketPrice?: Money$7;
      /**
       * Price of highest priced ticket.
       * @readonly
       */
      highestTicketPrice?: Money$7;
      /**
       * Formatted price of lowest priced ticket.
       * @readonly
       */
      lowestTicketPriceFormatted?: string | null;
      /**
       * Formatted price of highest priced ticket.
       * @readonly
       */
      highestTicketPriceFormatted?: string | null;
      /**
       * Whether all tickets are sold for this event.
       * @readonly
       */
      soldOut?: boolean | null;
  }
  interface TicketingConfig$4 {
      /** Whether the form must be filled out separately for each ticket. */
      guestAssignedTickets?: boolean;
      /** Tax configuration. */
      taxConfig?: TaxConfig$4;
      /** Limit of tickets that can be purchased per order, default 20. */
      ticketLimitPerOrder?: number;
      /**
       * App Id for external ticket stock management.
       * By default tickets stock is defined in TicketDefinition object.
       * If defined then limitation from TicketDefinition is ignored.
       * @internal
       */
      stockManagerAppId?: string | null;
      /** Duration for which the tickets being bought are reserved. */
      reservationDurationInMinutes?: number | null;
  }
  interface TaxConfig$4 {
      /** Tax application settings. */
      type?: TaxType$5;
      /** Tax name. */
      name?: string | null;
      /** Tax rate (e.g.,`21.55`). */
      rate?: string | null;
      /** Applies taxes for donations, default true. */
      appliesToDonations?: boolean | null;
  }
  enum TaxType$5 {
      /** Tax is included in the ticket price. */
      INCLUDED = "INCLUDED",
      /** Tax is added to the order at the checkout. */
      ADDED = "ADDED",
      /** Tax is added to the final total at the checkout. */
      ADDED_AT_CHECKOUT = "ADDED_AT_CHECKOUT"
  }
  interface Money$7 {
      /**
       * *Deprecated:** Use `value` instead.
       * @deprecated
       */
      amount?: string;
      /** ISO 4217 format of the currency e.g., `USD`. */
      currency?: string;
      /** Monetary amount. Decimal string with a period as a decimal separator (e.g., 3.99). Optionally, starts with a single (-), to indicate that the amount is negative. */
      value?: string | null;
  }
  interface ExternalEvent$4 {
      /** External event registration URL. */
      registration?: string;
  }
  enum VisitorType$4 {
      /** Site visitor (including member) */
      VISITOR = "VISITOR",
      /** Site member */
      MEMBER = "MEMBER",
      /** Site visitor or member */
      VISITOR_OR_MEMBER = "VISITOR_OR_MEMBER"
  }
  interface CalendarLinks$6 {
      /** "Add to Google calendar" URL. */
      google?: string;
      /** "Download ICS calendar file" URL. */
      ics?: string;
  }
  /** Site URL components */
  interface SiteUrl$4 {
      /**
       * Base URL. For premium sites, this will be the domain.
       * For free sites, this would be site URL (e.g `mysite.wixsite.com/mysite`)
       */
      base?: string;
      /** The path to that page - e.g `/my-events/weekly-meetup-2` */
      path?: string;
  }
  /**
   * The form defines which elements are rendered in the Wix UI during the registration process (RSVP or checkout).
   * It also contains customizable messages and labels.
   *
   *
   * A form is an ordered list of controls (blocks), which accept guest information into a field input.
   *
   * Each control contains one or more nested inputs. For example, `Name` control has two inputs:
   * - First Name
   * - Last Name
   *
   * By default, name and email controls are always required and are pinned to the top of the form.
   */
  interface Form$4 {
      /** Nested fields as an ordered list. */
      controls?: InputControl$4[];
      /** Set of configured form messages. */
      messages?: FormMessages$4;
  }
  /**
   * A block of nested fields.
   * Used to aggregate similar inputs like First Name and Last Name.
   */
  interface InputControl$4 {
      /** Field control type. */
      type?: InputControlType$4;
      /** Whether control is mandatory (such as name & email). When true, only label can be changed. */
      system?: boolean;
      /**
       * Deprecated: Use `id`.
       * @deprecated
       */
      name?: string;
      /** Child inputs. */
      inputs?: Input$4[];
      /**
       * Deprecated: use `inputs.label`.
       * @deprecated
       */
      label?: string;
      /** Field controls are sorted by this value in ascending order. */
      orderIndex?: number;
      /** Unique control ID. */
      _id?: string;
      /**
       * Whether input control is deleted.
       * @readonly
       */
      deleted?: boolean | null;
  }
  enum InputControlType$4 {
      /** Single text value field. */
      INPUT = "INPUT",
      /** Single text value field. */
      TEXTAREA = "TEXTAREA",
      /** Single-choice field of predefined values. */
      DROPDOWN = "DROPDOWN",
      /** Single-choice field of predefined values. */
      RADIO = "RADIO",
      /** Multiple-choice field of predefined values. */
      CHECKBOX = "CHECKBOX",
      /** First and last name fields. */
      NAME = "NAME",
      /** Additional guests and respective guest names fields. */
      GUEST_CONTROL = "GUEST_CONTROL",
      /** Single-line address field. */
      ADDRESS_SHORT = "ADDRESS_SHORT",
      /** Full address field. */
      ADDRESS_FULL = "ADDRESS_FULL",
      /** Year, month and day fields. */
      DATE = "DATE"
  }
  /** An input of one or multiple text values */
  interface Input$4 {
      /** Field name. */
      name?: string;
      /**
       * Deprecated: use `ValueType.TEXT_ARRAY`.
       * @deprecated
       */
      array?: boolean;
      /** Main field label */
      label?: string;
      /** Additional labels for multi-valued fields such as address. */
      additionalLabels?: Record<string, string>;
      /** Predefined choice options for fields, such as dropdown. */
      options?: string[];
      /** Whether field is mandatory. */
      mandatory?: boolean;
      /** Maximum number of accepted characters (relevant for text fields). */
      maxLength?: number;
      /**
       * Type which determines field format.
       * Used to validate submitted response.
       */
      type?: ValueType$4;
      /**
       * A maximum accepted values for array input.
       * Only applicable for inputs of valueType: TEXT_ARRAY.
       */
      maxSize?: number | null;
      /**
       * Preselected option.
       * Currently only applicable for dropdown.
       */
      defaultOptionSelection?: OptionSelection$4;
      /**
       * Additional labels for multi-valued fields such as address.
       * @readonly
       */
      labels?: Label$4[];
  }
  enum ValueType$4 {
      TEXT = "TEXT",
      NUMBER = "NUMBER",
      TEXT_ARRAY = "TEXT_ARRAY",
      DATE_TIME = "DATE_TIME",
      ADDRESS = "ADDRESS"
  }
  /**
   * Describes initially selected option when an input has multiple choices.
   * Defaults to first (0th) option if not configured.
   */
  interface OptionSelection$4 extends OptionSelectionSelectedOptionOneOf$4 {
      /** 0-based index from predefined `input.options` which is selected initially. */
      optionIndex?: number;
      /**
       * Placeholder hint describing expected choices (such as "Please select").
       * Considered an empty choice.
       */
      placeholderText?: string;
  }
  /** @oneof */
  interface OptionSelectionSelectedOptionOneOf$4 {
      /** 0-based index from predefined `input.options` which is selected initially. */
      optionIndex?: number;
      /**
       * Placeholder hint describing expected choices (such as "Please select").
       * Considered an empty choice.
       */
      placeholderText?: string;
  }
  interface Label$4 {
      /** Field name. */
      name?: string;
      /** Field label. */
      label?: string;
  }
  /**
   * Defines form messages shown in UI before, during, and after registration flow.
   * It enables configuration of form titles, response labels, "thank you" messages, and call-to-action texts.
   */
  interface FormMessages$4 {
      /** RSVP form messages. */
      rsvp?: RsvpFormMessages$4;
      /** Checkout form messages. */
      checkout?: CheckoutFormMessages$4;
      /** Messages shown when event registration is closed. */
      registrationClosed?: RegistrationClosedMessages$4;
      /** Messages shown when event tickets are unavailable. */
      ticketsUnavailable?: TicketsUnavailableMessages$4;
  }
  interface RsvpFormMessages$4 {
      /** Label text indicating RSVP `YES` response. */
      rsvpYesOption?: string;
      /** Label text indicating RSVP `NO` response. */
      rsvpNoOption?: string;
      /** Messages shown for RSVP = `YES`. */
      positiveMessages?: Positive$4;
      /** Messages shown for RSVP = `WAITING` (when event is full and waitlist is available). */
      waitlistMessages?: Positive$4;
      /** Messages shown for RSVP = `NO`. */
      negativeMessages?: Negative$4;
      /** "Submit form" call-to-action label text. */
      submitActionLabel?: string;
  }
  /** Confirmation messages shown after registration. */
  interface PositiveResponseConfirmation$4 {
      /** Confirmation message title. */
      title?: string;
      /** Confirmation message text. */
      message?: string;
      /** "Add to calendar" call-to-action label text. */
      addToCalendarActionLabel?: string;
      /** "Share event" call-to-action label text. */
      shareActionLabel?: string;
  }
  /** Confirmation messages shown after registration. */
  interface NegativeResponseConfirmation$4 {
      /** Confirmation message title. */
      title?: string;
      /** "Share event" call-to-action label text. */
      shareActionLabel?: string;
  }
  /** Set of messages shown during registration when RSVP response is positive. */
  interface Positive$4 {
      /** Main form title for positive response. */
      title?: string;
      /** Confirmation messages shown after registration. */
      confirmation?: PositiveResponseConfirmation$4;
  }
  /** A set of messages shown during registration with negative response */
  interface Negative$4 {
      /** Main form title for negative response. */
      title?: string;
      /** Confirmation messages shown after registration. */
      confirmation?: NegativeResponseConfirmation$4;
  }
  interface CheckoutFormMessages$4 {
      /** Main form title for response. */
      title?: string;
      /** Submit form call-to-action label text. */
      submitActionLabel?: string;
      /** Confirmation messages shown after checkout. */
      confirmation?: ResponseConfirmation$4;
  }
  /** Confirmation messages shown after checkout. */
  interface ResponseConfirmation$4 {
      /** Confirmation message title. */
      title?: string;
      /** Confirmation message text. */
      message?: string;
      /** "Download tickets" call-to-action label text. */
      downloadTicketsLabel?: string;
      /** "Add to calendar" call-to-action label text. */
      addToCalendarLabel?: string;
      /** "Share event" call-to-action label text. */
      shareEventLabel?: string;
  }
  interface RegistrationClosedMessages$4 {
      /** Message shown when event registration is closed. */
      message?: string;
      /** "Explore other events" call-to-action label text. */
      exploreEventsActionLabel?: string;
  }
  interface TicketsUnavailableMessages$4 {
      /** Message shown when event tickets are unavailable. */
      message?: string;
      /** "Explore other events" call-to-action label text. */
      exploreEventsActionLabel?: string;
  }
  interface Dashboard$6 {
      /** Guest RSVP summary. */
      rsvpSummary?: RsvpSummary$5;
      /**
       * Summary of revenue and tickets sold.
       * (Archived orders are not included).
       */
      ticketingSummary?: TicketingSummary$4;
  }
  interface RsvpSummary$5 {
      /** Total number of RSVPs. */
      total?: number;
      /** Number of RSVPs with status `YES`. */
      yes?: number;
      /** Number of RSVPs with status `NO`. */
      no?: number;
      /** Number of RSVPs in waitlist. */
      waitlist?: number;
  }
  interface TicketingSummary$4 {
      /** Number of tickets sold. */
      tickets?: number;
      /**
       * Total revenue, excluding fees.
       * (taxes and payment provider fees are not deducted.)
       */
      revenue?: Money$7;
      /** Whether currency is locked and cannot be changed (generally occurs after the first order in the specified currency has been created). */
      currencyLocked?: boolean;
      /** Number of orders placed. */
      orders?: number;
      /** Total balance of confirmed transactions. */
      totalSales?: Money$7;
  }
  interface GuestListConfig$4 {
      /** Whether members can see other members attending the event (defaults to true). */
      publicGuestList?: boolean;
  }
  interface Feed$4 {
      /** Event discussion feed token. */
      token?: string;
  }
  interface OnlineConferencing$4 {
      config?: OnlineConferencingConfig$4;
      session?: OnlineConferencingSession$4;
      /**
       * Configured conferencing provider name.
       * @internal
       * @readonly
       */
      providerName?: string;
  }
  interface OnlineConferencingConfig$4 {
      /**
       * Whether online conferencing is enabled (not supported for TBD schedules).
       * When enabled, links to join conferencing are generated and provided to guests.
       */
      enabled?: boolean;
      /** Conferencing provider ID. */
      providerId?: string | null;
      /** Conference type */
      conferenceType?: ConferenceType$4;
  }
  enum ConferenceType$4 {
      /** Everyone in the meeting can publish and subscribe video and audio. */
      MEETING = "MEETING",
      /** Guests can only subscribe to video and audio. */
      WEBINAR = "WEBINAR"
  }
  interface OnlineConferencingSession$4 {
      /**
       * Link for event host to start the online conference session.
       * @readonly
       */
      hostLink?: string;
      /**
       * Link for guests to join the online conference session.
       * @readonly
       */
      guestLink?: string;
      /**
       * The password required to join online conferencing session (when relevant).
       * @readonly
       */
      password?: string | null;
      /**
       * Indicates that session was created successfully on providers side.
       * @readonly
       */
      sessionCreated?: boolean | null;
      /**
       * Unique session id
       * @readonly
       */
      sessionId?: string | null;
  }
  interface SeoSettings$4 {
      /** URL slug */
      slug?: string;
      /** Advanced SEO data */
      advancedSeoData?: SeoSchema$4;
      /**
       * Hidden from SEO Site Map
       * @readonly
       */
      hidden?: boolean | null;
  }
  /**
   * The SEO schema object contains data about different types of meta tags. It makes sure that the information about your page is presented properly to search engines.
   * The search engines use this information for ranking purposes, or to display snippets in the search results.
   * This data will override other sources of tags (for example patterns) and will be included in the <head> section of the HTML document, while not being displayed on the page itself.
   */
  interface SeoSchema$4 {
      /** SEO tag information. */
      tags?: Tag$4[];
      /** SEO general settings. */
      settings?: Settings$5;
  }
  interface Keyword$4 {
      /** Keyword value. */
      term?: string;
      /** Whether the keyword is the main focus keyword. */
      isMain?: boolean;
      /** The source that added the keyword terms to the SEO settings. */
      origin?: string | null;
  }
  interface Tag$4 {
      /**
       * SEO tag type.
       *
       *
       * Supported values: `title`, `meta`, `script`, `link`.
       */
      type?: string;
      /**
       * A `{"key": "value"}` pair object where each SEO tag property (`"name"`, `"content"`, `"rel"`, `"href"`) contains a value.
       * For example: `{"name": "description", "content": "the description itself"}`.
       */
      props?: Record<string, any> | null;
      /** SEO tag meta data. For example, `{"height": 300, "width": 240}`. */
      meta?: Record<string, any> | null;
      /** SEO tag inner content. For example, `<title> inner content </title>`. */
      children?: string;
      /** Whether the tag is a custom tag. */
      custom?: boolean;
      /** Whether the tag is disabled. */
      disabled?: boolean;
  }
  interface Settings$5 {
      /**
       * Whether the Auto Redirect feature, which creates `301 redirects` on a slug change, is enabled.
       *
       *
       * Default: `false` (Auto Redirect is enabled.)
       */
      preventAutoRedirect?: boolean;
      /** User-selected keyword terms for a specific page. */
      keywords?: Keyword$4[];
  }
  interface Agenda$4 {
      /** Whether the schedule is enabled for the event. */
      enabled?: boolean;
      /**
       * Agenda page URL.
       * @readonly
       */
      pageUrl?: SiteUrl$4;
  }
  interface Category$5 {
      /**
       * Category ID.
       * @readonly
       */
      _id?: string;
      /** Category name. */
      name?: string;
      /**
       * Date and time when category was created.
       * @readonly
       */
      _createdDate?: Date | null;
      /**
       * Assigned events count. Deleted events are excluded.
       * @internal
       * @readonly
       * @deprecated
       */
      assignedEventsCount?: number | null;
      /**
       * The total number of draft and published events assigned to the category.
       * @readonly
       */
      counts?: CategoryCounts$5;
      /**
       * Category state. Possible values:
       *
       * `MANUAL`: Category is created manually by the user.
       * `AUTO`: Category is created automatically.
       * `RECURRING_EVENT`: Category is created automatically when publishing recurring events.
       * `HIDDEN`: Category can't be seen.
       *
       * Default: `MANUAL`.
       *
       * **Note:** The WIX_EVENTS.MANAGE_AUTO_CATEGORIES permission scope is required to use states other than `MANUAL`.
       */
      states?: State$8[];
      /**
       * Optionally client defined external ID.
       * @internal
       */
      externalId?: string | null;
  }
  interface CategoryCounts$5 {
      /** Total number of draft events assigned to the category. */
      assignedEventsCount?: number | null;
      /** Total number of published events assigned to the category. Deleted events are excluded. */
      assignedDraftEventsCount?: number | null;
  }
  enum State$8 {
      /** Created manually by the user. */
      MANUAL = "MANUAL",
      /** Created automatically. */
      AUTO = "AUTO",
      /** Created when publishing recurring events. */
      RECURRING_EVENT = "RECURRING_EVENT",
      /** Category is hidden. */
      HIDDEN = "HIDDEN",
      /** Category is used to store component events. */
      COMPONENT = "COMPONENT"
  }
  interface EventDisplaySettings$4 {
      /** Whether event details button is hidden. Only available for events with no registration. */
      hideEventDetailsButton?: boolean | null;
      /** Disables event details page visibility. If event has an external registration configured visitors will be redirected from this page. */
      hideEventDetailsPage?: boolean | null;
  }
  interface LabellingSettings$4 {
      /**
       * @internal
       * @readonly
       */
      assignedContactsLegacyLabelId?: string | null;
      /**
       * @internal
       * @readonly
       */
      assignedContactsLabelDeleted?: boolean | null;
  }
  interface OrderConfirmed$1 {
      /** Order confirmation timestamp in ISO UTC. */
      timestamp?: Date | null;
      /** Site language when Order initiated */
      language?: string | null;
      /** Notifications silenced for this domain event. */
      silent?: boolean | null;
      /** Locale in which Order was created. */
      locale?: string | null;
      /** Event ID. */
      eventId?: string;
      /** Unique order number. */
      orderNumber?: string;
      /** Contact ID associated with this order. */
      contactId?: string;
      /** Member ID associated with this order. */
      memberId?: string | null;
      /**
       * Order created timestamp
       * @readonly
       */
      created?: Date | null;
      /** Buyer first name. */
      firstName?: string;
      /** Buyer last name. */
      lastName?: string;
      /** Buyer email address. */
      email?: string;
      /** Checkout form response. */
      checkoutForm?: FormResponse$4;
      /** Order status. */
      status?: OrderStatus$2;
      /** Payment method used for paid tickets purchase, i.e. "payPal", "creditCard", etc. */
      method?: string | null;
      /** Tickets (generated after payment). */
      tickets?: Ticket$2[];
      /** Invoice. */
      invoice?: Invoice$1;
      /** Reservation ID associated with this order. */
      reservationId?: string;
  }
  enum OrderStatus$2 {
      /** Order status not available for this request fieldset. */
      NA_ORDER_STATUS = "NA_ORDER_STATUS",
      /** Order is confirmed and payment isn't required. */
      FREE = "FREE",
      /** Order is paid for but the payment gateway has suspended the payment. */
      PENDING = "PENDING",
      /** Order is paid via a payment gateway. */
      PAID = "PAID",
      /** Order is confirmed but must be paid via offline payment. Status needs to be manually updated to `PAID`. */
      OFFLINE_PENDING = "OFFLINE_PENDING",
      /** Order is awaiting payment at the cashier. */
      INITIATED = "INITIATED",
      /** Order is canceled. */
      CANCELED = "CANCELED",
      /** Order payment is declined. */
      DECLINED = "DECLINED",
      /** Order payment is authorized. */
      AUTHORIZED = "AUTHORIZED",
      /** Order payment is voided. */
      VOIDED = "VOIDED",
      /** Order is partially paid with less than the total amount. */
      PARTIALLY_PAID = "PARTIALLY_PAID"
  }
  interface Ticket$2 {
      /** Unique issued ticket number. */
      ticketNumber?: string;
      /** Ticket definition ID. */
      ticketDefinitionId?: string;
      /** Ticket check-in. */
      checkIn?: CheckIn$3;
      /** Ticket price. */
      price?: Money$7;
      /** Whether ticket is archived. */
      archived?: boolean;
      /** Guest first name. */
      firstName?: string | null;
      /** Guest last name. */
      lastName?: string | null;
      /** Guest email. */
      email?: string | null;
      /** Contact ID associated with this ticket. */
      contactId?: string | null;
      /** Whether ticket is confirmed */
      confirmed?: boolean;
      /** Member ID associated with this ticket. */
      memberId?: string | null;
      /** Ticket form response (only assigned tickets contain separate forms). */
      form?: FormResponse$4;
      /** Ticket name. */
      ticketName?: string;
      /** Anonymized tickets no longer contain personally identifiable information (PII). */
      anonymized?: boolean;
      /** URL and password to online conference */
      onlineConferencingLogin?: OnlineConferencingLogin$4;
  }
  interface Invoice$1 {
      items?: Item$2[];
      /**
       * Total cart amount.
       * @deprecated
       */
      total?: Money$7;
      /** Discount applied to cart. */
      discount?: Discount$1;
      /** Tax applied to cart. */
      tax?: Tax$1;
      /** Total cart amount before discount, tax, and fees. */
      subTotal?: Money$7;
      /**
       * Total amount of cart after discount, tax, and fees.
       * Grand total is calculated in the following order:
       * 1. Total prices of all items in the cart are calculated.
       * 2. Discount is subtracted from the cart (if applicable).
       * 3. Tax is added (if applicable).
       * 4. Wix ticket service fee is added.
       */
      grandTotal?: Money$7;
      /**
       * Fees applied to the cart.
       * @readonly
       */
      fees?: Fee$1[];
      /** Total revenue, excluding fees. (Taxes and payment provider fees are not deducted). */
      revenue?: Money$7;
      /** URL to invoice preview. Returned only if order is paid. */
      previewUrl?: string | null;
  }
  interface Item$2 {
      /** Unique line item ID. */
      _id?: string;
      /** Line item quantity. */
      quantity?: number;
      /** Line item name. */
      name?: string;
      /** Line item price. */
      price?: Money$7;
      /** Total price for line items. Always equal to price * quantity. */
      total?: Money$7;
      /** Discount applied to the line item. */
      discount?: Discount$1;
      /** Tax applied to the item. */
      tax?: Tax$1;
      /**
       * Fees applied to the item.
       * @readonly
       */
      fees?: Fee$1[];
  }
  interface Discount$1 {
      /** Total discount amount. */
      amount?: Money$7;
      /** Total charge after applied discount. */
      afterDiscount?: Money$7;
      /**
       * Discount coupon code.
       * @deprecated
       */
      code?: string;
      /**
       * Discount coupon name.
       * @deprecated
       */
      name?: string;
      /**
       * Discount coupon ID.
       * @deprecated
       */
      couponId?: string;
      /** Discount items. */
      discounts?: DiscountItem$1[];
  }
  interface DiscountItem$1 extends DiscountItemDiscountOneOf$1 {
      /** Coupon discount. */
      coupon?: CouponDiscount$1;
      /** Pricing plan discount. */
      paidPlan?: PaidPlanDiscount$1;
      /** Total discount amount. */
      amount?: Money$7;
  }
  /** @oneof */
  interface DiscountItemDiscountOneOf$1 {
      /** Coupon discount. */
      coupon?: CouponDiscount$1;
      /** Pricing plan discount. */
      paidPlan?: PaidPlanDiscount$1;
  }
  interface CouponDiscount$1 {
      /** Discount coupon name. */
      name?: string;
      /** Discount coupon code. */
      code?: string;
      /** Discount coupon ID. */
      couponId?: string;
  }
  interface PaidPlanDiscount$1 extends PaidPlanDiscountDiscountOneOf$1 {
      /** Discount by percentage applied to tickets. */
      percentDiscount?: PercentDiscount$1;
      /** Name of pricing plan. */
      name?: string;
  }
  /** @oneof */
  interface PaidPlanDiscountDiscountOneOf$1 {
      /** Discount by percentage applied to tickets. */
      percentDiscount?: PercentDiscount$1;
  }
  interface PercentDiscount$1 {
      /** Percent rate. */
      rate?: string;
      /** Number of discounted tickets. */
      quantityDiscounted?: number;
  }
  interface Tax$1 {
      /** Tax type. */
      type?: TaxType$5;
      /**
       * Tax name.
       * @readonly
       */
      name?: string;
      /** Tax rate. */
      rate?: string;
      /** Taxable amount. */
      taxable?: Money$7;
      /** Total tax amount. */
      amount?: Money$7;
  }
  interface Fee$1 {
      /** Fee identifier. */
      name?: FeeName$1;
      /** How fee is calculated. */
      type?: FeeType$2;
      /**
       * Fee rate.
       * @readonly
       */
      rate?: string;
      /** Total amount of fee charges. */
      amount?: Money$7;
  }
  enum FeeName$1 {
      /** Wix ticket service fee charges applied to the line item. */
      WIX_FEE = "WIX_FEE"
  }
  enum FeeType$2 {
      /** Fee is added to the ticket price at checkout. */
      FEE_ADDED = "FEE_ADDED",
      /** Seller absorbs the fee. It is deducted from the ticket price. */
      FEE_INCLUDED = "FEE_INCLUDED",
      /** Fee is added to the ticket price at checkout. */
      FEE_ADDED_AT_CHECKOUT = "FEE_ADDED_AT_CHECKOUT"
  }
  /** Produced if a buyer email was added to the existing order */
  interface OrderEmailAdded {
      /** Order updated timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Site language when Order initiated */
      language?: string | null;
      /** Locale in which Order was created. */
      locale?: string | null;
      /** Notifications silenced for this domain event. */
      silent?: boolean | null;
      /** Event ID. */
      eventId?: string;
      /** Unique order number. */
      orderNumber?: string;
      /** Contact ID associated with this order. */
      contactId?: string | null;
      /** Member ID associated with this order. */
      memberId?: string | null;
      /**
       * Order created timestamp.
       * @readonly
       */
      created?: Date | null;
      /**
       * Order updated timestamp.
       * @readonly
       */
      updated?: Date | null;
      /** Buyer first name. */
      firstName?: string | null;
      /** Buyer last name. */
      lastName?: string | null;
      /** Buyer email. */
      email?: string | null;
      /** Checkout form response. */
      checkoutForm?: FormResponse$4;
      /** Whether order is confirmed - occurs once payment gateway processes the payment and funds reach merchant's account. */
      confirmed?: boolean;
      /** Order status. */
      status?: OrderStatus$2;
      /** Payment method used for paid tickets purchase, i.e. "payPal", "creditCard", etc. */
      method?: string | null;
      /** Tickets generated after payment. */
      tickets?: Ticket$2[];
      /** Whether order was archived and excluded from results. */
      archived?: boolean;
      /** Reservation ID associated with this order. */
      reservationId?: string;
  }
  interface EventCanceled$2 {
      /** Event canceled timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Event ID. */
      eventId?: string;
      /** Event title */
      title?: string;
      /** Event creator user ID. */
      userId?: string | null;
  }
  interface EventReminder$1 {
      /** Reminder timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Event ID. */
      eventId?: string;
      /** Event location. */
      location?: Location$6;
      /** Event schedule configuration. */
      scheduleConfig?: ScheduleConfig$6;
      /** Event title. */
      title?: string;
      /** Event creator user ID. */
      userId?: string | null;
      /** Time until the event starts (currently, reminder is triggered 1 day before event starts). */
      startsIn?: TimeDuration$1;
  }
  /**
   * A coarse-grained representation of time duration divided into whole constituting components of days, hours, and minutes.
   * For example, 25.5 hours duration is represented as `{ days: 1, hours: 1, minutes: 30 }`.
   */
  interface TimeDuration$1 {
      /** Number of days. */
      days?: number;
      /** Number of hours. */
      hours?: number;
      /** Number of minutes. */
      minutes?: number;
  }
  interface OrderPaid$1 {
      /** Order paid timestamp in ISO UTC. */
      timestamp?: Date | null;
      /** Site language when Order initiated */
      language?: string | null;
      /** Notifications silenced for this domain event. */
      silent?: boolean | null;
      /** Locale in which Order was created. */
      locale?: string | null;
      /** Event ID. */
      eventId?: string;
      /** Unique order number. */
      orderNumber?: string;
      /** Reservation ID associated with this order. */
      reservationId?: string;
      /** Contact ID associated with this order. */
      contactId?: string;
      /** Member ID associated with this order. */
      memberId?: string | null;
      /**
       * Order created timestamp
       * @readonly
       */
      created?: Date | null;
      /** Buyer first name. */
      firstName?: string;
      /** Buyer last name. */
      lastName?: string;
      /** Buyer email address. */
      email?: string;
      /** Checkout form response. */
      checkoutForm?: FormResponse$4;
      /** Order status. */
      status?: OrderStatus$2;
      /** Payment method used for paid tickets purchase, i.e. "payPal", "creditCard", etc. */
      method?: string | null;
      /** Tickets (generated after payment). */
      tickets?: Ticket$2[];
      /** Invoice. */
      invoice?: Invoice$1;
  }
  interface TicketPdfResolved {
      /** Optional order number */
      orderNumber?: string | null;
      /** Optional ticket number */
      ticketNumber?: string | null;
      /** Resolved download url */
      downloadUrl?: string | null;
      /** Resolve status */
      resolveFailed?: boolean | null;
      /** Papyrus document id */
      documentId?: string | null;
  }
  interface TicketPdfResolveDelayed {
      /** Optional order number */
      orderNumber?: string | null;
      /** Optional ticket number */
      ticketNumber?: string | null;
      /** Papyrus document id */
      documentId?: string | null;
  }
  interface OrderCanceled {
      /** Event ID. */
      eventId?: string;
      /** Unique order number. */
      orderNumber?: string;
      /** Reservation ID associated with this order. */
      reservationId?: string;
      /** Contact ID associated with this order. */
      contactId?: string;
      /** Buyer first name. */
      firstName?: string | null;
      /** Buyer last name. */
      lastName?: string | null;
      /** Buyer email address. */
      email?: string | null;
      /** Checkout form response. */
      checkoutForm?: FormResponse$4;
      /** Invoice. */
      invoice?: Invoice$1;
  }
  interface EventEnded$2 {
      /** Event end timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Event ID. */
      eventId?: string;
  }
  interface EventStarted$1 {
      /** Event start timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Event ID. */
      eventId?: string;
  }
  interface ResolveNotificationConfigRequest {
      /** Id of the NotificationConfig to retrieve */
      notificationConfigId: string;
  }
  interface ResolveNotificationConfigResponse {
      /** The retrieved NotificationConfig */
      notificationConfig?: NotificationConfig;
  }
  interface UpsertNotificationConfigRequest {
      /** NotificationConfig to be upserted */
      notificationConfig: NotificationConfig;
      /**
       * Explicit list of fields to update.
       * @internal
       */
      fieldMask?: string[];
  }
  interface UpsertNotificationConfigResponse {
      /** The upserted NotificationConfig */
      notificationConfig?: NotificationConfig;
  }
  interface ResolveEmailNotificationConfigRequest {
      /** Id of the NotificationConfig to retrieve */
      notificationConfigId?: string;
      /** Notification type */
      notificationType?: EmailNotificationType;
  }
  interface ResolveEmailNotificationConfigResponse {
      /** The retrieved EmailNotificationConfig */
      emailNotificationConfig?: EmailNotificationConfig;
  }
  interface EventDeleted$4 {
      /** Event deleted timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Event ID. */
      eventId?: string;
      /** Event title. */
      title?: string;
      /** Event creator user ID. */
      userId?: string | null;
      /**
       * Event categories.
       * @internal
       */
      categories?: string[];
  }
  interface EventCopied$3 {
      /** Event created timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Event ID. */
      eventId?: string;
      /** Event location. */
      location?: Location$6;
      /** Event schedule configuration. */
      scheduleConfig?: ScheduleConfig$6;
      /** Event title. */
      title?: string;
      /** Event creator user ID. */
      userId?: string | null;
      /** Event status. */
      status?: EventStatus$6;
      /** Instance ID. Indicates the original app instance which current event was derived from. */
      derivedFromInstanceId?: string | null;
      /** Event ID. Indicates the original event which current event was derived from. */
      derivedFromEventId?: string | null;
      /**
       * Map of copied ticket definitions from original event.
       * Key represents ticket def id in the original event.
       * Value represents ticket def id in the newly created event.
       */
      ticketDefinitions?: Record<string, string>;
  }
  interface MessageEnvelope$c {
      /** App instance ID. */
      instanceId?: string | null;
      /** Event type. */
      eventType?: string;
      /** The identification type and identity data. */
      identity?: IdentificationData$c;
      /** Stringify payload. */
      data?: string;
  }
  interface IdentificationData$c extends IdentificationDataIdOneOf$c {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
      /** @readonly */
      identityType?: WebhookIdentityType$c;
  }
  /** @oneof */
  interface IdentificationDataIdOneOf$c {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
  }
  enum WebhookIdentityType$c {
      UNKNOWN = "UNKNOWN",
      ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
      MEMBER = "MEMBER",
      WIX_USER = "WIX_USER",
      APP = "APP"
  }
  /**
   * Triggers notification
   * @public
   * @documentationMaturity preview
   * @permissionId WIX_EVENTS.MANAGE
   * @adminMethod
   */
  function triggerNotification(options?: TriggerNotificationOptions): Promise<void>;
  interface TriggerNotificationOptions extends TriggerNotificationRequestNotificationOneOf, TriggerNotificationRequestGuestsOneOf {
      /** Email notification type */
      emailNotificationType?: EmailNotificationType;
      /** Push notification type */
      pushNotificationType?: PushNotificationType;
      /** Rsvp guest info */
      rsvpGuest?: RsvpGuest;
      /** Order guest info */
      orderGuest?: OrderGuest;
      /** Event guests info */
      eventGuests?: EventGuests;
      /** Ticket guests info */
      ticketGuest?: TicketGuest;
  }
  /**
   * Resolves a NotificationConfig by id. Returns saved value or default value if not saved yet.
   * @param notificationConfigId - Id of the NotificationConfig to retrieve
   * @public
   * @documentationMaturity preview
   * @requiredField notificationConfigId
   * @permissionId WIX_EVENTS.READ_NOTIFICATION_CONFIG
   * @adminMethod
   */
  function resolveNotificationConfig(notificationConfigId: string): Promise<ResolveNotificationConfigResponse>;
  /**
   * Upsert a NotificationConfig
   * @param _id - Event ID.
   * @public
   * @documentationMaturity preview
   * @requiredField _id
   * @requiredField notificationConfig
   * @permissionId WIX_EVENTS.UPDATE_NOTIFICATION_CONFIG
   * @adminMethod
   */
  function upsertNotificationConfig(_id: string | null, notificationConfig: UpsertNotificationConfig, options?: UpsertNotificationConfigOptions): Promise<UpsertNotificationConfigResponse>;
  interface UpsertNotificationConfig {
      /** Event ID. */
      _id?: string | null;
      /** Represents the current state of an item. Each time the item is modified, its `revision` changes. for an update operation to succeed, you MUST pass the latest revision. */
      revision?: string | null;
      /**
       * Represents the time this NotificationConfig was created.
       * @readonly
       */
      _createdDate?: Date | null;
      /**
       * Represents the time this NotificationConfig was last updated.
       * @readonly
       */
      _updatedDate?: Date | null;
      /** Rsvp confirmation. */
      rsvpConfirmation?: EmailNotificationConfig;
      /** New spots available. */
      newSpotsAvailable?: EmailNotificationConfig;
      /** Event cancelation. */
      eventCancelation?: EmailNotificationConfig;
      /** Event reminder. */
      upcomingEventReminder?: EmailNotificationConfig;
      /** Order confirmation. */
      orderConfirmation?: EmailNotificationConfig;
      /** Ticket confirmation. */
      ticketConfirmation?: EmailNotificationConfig;
      /** Invoice. */
      invoice?: EmailNotificationConfig;
      /** Order confirmation with tickets link. */
      orderConfirmationWithTicketsLink?: EmailNotificationConfig;
  }
  interface UpsertNotificationConfigOptions {
      /**
       * Explicit list of fields to update.
       * @internal
       */
      fieldMask?: string[];
  }
  
  type eventsNotificationsV2NotificationConfig_universal_d_NotificationConfig = NotificationConfig;
  type eventsNotificationsV2NotificationConfig_universal_d_EmailNotificationConfig = EmailNotificationConfig;
  type eventsNotificationsV2NotificationConfig_universal_d_EmailNotificationType = EmailNotificationType;
  const eventsNotificationsV2NotificationConfig_universal_d_EmailNotificationType: typeof EmailNotificationType;
  type eventsNotificationsV2NotificationConfig_universal_d_EmailTemplate = EmailTemplate;
  type eventsNotificationsV2NotificationConfig_universal_d_EmailNotificationReminderTime = EmailNotificationReminderTime;
  const eventsNotificationsV2NotificationConfig_universal_d_EmailNotificationReminderTime: typeof EmailNotificationReminderTime;
  type eventsNotificationsV2NotificationConfig_universal_d_TriggerNotificationRequest = TriggerNotificationRequest;
  type eventsNotificationsV2NotificationConfig_universal_d_TriggerNotificationRequestNotificationOneOf = TriggerNotificationRequestNotificationOneOf;
  type eventsNotificationsV2NotificationConfig_universal_d_TriggerNotificationRequestGuestsOneOf = TriggerNotificationRequestGuestsOneOf;
  type eventsNotificationsV2NotificationConfig_universal_d_PushNotificationType = PushNotificationType;
  const eventsNotificationsV2NotificationConfig_universal_d_PushNotificationType: typeof PushNotificationType;
  type eventsNotificationsV2NotificationConfig_universal_d_RsvpGuest = RsvpGuest;
  type eventsNotificationsV2NotificationConfig_universal_d_OrderGuest = OrderGuest;
  type eventsNotificationsV2NotificationConfig_universal_d_EventGuests = EventGuests;
  type eventsNotificationsV2NotificationConfig_universal_d_TicketGuest = TicketGuest;
  type eventsNotificationsV2NotificationConfig_universal_d_TriggerNotificationResponse = TriggerNotificationResponse;
  type eventsNotificationsV2NotificationConfig_universal_d_OrderEmailAdded = OrderEmailAdded;
  type eventsNotificationsV2NotificationConfig_universal_d_TicketPdfResolved = TicketPdfResolved;
  type eventsNotificationsV2NotificationConfig_universal_d_TicketPdfResolveDelayed = TicketPdfResolveDelayed;
  type eventsNotificationsV2NotificationConfig_universal_d_OrderCanceled = OrderCanceled;
  type eventsNotificationsV2NotificationConfig_universal_d_ResolveNotificationConfigRequest = ResolveNotificationConfigRequest;
  type eventsNotificationsV2NotificationConfig_universal_d_ResolveNotificationConfigResponse = ResolveNotificationConfigResponse;
  type eventsNotificationsV2NotificationConfig_universal_d_UpsertNotificationConfigRequest = UpsertNotificationConfigRequest;
  type eventsNotificationsV2NotificationConfig_universal_d_UpsertNotificationConfigResponse = UpsertNotificationConfigResponse;
  type eventsNotificationsV2NotificationConfig_universal_d_ResolveEmailNotificationConfigRequest = ResolveEmailNotificationConfigRequest;
  type eventsNotificationsV2NotificationConfig_universal_d_ResolveEmailNotificationConfigResponse = ResolveEmailNotificationConfigResponse;
  const eventsNotificationsV2NotificationConfig_universal_d_triggerNotification: typeof triggerNotification;
  type eventsNotificationsV2NotificationConfig_universal_d_TriggerNotificationOptions = TriggerNotificationOptions;
  const eventsNotificationsV2NotificationConfig_universal_d_resolveNotificationConfig: typeof resolveNotificationConfig;
  const eventsNotificationsV2NotificationConfig_universal_d_upsertNotificationConfig: typeof upsertNotificationConfig;
  type eventsNotificationsV2NotificationConfig_universal_d_UpsertNotificationConfig = UpsertNotificationConfig;
  type eventsNotificationsV2NotificationConfig_universal_d_UpsertNotificationConfigOptions = UpsertNotificationConfigOptions;
  namespace eventsNotificationsV2NotificationConfig_universal_d {
    export {
      eventsNotificationsV2NotificationConfig_universal_d_NotificationConfig as NotificationConfig,
      eventsNotificationsV2NotificationConfig_universal_d_EmailNotificationConfig as EmailNotificationConfig,
      eventsNotificationsV2NotificationConfig_universal_d_EmailNotificationType as EmailNotificationType,
      eventsNotificationsV2NotificationConfig_universal_d_EmailTemplate as EmailTemplate,
      Link$1 as Link,
      eventsNotificationsV2NotificationConfig_universal_d_EmailNotificationReminderTime as EmailNotificationReminderTime,
      eventsNotificationsV2NotificationConfig_universal_d_TriggerNotificationRequest as TriggerNotificationRequest,
      eventsNotificationsV2NotificationConfig_universal_d_TriggerNotificationRequestNotificationOneOf as TriggerNotificationRequestNotificationOneOf,
      eventsNotificationsV2NotificationConfig_universal_d_TriggerNotificationRequestGuestsOneOf as TriggerNotificationRequestGuestsOneOf,
      eventsNotificationsV2NotificationConfig_universal_d_PushNotificationType as PushNotificationType,
      eventsNotificationsV2NotificationConfig_universal_d_RsvpGuest as RsvpGuest,
      eventsNotificationsV2NotificationConfig_universal_d_OrderGuest as OrderGuest,
      eventsNotificationsV2NotificationConfig_universal_d_EventGuests as EventGuests,
      eventsNotificationsV2NotificationConfig_universal_d_TicketGuest as TicketGuest,
      eventsNotificationsV2NotificationConfig_universal_d_TriggerNotificationResponse as TriggerNotificationResponse,
      RsvpCreated$1 as RsvpCreated,
      FormResponse$4 as FormResponse,
      InputValue$4 as InputValue,
      FormattedAddress$4 as FormattedAddress,
      CommonAddress$3 as CommonAddress,
      CommonAddressStreetOneOf$3 as CommonAddressStreetOneOf,
      CommonStreetAddress$3 as CommonStreetAddress,
      CommonAddressLocation$3 as CommonAddressLocation,
      CommonSubdivision$3 as CommonSubdivision,
      SubdivisionType$9 as SubdivisionType,
      StandardDetails$4 as StandardDetails,
      RsvpStatus$2 as RsvpStatus,
      Guest$3 as Guest,
      CheckIn$3 as CheckIn,
      OnlineConferencingLogin$4 as OnlineConferencingLogin,
      Empty$5 as Empty,
      RsvpUpdated$1 as RsvpUpdated,
      DomainEvent$8 as DomainEvent,
      DomainEventBodyOneOf$8 as DomainEventBodyOneOf,
      EntityCreatedEvent$8 as EntityCreatedEvent,
      RestoreInfo$8 as RestoreInfo,
      EntityUpdatedEvent$8 as EntityUpdatedEvent,
      EntityDeletedEvent$8 as EntityDeletedEvent,
      ActionEvent$8 as ActionEvent,
      EventUpdated$3 as EventUpdated,
      Location$6 as Location,
      MapCoordinates$6 as MapCoordinates,
      LocationType$6 as LocationType,
      Address$9 as Address,
      AddressStreetOneOf$9 as AddressStreetOneOf,
      StreetAddress$9 as StreetAddress,
      AddressLocation$9 as AddressLocation,
      Subdivision$9 as Subdivision,
      ScheduleConfig$6 as ScheduleConfig,
      Recurrences$6 as Recurrences,
      Occurrence$6 as Occurrence,
      Status$7 as Status,
      Event$4 as Event,
      Scheduling$4 as Scheduling,
      EventStatus$6 as EventStatus,
      Registration$4 as Registration,
      EventType$4 as EventType,
      RegistrationStatus$4 as RegistrationStatus,
      RsvpCollection$4 as RsvpCollection,
      RsvpCollectionConfig$4 as RsvpCollectionConfig,
      RsvpStatusOptions$4 as RsvpStatusOptions,
      Ticketing$4 as Ticketing,
      TicketingConfig$4 as TicketingConfig,
      TaxConfig$4 as TaxConfig,
      TaxType$5 as TaxType,
      Money$7 as Money,
      ExternalEvent$4 as ExternalEvent,
      VisitorType$4 as VisitorType,
      CalendarLinks$6 as CalendarLinks,
      SiteUrl$4 as SiteUrl,
      Form$4 as Form,
      InputControl$4 as InputControl,
      InputControlType$4 as InputControlType,
      Input$4 as Input,
      ValueType$4 as ValueType,
      OptionSelection$4 as OptionSelection,
      OptionSelectionSelectedOptionOneOf$4 as OptionSelectionSelectedOptionOneOf,
      Label$4 as Label,
      FormMessages$4 as FormMessages,
      RsvpFormMessages$4 as RsvpFormMessages,
      PositiveResponseConfirmation$4 as PositiveResponseConfirmation,
      NegativeResponseConfirmation$4 as NegativeResponseConfirmation,
      Positive$4 as Positive,
      Negative$4 as Negative,
      CheckoutFormMessages$4 as CheckoutFormMessages,
      ResponseConfirmation$4 as ResponseConfirmation,
      RegistrationClosedMessages$4 as RegistrationClosedMessages,
      TicketsUnavailableMessages$4 as TicketsUnavailableMessages,
      Dashboard$6 as Dashboard,
      RsvpSummary$5 as RsvpSummary,
      TicketingSummary$4 as TicketingSummary,
      GuestListConfig$4 as GuestListConfig,
      Feed$4 as Feed,
      OnlineConferencing$4 as OnlineConferencing,
      OnlineConferencingConfig$4 as OnlineConferencingConfig,
      ConferenceType$4 as ConferenceType,
      OnlineConferencingSession$4 as OnlineConferencingSession,
      SeoSettings$4 as SeoSettings,
      SeoSchema$4 as SeoSchema,
      Keyword$4 as Keyword,
      Tag$4 as Tag,
      Settings$5 as Settings,
      Agenda$4 as Agenda,
      Category$5 as Category,
      CategoryCounts$5 as CategoryCounts,
      State$8 as State,
      EventDisplaySettings$4 as EventDisplaySettings,
      LabellingSettings$4 as LabellingSettings,
      OrderConfirmed$1 as OrderConfirmed,
      OrderStatus$2 as OrderStatus,
      Ticket$2 as Ticket,
      Invoice$1 as Invoice,
      Item$2 as Item,
      Discount$1 as Discount,
      DiscountItem$1 as DiscountItem,
      DiscountItemDiscountOneOf$1 as DiscountItemDiscountOneOf,
      CouponDiscount$1 as CouponDiscount,
      PaidPlanDiscount$1 as PaidPlanDiscount,
      PaidPlanDiscountDiscountOneOf$1 as PaidPlanDiscountDiscountOneOf,
      PercentDiscount$1 as PercentDiscount,
      Tax$1 as Tax,
      Fee$1 as Fee,
      FeeName$1 as FeeName,
      FeeType$2 as FeeType,
      eventsNotificationsV2NotificationConfig_universal_d_OrderEmailAdded as OrderEmailAdded,
      EventCanceled$2 as EventCanceled,
      EventReminder$1 as EventReminder,
      TimeDuration$1 as TimeDuration,
      OrderPaid$1 as OrderPaid,
      eventsNotificationsV2NotificationConfig_universal_d_TicketPdfResolved as TicketPdfResolved,
      eventsNotificationsV2NotificationConfig_universal_d_TicketPdfResolveDelayed as TicketPdfResolveDelayed,
      eventsNotificationsV2NotificationConfig_universal_d_OrderCanceled as OrderCanceled,
      EventEnded$2 as EventEnded,
      EventStarted$1 as EventStarted,
      eventsNotificationsV2NotificationConfig_universal_d_ResolveNotificationConfigRequest as ResolveNotificationConfigRequest,
      eventsNotificationsV2NotificationConfig_universal_d_ResolveNotificationConfigResponse as ResolveNotificationConfigResponse,
      eventsNotificationsV2NotificationConfig_universal_d_UpsertNotificationConfigRequest as UpsertNotificationConfigRequest,
      eventsNotificationsV2NotificationConfig_universal_d_UpsertNotificationConfigResponse as UpsertNotificationConfigResponse,
      eventsNotificationsV2NotificationConfig_universal_d_ResolveEmailNotificationConfigRequest as ResolveEmailNotificationConfigRequest,
      eventsNotificationsV2NotificationConfig_universal_d_ResolveEmailNotificationConfigResponse as ResolveEmailNotificationConfigResponse,
      EventDeleted$4 as EventDeleted,
      EventCopied$3 as EventCopied,
      MessageEnvelope$c as MessageEnvelope,
      IdentificationData$c as IdentificationData,
      IdentificationDataIdOneOf$c as IdentificationDataIdOneOf,
      WebhookIdentityType$c as WebhookIdentityType,
      eventsNotificationsV2NotificationConfig_universal_d_triggerNotification as triggerNotification,
      eventsNotificationsV2NotificationConfig_universal_d_TriggerNotificationOptions as TriggerNotificationOptions,
      eventsNotificationsV2NotificationConfig_universal_d_resolveNotificationConfig as resolveNotificationConfig,
      eventsNotificationsV2NotificationConfig_universal_d_upsertNotificationConfig as upsertNotificationConfig,
      eventsNotificationsV2NotificationConfig_universal_d_UpsertNotificationConfig as UpsertNotificationConfig,
      eventsNotificationsV2NotificationConfig_universal_d_UpsertNotificationConfigOptions as UpsertNotificationConfigOptions,
    };
  }
  
  /** Schedule item describes the schedule within an event. Each event may contain multiple schedule items. */
  interface ScheduleItem$1 {
      /**
       * Schedule item ID.
       * @readonly
       */
      _id?: string;
      /** Whether a schedule item is hidden from guests. */
      hidden?: boolean;
      /** Schedule item name. */
      name?: string;
      /** Time slot of a schedule item. */
      timeSlot?: TimeInterval$1;
      /** Rich text schedule item description. */
      description?: string;
      /** Stage or room name in which the session takes place. */
      stageName?: string;
      /** Schedule item tags. They're used to organize the items to a theme. */
      tags?: string[];
      /**
       * Schedule item status. Possible values:
       * - `SCHEDULED`: An item is scheduled.
       * - `CANCELED`: An item is canceled.
       */
      status?: ScheduleStatus$1;
      /**
       * Date and time when the schedule item was created.
       * @readonly
       */
      _createdDate?: Date | null;
      /**
       * Date and time when the schedule item was updated.
       * @readonly
       */
      _updatedDate?: Date | null;
      /**
       * Event ID to which the schedule belongs.
       * @readonly
       */
      eventId?: string;
      /**
       * Whether the schedule item is draft.
       * @readonly
       */
      draft?: boolean;
  }
  /** Time interval on the timeline between two points in time. */
  interface TimeInterval$1 {
      /** Start of the interval. Inclusive. */
      start?: Date | null;
      /** End of the interval. Non-inclusive. */
      end?: Date | null;
      /**
       * Time zone ID in the [TZ database](https://www.iana.org/time-zones) format. For example, `EST`, `America/Los_Angeles`.
       * Default: `Etc/UTC`.
       */
      timeZoneId?: string | null;
  }
  enum ScheduleStatus$1 {
      /** Item is scheduled for a future date. */
      SCHEDULED = "SCHEDULED",
      /** Item is canceled. */
      CANCELED = "CANCELED"
  }
  interface ListScheduleItemsRequest$1 {
      /** Event ID to which the schedule belongs. */
      eventId?: string[];
      /**
       * Schedule item state filter. Possible values:
       * - `PUBLISHED`: The schedule item is published.
       * - `DRAFT`: The schedule item is in the draft. You need the "WIX_EVENTS.MANAGE_AGENDA" permissions to change this state.
       * - `VISIBLE`: The schedule item is visible to guests.
       * - `HIDDEN`: The schedule item is hidden from guests. You need the "WIX_EVENTS.MANAGE_AGENDA" permissions to change this state.
       * Default: Filters by the `PUBLISHED` and `VISIBLE` states.
       */
      state?: StateFilter$1[];
      /** Filters schedule items starting on or after specified point in time. Inclusive. */
      startingFrom?: Date | null;
      /** Filters schedule items starting before specified point in time. Non-inclusive. */
      startingBefore?: Date | null;
      /**
       * Deprecated, use `paging`.
       * Number of items to skip. See [Pagination](https://dev.wix.com/api/rest/getting-started/pagination).
       * @deprecated
       */
      offset?: number;
      /**
       * Deprecated, use `paging`.
       * Number of items to load per page. See [Pagination](https://dev.wix.com/api/rest/getting-started/pagination).
       * @deprecated
       */
      limit?: number;
      /**
       * Filter facets.
       * See [supported facets](https://dev.wix.com/api/rest/wix-events/wix-events/filter-and-sort#wix-events_wix-events_filter-and-sort_list-schedule-items).
       */
      facet?: string[];
      /** Schedule item ID. */
      itemId?: string[];
      /** Schedule item tags. They're used to organize the items to a theme. */
      tag?: string[];
      /** Stage or room name in which the session takes place. */
      stageName?: string[];
      /**
       * Pointer to page of results using offset.
       * See [Pagination](https://dev.wix.com/api/rest/getting-started/pagination).
       */
      paging?: Paging$8;
  }
  enum StateFilter$1 {
      /** Schedule item is published. */
      PUBLISHED = "PUBLISHED",
      /** Opposite of `PUBLISHED`. Requires `WIX_EVENTS.MANAGE_AGENDA` permission. */
      DRAFT = "DRAFT",
      /** Schedule item is visible to the public. */
      VISIBLE = "VISIBLE",
      /** Opposite of `VISIBLE`. Requires `WIX_EVENTS.MANAGE_AGENDA` permission. */
      HIDDEN = "HIDDEN"
  }
  interface Paging$8 {
      /** Number of items to load per page. */
      limit?: number | null;
      /** Number of items to skip in the current sort order. */
      offset?: number | null;
  }
  interface ListScheduleItemsResponse$1 {
      /**
       * Deprecated, use `paging_metadata.total`.
       * Total schedule items matching the given filters.
       * @readonly
       * @deprecated
       */
      total?: number;
      /**
       * Deprecated.
       * Limit.
       * @deprecated
       */
      limit?: number;
      /**
       * Deprecated, use `paging_metadata.offset`.
       * Offset.
       * @deprecated
       */
      offset?: number;
      /** Schedule items. */
      items?: ScheduleItem$1[];
      /**
       * Facets.
       * @readonly
       */
      facets?: Record<string, FacetCounts$7>;
      /**
       * Whether there are draft changes which have not been published yet.
       * Returned only when filtering by single `event_id` with `WIX_EVENTS.MANAGE_AGENDA` permission.
       * @readonly
       */
      draftNotPublished?: boolean | null;
      /** Paging metadata. */
      pagingMetadata?: PagingMetadataV2$8;
  }
  interface FacetCounts$7 {
      /** Facet counts aggregated per value. */
      counts?: Record<string, number>;
  }
  interface PagingMetadataV2$8 {
      /** Number of items returned in the response. */
      count?: number | null;
      /** Offset that was requested. */
      offset?: number | null;
      /** Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set. */
      total?: number | null;
      /** Flag that indicates the server failed to calculate the `total` field. */
      tooManyToCount?: boolean | null;
      /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
      cursors?: Cursors$9;
      /**
       * Indicates if there are more results after the current page.
       * If `true`, another page of results can be retrieved.
       * If `false`, this is the last page.
       * @internal
       */
      hasNext?: boolean | null;
  }
  interface Cursors$9 {
      /** Cursor string pointing to the next page in the list of results. */
      next?: string | null;
      /** Cursor pointing to the previous page in the list of results. */
      prev?: string | null;
  }
  interface QueryScheduleItemsRequest$1 {
      query?: QueryV2$7;
  }
  interface QueryV2$7 extends QueryV2PagingMethodOneOf$7 {
      /**
       * Pointer to page of results using offset.
       * See [Pagination](https://dev.wix.com/api/rest/getting-started/pagination).
       */
      paging?: Paging$8;
      /** Filter. See [supported fields and operators](https://dev.wix.com/api/rest/wix-events/wix-events/filter-and-sort#wix-events_wix-events_filter-and-sort_list-query-events). */
      filter?: Record<string, any> | null;
      /**
       * Sort object in the form [{"fieldName":"sortField1"},{"fieldName":"sortField2","direction":"DESC"}]
       * See [supported fields](https://dev.wix.com/api/rest/wix-events/wix-events/filter-and-sort#wix-events_wix-events_filter-and-sort_list-query-events).
       */
      sort?: Sorting$9[];
  }
  /** @oneof */
  interface QueryV2PagingMethodOneOf$7 {
      /**
       * Pointer to page of results using offset.
       * See [Pagination](https://dev.wix.com/api/rest/getting-started/pagination).
       */
      paging?: Paging$8;
  }
  interface Sorting$9 {
      /** Name of the field to sort by */
      fieldName?: string;
      /** Sort order (ASC/DESC). Defaults to ASC */
      order?: SortOrder$9;
  }
  enum SortOrder$9 {
      ASC = "ASC",
      DESC = "DESC"
  }
  interface QueryScheduleItemsResponse$1 {
      pagingMetadata?: PagingMetadataV2$8;
      /** Schedule items. */
      items?: ScheduleItem$1[];
  }
  interface GetScheduleItemRequest$1 {
      /** Event ID to which the schedule belongs. */
      eventId?: string;
      /** Schedule item ID. */
      itemId: string;
      /** Whether to include draft schedules in the response. */
      includeDraft?: boolean;
  }
  interface GetScheduleItemResponse$1 {
      /** Schedule item. */
      item?: ScheduleItem$1;
      /** Draft of the Schedule item. */
      draft?: ScheduleItem$1;
  }
  interface AddScheduleItemRequest$1 {
      /** Event ID to which the schedule belongs. */
      eventId: string;
      /** Schedule item. */
      item?: ScheduleItemData$1;
  }
  /** Schedule item describes the schedule within an event. Each event may contain multiple schedule items. */
  interface ScheduleItemData$1 {
      /** Whether a schedule item is hidden from guests. */
      hidden?: boolean;
      /** Schedule item name. */
      name?: string;
      /** Time slot of a schedule item. */
      timeSlot?: TimeInterval$1;
      /** Rich text schedule item description. */
      description?: string;
      /** Stage or room name in which the session takes place. */
      stageName?: string;
      /** Schedule item tags. They're used to organize the items to a theme. */
      tags?: string[];
      /**
       * Schedule item status. Possible values:
       * - `SCHEDULED`: An item is scheduled.
       * - `CANCELED`: An item is canceled.
       */
      status?: ScheduleStatus$1;
  }
  interface AddScheduleItemResponse$1 {
      /** Schedule item. */
      item?: ScheduleItem$1;
  }
  interface UpdateScheduleItemRequest$1 {
      /** Event ID to which the schedule belongs. */
      eventId: string;
      /** Schedule item ID. */
      itemId: string;
      /** Schedule item. */
      item?: ScheduleItemData$1;
      /**
       * Set of field paths to update.
       * When fields are empty, request is interpreted as full update.
       * Behavior follows [google.protobuf.FieldMask](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#google.protobuf.FieldMask) semantics.
       * @internal
       */
      fields?: string[];
  }
  interface UpdateScheduleItemResponse$1 {
      /** Schedule item. */
      item?: ScheduleItem$1;
  }
  interface DeleteScheduleItemRequest$1 {
      /** Event ID to which the schedule belongs. */
      eventId: string;
      /** Schedule items to delete. */
      itemIds?: string[];
  }
  interface DeleteScheduleItemResponse$1 {
  }
  interface DiscardDraftRequest$2 {
      /** Event ID to which the schedule belongs. */
      eventId: string;
  }
  interface DiscardDraftResponse$2 {
  }
  interface PublishDraftRequest$2 {
      /** Event ID to which the schedule belongs. */
      eventId: string;
  }
  interface PublishDraftResponse$2 {
  }
  interface RescheduleDraftRequest$1 {
      /** Event ID to which the schedule belongs. */
      eventId: string;
      /**
       * Time zone ID in the [TZ database](https://www.iana.org/time-zones) format. For example, `EST`, `America/Los_Angeles`.
       * Default: `Etc/UTC`.
       */
      timeZoneId: string;
      /** Offset added or subtracted from the start and end times of schedule items. */
      timeSlotOffset?: GoogleProtoDuration$1;
  }
  interface RescheduleDraftResponse$1 {
  }
  interface ListBookmarksRequest$1 {
      /** Event ID to which the schedule belongs. */
      eventId: string;
  }
  interface ListBookmarksResponse$1 {
      /** Schedule items. */
      items?: ScheduleItem$1[];
  }
  interface CreateBookmarkRequest$1 {
      /** Event ID to which the schedule belongs. */
      eventId: string;
      /** Schedule item ID. */
      itemId: string;
  }
  interface CreateBookmarkResponse$1 {
  }
  interface DeleteBookmarkRequest$1 {
      /** Event ID to which the schedule belongs. */
      eventId: string;
      /** Schedule item ID. */
      itemId: string;
  }
  interface DeleteBookmarkResponse$1 {
  }
  type GoogleProtoDuration$1 = any;
  /**
   * Retrieves a list of bookmarked schedule items for a currently logged-in member.
   * @public
   * @requiredField eventId
   * @param eventId - Event ID to which the schedule belongs.
   * @permissionId WIX_EVENTS.READ_AGENDA_BOOKMARKS
   */
  function listBookmarks(eventId: string): Promise<ListBookmarksResponse$1>;
  /**
   * Bookmarks a schedule item for a currently logged-in member.
   * @param itemId - Schedule item ID.
   * @public
   * @requiredField eventId
   * @requiredField itemId
   * @param eventId - Event ID to which the schedule belongs.
   * @permissionId WIX_EVENTS.MANAGE_AGENDA_BOOKMARKS
   */
  function createBookmark(itemId: string, eventId: string): Promise<void>;
  /**
   * Removes a schedule item bookmark for a currently logged-in member.
   * @param itemId - Schedule item ID.
   * @public
   * @requiredField eventId
   * @requiredField itemId
   * @param eventId - Event ID to which the schedule belongs.
   * @permissionId WIX_EVENTS.MANAGE_AGENDA_BOOKMARKS
   */
  function deleteBookmark(itemId: string, eventId: string): Promise<void>;
  
  const eventsScheduleV1ScheduleItemScheduleBookmarks_universal_d_listBookmarks: typeof listBookmarks;
  const eventsScheduleV1ScheduleItemScheduleBookmarks_universal_d_createBookmark: typeof createBookmark;
  const eventsScheduleV1ScheduleItemScheduleBookmarks_universal_d_deleteBookmark: typeof deleteBookmark;
  namespace eventsScheduleV1ScheduleItemScheduleBookmarks_universal_d {
    export {
      ScheduleItem$1 as ScheduleItem,
      TimeInterval$1 as TimeInterval,
      ScheduleStatus$1 as ScheduleStatus,
      ListScheduleItemsRequest$1 as ListScheduleItemsRequest,
      StateFilter$1 as StateFilter,
      Paging$8 as Paging,
      ListScheduleItemsResponse$1 as ListScheduleItemsResponse,
      FacetCounts$7 as FacetCounts,
      PagingMetadataV2$8 as PagingMetadataV2,
      Cursors$9 as Cursors,
      QueryScheduleItemsRequest$1 as QueryScheduleItemsRequest,
      QueryV2$7 as QueryV2,
      QueryV2PagingMethodOneOf$7 as QueryV2PagingMethodOneOf,
      Sorting$9 as Sorting,
      SortOrder$9 as SortOrder,
      QueryScheduleItemsResponse$1 as QueryScheduleItemsResponse,
      GetScheduleItemRequest$1 as GetScheduleItemRequest,
      GetScheduleItemResponse$1 as GetScheduleItemResponse,
      AddScheduleItemRequest$1 as AddScheduleItemRequest,
      ScheduleItemData$1 as ScheduleItemData,
      AddScheduleItemResponse$1 as AddScheduleItemResponse,
      UpdateScheduleItemRequest$1 as UpdateScheduleItemRequest,
      UpdateScheduleItemResponse$1 as UpdateScheduleItemResponse,
      DeleteScheduleItemRequest$1 as DeleteScheduleItemRequest,
      DeleteScheduleItemResponse$1 as DeleteScheduleItemResponse,
      DiscardDraftRequest$2 as DiscardDraftRequest,
      DiscardDraftResponse$2 as DiscardDraftResponse,
      PublishDraftRequest$2 as PublishDraftRequest,
      PublishDraftResponse$2 as PublishDraftResponse,
      RescheduleDraftRequest$1 as RescheduleDraftRequest,
      RescheduleDraftResponse$1 as RescheduleDraftResponse,
      ListBookmarksRequest$1 as ListBookmarksRequest,
      ListBookmarksResponse$1 as ListBookmarksResponse,
      CreateBookmarkRequest$1 as CreateBookmarkRequest,
      CreateBookmarkResponse$1 as CreateBookmarkResponse,
      DeleteBookmarkRequest$1 as DeleteBookmarkRequest,
      DeleteBookmarkResponse$1 as DeleteBookmarkResponse,
      eventsScheduleV1ScheduleItemScheduleBookmarks_universal_d_listBookmarks as listBookmarks,
      eventsScheduleV1ScheduleItemScheduleBookmarks_universal_d_createBookmark as createBookmark,
      eventsScheduleV1ScheduleItemScheduleBookmarks_universal_d_deleteBookmark as deleteBookmark,
    };
  }
  
  /** Schedule item describes the schedule within an event. Each event may contain multiple schedule items. */
  interface ScheduleItem {
      /**
       * Schedule item ID.
       * @readonly
       */
      _id?: string;
      /** Whether a schedule item is hidden from guests. */
      hidden?: boolean;
      /** Schedule item name. */
      name?: string;
      /** Time slot of a schedule item. */
      timeSlot?: TimeInterval;
      /** Rich text schedule item description. */
      description?: string;
      /** Stage or room name in which the session takes place. */
      stageName?: string;
      /** Schedule item tags. They're used to organize the items to a theme. */
      tags?: string[];
      /**
       * Schedule item status. Possible values:
       * - `SCHEDULED`: An item is scheduled.
       * - `CANCELED`: An item is canceled.
       */
      status?: ScheduleStatus;
      /**
       * Date and time when the schedule item was created.
       * @readonly
       */
      _createdDate?: Date | null;
      /**
       * Date and time when the schedule item was updated.
       * @readonly
       */
      _updatedDate?: Date | null;
      /**
       * Event ID to which the schedule belongs.
       * @readonly
       */
      eventId?: string;
      /**
       * Whether the schedule item is draft.
       * @readonly
       */
      draft?: boolean;
  }
  /** Time interval on the timeline between two points in time. */
  interface TimeInterval {
      /** Start of the interval. Inclusive. */
      start?: Date | null;
      /** End of the interval. Non-inclusive. */
      end?: Date | null;
      /**
       * Time zone ID in the [TZ database](https://www.iana.org/time-zones) format. For example, `EST`, `America/Los_Angeles`.
       * Default: `Etc/UTC`.
       */
      timeZoneId?: string | null;
  }
  enum ScheduleStatus {
      /** Item is scheduled for a future date. */
      SCHEDULED = "SCHEDULED",
      /** Item is canceled. */
      CANCELED = "CANCELED"
  }
  interface ListScheduleItemsRequest {
      /** Event ID to which the schedule belongs. */
      eventId?: string[];
      /**
       * Schedule item state filter. Possible values:
       * - `PUBLISHED`: The schedule item is published.
       * - `DRAFT`: The schedule item is in the draft. You need the "WIX_EVENTS.MANAGE_AGENDA" permissions to change this state.
       * - `VISIBLE`: The schedule item is visible to guests.
       * - `HIDDEN`: The schedule item is hidden from guests. You need the "WIX_EVENTS.MANAGE_AGENDA" permissions to change this state.
       * Default: Filters by the `PUBLISHED` and `VISIBLE` states.
       */
      state?: StateFilter[];
      /** Filters schedule items starting on or after specified point in time. Inclusive. */
      startingFrom?: Date | null;
      /** Filters schedule items starting before specified point in time. Non-inclusive. */
      startingBefore?: Date | null;
      /**
       * Deprecated, use `paging`.
       * Number of items to skip. See [Pagination](https://dev.wix.com/api/rest/getting-started/pagination).
       * @deprecated
       */
      offset?: number;
      /**
       * Deprecated, use `paging`.
       * Number of items to load per page. See [Pagination](https://dev.wix.com/api/rest/getting-started/pagination).
       * @deprecated
       */
      limit?: number;
      /**
       * Filter facets.
       * See [supported facets](https://dev.wix.com/api/rest/wix-events/wix-events/filter-and-sort#wix-events_wix-events_filter-and-sort_list-schedule-items).
       */
      facet?: string[];
      /** Schedule item ID. */
      itemId?: string[];
      /** Schedule item tags. They're used to organize the items to a theme. */
      tag?: string[];
      /** Stage or room name in which the session takes place. */
      stageName?: string[];
      /**
       * Pointer to page of results using offset.
       * See [Pagination](https://dev.wix.com/api/rest/getting-started/pagination).
       */
      paging?: Paging$7;
  }
  enum StateFilter {
      /** Schedule item is published. */
      PUBLISHED = "PUBLISHED",
      /** Opposite of `PUBLISHED`. Requires `WIX_EVENTS.MANAGE_AGENDA` permission. */
      DRAFT = "DRAFT",
      /** Schedule item is visible to the public. */
      VISIBLE = "VISIBLE",
      /** Opposite of `VISIBLE`. Requires `WIX_EVENTS.MANAGE_AGENDA` permission. */
      HIDDEN = "HIDDEN"
  }
  interface Paging$7 {
      /** Number of items to load per page. */
      limit?: number | null;
      /** Number of items to skip in the current sort order. */
      offset?: number | null;
  }
  interface ListScheduleItemsResponse {
      /**
       * Deprecated, use `paging_metadata.total`.
       * Total schedule items matching the given filters.
       * @readonly
       * @deprecated
       */
      total?: number;
      /**
       * Deprecated.
       * Limit.
       * @deprecated
       */
      limit?: number;
      /**
       * Deprecated, use `paging_metadata.offset`.
       * Offset.
       * @deprecated
       */
      offset?: number;
      /** Schedule items. */
      items?: ScheduleItem[];
      /**
       * Facets.
       * @readonly
       */
      facets?: Record<string, FacetCounts$6>;
      /**
       * Whether there are draft changes which have not been published yet.
       * Returned only when filtering by single `event_id` with `WIX_EVENTS.MANAGE_AGENDA` permission.
       * @readonly
       */
      draftNotPublished?: boolean | null;
      /** Paging metadata. */
      pagingMetadata?: PagingMetadataV2$7;
  }
  interface FacetCounts$6 {
      /** Facet counts aggregated per value. */
      counts?: Record<string, number>;
  }
  interface PagingMetadataV2$7 {
      /** Number of items returned in the response. */
      count?: number | null;
      /** Offset that was requested. */
      offset?: number | null;
      /** Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set. */
      total?: number | null;
      /** Flag that indicates the server failed to calculate the `total` field. */
      tooManyToCount?: boolean | null;
      /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
      cursors?: Cursors$8;
      /**
       * Indicates if there are more results after the current page.
       * If `true`, another page of results can be retrieved.
       * If `false`, this is the last page.
       * @internal
       */
      hasNext?: boolean | null;
  }
  interface Cursors$8 {
      /** Cursor string pointing to the next page in the list of results. */
      next?: string | null;
      /** Cursor pointing to the previous page in the list of results. */
      prev?: string | null;
  }
  interface QueryScheduleItemsRequest {
      query?: QueryV2$6;
  }
  interface QueryV2$6 extends QueryV2PagingMethodOneOf$6 {
      /**
       * Pointer to page of results using offset.
       * See [Pagination](https://dev.wix.com/api/rest/getting-started/pagination).
       */
      paging?: Paging$7;
      /** Filter. See [supported fields and operators](https://dev.wix.com/api/rest/wix-events/wix-events/filter-and-sort#wix-events_wix-events_filter-and-sort_list-query-events). */
      filter?: Record<string, any> | null;
      /**
       * Sort object in the form [{"fieldName":"sortField1"},{"fieldName":"sortField2","direction":"DESC"}]
       * See [supported fields](https://dev.wix.com/api/rest/wix-events/wix-events/filter-and-sort#wix-events_wix-events_filter-and-sort_list-query-events).
       */
      sort?: Sorting$8[];
  }
  /** @oneof */
  interface QueryV2PagingMethodOneOf$6 {
      /**
       * Pointer to page of results using offset.
       * See [Pagination](https://dev.wix.com/api/rest/getting-started/pagination).
       */
      paging?: Paging$7;
  }
  interface Sorting$8 {
      /** Name of the field to sort by */
      fieldName?: string;
      /** Sort order (ASC/DESC). Defaults to ASC */
      order?: SortOrder$8;
  }
  enum SortOrder$8 {
      ASC = "ASC",
      DESC = "DESC"
  }
  interface QueryScheduleItemsResponse {
      pagingMetadata?: PagingMetadataV2$7;
      /** Schedule items. */
      items?: ScheduleItem[];
  }
  interface GetScheduleItemRequest {
      /** Event ID to which the schedule belongs. */
      eventId?: string;
      /** Schedule item ID. */
      itemId: string;
      /** Whether to include draft schedules in the response. */
      includeDraft?: boolean;
  }
  interface GetScheduleItemResponse {
      /** Schedule item. */
      item?: ScheduleItem;
      /** Draft of the Schedule item. */
      draft?: ScheduleItem;
  }
  interface AddScheduleItemRequest {
      /** Event ID to which the schedule belongs. */
      eventId: string;
      /** Schedule item. */
      item?: ScheduleItemData;
  }
  /** Schedule item describes the schedule within an event. Each event may contain multiple schedule items. */
  interface ScheduleItemData {
      /** Whether a schedule item is hidden from guests. */
      hidden?: boolean;
      /** Schedule item name. */
      name?: string;
      /** Time slot of a schedule item. */
      timeSlot?: TimeInterval;
      /** Rich text schedule item description. */
      description?: string;
      /** Stage or room name in which the session takes place. */
      stageName?: string;
      /** Schedule item tags. They're used to organize the items to a theme. */
      tags?: string[];
      /**
       * Schedule item status. Possible values:
       * - `SCHEDULED`: An item is scheduled.
       * - `CANCELED`: An item is canceled.
       */
      status?: ScheduleStatus;
  }
  interface AddScheduleItemResponse {
      /** Schedule item. */
      item?: ScheduleItem;
  }
  interface UpdateScheduleItemRequest {
      /** Event ID to which the schedule belongs. */
      eventId: string;
      /** Schedule item ID. */
      itemId: string;
      /** Schedule item. */
      item?: ScheduleItemData;
      /**
       * Set of field paths to update.
       * When fields are empty, request is interpreted as full update.
       * Behavior follows [google.protobuf.FieldMask](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#google.protobuf.FieldMask) semantics.
       * @internal
       */
      fields?: string[];
  }
  interface UpdateScheduleItemResponse {
      /** Schedule item. */
      item?: ScheduleItem;
  }
  interface DeleteScheduleItemRequest {
      /** Event ID to which the schedule belongs. */
      eventId: string;
      /** Schedule items to delete. */
      itemIds?: string[];
  }
  interface DeleteScheduleItemResponse {
  }
  interface DiscardDraftRequest$1 {
      /** Event ID to which the schedule belongs. */
      eventId: string;
  }
  interface DiscardDraftResponse$1 {
  }
  interface PublishDraftRequest$1 {
      /** Event ID to which the schedule belongs. */
      eventId: string;
  }
  interface PublishDraftResponse$1 {
  }
  interface RescheduleDraftRequest {
      /** Event ID to which the schedule belongs. */
      eventId: string;
      /**
       * Time zone ID in the [TZ database](https://www.iana.org/time-zones) format. For example, `EST`, `America/Los_Angeles`.
       * Default: `Etc/UTC`.
       */
      timeZoneId: string;
      /** Offset added or subtracted from the start and end times of schedule items. */
      timeSlotOffset?: GoogleProtoDuration;
  }
  interface RescheduleDraftResponse {
  }
  interface ListBookmarksRequest {
      /** Event ID to which the schedule belongs. */
      eventId: string;
  }
  interface ListBookmarksResponse {
      /** Schedule items. */
      items?: ScheduleItem[];
  }
  interface CreateBookmarkRequest {
      /** Event ID to which the schedule belongs. */
      eventId: string;
      /** Schedule item ID. */
      itemId: string;
  }
  interface CreateBookmarkResponse {
  }
  interface DeleteBookmarkRequest {
      /** Event ID to which the schedule belongs. */
      eventId: string;
      /** Schedule item ID. */
      itemId: string;
  }
  interface DeleteBookmarkResponse {
  }
  type GoogleProtoDuration = any;
  /**
   * Retrieves a list of up to 100 schedule items
   * @public
   * @param options - Optional fields.
   * @permissionId WIX_EVENTS.READ_AGENDA
   */
  function listScheduleItems(options?: ListScheduleItemsOptions): Promise<ListScheduleItemsResponse>;
  interface ListScheduleItemsOptions {
      /** Event ID to which the schedule belongs. */
      eventId?: string[];
      /**
       * Schedule item state filter. Possible values:
       * - `PUBLISHED`: The schedule item is published.
       * - `DRAFT`: The schedule item is in the draft. You need the "WIX_EVENTS.MANAGE_AGENDA" permissions to change this state.
       * - `VISIBLE`: The schedule item is visible to guests.
       * - `HIDDEN`: The schedule item is hidden from guests. You need the "WIX_EVENTS.MANAGE_AGENDA" permissions to change this state.
       * Default: Filters by the `PUBLISHED` and `VISIBLE` states.
       */
      state?: StateFilter[];
      /** Filters schedule items starting on or after specified point in time. Inclusive. */
      startingFrom?: Date | null;
      /** Filters schedule items starting before specified point in time. Non-inclusive. */
      startingBefore?: Date | null;
      /**
       * Deprecated, use `paging`.
       * Number of items to skip. See [Pagination](https://dev.wix.com/api/rest/getting-started/pagination).
       * @deprecated
       */
      offset?: number;
      /**
       * Deprecated, use `paging`.
       * Number of items to load per page. See [Pagination](https://dev.wix.com/api/rest/getting-started/pagination).
       * @deprecated
       */
      limit?: number;
      /**
       * Filter facets.
       * See [supported facets](https://dev.wix.com/api/rest/wix-events/wix-events/filter-and-sort#wix-events_wix-events_filter-and-sort_list-schedule-items).
       */
      facet?: string[];
      /** Schedule item ID. */
      itemId?: string[];
      /** Schedule item tags. They're used to organize the items to a theme. */
      tag?: string[];
      /** Stage or room name in which the session takes place. */
      stageName?: string[];
      /**
       * Pointer to page of results using offset.
       * See [Pagination](https://dev.wix.com/api/rest/getting-started/pagination).
       */
      paging?: Paging$7;
  }
  /**
   * Creates a query to retrieve a list of schedule items.
   *
   * The `queryScheduleItems( )` function builds a query to retrieve a list of schedule items and returns a [`ItemsQueryBuilder`](https://www.wix.com/velo/reference/wix-events-v2/schedule/itemsquerybuilder) object.
   *
   * The returned object contains the query definition, which is typically used to run the query using the [`find()`](https://www.wix.com/velo/reference/wix-events-v2/schedule/itemsquerybuilder/find) function.
   *
   * You can refine the query by chaining `ItemsQueryBuilder` functions onto the query. `ItemsQueryBuilder` functions enable you to sort, filter, and control the results `queryScheduleItems( )` returns.
   *
   * `queryScheduleItems( )` runs with these `ItemsQueryBuilder` defaults, which you can override:
   *
   *  - [`limit(50)`](https://www.wix.com/velo/reference/wix-events-v2/schedule/itemsquerybuilder/limit)
   *  - [`descending("_createdDate")`](https://www.wix.com/velo/reference/wix-events-v2/schedule/itemsquerybuilder/descending)
   *
   * The functions that are chained to `queryScheduleItems( )` are applied in the order they're called. For example, if you apply `ascending('name')` and then `descending('stageName')`, the results are sorted first by the `name`, and then, if there are multiple results with the same `name`, the items are sorted by `stageName`.
   * @public
   * @permissionId WIX_EVENTS.READ_AGENDA
   */
  function queryScheduleItems(): ItemsQueryBuilder;
  interface QueryCursorResult$6 {
      cursors: Cursors$8;
      hasNext: () => boolean;
      hasPrev: () => boolean;
      length: number;
      pageSize: number;
  }
  interface ItemsQueryResult extends QueryCursorResult$6 {
      items: ScheduleItem[];
      query: ItemsQueryBuilder;
      next: () => Promise<ItemsQueryResult>;
      prev: () => Promise<ItemsQueryResult>;
  }
  interface ItemsQueryBuilder {
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       */
      eq: (propertyName: '_id' | 'name' | 'description' | 'stageName' | '_createdDate' | '_updatedDate' | 'eventId', value: any) => ItemsQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       */
      ne: (propertyName: '_id' | 'name' | 'description' | 'stageName' | '_createdDate' | '_updatedDate' | 'eventId', value: any) => ItemsQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       */
      ge: (propertyName: '_createdDate' | '_updatedDate', value: any) => ItemsQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       */
      gt: (propertyName: '_createdDate' | '_updatedDate', value: any) => ItemsQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       */
      le: (propertyName: '_createdDate' | '_updatedDate', value: any) => ItemsQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       */
      lt: (propertyName: '_createdDate' | '_updatedDate', value: any) => ItemsQueryBuilder;
      /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments. */
      ascending: (...propertyNames: Array<'_id' | 'name' | 'description' | 'stageName' | '_createdDate' | '_updatedDate' | 'eventId'>) => ItemsQueryBuilder;
      /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments. */
      descending: (...propertyNames: Array<'_id' | 'name' | 'description' | 'stageName' | '_createdDate' | '_updatedDate' | 'eventId'>) => ItemsQueryBuilder;
      /** @param limit - Number of items to return, which is also the `pageSize` of the results object. */
      limit: (limit: number) => ItemsQueryBuilder;
      /** @param cursor - A pointer to specific record */
      skipTo: (cursor: string) => ItemsQueryBuilder;
      find: () => Promise<ItemsQueryResult>;
  }
  /**
   * Retrieves schedule item by ID.
   * @param itemId - Schedule item ID.
   * @public
   * @requiredField itemId
   * @param options - Optional fields.
   * @permissionId WIX_EVENTS.READ_AGENDA
   * @returns Schedule item.
   */
  function getScheduleItem(itemId: string, options?: GetScheduleItemOptions): Promise<ScheduleItem>;
  interface GetScheduleItemOptions {
      /** Event ID to which the schedule belongs. */
      eventId?: string;
      /** Whether to include draft schedules in the response. */
      includeDraft?: boolean;
  }
  /**
   * Adds a schedule item to the draft schedule.
   * @public
   * @requiredField eventId
   * @requiredField options.item.name
   * @requiredField options.item.timeSlot
   * @requiredField options.item.timeSlot.end
   * @requiredField options.item.timeSlot.start
   * @param eventId - Event ID to which the schedule belongs.
   * @param options - Optional fields.
   * @permissionId WIX_EVENTS.MANAGE_AGENDA
   * @adminMethod
   */
  function addScheduleItem(eventId: string, options?: AddScheduleItemOptions): Promise<AddScheduleItemResponse>;
  interface AddScheduleItemOptions {
      /** Schedule item. */
      item?: ScheduleItemData;
  }
  /**
   * Updates a schedule item in a draft schedule.
   * @param itemId - Schedule item ID.
   * @public
   * @requiredField eventId
   * @requiredField itemId
   * @param eventId - Event ID to which the schedule belongs.
   * @param options - Optional fields.
   * @permissionId WIX_EVENTS.MANAGE_AGENDA
   * @adminMethod
   */
  function updateScheduleItem(itemId: string, eventId: string, options?: UpdateScheduleItemOptions): Promise<UpdateScheduleItemResponse>;
  interface UpdateScheduleItemOptions {
      /** Schedule item. */
      item?: ScheduleItemData;
      /**
       * Set of field paths to update.
       * When fields are empty, request is interpreted as full update.
       * Behavior follows [google.protobuf.FieldMask](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#google.protobuf.FieldMask) semantics.
       * @internal
       */
      fields?: string[];
  }
  /**
   * Deletes schedule items from the draft schedule.
   * @public
   * @requiredField eventId
   * @param eventId - Event ID to which the schedule belongs.
   * @param options - Optional fields.
   * @permissionId WIX_EVENTS.MANAGE_AGENDA
   * @adminMethod
   */
  function deleteScheduleItem(eventId: string, options?: DeleteScheduleItemOptions): Promise<void>;
  interface DeleteScheduleItemOptions {
      /** Schedule items to delete. */
      itemIds?: string[];
  }
  /**
   * Clears all changes to the draft schedule.
   * @public
   * @requiredField eventId
   * @param eventId - Event ID to which the schedule belongs.
   * @permissionId WIX_EVENTS.MANAGE_AGENDA
   * @adminMethod
   */
  function discardDraft$1(eventId: string): Promise<void>;
  /**
   * Publishes the draft schedule.
   * @public
   * @requiredField eventId
   * @param eventId - Event ID to which the schedule belongs.
   * @permissionId WIX_EVENTS.MANAGE_AGENDA
   * @adminMethod
   */
  function publishDraft$1(eventId: string): Promise<void>;
  /**
   * Adjusts the time of all draft schedule items at once per event.
   * @public
   * @requiredField eventId
   * @requiredField options.timeZoneId
   * @param eventId - Event ID to which the schedule belongs.
   * @param options - Optional fields.
   * @permissionId WIX_EVENTS.MANAGE_AGENDA
   * @adminMethod
   */
  function rescheduleDraft(eventId: string, options?: RescheduleDraftOptions): Promise<void>;
  interface RescheduleDraftOptions {
      /**
       * Time zone ID in the [TZ database](https://www.iana.org/time-zones) format. For example, `EST`, `America/Los_Angeles`.
       * Default: `Etc/UTC`.
       */
      timeZoneId: string;
      /** Offset added or subtracted from the start and end times of schedule items. */
      timeSlotOffset?: GoogleProtoDuration;
  }
  
  type eventsScheduleV1ScheduleItemSchedule_universal_d_ScheduleItem = ScheduleItem;
  type eventsScheduleV1ScheduleItemSchedule_universal_d_TimeInterval = TimeInterval;
  type eventsScheduleV1ScheduleItemSchedule_universal_d_ScheduleStatus = ScheduleStatus;
  const eventsScheduleV1ScheduleItemSchedule_universal_d_ScheduleStatus: typeof ScheduleStatus;
  type eventsScheduleV1ScheduleItemSchedule_universal_d_ListScheduleItemsRequest = ListScheduleItemsRequest;
  type eventsScheduleV1ScheduleItemSchedule_universal_d_StateFilter = StateFilter;
  const eventsScheduleV1ScheduleItemSchedule_universal_d_StateFilter: typeof StateFilter;
  type eventsScheduleV1ScheduleItemSchedule_universal_d_ListScheduleItemsResponse = ListScheduleItemsResponse;
  type eventsScheduleV1ScheduleItemSchedule_universal_d_QueryScheduleItemsRequest = QueryScheduleItemsRequest;
  type eventsScheduleV1ScheduleItemSchedule_universal_d_QueryScheduleItemsResponse = QueryScheduleItemsResponse;
  type eventsScheduleV1ScheduleItemSchedule_universal_d_GetScheduleItemRequest = GetScheduleItemRequest;
  type eventsScheduleV1ScheduleItemSchedule_universal_d_GetScheduleItemResponse = GetScheduleItemResponse;
  type eventsScheduleV1ScheduleItemSchedule_universal_d_AddScheduleItemRequest = AddScheduleItemRequest;
  type eventsScheduleV1ScheduleItemSchedule_universal_d_ScheduleItemData = ScheduleItemData;
  type eventsScheduleV1ScheduleItemSchedule_universal_d_AddScheduleItemResponse = AddScheduleItemResponse;
  type eventsScheduleV1ScheduleItemSchedule_universal_d_UpdateScheduleItemRequest = UpdateScheduleItemRequest;
  type eventsScheduleV1ScheduleItemSchedule_universal_d_UpdateScheduleItemResponse = UpdateScheduleItemResponse;
  type eventsScheduleV1ScheduleItemSchedule_universal_d_DeleteScheduleItemRequest = DeleteScheduleItemRequest;
  type eventsScheduleV1ScheduleItemSchedule_universal_d_DeleteScheduleItemResponse = DeleteScheduleItemResponse;
  type eventsScheduleV1ScheduleItemSchedule_universal_d_RescheduleDraftRequest = RescheduleDraftRequest;
  type eventsScheduleV1ScheduleItemSchedule_universal_d_RescheduleDraftResponse = RescheduleDraftResponse;
  type eventsScheduleV1ScheduleItemSchedule_universal_d_ListBookmarksRequest = ListBookmarksRequest;
  type eventsScheduleV1ScheduleItemSchedule_universal_d_ListBookmarksResponse = ListBookmarksResponse;
  type eventsScheduleV1ScheduleItemSchedule_universal_d_CreateBookmarkRequest = CreateBookmarkRequest;
  type eventsScheduleV1ScheduleItemSchedule_universal_d_CreateBookmarkResponse = CreateBookmarkResponse;
  type eventsScheduleV1ScheduleItemSchedule_universal_d_DeleteBookmarkRequest = DeleteBookmarkRequest;
  type eventsScheduleV1ScheduleItemSchedule_universal_d_DeleteBookmarkResponse = DeleteBookmarkResponse;
  const eventsScheduleV1ScheduleItemSchedule_universal_d_listScheduleItems: typeof listScheduleItems;
  type eventsScheduleV1ScheduleItemSchedule_universal_d_ListScheduleItemsOptions = ListScheduleItemsOptions;
  const eventsScheduleV1ScheduleItemSchedule_universal_d_queryScheduleItems: typeof queryScheduleItems;
  type eventsScheduleV1ScheduleItemSchedule_universal_d_ItemsQueryResult = ItemsQueryResult;
  type eventsScheduleV1ScheduleItemSchedule_universal_d_ItemsQueryBuilder = ItemsQueryBuilder;
  const eventsScheduleV1ScheduleItemSchedule_universal_d_getScheduleItem: typeof getScheduleItem;
  type eventsScheduleV1ScheduleItemSchedule_universal_d_GetScheduleItemOptions = GetScheduleItemOptions;
  const eventsScheduleV1ScheduleItemSchedule_universal_d_addScheduleItem: typeof addScheduleItem;
  type eventsScheduleV1ScheduleItemSchedule_universal_d_AddScheduleItemOptions = AddScheduleItemOptions;
  const eventsScheduleV1ScheduleItemSchedule_universal_d_updateScheduleItem: typeof updateScheduleItem;
  type eventsScheduleV1ScheduleItemSchedule_universal_d_UpdateScheduleItemOptions = UpdateScheduleItemOptions;
  const eventsScheduleV1ScheduleItemSchedule_universal_d_deleteScheduleItem: typeof deleteScheduleItem;
  type eventsScheduleV1ScheduleItemSchedule_universal_d_DeleteScheduleItemOptions = DeleteScheduleItemOptions;
  const eventsScheduleV1ScheduleItemSchedule_universal_d_rescheduleDraft: typeof rescheduleDraft;
  type eventsScheduleV1ScheduleItemSchedule_universal_d_RescheduleDraftOptions = RescheduleDraftOptions;
  namespace eventsScheduleV1ScheduleItemSchedule_universal_d {
    export {
      eventsScheduleV1ScheduleItemSchedule_universal_d_ScheduleItem as ScheduleItem,
      eventsScheduleV1ScheduleItemSchedule_universal_d_TimeInterval as TimeInterval,
      eventsScheduleV1ScheduleItemSchedule_universal_d_ScheduleStatus as ScheduleStatus,
      eventsScheduleV1ScheduleItemSchedule_universal_d_ListScheduleItemsRequest as ListScheduleItemsRequest,
      eventsScheduleV1ScheduleItemSchedule_universal_d_StateFilter as StateFilter,
      Paging$7 as Paging,
      eventsScheduleV1ScheduleItemSchedule_universal_d_ListScheduleItemsResponse as ListScheduleItemsResponse,
      FacetCounts$6 as FacetCounts,
      PagingMetadataV2$7 as PagingMetadataV2,
      Cursors$8 as Cursors,
      eventsScheduleV1ScheduleItemSchedule_universal_d_QueryScheduleItemsRequest as QueryScheduleItemsRequest,
      QueryV2$6 as QueryV2,
      QueryV2PagingMethodOneOf$6 as QueryV2PagingMethodOneOf,
      Sorting$8 as Sorting,
      SortOrder$8 as SortOrder,
      eventsScheduleV1ScheduleItemSchedule_universal_d_QueryScheduleItemsResponse as QueryScheduleItemsResponse,
      eventsScheduleV1ScheduleItemSchedule_universal_d_GetScheduleItemRequest as GetScheduleItemRequest,
      eventsScheduleV1ScheduleItemSchedule_universal_d_GetScheduleItemResponse as GetScheduleItemResponse,
      eventsScheduleV1ScheduleItemSchedule_universal_d_AddScheduleItemRequest as AddScheduleItemRequest,
      eventsScheduleV1ScheduleItemSchedule_universal_d_ScheduleItemData as ScheduleItemData,
      eventsScheduleV1ScheduleItemSchedule_universal_d_AddScheduleItemResponse as AddScheduleItemResponse,
      eventsScheduleV1ScheduleItemSchedule_universal_d_UpdateScheduleItemRequest as UpdateScheduleItemRequest,
      eventsScheduleV1ScheduleItemSchedule_universal_d_UpdateScheduleItemResponse as UpdateScheduleItemResponse,
      eventsScheduleV1ScheduleItemSchedule_universal_d_DeleteScheduleItemRequest as DeleteScheduleItemRequest,
      eventsScheduleV1ScheduleItemSchedule_universal_d_DeleteScheduleItemResponse as DeleteScheduleItemResponse,
      DiscardDraftRequest$1 as DiscardDraftRequest,
      DiscardDraftResponse$1 as DiscardDraftResponse,
      PublishDraftRequest$1 as PublishDraftRequest,
      PublishDraftResponse$1 as PublishDraftResponse,
      eventsScheduleV1ScheduleItemSchedule_universal_d_RescheduleDraftRequest as RescheduleDraftRequest,
      eventsScheduleV1ScheduleItemSchedule_universal_d_RescheduleDraftResponse as RescheduleDraftResponse,
      eventsScheduleV1ScheduleItemSchedule_universal_d_ListBookmarksRequest as ListBookmarksRequest,
      eventsScheduleV1ScheduleItemSchedule_universal_d_ListBookmarksResponse as ListBookmarksResponse,
      eventsScheduleV1ScheduleItemSchedule_universal_d_CreateBookmarkRequest as CreateBookmarkRequest,
      eventsScheduleV1ScheduleItemSchedule_universal_d_CreateBookmarkResponse as CreateBookmarkResponse,
      eventsScheduleV1ScheduleItemSchedule_universal_d_DeleteBookmarkRequest as DeleteBookmarkRequest,
      eventsScheduleV1ScheduleItemSchedule_universal_d_DeleteBookmarkResponse as DeleteBookmarkResponse,
      eventsScheduleV1ScheduleItemSchedule_universal_d_listScheduleItems as listScheduleItems,
      eventsScheduleV1ScheduleItemSchedule_universal_d_ListScheduleItemsOptions as ListScheduleItemsOptions,
      eventsScheduleV1ScheduleItemSchedule_universal_d_queryScheduleItems as queryScheduleItems,
      eventsScheduleV1ScheduleItemSchedule_universal_d_ItemsQueryResult as ItemsQueryResult,
      eventsScheduleV1ScheduleItemSchedule_universal_d_ItemsQueryBuilder as ItemsQueryBuilder,
      eventsScheduleV1ScheduleItemSchedule_universal_d_getScheduleItem as getScheduleItem,
      eventsScheduleV1ScheduleItemSchedule_universal_d_GetScheduleItemOptions as GetScheduleItemOptions,
      eventsScheduleV1ScheduleItemSchedule_universal_d_addScheduleItem as addScheduleItem,
      eventsScheduleV1ScheduleItemSchedule_universal_d_AddScheduleItemOptions as AddScheduleItemOptions,
      eventsScheduleV1ScheduleItemSchedule_universal_d_updateScheduleItem as updateScheduleItem,
      eventsScheduleV1ScheduleItemSchedule_universal_d_UpdateScheduleItemOptions as UpdateScheduleItemOptions,
      eventsScheduleV1ScheduleItemSchedule_universal_d_deleteScheduleItem as deleteScheduleItem,
      eventsScheduleV1ScheduleItemSchedule_universal_d_DeleteScheduleItemOptions as DeleteScheduleItemOptions,
      discardDraft$1 as discardDraft,
      publishDraft$1 as publishDraft,
      eventsScheduleV1ScheduleItemSchedule_universal_d_rescheduleDraft as rescheduleDraft,
      eventsScheduleV1ScheduleItemSchedule_universal_d_RescheduleDraftOptions as RescheduleDraftOptions,
    };
  }
  
  /** Staff members are events hosts assigned persons who can perform check-in for tickets owners, sell tickets or add guests manually. */
  interface StaffMember extends StaffMemberEventAccessOneOf {
      /** All events. */
      allEvents?: AllEvents;
      /** Specific events. */
      specificEvents?: SpecificEvents;
      /**
       * Staff member ID.
       * @readonly
       */
      _id?: string | null;
      /**
       * Revision.
       * @readonly
       */
      revision?: string | null;
      /**
       * Date and time the staff member was created.
       * @readonly
       */
      _createdDate?: Date | null;
      /**
       * Date and time the staff member was last updated.
       * @readonly
       */
      _updatedDate?: Date | null;
      /** Name. */
      name?: string | null;
      /**
       * Scopes.
       * @deprecated Scopes.
       * @replacedBy permissions
       * @targetRemovalDate 2024-12-01
       */
      scopes?: Scope[];
      /** Status. Remains PENDING until staff member joins. Switches to SUSPENDED if user decides to temporarily revoke staff member access. */
      status?: Status$6;
      /**
       * Join link generated for staff member.
       * @readonly
       * @deprecated Join link generated for staff member.
       * @replacedBy login_link
       * @targetRemovalDate 2024-12-01
       */
      joinLink?: string | null;
      /** Data extensions */
      extendedFields?: ExtendedFields$3;
      /** Permissions. */
      permissions?: Permission[];
      /**
       * Login link generated for staff member.
       * @readonly
       */
      loginLink?: string | null;
  }
  /** @oneof */
  interface StaffMemberEventAccessOneOf {
      /** All events. */
      allEvents?: AllEvents;
      /** Specific events. */
      specificEvents?: SpecificEvents;
  }
  enum Scope {
      UNKNOWN_SCOPE = "UNKNOWN_SCOPE",
      /** Check in guests. */
      CHECK_IN_GUESTS = "CHECK_IN_GUESTS",
      /** Sell tickets. */
      SELL_TICKETS = "SELL_TICKETS",
      /** Add guests. */
      ADD_GUESTS = "ADD_GUESTS",
      /** Read analytics */
      READ_ANALYTICS = "READ_ANALYTICS"
  }
  interface AllEvents {
  }
  interface SpecificEvents {
      /** Specific events for which staff member have access (can perform check-in). */
      events?: string[];
  }
  enum Status$6 {
      /** Pending. Means that staff member has not joined. */
      PENDING = "PENDING",
      /** Has access. */
      HAS_ACCESS = "HAS_ACCESS",
      /** Access paused. When staff member is paused from performing actions. */
      ACCESS_PAUSED = "ACCESS_PAUSED"
  }
  interface ExtendedFields$3 {
      /**
       * Extended field data. Each key corresponds to the namespace of the app that created the extended fields.
       * The value of each key is structured according to the schema defined when the extended fields were configured.
       *
       * You can only access fields for which you have the appropriate permissions.
       *
       * Learn more about [extended fields](https://dev.wix.com/docs/rest/articles/getting-started/extended-fields).
       */
      namespaces?: Record<string, Record<string, any>>;
  }
  enum Permission {
      UNKNOWN_PERMISSION = "UNKNOWN_PERMISSION",
      /** Check in guests. */
      CHECK_IN_GUESTS = "CHECK_IN_GUESTS",
      /** Sell tickets. */
      SELL_TICKETS = "SELL_TICKETS",
      /** Add guests. */
      ADD_GUESTS = "ADD_GUESTS",
      /** Read analytics */
      READ_ANALYTICS = "READ_ANALYTICS"
  }
  interface CreateStaffMemberRequest {
      /** Staff member to be created. */
      staffMember: StaffMember;
  }
  interface CreateStaffMemberResponse {
      /** The created staff member. */
      staffMember?: StaffMember;
  }
  interface GetStaffMemberRequest {
      /** ID of the staff member to retrieve. */
      staffMemberId: string;
      /**
       * List of additional staff member fields to include in the response. For example, use the `JOIN_LINK` fieldset to retrieve the join link field in
       * the response in addition to the staff member’s base fields. Base fields don’t include any of the supported fieldset values. By default
       * only the staff member’s base fields are returned.
       */
      fieldsets?: Fieldset[];
  }
  enum Fieldset {
      /**
       * Includes join link.
       * Deprecated, use LOGIN_LINK
       */
      JOIN_LINK = "JOIN_LINK",
      /** Includes login link. */
      LOGIN_LINK = "LOGIN_LINK"
  }
  interface GetStaffMemberResponse {
      /** The requested staff member. */
      staffMember?: StaffMember;
  }
  interface UpdateStaffMemberRequest {
      /** Staff member to be updated, may be partial. */
      staffMember: StaffMember;
      /**
       * Set of fields to update.
       * @internal
       */
      fieldMask?: string[];
  }
  interface UpdateStaffMemberResponse {
      /** Updated staff member. */
      staffMember?: StaffMember;
  }
  interface DeleteStaffMemberRequest {
      /** Id of the staff member to delete. */
      staffMemberId: string;
  }
  interface DeleteStaffMemberResponse {
  }
  interface QueryStaffMembersRequest {
      /** WQL expression. */
      query?: QueryV2$5;
      /**
       * List of additional staff member fields to include in the response. For example, use the `JOIN_LINK` fieldset to retrieve the join link field in
       * the response in addition to the staff member’s base fields. Base fields don’t include any of the supported fieldset values. By default
       * only the staff member’s base fields are returned.
       */
      fieldsets?: Fieldset[];
  }
  interface QueryV2$5 extends QueryV2PagingMethodOneOf$5 {
      /** Paging options to limit and skip the number of items. */
      paging?: Paging$6;
      /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
      cursorPaging?: CursorPaging$6;
      /** Filter object in the following format: <br/> `"filter" : { "fieldName1": "value1", "fieldName2":{"$operator":"value2"} }`. <br/> <br/> **Example:** <br/> `"filter" : { "eventId": "sd3f-jhds-4fs77", "ticketNumber": {"$startsWith":"478"} }` <br/> <br/> See [supported fields and operators](https://dev.wix.com/api/rest/wix-events/wix-events/filter-and-sort) for more information. */
      filter?: Record<string, any> | null;
      /** Sort object in the following format: <br/> `[{"fieldName":"sortField1"},{"fieldName":"sortField2","direction":"DESC"}]` <br/> <br/> **Example:** <br/> `[{"fieldName":"createdDate","direction":"DESC"}]` <br/> <br/> See [supported fields](https://dev.wix.com/api/rest/wix-events/wix-events/filter-and-sort) for more information. */
      sort?: Sorting$7[];
      /** Currently the only supported fieldset is `guestDetails`. The `WIX_EVENTS.READ_GUESTS_DETAILS` permission is required to access the guest details. <br/> <br/> See [field projection](https://dev.wix.com/api/rest/getting-started/field-projection) for more information. */
      fieldsets?: string[];
  }
  /** @oneof */
  interface QueryV2PagingMethodOneOf$5 {
      /** Paging options to limit and skip the number of items. */
      paging?: Paging$6;
      /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
      cursorPaging?: CursorPaging$6;
  }
  interface Sorting$7 {
      /** Name of the field to sort by. */
      fieldName?: string;
      /** Sort order (ASC/DESC). Defaults to ASC */
      order?: SortOrder$7;
  }
  enum SortOrder$7 {
      ASC = "ASC",
      DESC = "DESC"
  }
  interface Paging$6 {
      /** Number of items to load per page. */
      limit?: number | null;
      /** Number of items to skip in the current sort order. */
      offset?: number | null;
  }
  interface CursorPaging$6 {
      /** Number of items to load per page. */
      limit?: number | null;
      /**
       * Pointer to the next or previous page in the list of results.
       *
       * You can get the relevant cursor token
       * from the `pagingMetadata` object in the previous call's response.
       * Not relevant for the first request.
       */
      cursor?: string | null;
  }
  interface QueryStaffMembersResponse {
      /** List of staff members. */
      staffMembers?: StaffMember[];
      /** Paging metadata */
      pagingMetadata?: PagingMetadataV2$6;
  }
  interface PagingMetadataV2$6 {
      /** Number of items returned in the response. */
      count?: number | null;
      /** Offset that was requested. */
      offset?: number | null;
      /** Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set. */
      total?: number | null;
      /** Flag that indicates the server failed to calculate the `total` field. */
      tooManyToCount?: boolean | null;
      /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
      cursors?: Cursors$7;
  }
  interface Cursors$7 {
      /** Cursor pointing to next page in the list of results. */
      next?: string | null;
      /** Cursor pointing to previous page in the list of results. */
      prev?: string | null;
  }
  interface JoinStaffMemberRequest {
      /** Used to authorise staff member */
      joinToken: string;
  }
  interface JoinStaffMemberResponse {
      /** The activated staff member. */
      staffMember?: StaffMember;
      /** Used to authorise service calls */
      accessToken?: string;
      /** The device id to which staff member is authorized */
      deviceId?: string;
  }
  interface LoginStaffMemberRequest {
      /** Used to authorise staff member */
      loginToken: string;
  }
  interface LoginStaffMemberResponse {
      /** The activated staff member. */
      staffMember?: StaffMember;
      /** Used to authorise service calls */
      accessToken?: string;
      /** The device id to which staff member is authorized */
      deviceId?: string;
  }
  interface AccessStaffMemberRequest {
      /** Used to authorise staff member */
      accessToken: string;
  }
  interface AccessStaffMemberResponse {
      /** The staff member. */
      staffMember?: StaffMember;
  }
  interface DomainEvent$7 extends DomainEventBodyOneOf$7 {
      createdEvent?: EntityCreatedEvent$7;
      updatedEvent?: EntityUpdatedEvent$7;
      deletedEvent?: EntityDeletedEvent$7;
      actionEvent?: ActionEvent$7;
      /**
       * Unique event ID.
       * Allows clients to ignore duplicate webhooks.
       */
      _id?: string;
      /**
       * Assumes actions are also always typed to an entity_type
       * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
       */
      entityFqdn?: string;
      /**
       * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
       * This is although the created/updated/deleted notion is duplication of the oneof types
       * Example: created/updated/deleted/started/completed/email_opened
       */
      slug?: string;
      /** ID of the entity associated with the event. */
      entityId?: string;
      /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
      eventTime?: Date | null;
      /**
       * Whether the event was triggered as a result of a privacy regulation application
       * (for example, GDPR).
       */
      triggeredByAnonymizeRequest?: boolean | null;
      /** If present, indicates the action that triggered the event. */
      originatedFrom?: string | null;
      /**
       * A sequence number defining the order of updates to the underlying entity.
       * For example, given that some entity was updated at 16:00 and than again at 16:01,
       * it is guaranteed that the sequence number of the second update is strictly higher than the first.
       * As the consumer, you can use this value to ensure that you handle messages in the correct order.
       * To do so, you will need to persist this number on your end, and compare the sequence number from the
       * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
       */
      entityEventSequence?: string | null;
  }
  /** @oneof */
  interface DomainEventBodyOneOf$7 {
      createdEvent?: EntityCreatedEvent$7;
      updatedEvent?: EntityUpdatedEvent$7;
      deletedEvent?: EntityDeletedEvent$7;
      actionEvent?: ActionEvent$7;
  }
  interface EntityCreatedEvent$7 {
      entityAsJson?: string;
      /**
       * Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity
       * @internal
       */
      triggeredByUndelete?: boolean | null;
      /** Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity */
      restoreInfo?: RestoreInfo$7;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface RestoreInfo$7 {
      deletedDate?: Date | null;
  }
  interface EntityUpdatedEvent$7 {
      /**
       * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
       * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
       * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
       */
      currentEntityAsJson?: string;
      /**
       * This field is currently part of the of the EntityUpdatedEvent msg, but scala/node libraries which implements the domain events standard
       * wont populate it / have any reference to it in the API.
       * The main reason for it is that fetching the old entity from the DB will have a performance hit on an update operation so unless truly needed,
       * the developer should send only the new (current) entity.
       * An additional reason is not wanting to send this additional entity over the wire (kafka) since in some cases it can be really big
       * Developers that must reflect the old entity will have to implement their own domain event sender mechanism which will follow the DomainEvent proto message.
       * @internal
       * @deprecated
       */
      previousEntityAsJson?: string | null;
      /**
       * WIP - This property will hold both names and previous values of the updated fields of the entity.
       * For more details please see [adr](https://docs.google.com/document/d/1PdqsOM20Ph2HAkmx8zvUnzzk3Sekp3BR9h34wSvsRnI/edit#heading=h.phlw87mh2imx) or [issue](https://github.com/wix-private/nile-tracker/issues/363)
       * @internal
       */
      modifiedFields?: Record<string, any>;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface EntityDeletedEvent$7 {
      /**
       * Indicates if the entity is sent to trash-bin. only available when trash-bin is enabled
       * @internal
       */
      movedToTrash?: boolean | null;
      /** Entity that was deleted */
      deletedEntityAsJson?: string | null;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface ActionEvent$7 {
      bodyAsJson?: string;
  }
  interface MessageEnvelope$b {
      /** App instance ID. */
      instanceId?: string | null;
      /** Event type. */
      eventType?: string;
      /** The identification type and identity data. */
      identity?: IdentificationData$b;
      /** Stringify payload. */
      data?: string;
  }
  interface IdentificationData$b extends IdentificationDataIdOneOf$b {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
      /** @readonly */
      identityType?: WebhookIdentityType$b;
  }
  /** @oneof */
  interface IdentificationDataIdOneOf$b {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
  }
  enum WebhookIdentityType$b {
      UNKNOWN = "UNKNOWN",
      ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
      MEMBER = "MEMBER",
      WIX_USER = "WIX_USER",
      APP = "APP"
  }
  /**
   * Creates a staff member.
   * @param staffMember - Staff member to be created.
   * @public
   * @documentationMaturity preview
   * @requiredField staffMember
   * @permissionId WIX_EVENTS.STAFF_MEMBER_CREATE
   * @adminMethod
   * @returns The created staff member.
   */
  function createStaffMember(staffMember: StaffMember): Promise<StaffMember>;
  /**
   * Retrieves a staff member.
   * @param staffMemberId - ID of the staff member to retrieve.
   * @public
   * @documentationMaturity preview
   * @requiredField staffMemberId
   * @permissionId WIX_EVENTS.STAFF_MEMBER_READ
   * @adminMethod
   * @returns The requested staff member.
   */
  function getStaffMember(staffMemberId: string, options?: GetStaffMemberOptions): Promise<StaffMember>;
  interface GetStaffMemberOptions {
      /**
       * List of additional staff member fields to include in the response. For example, use the `JOIN_LINK` fieldset to retrieve the join link field in
       * the response in addition to the staff member’s base fields. Base fields don’t include any of the supported fieldset values. By default
       * only the staff member’s base fields are returned.
       */
      fieldsets?: Fieldset[];
  }
  /**
   * Updates a staff member.
   *
   * Each time the staff member is updated,
   * `revision` increments by 1.
   * The current `revision` must be passed when updating the staff member.
   * This ensures you're working with the latest staff member
   * and prevents unintended overwrites.
   * @param _id - Staff member ID.
   * @public
   * @documentationMaturity preview
   * @requiredField _id
   * @requiredField staffMember
   * @requiredField staffMember.revision
   * @permissionId WIX_EVENTS.STAFF_MEMBER_UPDATE
   * @adminMethod
   * @returns Updated staff member.
   */
  function updateStaffMember(_id: string | null, staffMember: UpdateStaffMember, options?: UpdateStaffMemberOptions): Promise<StaffMember>;
  interface UpdateStaffMember {
      /** All events. */
      allEvents?: AllEvents;
      /** Specific events. */
      specificEvents?: SpecificEvents;
      /**
       * Staff member ID.
       * @readonly
       */
      _id?: string | null;
      /**
       * Revision.
       * @readonly
       */
      revision?: string | null;
      /**
       * Date and time the staff member was created.
       * @readonly
       */
      _createdDate?: Date | null;
      /**
       * Date and time the staff member was last updated.
       * @readonly
       */
      _updatedDate?: Date | null;
      /** Name. */
      name?: string | null;
      /**
       * Scopes.
       * @deprecated Scopes.
       * @replacedBy permissions
       * @targetRemovalDate 2024-12-01
       */
      scopes?: Scope[];
      /** Status. Remains PENDING until staff member joins. Switches to SUSPENDED if user decides to temporarily revoke staff member access. */
      status?: Status$6;
      /**
       * Join link generated for staff member.
       * @readonly
       * @deprecated Join link generated for staff member.
       * @replacedBy login_link
       * @targetRemovalDate 2024-12-01
       */
      joinLink?: string | null;
      /** Data extensions */
      extendedFields?: ExtendedFields$3;
      /** Permissions. */
      permissions?: Permission[];
      /**
       * Login link generated for staff member.
       * @readonly
       */
      loginLink?: string | null;
  }
  interface UpdateStaffMemberOptions {
      /**
       * Set of fields to update.
       * @internal
       */
      fieldMask?: string[];
  }
  /**
   * Deletes a staff member.
   *
   * Deleting a staff member permanently removes them from the staff member List.
   * @param staffMemberId - Id of the staff member to delete.
   * @public
   * @documentationMaturity preview
   * @requiredField staffMemberId
   * @permissionId WIX_EVENTS.STAFF_MEMBER_DELETE
   * @adminMethod
   */
  function deleteStaffMember(staffMemberId: string): Promise<void>;
  /**
   * Retrieves a list of staff members, given the provided paging, filtering, and sorting.
   * @public
   * @documentationMaturity preview
   * @permissionId WIX_EVENTS.STAFF_MEMBER_READ
   * @adminMethod
   */
  function queryStaffMembers(options?: QueryStaffMembersOptions): StaffMembersQueryBuilder;
  interface QueryStaffMembersOptions {
      /**
       * List of additional staff member fields to include in the response. For example, use the `JOIN_LINK` fieldset to retrieve the join link field in
       * the response in addition to the staff member’s base fields. Base fields don’t include any of the supported fieldset values. By default
       * only the staff member’s base fields are returned.
       */
      fieldsets?: Fieldset[] | undefined;
  }
  interface QueryCursorResult$5 {
      cursors: Cursors$7;
      hasNext: () => boolean;
      hasPrev: () => boolean;
      length: number;
      pageSize: number;
  }
  interface StaffMembersQueryResult extends QueryCursorResult$5 {
      items: StaffMember[];
      query: StaffMembersQueryBuilder;
      next: () => Promise<StaffMembersQueryResult>;
      prev: () => Promise<StaffMembersQueryResult>;
  }
  interface StaffMembersQueryBuilder {
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       * @documentationMaturity preview
       */
      eq: (propertyName: '_id', value: any) => StaffMembersQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       * @documentationMaturity preview
       */
      ne: (propertyName: '_id', value: any) => StaffMembersQueryBuilder;
      /** @documentationMaturity preview */
      in: (propertyName: '_id', value: any) => StaffMembersQueryBuilder;
      /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments.
       * @documentationMaturity preview
       */
      ascending: (...propertyNames: Array<'_id'>) => StaffMembersQueryBuilder;
      /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments.
       * @documentationMaturity preview
       */
      descending: (...propertyNames: Array<'_id'>) => StaffMembersQueryBuilder;
      /** @param limit - Number of items to return, which is also the `pageSize` of the results object.
       * @documentationMaturity preview
       */
      limit: (limit: number) => StaffMembersQueryBuilder;
      /** @param cursor - A pointer to specific record
       * @documentationMaturity preview
       */
      skipTo: (cursor: string) => StaffMembersQueryBuilder;
      /** @documentationMaturity preview */
      find: () => Promise<StaffMembersQueryResult>;
  }
  /**
   * Joins as staff member if he's not in suspended status via provided token.
   * @param joinToken - Used to authorise staff member
   * @public
   * @documentationMaturity preview
   * @requiredField joinToken
   * @permissionId WIX_EVENTS.STAFF_MEMBER_ACTIVATE
   */
  function joinStaffMember(joinToken: string): Promise<JoinStaffMemberResponse>;
  /**
   * Logins as staff member if he's not in suspended status via provided token.
   * @param loginToken - Used to authorise staff member
   * @public
   * @documentationMaturity preview
   * @requiredField loginToken
   * @permissionId WIX_EVENTS.STAFF_MEMBER_ACTIVATE
   */
  function loginStaffMember(loginToken: string): Promise<LoginStaffMemberResponse>;
  /**
   * Retrieves a staff by access token.
   * @param accessToken - Used to authorise staff member
   * @public
   * @documentationMaturity preview
   * @requiredField accessToken
   * @permissionId WIX_EVENTS.STAFF_MEMBER_ACTIVATE
   */
  function accessStaffMember(accessToken: string): Promise<AccessStaffMemberResponse>;
  
  type eventsStaffmembersV1StaffMember_universal_d_StaffMember = StaffMember;
  type eventsStaffmembersV1StaffMember_universal_d_StaffMemberEventAccessOneOf = StaffMemberEventAccessOneOf;
  type eventsStaffmembersV1StaffMember_universal_d_Scope = Scope;
  const eventsStaffmembersV1StaffMember_universal_d_Scope: typeof Scope;
  type eventsStaffmembersV1StaffMember_universal_d_AllEvents = AllEvents;
  type eventsStaffmembersV1StaffMember_universal_d_SpecificEvents = SpecificEvents;
  type eventsStaffmembersV1StaffMember_universal_d_Permission = Permission;
  const eventsStaffmembersV1StaffMember_universal_d_Permission: typeof Permission;
  type eventsStaffmembersV1StaffMember_universal_d_CreateStaffMemberRequest = CreateStaffMemberRequest;
  type eventsStaffmembersV1StaffMember_universal_d_CreateStaffMemberResponse = CreateStaffMemberResponse;
  type eventsStaffmembersV1StaffMember_universal_d_GetStaffMemberRequest = GetStaffMemberRequest;
  type eventsStaffmembersV1StaffMember_universal_d_Fieldset = Fieldset;
  const eventsStaffmembersV1StaffMember_universal_d_Fieldset: typeof Fieldset;
  type eventsStaffmembersV1StaffMember_universal_d_GetStaffMemberResponse = GetStaffMemberResponse;
  type eventsStaffmembersV1StaffMember_universal_d_UpdateStaffMemberRequest = UpdateStaffMemberRequest;
  type eventsStaffmembersV1StaffMember_universal_d_UpdateStaffMemberResponse = UpdateStaffMemberResponse;
  type eventsStaffmembersV1StaffMember_universal_d_DeleteStaffMemberRequest = DeleteStaffMemberRequest;
  type eventsStaffmembersV1StaffMember_universal_d_DeleteStaffMemberResponse = DeleteStaffMemberResponse;
  type eventsStaffmembersV1StaffMember_universal_d_QueryStaffMembersRequest = QueryStaffMembersRequest;
  type eventsStaffmembersV1StaffMember_universal_d_QueryStaffMembersResponse = QueryStaffMembersResponse;
  type eventsStaffmembersV1StaffMember_universal_d_JoinStaffMemberRequest = JoinStaffMemberRequest;
  type eventsStaffmembersV1StaffMember_universal_d_JoinStaffMemberResponse = JoinStaffMemberResponse;
  type eventsStaffmembersV1StaffMember_universal_d_LoginStaffMemberRequest = LoginStaffMemberRequest;
  type eventsStaffmembersV1StaffMember_universal_d_LoginStaffMemberResponse = LoginStaffMemberResponse;
  type eventsStaffmembersV1StaffMember_universal_d_AccessStaffMemberRequest = AccessStaffMemberRequest;
  type eventsStaffmembersV1StaffMember_universal_d_AccessStaffMemberResponse = AccessStaffMemberResponse;
  const eventsStaffmembersV1StaffMember_universal_d_createStaffMember: typeof createStaffMember;
  const eventsStaffmembersV1StaffMember_universal_d_getStaffMember: typeof getStaffMember;
  type eventsStaffmembersV1StaffMember_universal_d_GetStaffMemberOptions = GetStaffMemberOptions;
  const eventsStaffmembersV1StaffMember_universal_d_updateStaffMember: typeof updateStaffMember;
  type eventsStaffmembersV1StaffMember_universal_d_UpdateStaffMember = UpdateStaffMember;
  type eventsStaffmembersV1StaffMember_universal_d_UpdateStaffMemberOptions = UpdateStaffMemberOptions;
  const eventsStaffmembersV1StaffMember_universal_d_deleteStaffMember: typeof deleteStaffMember;
  const eventsStaffmembersV1StaffMember_universal_d_queryStaffMembers: typeof queryStaffMembers;
  type eventsStaffmembersV1StaffMember_universal_d_QueryStaffMembersOptions = QueryStaffMembersOptions;
  type eventsStaffmembersV1StaffMember_universal_d_StaffMembersQueryResult = StaffMembersQueryResult;
  type eventsStaffmembersV1StaffMember_universal_d_StaffMembersQueryBuilder = StaffMembersQueryBuilder;
  const eventsStaffmembersV1StaffMember_universal_d_joinStaffMember: typeof joinStaffMember;
  const eventsStaffmembersV1StaffMember_universal_d_loginStaffMember: typeof loginStaffMember;
  const eventsStaffmembersV1StaffMember_universal_d_accessStaffMember: typeof accessStaffMember;
  namespace eventsStaffmembersV1StaffMember_universal_d {
    export {
      eventsStaffmembersV1StaffMember_universal_d_StaffMember as StaffMember,
      eventsStaffmembersV1StaffMember_universal_d_StaffMemberEventAccessOneOf as StaffMemberEventAccessOneOf,
      eventsStaffmembersV1StaffMember_universal_d_Scope as Scope,
      eventsStaffmembersV1StaffMember_universal_d_AllEvents as AllEvents,
      eventsStaffmembersV1StaffMember_universal_d_SpecificEvents as SpecificEvents,
      Status$6 as Status,
      ExtendedFields$3 as ExtendedFields,
      eventsStaffmembersV1StaffMember_universal_d_Permission as Permission,
      eventsStaffmembersV1StaffMember_universal_d_CreateStaffMemberRequest as CreateStaffMemberRequest,
      eventsStaffmembersV1StaffMember_universal_d_CreateStaffMemberResponse as CreateStaffMemberResponse,
      eventsStaffmembersV1StaffMember_universal_d_GetStaffMemberRequest as GetStaffMemberRequest,
      eventsStaffmembersV1StaffMember_universal_d_Fieldset as Fieldset,
      eventsStaffmembersV1StaffMember_universal_d_GetStaffMemberResponse as GetStaffMemberResponse,
      eventsStaffmembersV1StaffMember_universal_d_UpdateStaffMemberRequest as UpdateStaffMemberRequest,
      eventsStaffmembersV1StaffMember_universal_d_UpdateStaffMemberResponse as UpdateStaffMemberResponse,
      eventsStaffmembersV1StaffMember_universal_d_DeleteStaffMemberRequest as DeleteStaffMemberRequest,
      eventsStaffmembersV1StaffMember_universal_d_DeleteStaffMemberResponse as DeleteStaffMemberResponse,
      eventsStaffmembersV1StaffMember_universal_d_QueryStaffMembersRequest as QueryStaffMembersRequest,
      QueryV2$5 as QueryV2,
      QueryV2PagingMethodOneOf$5 as QueryV2PagingMethodOneOf,
      Sorting$7 as Sorting,
      SortOrder$7 as SortOrder,
      Paging$6 as Paging,
      CursorPaging$6 as CursorPaging,
      eventsStaffmembersV1StaffMember_universal_d_QueryStaffMembersResponse as QueryStaffMembersResponse,
      PagingMetadataV2$6 as PagingMetadataV2,
      Cursors$7 as Cursors,
      eventsStaffmembersV1StaffMember_universal_d_JoinStaffMemberRequest as JoinStaffMemberRequest,
      eventsStaffmembersV1StaffMember_universal_d_JoinStaffMemberResponse as JoinStaffMemberResponse,
      eventsStaffmembersV1StaffMember_universal_d_LoginStaffMemberRequest as LoginStaffMemberRequest,
      eventsStaffmembersV1StaffMember_universal_d_LoginStaffMemberResponse as LoginStaffMemberResponse,
      eventsStaffmembersV1StaffMember_universal_d_AccessStaffMemberRequest as AccessStaffMemberRequest,
      eventsStaffmembersV1StaffMember_universal_d_AccessStaffMemberResponse as AccessStaffMemberResponse,
      DomainEvent$7 as DomainEvent,
      DomainEventBodyOneOf$7 as DomainEventBodyOneOf,
      EntityCreatedEvent$7 as EntityCreatedEvent,
      RestoreInfo$7 as RestoreInfo,
      EntityUpdatedEvent$7 as EntityUpdatedEvent,
      EntityDeletedEvent$7 as EntityDeletedEvent,
      ActionEvent$7 as ActionEvent,
      MessageEnvelope$b as MessageEnvelope,
      IdentificationData$b as IdentificationData,
      IdentificationDataIdOneOf$b as IdentificationDataIdOneOf,
      WebhookIdentityType$b as WebhookIdentityType,
      eventsStaffmembersV1StaffMember_universal_d_createStaffMember as createStaffMember,
      eventsStaffmembersV1StaffMember_universal_d_getStaffMember as getStaffMember,
      eventsStaffmembersV1StaffMember_universal_d_GetStaffMemberOptions as GetStaffMemberOptions,
      eventsStaffmembersV1StaffMember_universal_d_updateStaffMember as updateStaffMember,
      eventsStaffmembersV1StaffMember_universal_d_UpdateStaffMember as UpdateStaffMember,
      eventsStaffmembersV1StaffMember_universal_d_UpdateStaffMemberOptions as UpdateStaffMemberOptions,
      eventsStaffmembersV1StaffMember_universal_d_deleteStaffMember as deleteStaffMember,
      eventsStaffmembersV1StaffMember_universal_d_queryStaffMembers as queryStaffMembers,
      eventsStaffmembersV1StaffMember_universal_d_QueryStaffMembersOptions as QueryStaffMembersOptions,
      eventsStaffmembersV1StaffMember_universal_d_StaffMembersQueryResult as StaffMembersQueryResult,
      eventsStaffmembersV1StaffMember_universal_d_StaffMembersQueryBuilder as StaffMembersQueryBuilder,
      eventsStaffmembersV1StaffMember_universal_d_joinStaffMember as joinStaffMember,
      eventsStaffmembersV1StaffMember_universal_d_loginStaffMember as loginStaffMember,
      eventsStaffmembersV1StaffMember_universal_d_accessStaffMember as accessStaffMember,
    };
  }
  
  interface Category$4 {
      /**
       * Category ID.
       * @readonly
       */
      _id?: string;
      /** Category name. */
      name?: string;
      /**
       * Date and time when category was created.
       * @readonly
       */
      _createdDate?: Date | null;
      /**
       * Total number of published events assigned to the category. Deleted events are excluded.
       * @internal
       * @readonly
       * @deprecated
       */
      assignedEventsCount?: number | null;
      /**
       * The total number of draft and published events assigned to the category.
       * @readonly
       */
      counts?: CategoryCounts$4;
      /**
       * Category state. Possible values:
       * - `MANUAL`: Category is created manually by the user.
       * - `AUTO`: Category is created automatically.
       * - `RECURRING_EVENT`: Category is created automatically when publishing recurring events.
       * - `HIDDEN`: Category can't be seen.
       *
       * Default: `MANUAL`.
       *
       * **Note:** The WIX_EVENTS.MANAGE_AUTO_CATEGORIES permission is required to use states other than `MANUAL`.
       */
      states?: State$7[];
      /**
       * Optionally client defined external ID.
       * @internal
       */
      externalId?: string | null;
  }
  interface CategoryCounts$4 {
      /** Total number of published events assigned to the category. Deleted events are excluded. */
      assignedEventsCount?: number | null;
      /** Total number of draft events assigned to the category. */
      assignedDraftEventsCount?: number | null;
  }
  enum State$7 {
      /** Created manually by the user. */
      MANUAL = "MANUAL",
      /** Created automatically. */
      AUTO = "AUTO",
      /** Created when publishing recurring events. */
      RECURRING_EVENT = "RECURRING_EVENT",
      /** Category is hidden. */
      HIDDEN = "HIDDEN",
      /** Category is used to store component events. */
      COMPONENT = "COMPONENT"
  }
  interface CreateCategoryRequest {
      /** Category to create. */
      category: Category$4;
  }
  interface CreateCategoryResponse {
      /** Created category. */
      category?: Category$4;
  }
  interface BulkCreateCategoryRequest {
      /** Categories to create. */
      categories: Category$4[];
  }
  interface BulkCreateCategoryResponse {
      /** Bulk create results. */
      results?: BulkCategoryResult[];
      /** Metadata of results. */
      bulkActionMetadata?: BulkActionMetadata$1;
  }
  interface BulkCategoryResult {
      /** Metadata. */
      itemMetadata?: ItemMetadata$1;
      /** Created categories. */
      item?: Category$4;
  }
  interface ItemMetadata$1 {
      /** Item ID. Should always be available, unless it's impossible (for example, when failing to create an item). */
      _id?: string | null;
      /** Index of the item within the request array. Allows for correlation between request and response items. */
      originalIndex?: number;
      /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
      success?: boolean;
      /** Details about the error in case of failure. */
      error?: ApplicationError$1;
  }
  interface ApplicationError$1 {
      /** Error code. */
      code?: string;
      /** Description of the error. */
      description?: string;
      /** Data related to the error. */
      data?: Record<string, any> | null;
  }
  interface BulkActionMetadata$1 {
      /** Number of items that were successfully processed. */
      totalSuccesses?: number;
      /** Number of items that couldn't be processed. */
      totalFailures?: number;
      /** Number of failures without details due to exceeding the threshold for detailed failures. */
      undetailedFailures?: number;
  }
  interface UpdateCategoryRequest {
      /** Category to update. */
      category: Category$4;
  }
  interface UpdateCategoryResponse {
      /** Updated category. */
      category?: Category$4;
  }
  interface DeleteCategoryRequest {
      /** ID of category to be deleted. */
      categoryId: string;
  }
  interface DeleteCategoryResponse {
  }
  interface QueryCategoriesRequest {
      /** Options to use when querying categories. See [API Query Language](https://dev.wix.com/api/rest/getting-started/api-query-language) for more details. */
      query: QueryV2$4;
      /**
       * Predefined sets of fields to return.
       * - `COUNTS`: Returns `assignedEventsCount`.
       */
      fieldset?: CategoryFieldset[];
  }
  interface QueryV2$4 extends QueryV2PagingMethodOneOf$4 {
      /**
       * Pointer to page of results using offset.
       * See [Pagination](https://dev.wix.com/api/rest/getting-started/pagination).
       */
      paging?: Paging$5;
      /** Filter. See [supported fields and operators](https://dev.wix.com/api/rest/wix-events/wix-events/filter-and-sort#wix-events_wix-events_filter-and-sort_list-query-events). */
      filter?: Record<string, any> | null;
      /**
       * Sort object in the form [{"fieldName":"sortField1"},{"fieldName":"sortField2","direction":"DESC"}]
       * See [supported fields](https://dev.wix.com/api/rest/wix-events/wix-events/filter-and-sort#wix-events_wix-events_filter-and-sort_list-query-events).
       */
      sort?: Sorting$6[];
  }
  /** @oneof */
  interface QueryV2PagingMethodOneOf$4 {
      /**
       * Pointer to page of results using offset.
       * See [Pagination](https://dev.wix.com/api/rest/getting-started/pagination).
       */
      paging?: Paging$5;
  }
  interface Sorting$6 {
      /** Name of the field to sort by */
      fieldName?: string;
      /** Sort order (ASC/DESC). Defaults to ASC */
      order?: SortOrder$6;
  }
  enum SortOrder$6 {
      ASC = "ASC",
      DESC = "DESC"
  }
  interface Paging$5 {
      /** Number of items to load per page. */
      limit?: number | null;
      /** Number of items to skip in the current sort order. */
      offset?: number | null;
  }
  enum CategoryFieldset {
      /** Include `assignedEventsCount` in the response. */
      COUNTS = "COUNTS"
  }
  interface QueryCategoriesResponse {
      /** List of categories. */
      categories?: Category$4[];
      /** Metadata for the paginated results. */
      metaData?: PagingMetadataV2$5;
  }
  interface PagingMetadataV2$5 {
      /** Number of items returned in the response. */
      count?: number | null;
      /** Offset that was requested. */
      offset?: number | null;
      /** Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set. */
      total?: number | null;
      /** Flag that indicates the server failed to calculate the `total` field. */
      tooManyToCount?: boolean | null;
      /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
      cursors?: Cursors$6;
      /**
       * Indicates if there are more results after the current page.
       * If `true`, another page of results can be retrieved.
       * If `false`, this is the last page.
       * @internal
       */
      hasNext?: boolean | null;
  }
  interface Cursors$6 {
      /** Cursor string pointing to the next page in the list of results. */
      next?: string | null;
      /** Cursor pointing to the previous page in the list of results. */
      prev?: string | null;
  }
  interface AssignEventsRequest {
      /** ID of category to which events should be assigned. */
      categoryId: string;
      /** A list of events IDs. */
      eventId: string[];
  }
  interface AssignEventsResponse {
  }
  interface BulkAssignEventsRequest {
      /** A list of category IDs to which events should be assigned. */
      categoryId: string[];
      /** A list of events IDs. */
      eventId: string[];
  }
  interface BulkAssignEventsResponse {
      /** Bulk assign results. */
      results?: BulkCategoryResult[];
      /** Metadata of results. */
      bulkActionMetadata?: BulkActionMetadata$1;
  }
  interface BulkAssignEventsAsyncRequest {
      /** Category IDs. */
      categoryId: string[];
      /**
       * Criteria that must be met for an event to be considered for the bulk assign. Supported filters for this API:
       * - `_id`: [`eq()`](https://www.wix.com/velo/reference/wix-events-v2/categories/categoriesquerybuilder/eq)
       * - `name`: [`eq()`](https://www.wix.com/velo/reference/wix-events-v2/categories/categoriesquerybuilder/eq)
       */
      filter: Record<string, any> | null;
  }
  interface BulkAssignEventsAsyncResponse {
  }
  interface UnassignEventsRequest {
      /** Category ID. */
      categoryId: string;
      /** A list of events IDs. */
      eventId: string[];
  }
  interface UnassignEventsResponse {
  }
  interface BulkUnassignEventsRequest {
      /** A list of category IDs. */
      categoryId: string[];
      /** A list of events IDs. */
      eventId?: string[];
  }
  interface BulkUnassignEventsResponse {
      /** Results. */
      results?: BulkCategoryResult[];
      /** Metadata of results. */
      bulkActionMetadata?: BulkActionMetadata$1;
  }
  interface BulkUnassignEventsAsyncRequest {
      /** Category ID. */
      categoryId: string[];
      /**
       * Criteria that must be met for an event to be considered for the bulk assign. Supported filters for this API:
       * - `_id`: [`eq()`](https://www.wix.com/velo/reference/wix-events-v2/categories/categoriesquerybuilder/eq)
       * - `name`: [`eq()`](https://www.wix.com/velo/reference/wix-events-v2/categories/categoriesquerybuilder/eq)
       */
      filter: Record<string, any> | null;
  }
  interface BulkUnassignEventsAsyncResponse {
  }
  interface ListEventCategoriesRequest {
      /** Event ID. */
      eventId: string;
  }
  interface ListEventCategoriesResponse {
      /** A list of categories. */
      categories?: Category$4[];
  }
  interface ReorderCategoryEventsRequest extends ReorderCategoryEventsRequestReferenceEventOneOf {
      /** Move the event before defined `eventId`. */
      beforeEventId?: string;
      /** Move the event after defined `eventId`. */
      afterEventId?: string;
      /** Category ID. */
      categoryId: string;
      /** Event ID. */
      eventId?: string;
  }
  /** @oneof */
  interface ReorderCategoryEventsRequestReferenceEventOneOf {
      /** Move the event before defined `eventId`. */
      beforeEventId?: string;
      /** Move the event after defined `eventId`. */
      afterEventId?: string;
  }
  interface ReorderCategoryEventsResponse {
  }
  interface DomainEvent$6 extends DomainEventBodyOneOf$6 {
      createdEvent?: EntityCreatedEvent$6;
      updatedEvent?: EntityUpdatedEvent$6;
      deletedEvent?: EntityDeletedEvent$6;
      actionEvent?: ActionEvent$6;
      /**
       * Unique event ID.
       * Allows clients to ignore duplicate webhooks.
       */
      _id?: string;
      /**
       * Assumes actions are also always typed to an entity_type
       * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
       */
      entityFqdn?: string;
      /**
       * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
       * This is although the created/updated/deleted notion is duplication of the oneof types
       * Example: created/updated/deleted/started/completed/email_opened
       */
      slug?: string;
      /** ID of the entity associated with the event. */
      entityId?: string;
      /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
      eventTime?: Date | null;
      /**
       * Whether the event was triggered as a result of a privacy regulation application
       * (for example, GDPR).
       */
      triggeredByAnonymizeRequest?: boolean | null;
      /** If present, indicates the action that triggered the event. */
      originatedFrom?: string | null;
      /**
       * A sequence number defining the order of updates to the underlying entity.
       * For example, given that some entity was updated at 16:00 and than again at 16:01,
       * it is guaranteed that the sequence number of the second update is strictly higher than the first.
       * As the consumer, you can use this value to ensure that you handle messages in the correct order.
       * To do so, you will need to persist this number on your end, and compare the sequence number from the
       * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
       */
      entityEventSequence?: string | null;
  }
  /** @oneof */
  interface DomainEventBodyOneOf$6 {
      createdEvent?: EntityCreatedEvent$6;
      updatedEvent?: EntityUpdatedEvent$6;
      deletedEvent?: EntityDeletedEvent$6;
      actionEvent?: ActionEvent$6;
  }
  interface EntityCreatedEvent$6 {
      entityAsJson?: string;
      /**
       * Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity
       * @internal
       */
      triggeredByUndelete?: boolean | null;
      /** Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity */
      restoreInfo?: RestoreInfo$6;
  }
  interface RestoreInfo$6 {
      deletedDate?: Date | null;
  }
  interface EntityUpdatedEvent$6 {
      /**
       * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
       * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
       * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
       */
      currentEntityAsJson?: string;
      /**
       * This field is currently part of the of the EntityUpdatedEvent msg, but scala/node libraries which implements the domain events standard
       * wont populate it / have any reference to it in the API.
       * The main reason for it is that fetching the old entity from the DB will have a performance hit on an update operation so unless truly needed,
       * the developer should send only the new (current) entity.
       * An additional reason is not wanting to send this additional entity over the wire (kafka) since in some cases it can be really big
       * Developers that must reflect the old entity will have to implement their own domain event sender mechanism which will follow the DomainEvent proto message.
       * @internal
       * @deprecated
       */
      previousEntityAsJson?: string | null;
      /**
       * WIP - This property will hold both names and values of the updated fields of the entity.
       * For more details please see [adr](https://docs.google.com/document/d/1PdqsOM20Ph2HAkmx8zvUnzzk3Sekp3BR9h34wSvsRnI/edit#heading=h.phlw87mh2imx) or [issue](https://github.com/wix-private/nile-tracker/issues/363)
       * @internal
       */
      modifiedFields?: Record<string, any>;
  }
  interface EntityDeletedEvent$6 {
      /**
       * Indicates if the entity is sent to trash-bin. only available when trash-bin is enabled
       * @internal
       */
      movedToTrash?: boolean | null;
      /** Entity that was deleted */
      deletedEntityAsJson?: string | null;
  }
  interface ActionEvent$6 {
      bodyAsJson?: string;
  }
  interface MessageEnvelope$a {
      /** App instance ID. */
      instanceId?: string | null;
      /** Event type. */
      eventType?: string;
      /** The identification type and identity data. */
      identity?: IdentificationData$a;
      /** Stringify payload. */
      data?: string;
  }
  interface IdentificationData$a extends IdentificationDataIdOneOf$a {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
      /** @readonly */
      identityType?: WebhookIdentityType$a;
  }
  /** @oneof */
  interface IdentificationDataIdOneOf$a {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
  }
  enum WebhookIdentityType$a {
      UNKNOWN = "UNKNOWN",
      ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
      MEMBER = "MEMBER",
      WIX_USER = "WIX_USER",
      APP = "APP"
  }
  /**
   * Creates a category.
   * @public
   * @requiredField category
   * @param category - Category to create.
   * @permissionId WIX_EVENTS.MANAGE_CATEGORIES
   * @adminMethod
   * @returns Created category.
   */
  function createCategory(category: Category$4): Promise<Category$4>;
  /**
   * Creates multipe categories at once.
   * @param categories - Categories to create.
   * @public
   * @requiredField categories
   * @permissionId WIX_EVENTS.MANAGE_CATEGORIES
   * @adminMethod
   */
  function bulkCreateCategory(categories: Category$4[]): Promise<BulkCreateCategoryResponse>;
  /**
   * Updates an existing category.
   * @param _id - Category ID.
   * @public
   * @requiredField _id
   * @requiredField category
   * @permissionId WIX_EVENTS.MANAGE_CATEGORIES
   * @adminMethod
   * @returns Updated category.
   */
  function updateCategory(_id: string, category: UpdateCategory): Promise<Category$4>;
  interface UpdateCategory {
      /**
       * Category ID.
       * @readonly
       */
      _id?: string;
      /** Category name. */
      name?: string;
      /**
       * Date and time when category was created.
       * @readonly
       */
      _createdDate?: Date | null;
      /**
       * Total number of published events assigned to the category. Deleted events are excluded.
       * @internal
       * @readonly
       * @deprecated
       */
      assignedEventsCount?: number | null;
      /**
       * The total number of draft and published events assigned to the category.
       * @readonly
       */
      counts?: CategoryCounts$4;
      /**
       * Category state. Possible values:
       * - `MANUAL`: Category is created manually by the user.
       * - `AUTO`: Category is created automatically.
       * - `RECURRING_EVENT`: Category is created automatically when publishing recurring events.
       * - `HIDDEN`: Category can't be seen.
       *
       * Default: `MANUAL`.
       *
       * **Note:** The WIX_EVENTS.MANAGE_AUTO_CATEGORIES permission is required to use states other than `MANUAL`.
       */
      states?: State$7[];
      /**
       * Optionally client defined external ID.
       * @internal
       */
      externalId?: string | null;
  }
  /**
   * Deletes a category.
   * @param categoryId - ID of category to be deleted.
   * @public
   * @requiredField categoryId
   * @permissionId WIX_EVENTS.MANAGE_CATEGORIES
   * @adminMethod
   */
  function deleteCategory(categoryId: string): Promise<void>;
  /**
   * Creates a query to retrieve a list of categories.
   *
   *
   * The `queryCategories()` function builds a query to retrieve a list of categories and returns a [`CategoriesQueryBuilder`](https://www.wix.com/velo/reference/wix-events-v2/categories/categoriesquerybuilder) object.
   *
   * The returned object contains the query definition, which is typically used to run the query using the [`find()`](https://www.wix.com/velo/reference/wix-events-v2/categories/categoriesquerybuilder/find) function.
   *
   * You can refine the query by chaining `CategoriesQueryBuilder` functions onto the query. `CategoriesQueryBuilder` functions enable you to sort, filter, and control the results `queryCategories()` returns.
   *
   * `queryCategories()` runs with these `CategoriesQueryBuilder` defaults, which you can override:
   *
   *  - [`limit(50)`](https://www.wix.com/velo/reference/wix-events-v2/categories/categoriesquerybuilder/limit)
   * @public
   * @param options - Options to use when querying categories.
   * @permissionId WIX_EVENTS.READ_CATEGORIES
   */
  function queryCategories(options?: QueryCategoriesOptions): CategoriesQueryBuilder;
  interface QueryCategoriesOptions {
      /**
       * Predefined sets of fields to return.
       * - `COUNTS`: Returns `assignedEventsCount`.
       */
      fieldset?: CategoryFieldset[] | undefined;
  }
  interface QueryOffsetResult$1 {
      currentPage: number | undefined;
      totalPages: number | undefined;
      totalCount: number | undefined;
      hasNext: () => boolean;
      hasPrev: () => boolean;
      length: number;
      pageSize: number;
  }
  interface CategoriesQueryResult extends QueryOffsetResult$1 {
      items: Category$4[];
      query: CategoriesQueryBuilder;
      next: () => Promise<CategoriesQueryResult>;
      prev: () => Promise<CategoriesQueryResult>;
  }
  interface CategoriesQueryBuilder {
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       */
      eq: (propertyName: '_id' | 'name', value: any) => CategoriesQueryBuilder;
      /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments. */
      ascending: (...propertyNames: Array<'_createdDate'>) => CategoriesQueryBuilder;
      /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments. */
      descending: (...propertyNames: Array<'_createdDate'>) => CategoriesQueryBuilder;
      /** @param limit - Number of items to return, which is also the `pageSize` of the results object. */
      limit: (limit: number) => CategoriesQueryBuilder;
      /** @param skip - Number of items to skip in the query results before returning the results. */
      skip: (skip: number) => CategoriesQueryBuilder;
      find: () => Promise<CategoriesQueryResult>;
  }
  /**
   * Assigns events to a single category.
   * @param categoryId - ID of category to which events should be assigned.
   * @param eventId - A list of events IDs.
   * @public
   * @requiredField categoryId
   * @requiredField eventId
   * @permissionId WIX_EVENTS.MANAGE_CATEGORIES
   * @adminMethod
   */
  function assignEvents(categoryId: string, eventId: string[]): Promise<void>;
  /**
   * Assigns events to multiple categories at once.
   * @param categoryId - A list of category IDs to which events should be assigned.
   * @public
   * @requiredField categoryId
   * @requiredField options
   * @requiredField options.eventId
   * @param options - Options to use when assigning events to multiple categories.
   * @permissionId WIX_EVENTS.MANAGE_CATEGORIES
   * @adminMethod
   */
  function bulkAssignEvents(categoryId: string[], options: BulkAssignEventsOptions): Promise<BulkAssignEventsResponse>;
  interface BulkAssignEventsOptions {
      /** A list of events IDs. */
      eventId: string[];
  }
  /**
   * Assigns events that match given filter criteria to multiple categories.
   *
   * Unlike the [`bulkAssignEvents()`](https://www.wix.com/velo/reference/wix-events-v2/categories/bulkassignevents) function, this function can handle numerous requests and is less prone to failures.
   *
   * However, the events will not be instantly assigned to the categories (as with `bulkAssignEvents()`), but rather after some time. In this case, if try to [`listEventCategories`](https://www.wix.com/velo/reference/wix-events-v2/categories/listeventcategories) or [`queryCategories`](https://www.wix.com/velo/reference/wix-events-v2/categories/querycategories), you might not get the correct response.
   * @param categoryId - Category IDs.
   * @public
   * @requiredField categoryId
   * @requiredField options
   * @requiredField options.filter
   * @param options - Options to use when assigning events to multiple categories.
   * @permissionId WIX_EVENTS.MANAGE_CATEGORIES
   * @adminMethod
   */
  function bulkAssignEventsAsync(categoryId: string[], options: BulkAssignEventsAsyncOptions): Promise<void>;
  interface BulkAssignEventsAsyncOptions {
      /**
       * Criteria that must be met for an event to be considered for the bulk assign. Supported filters for this API:
       * - `_id`: [`eq()`](https://www.wix.com/velo/reference/wix-events-v2/categories/categoriesquerybuilder/eq)
       * - `name`: [`eq()`](https://www.wix.com/velo/reference/wix-events-v2/categories/categoriesquerybuilder/eq)
       */
      filter: Record<string, any> | null;
  }
  /**
   * Unassigns events from a category.
   * @param categoryId - Category ID.
   * @param eventId - A list of events IDs.
   * @public
   * @requiredField categoryId
   * @requiredField eventId
   * @permissionId WIX_EVENTS.MANAGE_CATEGORIES
   * @adminMethod
   */
  function unassignEvents(categoryId: string, eventId: string[]): Promise<void>;
  /**
   * Unassigns events from multiple categories at once.
   * @param categoryId - A list of category IDs.
   * @public
   * @requiredField categoryId
   * @param options - Options to use when removing events from multiple categories.
   * @permissionId WIX_EVENTS.MANAGE_CATEGORIES
   * @adminMethod
   */
  function bulkUnassignEvents(categoryId: string[], options?: BulkUnassignEventsOptions): Promise<BulkUnassignEventsResponse>;
  interface BulkUnassignEventsOptions {
      /** A list of events IDs. */
      eventId?: string[];
  }
  /**
   * Removes events that match given filter criteria from multiple categories.
   *
   * Unlike the [`bulkUnassignEvents()`](https://www.wix.com/velo/reference/wix-events-v2/categories/bulkunassignevents) function, this function can handle numerous requests and is less prone to failures.
   *
   * However, the events will not be instantly removed from the categories (as with `bulkUnassignEvents()`), but rather after some time. In this case, if try to [`listEventCategories`](https://www.wix.com/velo/reference/wix-events-v2/categories/listeventcategories) or [`queryCategories`](https://www.wix.com/velo/reference/wix-events-v2/categories/querycategories), you might not get the correct response.
   * @param categoryId - Category ID.
   * @public
   * @requiredField categoryId
   * @requiredField options
   * @requiredField options.filter
   * @param options - Options to use when removing events from multiple categories.
   * @permissionId WIX_EVENTS.MANAGE_CATEGORIES
   * @adminMethod
   */
  function bulkUnassignEventsAsync(categoryId: string[], options: BulkUnassignEventsAsyncOptions): Promise<void>;
  interface BulkUnassignEventsAsyncOptions {
      /**
       * Criteria that must be met for an event to be considered for the bulk assign. Supported filters for this API:
       * - `_id`: [`eq()`](https://www.wix.com/velo/reference/wix-events-v2/categories/categoriesquerybuilder/eq)
       * - `name`: [`eq()`](https://www.wix.com/velo/reference/wix-events-v2/categories/categoriesquerybuilder/eq)
       */
      filter: Record<string, any> | null;
  }
  /**
   * Retrieves a list of categories that are not in the `HIDDEN` state.
   * @param eventId - Event ID.
   * @public
   * @requiredField eventId
   * @permissionId WIX_EVENTS.READ_CATEGORIES
   */
  function listEventCategories(eventId: string): Promise<ListEventCategoriesResponse>;
  /**
   * Change the order of events that are assigned to the same category on the Events Widget.
   *
   *
   * For more information see [this article](https://support.wix.com/en/article/creating-and-displaying-event-categories)
   * @param categoryId - Category ID.
   * @public
   * @requiredField categoryId
   * @param options - Options to use when reordering events.
   * @permissionId WIX_EVENTS.MANAGE_CATEGORIES
   * @adminMethod
   */
  function reorderCategoryEvents(categoryId: string, options?: ReorderCategoryEventsOptions): Promise<void>;
  interface ReorderCategoryEventsOptions extends ReorderCategoryEventsRequestReferenceEventOneOf {
      /** Event ID. */
      eventId?: string;
      /** Move the event before defined `eventId`. */
      beforeEventId?: string;
      /** Move the event after defined `eventId`. */
      afterEventId?: string;
  }
  
  type eventsV1Category_universal_d_CreateCategoryRequest = CreateCategoryRequest;
  type eventsV1Category_universal_d_CreateCategoryResponse = CreateCategoryResponse;
  type eventsV1Category_universal_d_BulkCreateCategoryRequest = BulkCreateCategoryRequest;
  type eventsV1Category_universal_d_BulkCreateCategoryResponse = BulkCreateCategoryResponse;
  type eventsV1Category_universal_d_BulkCategoryResult = BulkCategoryResult;
  type eventsV1Category_universal_d_UpdateCategoryRequest = UpdateCategoryRequest;
  type eventsV1Category_universal_d_UpdateCategoryResponse = UpdateCategoryResponse;
  type eventsV1Category_universal_d_DeleteCategoryRequest = DeleteCategoryRequest;
  type eventsV1Category_universal_d_DeleteCategoryResponse = DeleteCategoryResponse;
  type eventsV1Category_universal_d_QueryCategoriesRequest = QueryCategoriesRequest;
  type eventsV1Category_universal_d_CategoryFieldset = CategoryFieldset;
  const eventsV1Category_universal_d_CategoryFieldset: typeof CategoryFieldset;
  type eventsV1Category_universal_d_QueryCategoriesResponse = QueryCategoriesResponse;
  type eventsV1Category_universal_d_AssignEventsRequest = AssignEventsRequest;
  type eventsV1Category_universal_d_AssignEventsResponse = AssignEventsResponse;
  type eventsV1Category_universal_d_BulkAssignEventsRequest = BulkAssignEventsRequest;
  type eventsV1Category_universal_d_BulkAssignEventsResponse = BulkAssignEventsResponse;
  type eventsV1Category_universal_d_BulkAssignEventsAsyncRequest = BulkAssignEventsAsyncRequest;
  type eventsV1Category_universal_d_BulkAssignEventsAsyncResponse = BulkAssignEventsAsyncResponse;
  type eventsV1Category_universal_d_UnassignEventsRequest = UnassignEventsRequest;
  type eventsV1Category_universal_d_UnassignEventsResponse = UnassignEventsResponse;
  type eventsV1Category_universal_d_BulkUnassignEventsRequest = BulkUnassignEventsRequest;
  type eventsV1Category_universal_d_BulkUnassignEventsResponse = BulkUnassignEventsResponse;
  type eventsV1Category_universal_d_BulkUnassignEventsAsyncRequest = BulkUnassignEventsAsyncRequest;
  type eventsV1Category_universal_d_BulkUnassignEventsAsyncResponse = BulkUnassignEventsAsyncResponse;
  type eventsV1Category_universal_d_ListEventCategoriesRequest = ListEventCategoriesRequest;
  type eventsV1Category_universal_d_ListEventCategoriesResponse = ListEventCategoriesResponse;
  type eventsV1Category_universal_d_ReorderCategoryEventsRequest = ReorderCategoryEventsRequest;
  type eventsV1Category_universal_d_ReorderCategoryEventsRequestReferenceEventOneOf = ReorderCategoryEventsRequestReferenceEventOneOf;
  type eventsV1Category_universal_d_ReorderCategoryEventsResponse = ReorderCategoryEventsResponse;
  const eventsV1Category_universal_d_createCategory: typeof createCategory;
  const eventsV1Category_universal_d_bulkCreateCategory: typeof bulkCreateCategory;
  const eventsV1Category_universal_d_updateCategory: typeof updateCategory;
  type eventsV1Category_universal_d_UpdateCategory = UpdateCategory;
  const eventsV1Category_universal_d_deleteCategory: typeof deleteCategory;
  const eventsV1Category_universal_d_queryCategories: typeof queryCategories;
  type eventsV1Category_universal_d_QueryCategoriesOptions = QueryCategoriesOptions;
  type eventsV1Category_universal_d_CategoriesQueryResult = CategoriesQueryResult;
  type eventsV1Category_universal_d_CategoriesQueryBuilder = CategoriesQueryBuilder;
  const eventsV1Category_universal_d_assignEvents: typeof assignEvents;
  const eventsV1Category_universal_d_bulkAssignEvents: typeof bulkAssignEvents;
  type eventsV1Category_universal_d_BulkAssignEventsOptions = BulkAssignEventsOptions;
  const eventsV1Category_universal_d_bulkAssignEventsAsync: typeof bulkAssignEventsAsync;
  type eventsV1Category_universal_d_BulkAssignEventsAsyncOptions = BulkAssignEventsAsyncOptions;
  const eventsV1Category_universal_d_unassignEvents: typeof unassignEvents;
  const eventsV1Category_universal_d_bulkUnassignEvents: typeof bulkUnassignEvents;
  type eventsV1Category_universal_d_BulkUnassignEventsOptions = BulkUnassignEventsOptions;
  const eventsV1Category_universal_d_bulkUnassignEventsAsync: typeof bulkUnassignEventsAsync;
  type eventsV1Category_universal_d_BulkUnassignEventsAsyncOptions = BulkUnassignEventsAsyncOptions;
  const eventsV1Category_universal_d_listEventCategories: typeof listEventCategories;
  const eventsV1Category_universal_d_reorderCategoryEvents: typeof reorderCategoryEvents;
  type eventsV1Category_universal_d_ReorderCategoryEventsOptions = ReorderCategoryEventsOptions;
  namespace eventsV1Category_universal_d {
    export {
      Category$4 as Category,
      CategoryCounts$4 as CategoryCounts,
      State$7 as State,
      eventsV1Category_universal_d_CreateCategoryRequest as CreateCategoryRequest,
      eventsV1Category_universal_d_CreateCategoryResponse as CreateCategoryResponse,
      eventsV1Category_universal_d_BulkCreateCategoryRequest as BulkCreateCategoryRequest,
      eventsV1Category_universal_d_BulkCreateCategoryResponse as BulkCreateCategoryResponse,
      eventsV1Category_universal_d_BulkCategoryResult as BulkCategoryResult,
      ItemMetadata$1 as ItemMetadata,
      ApplicationError$1 as ApplicationError,
      BulkActionMetadata$1 as BulkActionMetadata,
      eventsV1Category_universal_d_UpdateCategoryRequest as UpdateCategoryRequest,
      eventsV1Category_universal_d_UpdateCategoryResponse as UpdateCategoryResponse,
      eventsV1Category_universal_d_DeleteCategoryRequest as DeleteCategoryRequest,
      eventsV1Category_universal_d_DeleteCategoryResponse as DeleteCategoryResponse,
      eventsV1Category_universal_d_QueryCategoriesRequest as QueryCategoriesRequest,
      QueryV2$4 as QueryV2,
      QueryV2PagingMethodOneOf$4 as QueryV2PagingMethodOneOf,
      Sorting$6 as Sorting,
      SortOrder$6 as SortOrder,
      Paging$5 as Paging,
      eventsV1Category_universal_d_CategoryFieldset as CategoryFieldset,
      eventsV1Category_universal_d_QueryCategoriesResponse as QueryCategoriesResponse,
      PagingMetadataV2$5 as PagingMetadataV2,
      Cursors$6 as Cursors,
      eventsV1Category_universal_d_AssignEventsRequest as AssignEventsRequest,
      eventsV1Category_universal_d_AssignEventsResponse as AssignEventsResponse,
      eventsV1Category_universal_d_BulkAssignEventsRequest as BulkAssignEventsRequest,
      eventsV1Category_universal_d_BulkAssignEventsResponse as BulkAssignEventsResponse,
      eventsV1Category_universal_d_BulkAssignEventsAsyncRequest as BulkAssignEventsAsyncRequest,
      eventsV1Category_universal_d_BulkAssignEventsAsyncResponse as BulkAssignEventsAsyncResponse,
      eventsV1Category_universal_d_UnassignEventsRequest as UnassignEventsRequest,
      eventsV1Category_universal_d_UnassignEventsResponse as UnassignEventsResponse,
      eventsV1Category_universal_d_BulkUnassignEventsRequest as BulkUnassignEventsRequest,
      eventsV1Category_universal_d_BulkUnassignEventsResponse as BulkUnassignEventsResponse,
      eventsV1Category_universal_d_BulkUnassignEventsAsyncRequest as BulkUnassignEventsAsyncRequest,
      eventsV1Category_universal_d_BulkUnassignEventsAsyncResponse as BulkUnassignEventsAsyncResponse,
      eventsV1Category_universal_d_ListEventCategoriesRequest as ListEventCategoriesRequest,
      eventsV1Category_universal_d_ListEventCategoriesResponse as ListEventCategoriesResponse,
      eventsV1Category_universal_d_ReorderCategoryEventsRequest as ReorderCategoryEventsRequest,
      eventsV1Category_universal_d_ReorderCategoryEventsRequestReferenceEventOneOf as ReorderCategoryEventsRequestReferenceEventOneOf,
      eventsV1Category_universal_d_ReorderCategoryEventsResponse as ReorderCategoryEventsResponse,
      DomainEvent$6 as DomainEvent,
      DomainEventBodyOneOf$6 as DomainEventBodyOneOf,
      EntityCreatedEvent$6 as EntityCreatedEvent,
      RestoreInfo$6 as RestoreInfo,
      EntityUpdatedEvent$6 as EntityUpdatedEvent,
      EntityDeletedEvent$6 as EntityDeletedEvent,
      ActionEvent$6 as ActionEvent,
      MessageEnvelope$a as MessageEnvelope,
      IdentificationData$a as IdentificationData,
      IdentificationDataIdOneOf$a as IdentificationDataIdOneOf,
      WebhookIdentityType$a as WebhookIdentityType,
      eventsV1Category_universal_d_createCategory as createCategory,
      eventsV1Category_universal_d_bulkCreateCategory as bulkCreateCategory,
      eventsV1Category_universal_d_updateCategory as updateCategory,
      eventsV1Category_universal_d_UpdateCategory as UpdateCategory,
      eventsV1Category_universal_d_deleteCategory as deleteCategory,
      eventsV1Category_universal_d_queryCategories as queryCategories,
      eventsV1Category_universal_d_QueryCategoriesOptions as QueryCategoriesOptions,
      eventsV1Category_universal_d_CategoriesQueryResult as CategoriesQueryResult,
      eventsV1Category_universal_d_CategoriesQueryBuilder as CategoriesQueryBuilder,
      eventsV1Category_universal_d_assignEvents as assignEvents,
      eventsV1Category_universal_d_bulkAssignEvents as bulkAssignEvents,
      eventsV1Category_universal_d_BulkAssignEventsOptions as BulkAssignEventsOptions,
      eventsV1Category_universal_d_bulkAssignEventsAsync as bulkAssignEventsAsync,
      eventsV1Category_universal_d_BulkAssignEventsAsyncOptions as BulkAssignEventsAsyncOptions,
      eventsV1Category_universal_d_unassignEvents as unassignEvents,
      eventsV1Category_universal_d_bulkUnassignEvents as bulkUnassignEvents,
      eventsV1Category_universal_d_BulkUnassignEventsOptions as BulkUnassignEventsOptions,
      eventsV1Category_universal_d_bulkUnassignEventsAsync as bulkUnassignEventsAsync,
      eventsV1Category_universal_d_BulkUnassignEventsAsyncOptions as BulkUnassignEventsAsyncOptions,
      eventsV1Category_universal_d_listEventCategories as listEventCategories,
      eventsV1Category_universal_d_reorderCategoryEvents as reorderCategoryEvents,
      eventsV1Category_universal_d_ReorderCategoryEventsOptions as ReorderCategoryEventsOptions,
    };
  }
  
  /**
   * The form defines which elements are rendered in the Wix UI during the registration process (RSVP or checkout).
   * It also contains customizable messages and labels.
   *
   *
   * A form is an ordered list of controls (blocks), which accept guest information into a field input.
   *
   * Each control contains one or more nested inputs. For example, `Name` control has two inputs:
   * - First Name
   * - Last Name
   *
   * By default, name and email controls are always required and are pinned to the top of the form.
   */
  interface Form$3 {
      /** Nested fields as an ordered list. */
      controls?: InputControl$3[];
      /** Set of configured form messages. */
      messages?: FormMessages$3;
  }
  /**
   * A block of nested fields.
   * Used to aggregate similar inputs like First Name and Last Name.
   */
  interface InputControl$3 {
      /**
       * Field control type. Possible values:
       * - `INPUT`: Single text value field.
       * - `TEXTAREA`: Single text value field with multiple lines.
       * - `DROPDOWN`: Single-choice field with predefined values.
       * - `RADIO`: Single-choice field with predefined values.
       * - `CHECKBOX`: Multiple-choice field with predefined values.
       * - `NAME`: Fields for entering first and last names.
       * - `GUEST_CONTROL`: Fields for additional guests and their respective names.
       * - `ADDRESS_SHORT`: Single-line address field.
       * - `ADDRESS_FULL`: Full address field with multiple lines.
       * - `DATE`: Fields for entering year, month, and day.
       */
      type?: InputControlType$3;
      /**
       * Whether the control is mandatory (such as `name` & `email`).
       * When `true`, only the label can be changed.
       */
      system?: boolean;
      /**
       * Deprecated: Use `id`.
       * @deprecated
       */
      name?: string;
      /** Child inputs. */
      inputs?: Input$3[];
      /**
       * Deprecated: use `inputs.label`.
       * @deprecated
       */
      label?: string;
      /** Field controls are sorted by this value in ascending order. */
      orderIndex?: number;
      /** Unique control ID. */
      _id?: string;
      /**
       * Whether input control is deleted.
       * @readonly
       */
      deleted?: boolean | null;
  }
  enum InputControlType$3 {
      /** Single text value field. */
      INPUT = "INPUT",
      /** Single text value field. */
      TEXTAREA = "TEXTAREA",
      /** Single-choice field of predefined values. */
      DROPDOWN = "DROPDOWN",
      /** Single-choice field of predefined values. */
      RADIO = "RADIO",
      /** Multiple-choice field of predefined values. */
      CHECKBOX = "CHECKBOX",
      /** First and last name fields. */
      NAME = "NAME",
      /** Additional guests and respective guest names fields. */
      GUEST_CONTROL = "GUEST_CONTROL",
      /** Single-line address field. */
      ADDRESS_SHORT = "ADDRESS_SHORT",
      /** Full address field. */
      ADDRESS_FULL = "ADDRESS_FULL",
      /** Year, month and day fields. */
      DATE = "DATE"
  }
  /** An input of one or multiple text values */
  interface Input$3 {
      /** Field name. */
      name?: string;
      /**
       * Deprecated: use `ValueType.TEXT_ARRAY`.
       * @deprecated
       */
      array?: boolean;
      /** Main field label */
      label?: string;
      /** Additional labels for multi-valued fields such as address. */
      additionalLabels?: Record<string, string>;
      /** Predefined choice options for fields, such as dropdown. */
      options?: string[];
      /** Whether field is mandatory. */
      mandatory?: boolean;
      /** Maximum number of accepted characters (relevant for text fields). */
      maxLength?: number;
      /**
       * Type which determines field format.
       * Used to validate submitted response.
       */
      type?: ValueType$3;
      /**
       * The maximum number of accepted values for array input.
       * **Note:** Only applicable for `TEXT_ARRAY` input fields.
       */
      maxSize?: number | null;
      /**
       * Preselected option.
       * Currently only applicable for dropdown.
       */
      defaultOptionSelection?: OptionSelection$3;
      /**
       * Additional labels for multi-valued fields such as address.
       * @readonly
       */
      labels?: Label$3[];
  }
  enum ValueType$3 {
      TEXT = "TEXT",
      NUMBER = "NUMBER",
      TEXT_ARRAY = "TEXT_ARRAY",
      DATE_TIME = "DATE_TIME",
      ADDRESS = "ADDRESS"
  }
  /**
   * Describes initially selected option when an input has multiple choices.
   * Defaults to first (0th) option if not configured.
   */
  interface OptionSelection$3 extends OptionSelectionSelectedOptionOneOf$3 {
      /** 0-based index from predefined `input.options` which is selected initially. */
      optionIndex?: number;
      /**
       * Placeholder hint describing expected choices (such as "Please select").
       * Considered an empty choice.
       */
      placeholderText?: string;
  }
  /** @oneof */
  interface OptionSelectionSelectedOptionOneOf$3 {
      /** 0-based index from predefined `input.options` which is selected initially. */
      optionIndex?: number;
      /**
       * Placeholder hint describing expected choices (such as "Please select").
       * Considered an empty choice.
       */
      placeholderText?: string;
  }
  interface Label$3 {
      /** Field name. */
      name?: string;
      /** Field label. */
      label?: string;
  }
  /**
   * Defines form messages shown in UI before, during, and after registration flow.
   * It enables configuration of form titles, response labels, "thank you" messages, and call-to-action texts.
   */
  interface FormMessages$3 {
      /** RSVP form messages. */
      rsvp?: RsvpFormMessages$3;
      /** Checkout form messages. */
      checkout?: CheckoutFormMessages$3;
      /** Messages shown when event registration is closed. */
      registrationClosed?: RegistrationClosedMessages$3;
      /** Messages shown when event tickets are unavailable. */
      ticketsUnavailable?: TicketsUnavailableMessages$3;
  }
  interface RsvpFormMessages$3 {
      /** Label text indicating RSVP `YES` response. */
      rsvpYesOption?: string;
      /** Label text indicating RSVP `NO` response. */
      rsvpNoOption?: string;
      /** Messages shown for RSVP = `YES`. */
      positiveMessages?: Positive$3;
      /** Messages shown for RSVP = `WAITING` (when event is full and waitlist is available). */
      waitlistMessages?: Positive$3;
      /** Messages shown for RSVP = `NO`. */
      negativeMessages?: Negative$3;
      /** "Submit form" call-to-action label text. */
      submitActionLabel?: string;
  }
  /** Confirmation messages shown after registration. */
  interface PositiveResponseConfirmation$3 {
      /** Confirmation message title. */
      title?: string;
      /** Confirmation message text. */
      message?: string;
      /** "Add to calendar" call-to-action label text. */
      addToCalendarActionLabel?: string;
      /** "Share event" call-to-action label text. */
      shareActionLabel?: string;
  }
  /** Confirmation messages shown after registration. */
  interface NegativeResponseConfirmation$3 {
      /** Confirmation message title. */
      title?: string;
      /** "Share event" call-to-action label text. */
      shareActionLabel?: string;
  }
  /** Set of messages shown during registration when RSVP response is positive. */
  interface Positive$3 {
      /** Main form title for positive response. */
      title?: string;
      /** Confirmation messages shown after registration. */
      confirmation?: PositiveResponseConfirmation$3;
  }
  /** A set of messages shown during registration with negative response */
  interface Negative$3 {
      /** Main form title for negative response. */
      title?: string;
      /** Confirmation messages shown after registration. */
      confirmation?: NegativeResponseConfirmation$3;
  }
  interface CheckoutFormMessages$3 {
      /** Main form title for response. */
      title?: string;
      /** Submit form call-to-action label text. */
      submitActionLabel?: string;
      /** Confirmation messages shown after checkout. */
      confirmation?: ResponseConfirmation$3;
  }
  /** Confirmation messages shown after checkout. */
  interface ResponseConfirmation$3 {
      /** Confirmation message title. */
      title?: string;
      /** Confirmation message text. */
      message?: string;
      /** "Download tickets" call-to-action label text. */
      downloadTicketsLabel?: string;
      /** "Add to calendar" call-to-action label text. */
      addToCalendarLabel?: string;
      /** "Share event" call-to-action label text. */
      shareEventLabel?: string;
  }
  interface RegistrationClosedMessages$3 {
      /** Message shown when event registration is closed. */
      message?: string;
      /** "Explore other events" call-to-action label text. */
      exploreEventsActionLabel?: string;
  }
  interface TicketsUnavailableMessages$3 {
      /** Message shown when event tickets are unavailable. */
      message?: string;
      /** "Explore other events" call-to-action label text. */
      exploreEventsActionLabel?: string;
  }
  interface FormInputControlAdded {
      /** Event ID to which the form belongs. */
      eventId?: string;
      /** Input control. */
      inputControl?: InputControl$3;
  }
  interface FormInputControlUpdated {
      /** Event ID to which the form belongs. */
      eventId?: string;
      /** Input control. */
      updatedInputControl?: InputControl$3;
  }
  interface FormInputControlDeleted {
      /** Event ID to which the form belongs. */
      eventId?: string;
      /** Input control. */
      deletedInputControl?: InputControl$3;
  }
  interface GetFormRequest {
      /** Event ID to which the form belongs. */
      eventId: string;
      /**
       * Whether to return additional data with the response.
       * @internal
       */
      fields?: RequestedFields$2[];
  }
  enum RequestedFields$2 {
      UNKNOWN_REQUESTED_FIELD = "UNKNOWN_REQUESTED_FIELD",
      /** Include soft deleted input controls in the response. */
      DELETED = "DELETED"
  }
  interface GetFormResponse {
      /**
       * Currently published event form.
       * Published form is visible to site visitors.
       */
      form?: Form$3;
      /**
       * Draft event form.
       * Not available to visitors unless published.
       */
      draftForm?: Form$3;
  }
  interface AddControlRequest extends AddControlRequestControlOneOf {
      /** Phone number input control. */
      phone?: PhoneControl;
      /** Single-line or full address input control. */
      address?: AddressControl;
      /** Day, month, year date input control. */
      date?: DateControl;
      /** Additional guests input control. */
      additionalGuests?: AdditionalGuestsControl;
      /** Single-choice dropdown style input control. */
      dropdown?: DropdownControl;
      /**
       * Deprecated. Use radioButton.
       * @internal
       * @deprecated
       */
      radio?: RadioButtonControl;
      /** Multiple-choice checkbox style input control. */
      checkbox?: CheckboxControl;
      /** Free-form text input control. */
      text?: TextControl;
      /** Single-choice radio button style input control. */
      radioButton?: RadioButtonControl;
      /** Event ID to which the form belongs. */
      eventId: string;
  }
  /** @oneof */
  interface AddControlRequestControlOneOf {
      /** Phone number input control. */
      phone?: PhoneControl;
      /** Single-line or full address input control. */
      address?: AddressControl;
      /** Day, month, year date input control. */
      date?: DateControl;
      /** Additional guests input control. */
      additionalGuests?: AdditionalGuestsControl;
      /** Single-choice dropdown style input control. */
      dropdown?: DropdownControl;
      /**
       * Deprecated. Use radioButton.
       * @internal
       * @deprecated
       */
      radio?: RadioButtonControl;
      /** Multiple-choice checkbox style input control. */
      checkbox?: CheckboxControl;
      /** Free-form text input control. */
      text?: TextControl;
      /** Single-choice radio button style input control. */
      radioButton?: RadioButtonControl;
  }
  interface PhoneControl {
      /** Phone input label. */
      label?: string;
      /** Whether phone input is required. */
      mandatory?: boolean;
  }
  interface AddressControl {
      /** Address control labels for each input. */
      labels?: AddressControlLabels;
      /** Whether address is multi-line (consisting of multiple fields such as country, city, postal code). When false, address is single-line. */
      full?: boolean;
      /** Whether address input is required. */
      mandatory?: boolean;
  }
  interface AddressControlLabels {
      /** Single-line address input label. */
      addressLine?: string;
      /** Country input label. */
      country?: string;
      /** Subdivision input label. */
      subdivision?: string;
      /** City input label. */
      city?: string;
      /** Postal code input label. */
      postalCode?: string;
      /** Street address input label. */
      streetAddress?: string;
  }
  interface DateControl {
      /** Input control label. */
      label?: string;
      /** Whether date input is required */
      mandatory?: boolean;
  }
  interface AdditionalGuestsControl {
      /** Additional guests control labels for each input. */
      labels?: Labels;
      /** Whether individual guest names are required. */
      namesMandatory?: boolean;
      /** Maximum number of additional guests. */
      maxGuests?: number;
  }
  interface Labels {
      /** Input label for a single guest. */
      single?: string;
      /** Input label for multiple guests. */
      multiple?: string;
  }
  interface DropdownControl {
      /** Input control label. */
      label?: string;
      /** Predefined options guests can choose from. */
      options?: string[];
      /** Whether choice is required. */
      mandatory?: boolean;
      /** Preselected option. */
      defaultOptionSelection?: OptionSelection$3;
  }
  interface RadioButtonControl {
      /** Input control label. */
      label?: string;
      /** Predefined options guests can choose from. */
      options?: string[];
  }
  interface CheckboxControl {
      /** Input control label. */
      label?: string;
      /** Whether at least one checkbox is required. */
      mandatory?: boolean;
      /** Predefined options guests can choose from. */
      options?: string[];
  }
  interface TextControl {
      /** Input control label. */
      label?: string;
      /** Whether text input is required. */
      mandatory?: boolean;
      /** Maximum number of characters allowed. */
      maxLength?: number;
      /** Whether input control should allow multiple lines in text. */
      multiLine?: boolean;
      /** Whether input control should be displayed as a comment. */
      comment?: boolean;
  }
  interface AddControlResponse {
      /** Generated unique input control ID. */
      _id?: string;
      /** Modified draft event form. */
      form?: Form$3;
  }
  interface UpdateControlRequest extends UpdateControlRequestControlOneOf {
      /** Phone number input control. */
      phone?: PhoneControl;
      /** Single-line or full address input control. */
      address?: AddressControl;
      /** Day, month, year date input control. */
      date?: DateControl;
      /** Additional guests input control. */
      additionalGuests?: AdditionalGuestsControl;
      /** Single-choice dropdown style input control. */
      dropdown?: DropdownControl;
      /**
       * Single-choice radio style input control.
       * @internal
       * @deprecated
       */
      radio?: RadioButtonControl;
      /** Multiple-choice checkbox style input control. */
      checkbox?: CheckboxControl;
      /** Free-form text input control. */
      text?: TextControl;
      /** Main guest name input control. */
      name?: NameControl;
      /** Main guest email input control. */
      email?: EmailControl;
      /** Single-choice radio style input control. */
      radioButton?: RadioButtonControl;
      /** Event ID to which the form belongs. */
      eventId: string;
      /** Unique input control ID. */
      _id: string;
      /** Index used to sort input controls in ascending order. */
      orderIndex?: number;
  }
  /** @oneof */
  interface UpdateControlRequestControlOneOf {
      /** Phone number input control. */
      phone?: PhoneControl;
      /** Single-line or full address input control. */
      address?: AddressControl;
      /** Day, month, year date input control. */
      date?: DateControl;
      /** Additional guests input control. */
      additionalGuests?: AdditionalGuestsControl;
      /** Single-choice dropdown style input control. */
      dropdown?: DropdownControl;
      /**
       * Single-choice radio style input control.
       * @internal
       * @deprecated
       */
      radio?: RadioButtonControl;
      /** Multiple-choice checkbox style input control. */
      checkbox?: CheckboxControl;
      /** Free-form text input control. */
      text?: TextControl;
      /** Main guest name input control. */
      name?: NameControl;
      /** Main guest email input control. */
      email?: EmailControl;
      /** Single-choice radio style input control. */
      radioButton?: RadioButtonControl;
  }
  interface NameControl {
      /** Name control labels of each input */
      labels?: NameControlLabels;
  }
  interface NameControlLabels {
      /** First name input label */
      firstName?: string;
      /** Last name input label */
      lastName?: string;
  }
  interface EmailControl {
      /** Email input label. */
      label?: string;
  }
  interface UpdateControlResponse {
      /** Modified draft event form. */
      form?: Form$3;
  }
  interface DeleteControlRequest {
      /** Event ID to which the form belongs. */
      eventId: string;
      /** Unique input control ID. */
      _id: string;
  }
  interface DeleteControlResponse {
      /** Modified draft event form. */
      form?: Form$3;
  }
  interface UpdateMessagesRequest {
      /** Event ID to which the form belongs. */
      eventId: string;
      /**
       * Set of field paths, specifying which parts of this resource to update.
       * When fields are empty, request is interpreted as full update.
       * Behavior follows [google.protobuf.FieldMask](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#google.protobuf.FieldMask) semantics.
       * @internal
       */
      fields?: string[];
      /** Set of configured form messages. */
      messages?: FormMessages$3;
  }
  interface UpdateMessagesResponse {
      /** Modified draft event form. */
      form?: Form$3;
  }
  interface PublishDraftRequest {
      /** Event ID to which the form belongs. */
      eventId: string;
  }
  interface PublishDraftResponse {
      /** Published event form. */
      form?: Form$3;
  }
  interface EventUpdated$2 {
      /** Event update timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Event ID. */
      eventId?: string;
      /** Event location. */
      location?: Location$5;
      /** Event schedule configuration. */
      scheduleConfig?: ScheduleConfig$5;
      /** Event title. */
      title?: string;
      /**
       * Whether schedule configuration was updated.
       * @deprecated
       */
      scheduleConfigUpdated?: boolean;
      /**
       * The set of properties which were updated. For example 'title' or 'location'
       * @internal
       */
      fields?: string[];
      /**
       * Whether event has opened new spots with this update.
       * @internal
       */
      newSpotsOpened?: boolean | null;
      /** Updated event */
      event?: Event$3;
  }
  interface Location$5 {
      /** Location name. */
      name?: string | null;
      /** Location map coordinates. */
      coordinates?: MapCoordinates$5;
      /** Single line address representation. */
      address?: string | null;
      /** Location type. */
      type?: LocationType$5;
      /**
       * Full address derived from formatted single line `address`.
       * When `full_address` is used to create or update the event, deprecated `address` and `coordinates` are ignored.
       * If provided `full_address` has empty `formatted_address` or `coordinates`, it will be auto-completed using Atlas service.
       *
       * Migration notes:
       * - `full_address.formatted_address` is equivalent to `address`.
       * - `full_address.geocode` is equivalent to `coordinates`.
       */
      fullAddress?: Address$8;
      /**
       * Defines event location as TBD (To Be Determined).
       * When event location is not yet defined, `name` is displayed instead of location address.
       * `coordinates`, `address`, `type` and `full_address` are not required when location is TBD.
       */
      tbd?: boolean | null;
  }
  interface MapCoordinates$5 {
      /** Latitude. */
      lat?: number;
      /** Longitude. */
      lng?: number;
  }
  enum LocationType$5 {
      VENUE = "VENUE",
      ONLINE = "ONLINE"
  }
  /** Physical address */
  interface Address$8 extends AddressStreetOneOf$8 {
      /** a break down of the street to number and street name */
      streetAddress?: StreetAddress$8;
      /** Main address line (usually street and number) as free text */
      addressLine1?: string | null;
      /** country code */
      country?: string | null;
      /** subdivision (usually state or region) code according to ISO 3166-2 */
      subdivision?: string | null;
      /** city name */
      city?: string | null;
      /** zip/postal code */
      postalCode?: string | null;
      /** Free text providing more detailed address info. Usually contains Apt, Suite, Floor */
      addressLine2?: string | null;
      /** A string containing the human-readable address of this location */
      formatted?: string | null;
      /** coordinates of the physical address */
      location?: AddressLocation$8;
      /** country full-name */
      countryFullname?: string | null;
      /** multi-level subdivisions from top to bottom */
      subdivisions?: Subdivision$8[];
  }
  /** @oneof */
  interface AddressStreetOneOf$8 {
      /** a break down of the street to number and street name */
      streetAddress?: StreetAddress$8;
      /** Main address line (usually street and number) as free text */
      addressLine?: string | null;
  }
  interface StreetAddress$8 {
      /** street number */
      number?: string;
      /** street name */
      name?: string;
      /**
       * apartment number
       * @internal
       */
      apt?: string;
  }
  interface AddressLocation$8 {
      /** address latitude coordinates */
      latitude?: number | null;
      /** address longitude coordinates */
      longitude?: number | null;
  }
  interface Subdivision$8 {
      /** subdivision short code */
      code?: string;
      /** subdivision full-name */
      name?: string;
      /**
       * subdivision level
       * @internal
       */
      type?: SubdivisionType$8;
      /**
       * free text description of subdivision type
       * @internal
       */
      typeInfo?: string | null;
  }
  enum SubdivisionType$8 {
      UNKNOWN_SUBDIVISION_TYPE = "UNKNOWN_SUBDIVISION_TYPE",
      /** State */
      ADMINISTRATIVE_AREA_LEVEL_1 = "ADMINISTRATIVE_AREA_LEVEL_1",
      /** County */
      ADMINISTRATIVE_AREA_LEVEL_2 = "ADMINISTRATIVE_AREA_LEVEL_2",
      /** City/town */
      ADMINISTRATIVE_AREA_LEVEL_3 = "ADMINISTRATIVE_AREA_LEVEL_3",
      /** Neighborhood/quarter */
      ADMINISTRATIVE_AREA_LEVEL_4 = "ADMINISTRATIVE_AREA_LEVEL_4",
      /** Street/block */
      ADMINISTRATIVE_AREA_LEVEL_5 = "ADMINISTRATIVE_AREA_LEVEL_5",
      /** ADMINISTRATIVE_AREA_LEVEL_0. Indicates the national political entity, and is typically the highest order type returned by the Geocoder. */
      COUNTRY = "COUNTRY"
  }
  interface ScheduleConfig$5 {
      /**
       * Defines event as TBD (To Be Determined) schedule.
       * When event time is not yet defined, TBD message is displayed instead of event start and end times.
       * `startDate`, `endDate` and `timeZoneId` are not required when schedule is TBD.
       */
      scheduleTbd?: boolean;
      /** TBD message. */
      scheduleTbdMessage?: string | null;
      /** Event start timestamp. */
      startDate?: Date | null;
      /** Event end timestamp. */
      endDate?: Date | null;
      /** Event time zone ID in TZ database format, e.g., `EST`, `America/Los_Angeles`. */
      timeZoneId?: string | null;
      /** Whether end date is hidden in the formatted schedule. */
      endDateHidden?: boolean;
      /** Whether time zone is displayed in formatted schedule. */
      showTimeZone?: boolean;
      /** Event recurrences. */
      recurrences?: Recurrences$5;
  }
  interface Recurrences$5 {
      /** Event occurrences. */
      occurrences?: Occurrence$5[];
      /**
       * Recurring event category ID.
       * @readonly
       */
      categoryId?: string | null;
      /**
       * Recurrence status.
       * @readonly
       */
      status?: Status$5;
  }
  interface Occurrence$5 {
      /** Event start timestamp. */
      startDate?: Date | null;
      /** Event end timestamp. */
      endDate?: Date | null;
      /** Event time zone ID in TZ database format, e.g., `EST`, `America/Los_Angeles`. */
      timeZoneId?: string | null;
      /** Whether time zone is displayed in formatted schedule. */
      showTimeZone?: boolean;
  }
  enum Status$5 {
      /** Event occurs only once. */
      ONE_TIME = "ONE_TIME",
      /** Event is recurring. */
      RECURRING = "RECURRING",
      /** Marks the next upcoming occurrence of the recurring event. */
      RECURRING_NEXT = "RECURRING_NEXT",
      /** Marks the most recent ended occurrence of the recurring event. */
      RECURRING_LAST_ENDED = "RECURRING_LAST_ENDED",
      /** Marks the most recent canceled occurrence of the recurring event. */
      RECURRING_LAST_CANCELED = "RECURRING_LAST_CANCELED"
  }
  interface Event$3 {
      /**
       * Event ID.
       * @readonly
       */
      _id?: string;
      /** Event location. */
      location?: Location$5;
      /** Event scheduling. */
      scheduling?: Scheduling$3;
      /** Event title. */
      title?: string;
      /** Event description. */
      description?: string;
      /** Rich-text content displayed in Wix UI - "About Event" section (HTML). */
      about?: string;
      /** Main event image. */
      mainImage?: string;
      /** Event slug URL (generated from event title). */
      slug?: string;
      /** ISO 639-1 language code of the event (used in content translations). */
      language?: string;
      /** Event creation timestamp. */
      created?: Date | null;
      /** Event modified timestamp. */
      modified?: Date | null;
      /** Event status. */
      status?: EventStatus$5;
      /** RSVP or ticketing registration details. */
      registration?: Registration$3;
      /** "Add to calendar" URLs. */
      calendarLinks?: CalendarLinks$5;
      /** Event page URL components. */
      eventPageUrl?: SiteUrl$3;
      /** Event registration form. */
      form?: Form$3;
      /** Event dashboard summary of RSVP / ticket sales. */
      dashboard?: Dashboard$5;
      /** Instance ID of the site where event is hosted. */
      instanceId?: string;
      /** Guest list configuration. */
      guestListConfig?: GuestListConfig$3;
      /** Event creator user ID. */
      userId?: string;
      /** Event discussion feed. For internal use. */
      feed?: Feed$3;
      /** Online conferencing details. */
      onlineConferencing?: OnlineConferencing$3;
      /** SEO settings. */
      seoSettings?: SeoSettings$3;
      /** Assigned contacts label key. */
      assignedContactsLabel?: string | null;
      /** Agenda details. */
      agenda?: Agenda$3;
      /** Categories this event is assigned to. */
      categories?: Category$3[];
      /** Visual settings for event. */
      eventDisplaySettings?: EventDisplaySettings$3;
      /**
       * @internal
       * @readonly
       */
      customizableTickets?: boolean | null;
      /**
       * Labelling related data.
       * @internal
       */
      labellingSettings?: LabellingSettings$3;
  }
  interface Scheduling$3 {
      /** Schedule configuration. */
      config?: ScheduleConfig$5;
      /** Formatted schedule representation. */
      formatted?: string;
      /** Formatted start date of the event (empty for TBD schedules). */
      startDateFormatted?: string;
      /** Formatted start time of the event (empty for TBD schedules). */
      startTimeFormatted?: string;
      /** Formatted end date of the event (empty for TBD schedules or when end date is hidden). */
      endDateFormatted?: string;
      /** Formatted end time of the event (empty for TBD schedules or when end date is hidden). */
      endTimeFormatted?: string;
  }
  enum EventStatus$5 {
      /** Event is public and scheduled to start */
      SCHEDULED = "SCHEDULED",
      /** Event has started */
      STARTED = "STARTED",
      /** Event has ended */
      ENDED = "ENDED",
      /** Event was canceled */
      CANCELED = "CANCELED",
      /** Event is not public and needs to be published */
      DRAFT = "DRAFT"
  }
  interface Registration$3 {
      /** Event type. */
      type?: EventType$3;
      /** Event registration status. */
      status?: RegistrationStatus$3;
      /** RSVP collection details. */
      rsvpCollection?: RsvpCollection$3;
      /** Ticketing details. */
      ticketing?: Ticketing$3;
      /** External registration details. */
      external?: ExternalEvent$3;
      /** Types of users allowed to register. */
      restrictedTo?: VisitorType$3;
      /** Initial event type which was set when creating an event. */
      initialType?: EventType$3;
  }
  enum EventType$3 {
      /** Type not available for this request fieldset */
      NA_EVENT_TYPE = "NA_EVENT_TYPE",
      /** Registration via RSVP */
      RSVP = "RSVP",
      /** Registration via ticket purchase */
      TICKETS = "TICKETS",
      /** External registration */
      EXTERNAL = "EXTERNAL",
      /** Registration not available */
      NO_REGISTRATION = "NO_REGISTRATION"
  }
  enum RegistrationStatus$3 {
      /** Registration status is not applicable */
      NA_REGISTRATION_STATUS = "NA_REGISTRATION_STATUS",
      /** Registration to event is closed */
      CLOSED = "CLOSED",
      /** Registration to event is closed manually */
      CLOSED_MANUALLY = "CLOSED_MANUALLY",
      /** Registration is open via RSVP */
      OPEN_RSVP = "OPEN_RSVP",
      /** Registration to event waitlist is open via RSVP */
      OPEN_RSVP_WAITLIST = "OPEN_RSVP_WAITLIST",
      /** Registration is open via ticket purchase */
      OPEN_TICKETS = "OPEN_TICKETS",
      /** Registration is open via external URL */
      OPEN_EXTERNAL = "OPEN_EXTERNAL",
      /** Registration will be open via RSVP */
      SCHEDULED_RSVP = "SCHEDULED_RSVP"
  }
  interface RsvpCollection$3 {
      /** RSVP collection configuration. */
      config?: RsvpCollectionConfig$3;
  }
  interface RsvpCollectionConfig$3 {
      /** Defines the supported RSVP statuses. */
      rsvpStatusOptions?: RsvpStatusOptions$3;
      /**
       * Total guest limit available to register to the event.
       * Additional guests per RSVP are counted towards total guests.
       */
      limit?: number | null;
      /** Whether a waitlist is opened when total guest limit is reached, allowing guests to create RSVP with WAITING RSVP status. */
      waitlist?: boolean;
      /** Registration start timestamp. */
      startDate?: Date | null;
      /** Registration end timestamp. */
      endDate?: Date | null;
  }
  enum RsvpStatusOptions$3 {
      /** Only YES RSVP status is available for RSVP registration */
      YES_ONLY = "YES_ONLY",
      /** YES and NO RSVP status options are available for the registration */
      YES_AND_NO = "YES_AND_NO"
  }
  interface Ticketing$3 {
      /**
       * Deprecated.
       * @deprecated
       */
      lowestPrice?: string | null;
      /**
       * Deprecated.
       * @deprecated
       */
      highestPrice?: string | null;
      /** Currency used in event transactions. */
      currency?: string | null;
      /** Ticketing configuration. */
      config?: TicketingConfig$3;
      /**
       * Price of lowest priced ticket.
       * @readonly
       */
      lowestTicketPrice?: Money$6;
      /**
       * Price of highest priced ticket.
       * @readonly
       */
      highestTicketPrice?: Money$6;
      /**
       * Formatted price of lowest priced ticket.
       * @readonly
       */
      lowestTicketPriceFormatted?: string | null;
      /**
       * Formatted price of highest priced ticket.
       * @readonly
       */
      highestTicketPriceFormatted?: string | null;
      /**
       * Whether all tickets are sold for this event.
       * @readonly
       */
      soldOut?: boolean | null;
  }
  interface TicketingConfig$3 {
      /** Whether the form must be filled out separately for each ticket. */
      guestAssignedTickets?: boolean;
      /** Tax configuration. */
      taxConfig?: TaxConfig$3;
      /** Limit of tickets that can be purchased per order, default 20. */
      ticketLimitPerOrder?: number;
      /**
       * App Id for external ticket stock management.
       * By default tickets stock is defined in TicketDefinition object.
       * If defined then limitation from TicketDefinition is ignored.
       * @internal
       */
      stockManagerAppId?: string | null;
      /** Duration for which the tickets being bought are reserved. */
      reservationDurationInMinutes?: number | null;
  }
  interface TaxConfig$3 {
      /** Tax application settings. */
      type?: TaxType$4;
      /** Tax name. */
      name?: string | null;
      /** Tax rate (e.g.,`21.55`). */
      rate?: string | null;
      /** Applies taxes for donations, default true. */
      appliesToDonations?: boolean | null;
  }
  enum TaxType$4 {
      /** Tax is included in the ticket price. */
      INCLUDED = "INCLUDED",
      /** Tax is added to the order at the checkout. */
      ADDED = "ADDED",
      /** Tax is added to the final total at the checkout. */
      ADDED_AT_CHECKOUT = "ADDED_AT_CHECKOUT"
  }
  interface Money$6 {
      /**
       * *Deprecated:** Use `value` instead.
       * @deprecated
       */
      amount?: string;
      /** ISO 4217 format of the currency e.g., `USD`. */
      currency?: string;
      /** Monetary amount. Decimal string with a period as a decimal separator (e.g., 3.99). Optionally, starts with a single (-), to indicate that the amount is negative. */
      value?: string | null;
  }
  interface ExternalEvent$3 {
      /** External event registration URL. */
      registration?: string;
  }
  enum VisitorType$3 {
      /** Site visitor (including member) */
      VISITOR = "VISITOR",
      /** Site member */
      MEMBER = "MEMBER",
      /** Site visitor or member */
      VISITOR_OR_MEMBER = "VISITOR_OR_MEMBER"
  }
  interface CalendarLinks$5 {
      /** "Add to Google calendar" URL. */
      google?: string;
      /** "Download ICS calendar file" URL. */
      ics?: string;
  }
  /** Site URL components */
  interface SiteUrl$3 {
      /**
       * Base URL. For premium sites, this will be the domain.
       * For free sites, this would be site URL (e.g `mysite.wixsite.com/mysite`)
       */
      base?: string;
      /** The path to that page - e.g `/my-events/weekly-meetup-2` */
      path?: string;
  }
  interface Dashboard$5 {
      /** Guest RSVP summary. */
      rsvpSummary?: RsvpSummary$4;
      /**
       * Summary of revenue and tickets sold.
       * (Archived orders are not included).
       */
      ticketingSummary?: TicketingSummary$3;
  }
  interface RsvpSummary$4 {
      /** Total number of RSVPs. */
      total?: number;
      /** Number of RSVPs with status `YES`. */
      yes?: number;
      /** Number of RSVPs with status `NO`. */
      no?: number;
      /** Number of RSVPs in waitlist. */
      waitlist?: number;
  }
  interface TicketingSummary$3 {
      /** Number of tickets sold. */
      tickets?: number;
      /**
       * Total revenue, excluding fees.
       * (taxes and payment provider fees are not deducted.)
       */
      revenue?: Money$6;
      /** Whether currency is locked and cannot be changed (generally occurs after the first order in the specified currency has been created). */
      currencyLocked?: boolean;
      /** Number of orders placed. */
      orders?: number;
      /** Total balance of confirmed transactions. */
      totalSales?: Money$6;
  }
  interface GuestListConfig$3 {
      /** Whether members can see other members attending the event (defaults to true). */
      publicGuestList?: boolean;
  }
  interface Feed$3 {
      /** Event discussion feed token. */
      token?: string;
  }
  interface OnlineConferencing$3 {
      config?: OnlineConferencingConfig$3;
      session?: OnlineConferencingSession$3;
      /**
       * Configured conferencing provider name.
       * @internal
       * @readonly
       */
      providerName?: string;
  }
  interface OnlineConferencingConfig$3 {
      /**
       * Whether online conferencing is enabled (not supported for TBD schedules).
       * When enabled, links to join conferencing are generated and provided to guests.
       */
      enabled?: boolean;
      /** Conferencing provider ID. */
      providerId?: string | null;
      /** Conference type */
      conferenceType?: ConferenceType$3;
  }
  enum ConferenceType$3 {
      /** Everyone in the meeting can publish and subscribe video and audio. */
      MEETING = "MEETING",
      /** Guests can only subscribe to video and audio. */
      WEBINAR = "WEBINAR"
  }
  interface OnlineConferencingSession$3 {
      /**
       * Link for event host to start the online conference session.
       * @readonly
       */
      hostLink?: string;
      /**
       * Link for guests to join the online conference session.
       * @readonly
       */
      guestLink?: string;
      /**
       * The password required to join online conferencing session (when relevant).
       * @readonly
       */
      password?: string | null;
      /**
       * Indicates that session was created successfully on providers side.
       * @readonly
       */
      sessionCreated?: boolean | null;
      /**
       * Unique session id
       * @readonly
       */
      sessionId?: string | null;
  }
  interface SeoSettings$3 {
      /** URL slug */
      slug?: string;
      /** Advanced SEO data */
      advancedSeoData?: SeoSchema$3;
      /**
       * Hidden from SEO Site Map
       * @readonly
       */
      hidden?: boolean | null;
  }
  /**
   * The SEO schema object contains data about different types of meta tags. It makes sure that the information about your page is presented properly to search engines.
   * The search engines use this information for ranking purposes, or to display snippets in the search results.
   * This data will override other sources of tags (for example patterns) and will be included in the <head> section of the HTML document, while not being displayed on the page itself.
   */
  interface SeoSchema$3 {
      /** SEO tag information. */
      tags?: Tag$3[];
      /** SEO general settings. */
      settings?: Settings$4;
  }
  interface Keyword$3 {
      /** Keyword value. */
      term?: string;
      /** Whether the keyword is the main focus keyword. */
      isMain?: boolean;
      /** The source that added the keyword terms to the SEO settings. */
      origin?: string | null;
  }
  interface Tag$3 {
      /**
       * SEO tag type.
       *
       *
       * Supported values: `title`, `meta`, `script`, `link`.
       */
      type?: string;
      /**
       * A `{"key": "value"}` pair object where each SEO tag property (`"name"`, `"content"`, `"rel"`, `"href"`) contains a value.
       * For example: `{"name": "description", "content": "the description itself"}`.
       */
      props?: Record<string, any> | null;
      /** SEO tag meta data. For example, `{"height": 300, "width": 240}`. */
      meta?: Record<string, any> | null;
      /** SEO tag inner content. For example, `<title> inner content </title>`. */
      children?: string;
      /** Whether the tag is a custom tag. */
      custom?: boolean;
      /** Whether the tag is disabled. */
      disabled?: boolean;
  }
  interface Settings$4 {
      /**
       * Whether the Auto Redirect feature, which creates `301 redirects` on a slug change, is enabled.
       *
       *
       * Default: `false` (Auto Redirect is enabled.)
       */
      preventAutoRedirect?: boolean;
      /** User-selected keyword terms for a specific page. */
      keywords?: Keyword$3[];
  }
  interface Agenda$3 {
      /** Whether the schedule is enabled for the event. */
      enabled?: boolean;
      /**
       * Agenda page URL.
       * @readonly
       */
      pageUrl?: SiteUrl$3;
  }
  interface Category$3 {
      /**
       * Category ID.
       * @readonly
       */
      _id?: string;
      /** Category name. */
      name?: string;
      /**
       * Date and time when category was created.
       * @readonly
       */
      _createdDate?: Date | null;
      /**
       * Assigned events count. Deleted events are excluded.
       * @internal
       * @readonly
       * @deprecated
       */
      assignedEventsCount?: number | null;
      /**
       * The total number of draft and published events assigned to the category.
       * @readonly
       */
      counts?: CategoryCounts$3;
      /**
       * Category state. Possible values:
       *
       * `MANUAL`: Category is created manually by the user.
       * `AUTO`: Category is created automatically.
       * `RECURRING_EVENT`: Category is created automatically when publishing recurring events.
       * `HIDDEN`: Category can't be seen.
       *
       * Default: `MANUAL`.
       *
       * **Note:** The WIX_EVENTS.MANAGE_AUTO_CATEGORIES permission scope is required to use states other than `MANUAL`.
       */
      states?: State$6[];
      /**
       * Optionally client defined external ID.
       * @internal
       */
      externalId?: string | null;
  }
  interface CategoryCounts$3 {
      /** Total number of draft events assigned to the category. */
      assignedEventsCount?: number | null;
      /** Total number of published events assigned to the category. Deleted events are excluded. */
      assignedDraftEventsCount?: number | null;
  }
  enum State$6 {
      /** Created manually by the user. */
      MANUAL = "MANUAL",
      /** Created automatically. */
      AUTO = "AUTO",
      /** Created when publishing recurring events. */
      RECURRING_EVENT = "RECURRING_EVENT",
      /** Category is hidden. */
      HIDDEN = "HIDDEN",
      /** Category is used to store component events. */
      COMPONENT = "COMPONENT"
  }
  interface EventDisplaySettings$3 {
      /** Whether event details button is hidden. Only available for events with no registration. */
      hideEventDetailsButton?: boolean | null;
      /** Disables event details page visibility. If event has an external registration configured visitors will be redirected from this page. */
      hideEventDetailsPage?: boolean | null;
  }
  interface LabellingSettings$3 {
      /**
       * @internal
       * @readonly
       */
      assignedContactsLegacyLabelId?: string | null;
      /**
       * @internal
       * @readonly
       */
      assignedContactsLabelDeleted?: boolean | null;
  }
  interface DiscardDraftRequest {
      /** Event ID to which the form belongs. */
      eventId: string;
  }
  interface DiscardDraftResponse {
  }
  interface DomainEvent$5 extends DomainEventBodyOneOf$5 {
      createdEvent?: EntityCreatedEvent$5;
      updatedEvent?: EntityUpdatedEvent$5;
      deletedEvent?: EntityDeletedEvent$5;
      actionEvent?: ActionEvent$5;
      /**
       * Unique event ID.
       * Allows clients to ignore duplicate webhooks.
       */
      _id?: string;
      /**
       * Assumes actions are also always typed to an entity_type
       * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
       */
      entityFqdn?: string;
      /**
       * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
       * This is although the created/updated/deleted notion is duplication of the oneof types
       * Example: created/updated/deleted/started/completed/email_opened
       */
      slug?: string;
      /** ID of the entity associated with the event. */
      entityId?: string;
      /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
      eventTime?: Date | null;
      /**
       * Whether the event was triggered as a result of a privacy regulation application
       * (for example, GDPR).
       */
      triggeredByAnonymizeRequest?: boolean | null;
      /** If present, indicates the action that triggered the event. */
      originatedFrom?: string | null;
      /**
       * A sequence number defining the order of updates to the underlying entity.
       * For example, given that some entity was updated at 16:00 and than again at 16:01,
       * it is guaranteed that the sequence number of the second update is strictly higher than the first.
       * As the consumer, you can use this value to ensure that you handle messages in the correct order.
       * To do so, you will need to persist this number on your end, and compare the sequence number from the
       * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
       */
      entityEventSequence?: string | null;
  }
  /** @oneof */
  interface DomainEventBodyOneOf$5 {
      createdEvent?: EntityCreatedEvent$5;
      updatedEvent?: EntityUpdatedEvent$5;
      deletedEvent?: EntityDeletedEvent$5;
      actionEvent?: ActionEvent$5;
  }
  interface EntityCreatedEvent$5 {
      entityAsJson?: string;
      /**
       * Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity
       * @internal
       */
      triggeredByUndelete?: boolean | null;
      /** Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity */
      restoreInfo?: RestoreInfo$5;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface RestoreInfo$5 {
      deletedDate?: Date | null;
  }
  interface EntityUpdatedEvent$5 {
      /**
       * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
       * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
       * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
       */
      currentEntityAsJson?: string;
      /**
       * This field is currently part of the of the EntityUpdatedEvent msg, but scala/node libraries which implements the domain events standard
       * wont populate it / have any reference to it in the API.
       * The main reason for it is that fetching the old entity from the DB will have a performance hit on an update operation so unless truly needed,
       * the developer should send only the new (current) entity.
       * An additional reason is not wanting to send this additional entity over the wire (kafka) since in some cases it can be really big
       * Developers that must reflect the old entity will have to implement their own domain event sender mechanism which will follow the DomainEvent proto message.
       * @internal
       * @deprecated
       */
      previousEntityAsJson?: string | null;
      /**
       * WIP - This property will hold both names and previous values of the updated fields of the entity.
       * For more details please see [adr](https://docs.google.com/document/d/1PdqsOM20Ph2HAkmx8zvUnzzk3Sekp3BR9h34wSvsRnI/edit#heading=h.phlw87mh2imx) or [issue](https://github.com/wix-private/nile-tracker/issues/363)
       * @internal
       */
      modifiedFields?: Record<string, any>;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface EntityDeletedEvent$5 {
      /**
       * Indicates if the entity is sent to trash-bin. only available when trash-bin is enabled
       * @internal
       */
      movedToTrash?: boolean | null;
      /** Entity that was deleted */
      deletedEntityAsJson?: string | null;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface ActionEvent$5 {
      bodyAsJson?: string;
  }
  interface MessageEnvelope$9 {
      /** App instance ID. */
      instanceId?: string | null;
      /** Event type. */
      eventType?: string;
      /** The identification type and identity data. */
      identity?: IdentificationData$9;
      /** Stringify payload. */
      data?: string;
  }
  interface IdentificationData$9 extends IdentificationDataIdOneOf$9 {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
      /** @readonly */
      identityType?: WebhookIdentityType$9;
  }
  /** @oneof */
  interface IdentificationDataIdOneOf$9 {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
  }
  enum WebhookIdentityType$9 {
      UNKNOWN = "UNKNOWN",
      ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
      MEMBER = "MEMBER",
      WIX_USER = "WIX_USER",
      APP = "APP"
  }
  /**
   * Retrieves an event registration form (both the draft and published versions).
   * @public
   * @requiredField eventId
   * @param eventId - Event ID to which the form belongs.
   * @param options - Optional fields.
   * @permissionId WIX_EVENTS.READ_EVENTS
   * @returns Currently published event form.
   * Published form is visible to site visitors.
   */
  function getForm(eventId: string, options?: GetFormOptions): Promise<Form$3>;
  interface GetFormOptions {
      /**
       * Whether to return additional data with the response.
       * @internal
       */
      fields?: RequestedFields$2[];
  }
  /**
   * Adds an input control to the draft form.
   * @public
   * @requiredField eventId
   * @param eventId - Event ID to which the form belongs.
   * @param options - Optional fields.
   * @permissionId WIX_EVENTS.MANAGE_EVENTS
   * @adminMethod
   */
  function addControl(eventId: string, options?: AddControlOptions): Promise<AddControlResponse>;
  interface AddControlOptions extends AddControlRequestControlOneOf {
      /** Phone number input control. */
      phone?: PhoneControl;
      /** Single-line or full address input control. */
      address?: AddressControl;
      /** Day, month, year date input control. */
      date?: DateControl;
      /** Additional guests input control. */
      additionalGuests?: AdditionalGuestsControl;
      /** Single-choice dropdown style input control. */
      dropdown?: DropdownControl;
      /**
       * Deprecated. Use radioButton.
       * @internal
       * @deprecated
       */
      radio?: RadioButtonControl;
      /** Multiple-choice checkbox style input control. */
      checkbox?: CheckboxControl;
      /** Free-form text input control. */
      text?: TextControl;
      /** Single-choice radio button style input control. */
      radioButton?: RadioButtonControl;
  }
  /**
   * Updates an existing input control in the draft form.
   * @public
   * @requiredField identifiers
   * @requiredField identifiers.eventId
   * @requiredField identifiers.id
   * @param options - Optional fields.
   * @param identifiers - Identifies what form to update.
   * @permissionId WIX_EVENTS.MANAGE_EVENTS
   * @adminMethod
   */
  function updateControl(identifiers: UpdateControlIdentifiers, options?: UpdateControlOptions): Promise<UpdateControlResponse>;
  interface UpdateControlIdentifiers extends UpdateControlRequestControlOneOf {
      /** Event ID to which the form belongs. */
      eventId: string;
      /** Unique input control ID. */
      _id: string;
  }
  interface UpdateControlOptions extends UpdateControlRequestControlOneOf {
      /** Index used to sort input controls in ascending order. */
      orderIndex?: number;
      /** Phone number input control. */
      phone?: PhoneControl;
      /** Single-line or full address input control. */
      address?: AddressControl;
      /** Day, month, year date input control. */
      date?: DateControl;
      /** Additional guests input control. */
      additionalGuests?: AdditionalGuestsControl;
      /** Single-choice dropdown style input control. */
      dropdown?: DropdownControl;
      /**
       * Single-choice radio style input control.
       * @internal
       * @deprecated
       */
      radio?: RadioButtonControl;
      /** Multiple-choice checkbox style input control. */
      checkbox?: CheckboxControl;
      /** Free-form text input control. */
      text?: TextControl;
      /** Main guest name input control. */
      name?: NameControl;
      /** Main guest email input control. */
      email?: EmailControl;
      /** Single-choice radio style input control. */
      radioButton?: RadioButtonControl;
  }
  /**
   * Deletes an input control from the draft form.
   * @public
   * @requiredField identifiers
   * @requiredField identifiers.eventId
   * @requiredField identifiers.id
   * @param identifiers - Identifies what form to delete.
   * @permissionId WIX_EVENTS.MANAGE_EVENTS
   * @adminMethod
   */
  function deleteControl(identifiers: DeleteControlIdentifiers): Promise<DeleteControlResponse>;
  interface DeleteControlIdentifiers {
      /** Event ID to which the form belongs. */
      eventId: string;
      /** Unique input control ID. */
      _id: string;
  }
  /**
   * Updates draft form messages, as displayed in the Wix UI before, during, and after the registration flow.
   * Configurable messages include form titles, response labels, "thank you" messages, and call-to-action texts.
   * @public
   * @requiredField eventId
   * @param eventId - Event ID to which the form belongs.
   * @param options - Optional fields.
   * @permissionId WIX_EVENTS.MANAGE_EVENTS
   * @adminMethod
   */
  function updateMessages(eventId: string, options?: UpdateMessagesOptions): Promise<UpdateMessagesResponse>;
  interface UpdateMessagesOptions {
      /**
       * Set of field paths, specifying which parts of this resource to update.
       * When fields are empty, request is interpreted as full update.
       * Behavior follows [google.protobuf.FieldMask](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#google.protobuf.FieldMask) semantics.
       * @internal
       */
      fields?: string[];
      /** Set of configured form messages. */
      messages?: FormMessages$3;
  }
  /**
   * Publishes the draft form.
   * @public
   * @requiredField eventId
   * @param eventId - Event ID to which the form belongs.
   * @permissionId WIX_EVENTS.MANAGE_EVENTS
   * @adminMethod
   */
  function publishDraft(eventId: string): Promise<PublishDraftResponse>;
  /**
   * Clears all changes to the draft form.
   * @public
   * @requiredField eventId
   * @param eventId - Event ID to which the form belongs.
   * @permissionId WIX_EVENTS.MANAGE_EVENTS
   * @adminMethod
   */
  function discardDraft(eventId: string): Promise<void>;
  
  type eventsV1Form_universal_d_FormInputControlAdded = FormInputControlAdded;
  type eventsV1Form_universal_d_FormInputControlUpdated = FormInputControlUpdated;
  type eventsV1Form_universal_d_FormInputControlDeleted = FormInputControlDeleted;
  type eventsV1Form_universal_d_GetFormRequest = GetFormRequest;
  type eventsV1Form_universal_d_GetFormResponse = GetFormResponse;
  type eventsV1Form_universal_d_AddControlRequest = AddControlRequest;
  type eventsV1Form_universal_d_AddControlRequestControlOneOf = AddControlRequestControlOneOf;
  type eventsV1Form_universal_d_PhoneControl = PhoneControl;
  type eventsV1Form_universal_d_AddressControl = AddressControl;
  type eventsV1Form_universal_d_AddressControlLabels = AddressControlLabels;
  type eventsV1Form_universal_d_DateControl = DateControl;
  type eventsV1Form_universal_d_AdditionalGuestsControl = AdditionalGuestsControl;
  type eventsV1Form_universal_d_Labels = Labels;
  type eventsV1Form_universal_d_DropdownControl = DropdownControl;
  type eventsV1Form_universal_d_RadioButtonControl = RadioButtonControl;
  type eventsV1Form_universal_d_CheckboxControl = CheckboxControl;
  type eventsV1Form_universal_d_TextControl = TextControl;
  type eventsV1Form_universal_d_AddControlResponse = AddControlResponse;
  type eventsV1Form_universal_d_UpdateControlRequest = UpdateControlRequest;
  type eventsV1Form_universal_d_UpdateControlRequestControlOneOf = UpdateControlRequestControlOneOf;
  type eventsV1Form_universal_d_NameControl = NameControl;
  type eventsV1Form_universal_d_NameControlLabels = NameControlLabels;
  type eventsV1Form_universal_d_EmailControl = EmailControl;
  type eventsV1Form_universal_d_UpdateControlResponse = UpdateControlResponse;
  type eventsV1Form_universal_d_DeleteControlRequest = DeleteControlRequest;
  type eventsV1Form_universal_d_DeleteControlResponse = DeleteControlResponse;
  type eventsV1Form_universal_d_UpdateMessagesRequest = UpdateMessagesRequest;
  type eventsV1Form_universal_d_UpdateMessagesResponse = UpdateMessagesResponse;
  type eventsV1Form_universal_d_PublishDraftRequest = PublishDraftRequest;
  type eventsV1Form_universal_d_PublishDraftResponse = PublishDraftResponse;
  type eventsV1Form_universal_d_DiscardDraftRequest = DiscardDraftRequest;
  type eventsV1Form_universal_d_DiscardDraftResponse = DiscardDraftResponse;
  const eventsV1Form_universal_d_getForm: typeof getForm;
  type eventsV1Form_universal_d_GetFormOptions = GetFormOptions;
  const eventsV1Form_universal_d_addControl: typeof addControl;
  type eventsV1Form_universal_d_AddControlOptions = AddControlOptions;
  const eventsV1Form_universal_d_updateControl: typeof updateControl;
  type eventsV1Form_universal_d_UpdateControlIdentifiers = UpdateControlIdentifiers;
  type eventsV1Form_universal_d_UpdateControlOptions = UpdateControlOptions;
  const eventsV1Form_universal_d_deleteControl: typeof deleteControl;
  type eventsV1Form_universal_d_DeleteControlIdentifiers = DeleteControlIdentifiers;
  const eventsV1Form_universal_d_updateMessages: typeof updateMessages;
  type eventsV1Form_universal_d_UpdateMessagesOptions = UpdateMessagesOptions;
  const eventsV1Form_universal_d_publishDraft: typeof publishDraft;
  const eventsV1Form_universal_d_discardDraft: typeof discardDraft;
  namespace eventsV1Form_universal_d {
    export {
      Form$3 as Form,
      InputControl$3 as InputControl,
      InputControlType$3 as InputControlType,
      Input$3 as Input,
      ValueType$3 as ValueType,
      OptionSelection$3 as OptionSelection,
      OptionSelectionSelectedOptionOneOf$3 as OptionSelectionSelectedOptionOneOf,
      Label$3 as Label,
      FormMessages$3 as FormMessages,
      RsvpFormMessages$3 as RsvpFormMessages,
      PositiveResponseConfirmation$3 as PositiveResponseConfirmation,
      NegativeResponseConfirmation$3 as NegativeResponseConfirmation,
      Positive$3 as Positive,
      Negative$3 as Negative,
      CheckoutFormMessages$3 as CheckoutFormMessages,
      ResponseConfirmation$3 as ResponseConfirmation,
      RegistrationClosedMessages$3 as RegistrationClosedMessages,
      TicketsUnavailableMessages$3 as TicketsUnavailableMessages,
      eventsV1Form_universal_d_FormInputControlAdded as FormInputControlAdded,
      eventsV1Form_universal_d_FormInputControlUpdated as FormInputControlUpdated,
      eventsV1Form_universal_d_FormInputControlDeleted as FormInputControlDeleted,
      eventsV1Form_universal_d_GetFormRequest as GetFormRequest,
      RequestedFields$2 as RequestedFields,
      eventsV1Form_universal_d_GetFormResponse as GetFormResponse,
      eventsV1Form_universal_d_AddControlRequest as AddControlRequest,
      eventsV1Form_universal_d_AddControlRequestControlOneOf as AddControlRequestControlOneOf,
      eventsV1Form_universal_d_PhoneControl as PhoneControl,
      eventsV1Form_universal_d_AddressControl as AddressControl,
      eventsV1Form_universal_d_AddressControlLabels as AddressControlLabels,
      eventsV1Form_universal_d_DateControl as DateControl,
      eventsV1Form_universal_d_AdditionalGuestsControl as AdditionalGuestsControl,
      eventsV1Form_universal_d_Labels as Labels,
      eventsV1Form_universal_d_DropdownControl as DropdownControl,
      eventsV1Form_universal_d_RadioButtonControl as RadioButtonControl,
      eventsV1Form_universal_d_CheckboxControl as CheckboxControl,
      eventsV1Form_universal_d_TextControl as TextControl,
      eventsV1Form_universal_d_AddControlResponse as AddControlResponse,
      eventsV1Form_universal_d_UpdateControlRequest as UpdateControlRequest,
      eventsV1Form_universal_d_UpdateControlRequestControlOneOf as UpdateControlRequestControlOneOf,
      eventsV1Form_universal_d_NameControl as NameControl,
      eventsV1Form_universal_d_NameControlLabels as NameControlLabels,
      eventsV1Form_universal_d_EmailControl as EmailControl,
      eventsV1Form_universal_d_UpdateControlResponse as UpdateControlResponse,
      eventsV1Form_universal_d_DeleteControlRequest as DeleteControlRequest,
      eventsV1Form_universal_d_DeleteControlResponse as DeleteControlResponse,
      eventsV1Form_universal_d_UpdateMessagesRequest as UpdateMessagesRequest,
      eventsV1Form_universal_d_UpdateMessagesResponse as UpdateMessagesResponse,
      eventsV1Form_universal_d_PublishDraftRequest as PublishDraftRequest,
      eventsV1Form_universal_d_PublishDraftResponse as PublishDraftResponse,
      EventUpdated$2 as EventUpdated,
      Location$5 as Location,
      MapCoordinates$5 as MapCoordinates,
      LocationType$5 as LocationType,
      Address$8 as Address,
      AddressStreetOneOf$8 as AddressStreetOneOf,
      StreetAddress$8 as StreetAddress,
      AddressLocation$8 as AddressLocation,
      Subdivision$8 as Subdivision,
      SubdivisionType$8 as SubdivisionType,
      ScheduleConfig$5 as ScheduleConfig,
      Recurrences$5 as Recurrences,
      Occurrence$5 as Occurrence,
      Status$5 as Status,
      Event$3 as Event,
      Scheduling$3 as Scheduling,
      EventStatus$5 as EventStatus,
      Registration$3 as Registration,
      EventType$3 as EventType,
      RegistrationStatus$3 as RegistrationStatus,
      RsvpCollection$3 as RsvpCollection,
      RsvpCollectionConfig$3 as RsvpCollectionConfig,
      RsvpStatusOptions$3 as RsvpStatusOptions,
      Ticketing$3 as Ticketing,
      TicketingConfig$3 as TicketingConfig,
      TaxConfig$3 as TaxConfig,
      TaxType$4 as TaxType,
      Money$6 as Money,
      ExternalEvent$3 as ExternalEvent,
      VisitorType$3 as VisitorType,
      CalendarLinks$5 as CalendarLinks,
      SiteUrl$3 as SiteUrl,
      Dashboard$5 as Dashboard,
      RsvpSummary$4 as RsvpSummary,
      TicketingSummary$3 as TicketingSummary,
      GuestListConfig$3 as GuestListConfig,
      Feed$3 as Feed,
      OnlineConferencing$3 as OnlineConferencing,
      OnlineConferencingConfig$3 as OnlineConferencingConfig,
      ConferenceType$3 as ConferenceType,
      OnlineConferencingSession$3 as OnlineConferencingSession,
      SeoSettings$3 as SeoSettings,
      SeoSchema$3 as SeoSchema,
      Keyword$3 as Keyword,
      Tag$3 as Tag,
      Settings$4 as Settings,
      Agenda$3 as Agenda,
      Category$3 as Category,
      CategoryCounts$3 as CategoryCounts,
      State$6 as State,
      EventDisplaySettings$3 as EventDisplaySettings,
      LabellingSettings$3 as LabellingSettings,
      eventsV1Form_universal_d_DiscardDraftRequest as DiscardDraftRequest,
      eventsV1Form_universal_d_DiscardDraftResponse as DiscardDraftResponse,
      DomainEvent$5 as DomainEvent,
      DomainEventBodyOneOf$5 as DomainEventBodyOneOf,
      EntityCreatedEvent$5 as EntityCreatedEvent,
      RestoreInfo$5 as RestoreInfo,
      EntityUpdatedEvent$5 as EntityUpdatedEvent,
      EntityDeletedEvent$5 as EntityDeletedEvent,
      ActionEvent$5 as ActionEvent,
      MessageEnvelope$9 as MessageEnvelope,
      IdentificationData$9 as IdentificationData,
      IdentificationDataIdOneOf$9 as IdentificationDataIdOneOf,
      WebhookIdentityType$9 as WebhookIdentityType,
      eventsV1Form_universal_d_getForm as getForm,
      eventsV1Form_universal_d_GetFormOptions as GetFormOptions,
      eventsV1Form_universal_d_addControl as addControl,
      eventsV1Form_universal_d_AddControlOptions as AddControlOptions,
      eventsV1Form_universal_d_updateControl as updateControl,
      eventsV1Form_universal_d_UpdateControlIdentifiers as UpdateControlIdentifiers,
      eventsV1Form_universal_d_UpdateControlOptions as UpdateControlOptions,
      eventsV1Form_universal_d_deleteControl as deleteControl,
      eventsV1Form_universal_d_DeleteControlIdentifiers as DeleteControlIdentifiers,
      eventsV1Form_universal_d_updateMessages as updateMessages,
      eventsV1Form_universal_d_UpdateMessagesOptions as UpdateMessagesOptions,
      eventsV1Form_universal_d_publishDraft as publishDraft,
      eventsV1Form_universal_d_discardDraft as discardDraft,
    };
  }
  
  interface Order {
      /** Unique order number. */
      orderNumber?: string;
      /** Reservation ID. */
      reservationId?: string;
      /**
       * Payment snapshot ID. Empty for the `FREE` order.
       * @readonly
       */
      snapshotId?: string;
      /** Event ID to which the order belongs. */
      eventId?: string;
      /** Contact ID of buyer (resolved using email address). */
      contactId?: string;
      /** Buyer member ID, if applicable. */
      memberId?: string;
      /**
       * RSVP created timestamp.
       * @readonly
       */
      created?: Date | null;
      /** Guest first name. */
      firstName?: string;
      /** Guest last name. */
      lastName?: string;
      /** Guest email. */
      email?: string;
      /** Checkout form response. When each purchased ticket is assigned to a guest, guest forms are returned for each ticket, and buyer info is returned. */
      checkoutForm?: FormResponse$3;
      /** Whether the order is confirmed (triggered once payment gateway processes the payment and funds reach the merchant's account). */
      confirmed?: boolean;
      /**
       * Order status. Possible values:
       * - `FREE`: The order is confirmed, no payment is required.
       * - `PENDING`: The order was paid, but the payment gateway suspended the payment.
       * - `PAID`: The order is paid.
       * - `OFFLINE_PENDING`: The order is confirmed but has to be paid in cash and the status is manually updated to `PAID`.
       * - `INITIATED`: The order is awaiting for payment.
       * - `CANCELED`: The order is canceled.
       * - `DECLINED`: The order is payment is declined.
       */
      status?: OrderStatus$1;
      /** Payment method used for purchase, e.g., "payPal", "creditCard", etc. */
      method?: string;
      /** Quantity of ordered tickets. */
      ticketsQuantity?: number;
      /** Total order price. */
      totalPrice?: Money$5;
      /** Ticket PDF URL. */
      ticketsPdf?: string;
      /** Tickets (generated after payment). */
      tickets?: TicketingTicket$1[];
      /** Whether the order is archived. */
      archived?: boolean;
      /** Whether the order is anonymized by GDPR delete. */
      anonymized?: boolean;
      /** Guest full name. */
      fullName?: string;
      /** Order invoice. */
      invoice?: Invoice;
      /** Whether all tickets in order are checked-in. */
      fullyCheckedIn?: boolean;
      /**
       * Deprecated. Use `payment_details.transaction.transaction_id`.
       * @internal
       * @readonly
       * @deprecated
       */
      transactionId?: string;
      /** Internal order payment details */
      paymentDetails?: PaymentDetails;
      /** Checkout channel type */
      channel?: ChannelType$1;
      /**
       * Language in which Order was created.
       * @internal
       */
      language?: string | null;
      /**
       * Locale in which Order was created.
       * @internal
       */
      locale?: string | null;
      /**
       * Order updated timestamp.
       * @readonly
       */
      updated?: Date | null;
      /**
       * Possible order actions.
       * @internal
       * @readonly
       */
      availableActions?: Action[];
      /**
       * Gift card payments.
       * @internal
       */
      giftCardPaymentDetails?: GiftCardPaymentDetails[];
      /**
       * Balance summary.
       * @internal
       */
      balanceSummary?: BalanceSummary;
  }
  interface FormResponse$3 {
      /** Input fields for a checkout form. */
      inputValues?: InputValue$3[];
  }
  interface InputValue$3 {
      /** Input field name. */
      inputName?: string;
      /** Input field value. */
      value?: string;
      /** Multiple input field values. */
      values?: string[];
      /**
       * Int or floating point number value.
       * @internal
       */
      number?: number | null;
      /**
       * Date/time value.
       * @internal
       */
      dateTime?: Date | null;
      /**
       * Address type value.
       * @internal
       */
      address?: FormattedAddress$3;
  }
  interface FormattedAddress$3 {
      /** One line address representation. */
      formatted?: string;
      /** Address components (optional). */
      address?: Address$7;
  }
  /** Physical address */
  interface Address$7 extends AddressStreetOneOf$7 {
      /** Street name and number. */
      streetAddress?: StreetAddress$7;
      /** Main address line, usually street and number as free text. */
      addressLine1?: string | null;
      /** Country code. */
      country?: string | null;
      /** Subdivision shorthand. Usually, a short code (2 or 3 letters) that represents a state, region, prefecture, or province. e.g. NY */
      subdivision?: string | null;
      /** City name. */
      city?: string | null;
      /** Zip/postal code. */
      postalCode?: string | null;
      /** Free text providing more detailed address info. Usually contains Apt, Suite, and Floor. */
      addressLine2?: string | null;
      /**
       * A string containing the full address of this location.
       * @internal
       */
      formatted?: string | null;
      /**
       * Coordinates of the physical address.
       * @internal
       */
      location?: AddressLocation$7;
      /**
       * Country full name.
       * @internal
       */
      countryFullname?: string | null;
      /**
       * Subdivision full name.
       * @internal
       */
      subdivisionFullname?: string | null;
      /**
       * Multi-level subdivisions from top to bottom.
       * @internal
       */
      subdivisions?: Subdivision$7[];
  }
  /** @oneof */
  interface AddressStreetOneOf$7 {
      /** Street name and number. */
      streetAddress?: StreetAddress$7;
      /** Main address line, usually street and number as free text. */
      addressLine?: string | null;
  }
  interface StreetAddress$7 {
      /** Street number. */
      number?: string;
      /** Street name. */
      name?: string;
      /**
       * Apartment number.
       * @internal
       */
      apt?: string;
      /**
       * Optional address line 1
       * @internal
       */
      formattedAddressLine?: string | null;
  }
  interface AddressLocation$7 {
      /** Address latitude. */
      latitude?: number | null;
      /** Address longitude. */
      longitude?: number | null;
  }
  interface Subdivision$7 {
      /** Short subdivision code. */
      code?: string;
      /** Subdivision full name. */
      name?: string;
      /**
       * Subdivision level
       * @internal
       */
      type?: SubdivisionType$7;
      /**
       * Free text description of subdivision type.
       * @internal
       */
      typeInfo?: string | null;
      /**
       * Standard organizations details (e.g. ISO).
       * @internal
       */
      standardDetails?: StandardDetails$3;
  }
  enum SubdivisionType$7 {
      UNKNOWN_SUBDIVISION_TYPE = "UNKNOWN_SUBDIVISION_TYPE",
      /** State */
      ADMINISTRATIVE_AREA_LEVEL_1 = "ADMINISTRATIVE_AREA_LEVEL_1",
      /** County */
      ADMINISTRATIVE_AREA_LEVEL_2 = "ADMINISTRATIVE_AREA_LEVEL_2",
      /** City/town */
      ADMINISTRATIVE_AREA_LEVEL_3 = "ADMINISTRATIVE_AREA_LEVEL_3",
      /** Neighborhood/quarter */
      ADMINISTRATIVE_AREA_LEVEL_4 = "ADMINISTRATIVE_AREA_LEVEL_4",
      /** Street/block */
      ADMINISTRATIVE_AREA_LEVEL_5 = "ADMINISTRATIVE_AREA_LEVEL_5",
      /** ADMINISTRATIVE_AREA_LEVEL_0. Indicates the national political entity, and is typically the highest order type returned by the Geocoder. */
      COUNTRY = "COUNTRY"
  }
  /** Subdivision Concordance values */
  interface StandardDetails$3 {
      /** subdivision iso-3166-2 code according to [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). e.g. US-NY, GB-SCT, NO-30 */
      iso31662?: string | null;
  }
  enum OrderStatus$1 {
      /** Order status not available for this request fieldset. */
      NA_ORDER_STATUS = "NA_ORDER_STATUS",
      /** Order is confirmed and payment isn't required. */
      FREE = "FREE",
      /** Order is paid for but the payment gateway has suspended the payment. */
      PENDING = "PENDING",
      /** Order is paid via a payment gateway. */
      PAID = "PAID",
      /** Order is confirmed but must be paid via offline payment. Status needs to be manually updated to `PAID`. */
      OFFLINE_PENDING = "OFFLINE_PENDING",
      /** Order is awaiting payment at the cashier. */
      INITIATED = "INITIATED",
      /** Order is canceled. */
      CANCELED = "CANCELED",
      /** Order payment is declined. */
      DECLINED = "DECLINED",
      /** Order payment is authorized. */
      AUTHORIZED = "AUTHORIZED",
      /** Order payment is voided. */
      VOIDED = "VOIDED",
      /** Order is partially paid with less than the total amount. */
      PARTIALLY_PAID = "PARTIALLY_PAID"
  }
  interface Money$5 {
      /**
       * *Deprecated:** Use `value` instead.
       * @deprecated
       */
      amount?: string;
      /** Currency code. Must be a valid [ISO 4217](https://www.iso.org/iso-4217-currency-codes.html) currency code (e.g., USD). */
      currency?: string;
      /** Monetary amount. Decimal string with a period as a decimal separator (e.g., 3.99). Optionally, starts with a single (-), to indicate that the amount is negative. */
      value?: string | null;
  }
  interface TicketingTicket$1 {
      /** Unique ticket number (issued automatically). */
      ticketNumber?: string;
      /** Associated order number. */
      orderNumber?: string;
      /** Ticket definition ID. */
      ticketDefinitionId?: string;
      /** Ticket name. */
      name?: string;
      /** Ticket price. */
      price?: Money$5;
      /**
       * Whether the ticket requires payment.
       * @readonly
       */
      free?: boolean;
      /** Event and ticket policies. */
      policy?: string;
      /**
       * Deprecated, use `check_in_url`.
       * @deprecated
       */
      qrCode?: string;
      /** Ticket check-in. */
      checkIn?: CheckIn$2;
      /** Associated order status. */
      orderStatus?: OrderStatus$1;
      /** Whether order and ticket are visible in order list. */
      orderArchived?: boolean;
      /** Buyer full name. */
      orderFullName?: string;
      /** Guest full name. */
      guestFullName?: string | null;
      /** Guest personal details. */
      guestDetails?: GuestDetails$1;
      /** Whether ticket is visible in guest list. */
      archived?: boolean;
      /**
       * Deprecated, use `ticket_pdf_url`.
       * @deprecated
       */
      ticketPdf?: string;
      /** Ticket owner member ID. */
      memberId?: string | null;
      /**
       * Whether ticket was anonymized by GDPR delete.
       * Anonymized tickets no longer contain personally identifiable information (PII).
       */
      anonymized?: boolean;
      /**
       * Ticket check-in URL.
       * Shown as a QR code image in PDF.
       * Format: `https://www.wixevents.com/check-in/{ticket number},{event id}`.
       * Example: `https://www.wixevents.com/check-in/AAAA-AAAA-BB021,00000000-0000-0000-0000-000000000000`
       */
      checkInUrl?: string;
      /** URL for ticket PDF download. */
      ticketPdfUrl?: string;
      /** Associated order checkout channel type */
      channel?: ChannelType$1;
      /**
       * URL to download ticket in the `.pkpass` format for Apple Wallet
       * @readonly
       */
      walletPassUrl?: string;
      /**
       * Additional ticket details.
       * @internal
       * @readonly
       */
      ticketDetails?: TicketDetails$1;
  }
  interface CheckIn$2 {
      /** Time of check-in */
      created?: Date | null;
  }
  interface GuestDetails$1 {
      /** Whether ticket belongs to assigned guest. */
      guestAssigned?: boolean;
      /** Guest first name. */
      firstName?: string | null;
      /** Guest last name. */
      lastName?: string | null;
      /** Guest email. */
      email?: string | null;
      /** Full form response. */
      form?: FormResponse$3;
      /** Contact ID associated with this guest. */
      contactId?: string | null;
      /** Guest phone number. */
      phone?: string | null;
  }
  enum ChannelType$1 {
      /** Buyer created the order via an online channel such as a website or mobile app. */
      ONLINE = "ONLINE",
      /** Sales person created the order and collected the money. */
      OFFLINE_POS = "OFFLINE_POS"
  }
  interface TicketDetails$1 {
      /** Unique seat id in the event venue. */
      seatId?: string | null;
      /**
       * Optional sector name.
       * @internal
       * @readonly
       */
      sectorName?: string | null;
      /**
       * Area name.
       * @internal
       * @readonly
       */
      areaName?: string | null;
      /**
       * Table name.
       * @internal
       * @readonly
       */
      tableName?: string | null;
      /**
       * Row label.
       * @internal
       * @readonly
       */
      rowNumber?: string | null;
      /**
       * Seat label in a row or table.
       * @internal
       * @readonly
       */
      seatNumber?: string | null;
      /**
       * Optional sector label.
       * @readonly
       */
      sectionLabel?: string | null;
      /**
       * Area label.
       * @readonly
       */
      areaLabel?: string | null;
      /**
       * Table label.
       * @readonly
       */
      tableLabel?: string | null;
      /**
       * Row label.
       * @readonly
       */
      rowLabel?: string | null;
      /**
       * Seat label in a row or table.
       * @readonly
       */
      seatLabel?: string | null;
      /** Number of places in the spot. If not provided - defaults to 1. */
      capacity?: number | null;
      /** Custom pricing of ticket. */
      priceOverride?: string | null;
      /** Pricing option id. */
      pricingOptionId?: string | null;
      /**
       * Pricing option name.
       * @readonly
       */
      pricingOptionName?: string | null;
  }
  interface Invoice {
      /** Items listed in the invoice. */
      items?: Item$1[];
      /**
       * Total cart amount.
       * @deprecated
       */
      total?: Money$5;
      /** Discount applied to a cart. */
      discount?: Discount;
      /** Tax applied to cart. */
      tax?: Tax;
      /** Total cart amount before discount, tax, and fees. */
      subTotal?: Money$5;
      /**
       * Total amount of cart after discount, tax, and fees.
       * Grand total is calculated in the following order:
       * 1. Total prices of all items in the cart are calculated.
       * 2. Discount is subtracted from the cart (if applicable).
       * 3. Tax is added (if applicable).
       * 4. Wix ticket service fee is added.
       */
      grandTotal?: Money$5;
      /**
       * Fees applied to the cart.
       * @readonly
       */
      fees?: Fee[];
      /** Total revenue, excluding fees. (Taxes and payment provider fees are not deducted). */
      revenue?: Money$5;
      /** Invoice preview URL. This value is only returned when the order is paid. */
      previewUrl?: string | null;
  }
  interface Item$1 {
      /** Unique line item ID. */
      _id?: string;
      /** Line item quantity. */
      quantity?: number;
      /** Line item name. */
      name?: string;
      /** Line item price. */
      price?: Money$5;
      /** Total price for line items. It's calculated by multiplying price and item quantity. */
      total?: Money$5;
      /** Discount applied to the line item. */
      discount?: Discount;
      /** Tax applied to the item. */
      tax?: Tax;
      /**
       * Fees applied to the item.
       * @readonly
       */
      fees?: Fee[];
  }
  interface Discount {
      /** Total discount amount. */
      amount?: Money$5;
      /** Total sum after the discount. */
      afterDiscount?: Money$5;
      /**
       * Discount coupon code.
       * @deprecated
       */
      code?: string;
      /**
       * Discount coupon name.
       * @deprecated
       */
      name?: string;
      /**
       * Discount coupon ID.
       * @deprecated
       */
      couponId?: string;
      /** Discount items. */
      discounts?: DiscountItem[];
  }
  interface DiscountItem extends DiscountItemDiscountOneOf {
      /** Coupon discount. */
      coupon?: CouponDiscount;
      /** Pricing plan discount. */
      paidPlan?: PaidPlanDiscount;
      /** Total discount amount. */
      amount?: Money$5;
  }
  /** @oneof */
  interface DiscountItemDiscountOneOf {
      /** Coupon discount. */
      coupon?: CouponDiscount;
      /** Pricing plan discount. */
      paidPlan?: PaidPlanDiscount;
  }
  interface CouponDiscount {
      /** Discount coupon name. */
      name?: string;
      /** Discount coupon code. */
      code?: string;
      /** Discount coupon ID. */
      couponId?: string;
  }
  interface PaidPlanDiscount extends PaidPlanDiscountDiscountOneOf {
      /** Discount by percentage applied to tickets. */
      percentDiscount?: PercentDiscount;
      /** Name of pricing plan. */
      name?: string;
  }
  /** @oneof */
  interface PaidPlanDiscountDiscountOneOf {
      /** Discount by percentage applied to tickets. */
      percentDiscount?: PercentDiscount;
  }
  interface PercentDiscount {
      /** Percent rate. */
      rate?: string;
      /** Number of discounted tickets. */
      quantityDiscounted?: number;
  }
  interface Tax {
      /** Tax type. */
      type?: TaxType$3;
      /**
       * Tax name.
       * @readonly
       */
      name?: string;
      /** Tax rate. */
      rate?: string;
      /** Taxable amount. */
      taxable?: Money$5;
      /** Total tax amount. */
      amount?: Money$5;
  }
  enum TaxType$3 {
      /** Tax is included in the ticket price. */
      INCLUDED = "INCLUDED",
      /** Tax is added to the order at the checkout. */
      ADDED = "ADDED",
      /** Tax is added to the final total at the checkout. */
      ADDED_AT_CHECKOUT = "ADDED_AT_CHECKOUT"
  }
  interface Fee {
      /** Fee identifier. */
      name?: FeeName;
      /** How fee is calculated. */
      type?: FeeType$1;
      /**
       * Fee rate.
       * @readonly
       */
      rate?: string;
      /** Total amount of fee charges. */
      amount?: Money$5;
  }
  enum FeeName {
      /** Wix ticket service fee charges applied to the line item. */
      WIX_FEE = "WIX_FEE"
  }
  enum FeeType$1 {
      /** Fee is added to the ticket price at checkout. */
      FEE_ADDED = "FEE_ADDED",
      /** Seller absorbs the fee. It is deducted from the ticket price. */
      FEE_INCLUDED = "FEE_INCLUDED",
      /** Fee is added to the ticket price at checkout. */
      FEE_ADDED_AT_CHECKOUT = "FEE_ADDED_AT_CHECKOUT"
  }
  interface PaymentDetails {
      /** Wix Payments transaction */
      transaction?: PaymentTransaction;
  }
  interface PaymentTransaction {
      /**
       * Wix Payments transaction id
       * @readonly
       */
      transactionId?: string;
      /**
       * Transaction Payment method e.g., "payPal", "creditCard", etc.
       * @readonly
       */
      method?: string;
      /**
       * Scheduled action.
       * @internal
       * @readonly
       */
      scheduledAction?: ScheduledActionEnumAction;
      /**
       * Scheduled action execution date. Non empty for delayed transactions.
       * @internal
       * @readonly
       */
      scheduledActionExecutionDate?: Date | null;
  }
  enum ScheduledActionEnumAction {
      /** Action not scheduled. */
      UNKNOWN_ACTION = "UNKNOWN_ACTION",
      /** Captured after the delay. */
      CAPTURE = "CAPTURE",
      /** Void after the delay. */
      VOID = "VOID"
  }
  enum Action {
      /** Order can be archived. */
      ARCHIVE = "ARCHIVE",
      /** Order can be unarchived. */
      UNARCHIVE = "UNARCHIVE",
      /** Order can be confirmed. */
      CONFIRM = "CONFIRM",
      /** Order can be captured. */
      CAPTURE = "CAPTURE",
      /** Order can be voided. */
      VOID = "VOID"
  }
  interface GiftCardPaymentDetails {
      /** Gift card payment id. */
      giftCardPaymentId?: string | null;
      /** ID of the app that created the gift card. */
      appId?: string | null;
      /** Whether the gift card payment is voided. */
      voided?: boolean | null;
      /** Amount */
      amount?: Money$5;
      /** Obfuscated gift card code. */
      obfuscatedCode?: string | null;
  }
  interface BalanceSummary {
      /** Amount left to pay. */
      balance?: Money$5;
  }
  interface OrderDeleted {
      /** Order deleted timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Event ID to which the order belongs. */
      eventId?: string;
      /** Unique order number. */
      orderNumber?: string;
      /** Contact ID associated with this order */
      contactId?: string;
      /** Member ID associated with this order. */
      memberId?: string | null;
      /**
       * Order created timestamp.
       * @readonly
       */
      created?: Date | null;
      /**
       * Order updated timestamp.
       * @readonly
       */
      updated?: Date | null;
      /** Whether order was anonymized by GDPR delete. */
      anonymized?: boolean;
      /** Order type. */
      orderType?: OrderType;
      /** Whether event was triggered by GDPR delete request. */
      triggeredByAnonymizeRequest?: boolean;
      /** Tickets generated after payment. */
      tickets?: Ticket$1[];
  }
  enum OrderType {
      /** Buyer form is used for all tickets. */
      UNASSIGNED_TICKETS = "UNASSIGNED_TICKETS",
      /** Each order ticket has its own form. */
      ASSIGNED_TICKETS = "ASSIGNED_TICKETS"
  }
  interface Ticket$1 {
      /** Unique issued ticket number. */
      ticketNumber?: string;
      /** Ticket definition ID. */
      ticketDefinitionId?: string;
      /** Ticket check-in. */
      checkIn?: CheckIn$2;
      /** Ticket price. */
      price?: Money$5;
      /** Whether ticket is archived. */
      archived?: boolean;
      /** Guest first name. */
      firstName?: string | null;
      /** Guest last name. */
      lastName?: string | null;
      /** Guest email. */
      email?: string | null;
      /** Contact ID associated with this ticket. */
      contactId?: string | null;
      /** Whether ticket is confirmed */
      confirmed?: boolean;
      /** Member ID associated with this ticket. */
      memberId?: string | null;
      /** Ticket form response (only assigned tickets contain separate forms). */
      form?: FormResponse$3;
      /** Ticket name. */
      ticketName?: string;
      /** Anonymized tickets no longer contain personally identifiable information (PII). */
      anonymized?: boolean;
      /** URL and password to online conference */
      onlineConferencingLogin?: OnlineConferencingLogin$3;
  }
  interface OnlineConferencingLogin$3 {
      /**
       * Link URL to the online conference.
       * @readonly
       */
      link?: string;
      /**
       * Password for the online conference.
       * @readonly
       */
      password?: string | null;
  }
  interface ListOrdersRequest {
      /** Offset. */
      offset?: number;
      /** Limit. */
      limit?: number;
      /**
       * Predefined sets of fields to return.
       * - `TICKETS`: Returns `tickets`.
       * - `DETAILS`: Returns `reservationId`, `snapshotId`, `created`, `firstName`, `lastName`, `confirmed`, `status`, `method`, `ticketsQuantity`, `totalPrice`, `ticketsPdf`, `archived`, `fullName`.
       * - `FORM` : Returns `checkoutForm`.
       * - `INVOICE`: Returns `invoice`.
       *
       * Default: If `fieldset` is not included in the request,  `orderNumber`, `eventId`, `contactId`, `memberId`, `anonymized`, `fullyCheckedIn` are returned.
       *
       */
      fieldset?: OrderFieldset[];
      /**
       * Order status. Possible values:
       * - `FREE`: The order is confirmed, no payment is required.
       * - `PENDING`: The order was paid, but the payment gateway suspended the payment.
       * - `PAID`: The order is paid.
       * - `OFFLINE_PENDING`: The order is confirmed but has to be paid in cash and the status is manually updated to `PAID`.
       * - `INITIATED`: The order is awaiting for payment.
       * - `CANCELED`: The order is canceled.
       * - `DECLINED`: The order is payment is declined.
       */
      status?: OrderStatus$1[];
      /**
       * Deprecated: use tag = CONFIRMED
       * @internal
       * @deprecated
       */
      confirmed?: boolean | null;
      /** Event ID to which the order belongs. */
      eventId?: string[];
      /** Order number. */
      orderNumber?: string[];
      /** Site member ID. */
      memberId?: string[];
      /**
       * Deprecated: use tag = MEMBER
       * @internal
       * @deprecated
       */
      membersOnly?: boolean;
      /** Field facets, */
      facet?: string[];
      /**
       * Deprecated: use tag = ARCHIVED / NON_ARCHIVED
       * @internal
       * @deprecated
       */
      archived?: boolean | null;
      /** Search filter. You can search `fullName`, `email` and `orderNumber`. */
      searchPhrase?: string;
      /** Event creator ID. */
      eventCreatorId?: string[];
      /**
       * Deprecated: use tag = FULLY_CHECKED_IN / NOT_FULLY_CHECKED_IN
       * @internal
       * @deprecated
       */
      fullyCheckedIn?: boolean | null;
      /**
       * Sort order.
       * Default: `created:asc`.
       */
      sort?: string;
      /** Order tag. */
      tag?: OrderTag[];
      /** Guest contact IDs. */
      contactId?: string[];
  }
  enum OrderFieldset {
      /** Include tickets in response. */
      TICKETS = "TICKETS",
      /** Include order details in the response: `status`, `firstName`, `lastName`, `email`, `created`, etc. */
      DETAILS = "DETAILS",
      /** Include `checkoutForm` in the response. */
      FORM = "FORM",
      /** Include `invoice` in the response. */
      INVOICE = "INVOICE"
  }
  enum OrderTag {
      /** Return only confirmed orders. */
      CONFIRMED = "CONFIRMED",
      /** Return only unconfirmed orders. */
      UNCONFIRMED = "UNCONFIRMED",
      /** Return only member orders. */
      MEMBER = "MEMBER",
      /** Return only archived orders. */
      ARCHIVED = "ARCHIVED",
      /** Return only non archived orders. */
      NON_ARCHIVED = "NON_ARCHIVED",
      /** Return only orders with all guests checked-in. */
      FULLY_CHECKED_IN = "FULLY_CHECKED_IN",
      /** Return only orders with no guests checked-in. */
      NOT_FULLY_CHECKED_IN = "NOT_FULLY_CHECKED_IN"
  }
  interface ListOrdersResponse {
      /** Total orders matching the given filters. */
      total?: number;
      /** Offset. */
      offset?: number;
      /** Limit. */
      limit?: number;
      /** Orders. */
      orders?: Order[];
      /** Filter facets. */
      facets?: Record<string, FacetCounts$5>;
      /** Order data enriched facets. */
      orderFacets?: OrderFacets;
  }
  interface FacetCounts$5 {
      /** Facet counts aggregated per value. */
      counts?: Record<string, number>;
  }
  interface OrderFacets {
      /** Filter facets. */
      facets?: Record<string, OrderFacetCounts>;
  }
  interface OrderFacetCounts {
      /** Facet counts aggregated per value */
      counts?: Record<string, Counts$2>;
  }
  interface Counts$2 {
      /** Number or orders */
      count?: number;
      /** Number of tickets within orders */
      tickets?: number;
      /** Number of tickets with check-in */
      ticketsCheckIn?: number;
  }
  interface GetOrderRequest {
      /** Event ID to which the order belongs. */
      eventId: string;
      /** Unique order number. */
      orderNumber: string;
      /**
       * Predefined sets of fields to return.
       * - `TICKETS`: Returns `tickets`.
       * - `DETAILS`: Returns `reservationId`, `snapshotId`, `created`, `firstName`, `lastName`, `confirmed`, `status`, `method`, `ticketsQuantity`, `totalPrice`, `ticketsPdf`, `archived`, `fullName`.
       * - `FORM` : Returns `checkoutForm`.
       * - `INVOICE`: Returns `invoice`.
       *
       * Default: If `fieldset` is not included in the request,  `orderNumber`, `eventId`, `contactId`, `memberId`, `anonymized`, `fullyCheckedIn` are returned.
       *
       */
      fieldset?: OrderFieldset[];
  }
  interface GetOrderResponse {
      /** Requested order. */
      order?: Order;
      /** "Add to calendar" links. */
      calendarLinks?: CalendarLinks$4;
  }
  interface CalendarLinks$4 {
      /** "Add to Google calendar" URL. */
      google?: string;
      /** "Download ICS calendar file" URL. */
      ics?: string;
  }
  interface UpdateOrderRequest {
      /** Event ID to which the order belongs. */
      eventId: string;
      /** Unique order number. */
      orderNumber: string;
      /**
       * Set of field paths to update.
       * @internal
       */
      fields?: string[];
      /** Checkout form. */
      checkoutForm?: FormResponse$3;
      /** Whether order is archived. */
      archived?: boolean;
      /**
       * Only used in tests.
       * @internal
       */
      expires?: Date | null;
      /**
       * @internal
       * @deprecated
       * @targetRemovalDate 2026-06-01
       */
      silent?: boolean | null;
  }
  interface UpdateOrderResponse {
      /** Updated order. */
      order?: Order;
  }
  interface OrderUpdated$1 {
      /** Order updated timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Site language when Order initiated */
      language?: string | null;
      /** Locale in which Order was created. */
      locale?: string | null;
      /** Event ID to which the order belongs. */
      eventId?: string;
      /** Unique order number. */
      orderNumber?: string;
      /** Contact ID associated with this order. */
      contactId?: string;
      /** Member ID associated with this order. */
      memberId?: string | null;
      /**
       * Order created timestamp.
       * @readonly
       */
      created?: Date | null;
      /**
       * Order updated timestamp.
       * @readonly
       */
      updated?: Date | null;
      /** Buyer first name. */
      firstName?: string;
      /** Buyer last name. */
      lastName?: string;
      /** Buyer email. */
      email?: string;
      /** Checkout form response. */
      checkoutForm?: FormResponse$3;
      /** Whether order is confirmed - occurs once payment gateway processes the payment and funds reach merchant's account. */
      confirmed?: boolean;
      /**
       * Order status. Possible values:
       * - `FREE`: The order is confirmed, no payment is required.
       * - `PENDING`: The order was paid, but the payment gateway suspended the payment.
       * - `PAID`: The order is paid.
       * - `OFFLINE_PENDING`: The order is confirmed but has to be paid in cash and the status is manually updated to `PAID`.
       * - `INITIATED`: The order is awaiting for payment.
       * - `CANCELED`: The order is canceled.
       * - `DECLINED`: The order is payment is declined.
       */
      status?: OrderStatus$1;
      /** Payment method used for paid tickets purchase, i.e. "payPal", "creditCard", etc. */
      method?: string | null;
      /** Tickets generated after payment. */
      tickets?: Ticket$1[];
      /** Whether order was archived and excluded from results. */
      archived?: boolean;
      /** Whether event was triggered by GDPR delete request. */
      triggeredByAnonymizeRequest?: boolean;
  }
  interface BulkUpdateOrdersRequest {
      /** Event ID to which the order belongs. */
      eventId: string;
      orderNumber?: string[];
      /**
       * Set of fields to update.
       * @internal
       */
      fields?: string[];
      /** Whether to archive the order. */
      archived?: boolean;
  }
  interface BulkUpdateOrdersResponse {
      /** Updated orders. */
      orders?: Order[];
  }
  interface ConfirmOrderRequest {
      /** Event ID to which the order belongs. */
      eventId: string;
      /** Order numbers. */
      orderNumber?: string[];
  }
  interface ConfirmOrderResponse {
      /** Confirmed orders. */
      orders?: Order[];
  }
  interface GetSummaryRequest {
      /** Event ID. */
      eventId?: string | null;
  }
  interface GetSummaryResponse {
      /** Ticket sales grouped by currency. */
      sales?: TicketSales[];
  }
  interface TicketSales {
      /** Total balance of confirmed transactions. */
      total?: Money$5;
      /** Total number of confirmed orders. */
      totalOrders?: number;
      /** Total number of tickets purchased. */
      totalTickets?: number;
      /** Total revenue, excluding fees (taxes and payment provider fees are not deducted). */
      revenue?: Money$5;
  }
  interface GetInvoicePreviewRequest {
      /** Event ID to which the invoice belongs. */
      eventId: string;
      /** Order number. */
      orderNumber: string;
  }
  interface RawHttpResponse {
      body?: Uint8Array;
      statusCode?: number | null;
      headers?: HeadersEntry[];
  }
  interface HeadersEntry {
      key?: string;
      value?: string;
  }
  interface GetPaymentInfoRequest {
      /** Event ID. */
      eventId?: string;
      /** Order number. */
      orderNumber?: string;
  }
  interface GetPaymentInfoResponse {
      transactions?: PaymentTransactionSummary[];
      status?: string | null;
      /** @readonly */
      transactionId?: string | null;
  }
  interface PaymentTransactionSummary {
      /**
       * Wix Payments transaction id
       * @readonly
       */
      transactionId?: string;
      /**
       * Final transaction status
       * @readonly
       */
      finalTransactionStatus?: string;
      /** Transaction events */
      events?: PaymentTransactionEvent[];
  }
  interface PaymentTransactionEvent {
      /**
       * Order snapshot id
       * @readonly
       */
      snapshotId?: string;
      /**
       * Transaction status
       * @readonly
       */
      transactionStatus?: string;
      /**
       * Transaction Payment method e.g., "payPal", "creditCard", etc.
       * @readonly
       */
      paymentMethod?: string;
      /**
       * Transaction payment amount
       * @readonly
       */
      paymentAmount?: Money$5;
      /**
       * Crated date
       * @readonly
       */
      _createdDate?: Date | null;
      /**
       * Reason code
       * @readonly
       */
      reasonCode?: string | null;
      /**
       * Refunded amount
       * @readonly
       */
      refundedAmount?: Money$5;
  }
  interface CaptureAuthorizedPaymentRequest {
      /** Event ID. */
      eventId?: string;
      /** Order number. */
      orderNumber: string;
  }
  interface CaptureAuthorizedPaymentResponse {
  }
  interface VoidAuthorizedPaymentRequest {
      /** Event ID. */
      eventId?: string;
      /** Order number. */
      orderNumber: string;
  }
  interface VoidAuthorizedPaymentResponse {
  }
  interface MessageEnvelope$8 {
      /** App instance ID. */
      instanceId?: string | null;
      /** Event type. */
      eventType?: string;
      /** The identification type and identity data. */
      identity?: IdentificationData$8;
      /** Stringify payload. */
      data?: string;
  }
  interface IdentificationData$8 extends IdentificationDataIdOneOf$8 {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
      /** @readonly */
      identityType?: WebhookIdentityType$8;
  }
  /** @oneof */
  interface IdentificationDataIdOneOf$8 {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
  }
  enum WebhookIdentityType$8 {
      UNKNOWN = "UNKNOWN",
      ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
      MEMBER = "MEMBER",
      WIX_USER = "WIX_USER",
      APP = "APP"
  }
  interface OrderConfirmed {
      /** Order confirmation timestamp in ISO UTC. */
      timestamp?: Date | null;
      /** Site language when Order initiated */
      language?: string | null;
      /** Notifications silenced for this domain event. */
      silent?: boolean | null;
      /** Locale in which Order was created. */
      locale?: string | null;
      /** Event ID to which the order belongs. */
      eventId?: string;
      /** Unique order number. */
      orderNumber?: string;
      /** Contact ID associated with this order. */
      contactId?: string;
      /** Member ID associated with this order. */
      memberId?: string | null;
      /**
       * Order created timestamp
       * @readonly
       */
      created?: Date | null;
      /** Buyer first name. */
      firstName?: string;
      /** Buyer last name. */
      lastName?: string;
      /** Buyer email address. */
      email?: string;
      /** Checkout form response. */
      checkoutForm?: FormResponse$3;
      /**
       * Order status. Possible values:
       * - `FREE`: The order is confirmed, no payment is required.
       * - `PENDING`: The order was paid, but the payment gateway suspended the payment.
       * - `PAID`: The order is paid.
       * - `OFFLINE_PENDING`: The order is confirmed but has to be paid in cash and the status is manually updated to `PAID`.
       * - `INITIATED`: The order is awaiting for payment.
       * - `CANCELED`: The order is canceled.
       * - `DECLINED`: The order is payment is declined.
       */
      status?: OrderStatus$1;
      /** Payment method used for paid tickets purchase, i.e. "payPal", "creditCard", etc. */
      method?: string | null;
      /** Tickets (generated after payment). */
      tickets?: Ticket$1[];
      /** Invoice. */
      invoice?: Invoice;
      /** Reservation ID associated with this order. */
      reservationId?: string;
  }
  interface OrderPaid {
      /** Order paid timestamp in ISO UTC. */
      timestamp?: Date | null;
      /** Site language when Order initiated */
      language?: string | null;
      /** Notifications silenced for this domain event. */
      silent?: boolean | null;
      /** Locale in which Order was created. */
      locale?: string | null;
      /** Event ID to which the order belongs. */
      eventId?: string;
      /** Unique order number. */
      orderNumber?: string;
      /** Reservation ID associated with this order. */
      reservationId?: string;
      /** Contact ID associated with this order. */
      contactId?: string;
      /** Member ID associated with this order. */
      memberId?: string | null;
      /**
       * Order created timestamp
       * @readonly
       */
      created?: Date | null;
      /** Buyer first name. */
      firstName?: string;
      /** Buyer last name. */
      lastName?: string;
      /** Buyer email address. */
      email?: string;
      /** Checkout form response. */
      checkoutForm?: FormResponse$3;
      /** Order status. */
      status?: OrderStatus$1;
      /** Payment method used for paid tickets purchase, i.e. "payPal", "creditCard", etc. */
      method?: string | null;
      /** Tickets (generated after payment). */
      tickets?: Ticket$1[];
      /** Invoice. */
      invoice?: Invoice;
  }
  interface ReservationCreated$1 {
      /** Reservation created timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Event ID to which the reservation belongs. */
      eventId?: string;
      /**
       * Reservation ID.
       * Can be used to retrieve a reservation invoice.
       */
      reservationId?: string;
      /** Reservation expiration timestamp. */
      expires?: Date | null;
      /** Reservation status. */
      status?: ReservationStatus$1;
      /** Reservation ticket quantities. */
      quantities?: TicketQuantity$1[];
      /** Reservation update timestamp. */
      _updatedDate?: Date | null;
      /** Reservation counts. */
      counts?: ReservationCount$1[];
  }
  enum ReservationStatus$1 {
      /** The Reservation is pending confirmation and will expire after the expiration due time. */
      RESERVATION_PENDING = "RESERVATION_PENDING",
      /** The reservation is confirmed and will not expire. */
      RESERVATION_CONFIRMED = "RESERVATION_CONFIRMED",
      /** The reservation is canceled because of non payment. */
      RESERVATION_CANCELED = "RESERVATION_CANCELED",
      /** The reservation is canceled manually by the buyer. */
      RESERVATION_CANCELED_MANUALLY = "RESERVATION_CANCELED_MANUALLY",
      /** The reservation is expired. */
      RESERVATION_EXPIRED = "RESERVATION_EXPIRED"
  }
  interface TicketQuantity$1 {
      /** Ticket definition ID. */
      ticketDefinitionId?: string | null;
      /** Quantity. */
      quantity?: number | null;
      /** Quantity update timestamp. */
      _updatedDate?: Date | null;
  }
  interface ReservationCount$1 {
      /** Reservation Count snapshot timestamp. */
      timestamp?: Date | null;
      /** Ticket Definition ID. */
      ticketDefinitionId?: string;
      /** Confirmed reservation count. */
      confirmedCount?: number;
      /** Pending reservation count. */
      pendingCount?: number;
      /** True if paid ticket reservation exist. */
      paidExists?: boolean;
  }
  interface ReservationUpdated$1 {
      /** Reservation updated timestamp. */
      timestamp?: Date | null;
      /** Event ID to which the reservation belongs. */
      eventId?: string;
      /**
       * Reservation ID.
       * Can be used to retrieve a reservation invoice.
       */
      reservationId?: string;
      /** Reservation status. */
      status?: ReservationStatus$1;
      /** Reservation expiration timestamp. */
      expires?: Date | null;
      /** Reservation ticket quantities. */
      quantities?: TicketQuantity$1[];
      /** Reservation update timestamp. */
      _updatedDate?: Date | null;
      /** Reservation counts. */
      counts?: ReservationCount$1[];
  }
  interface GetCheckoutOptionsRequest {
  }
  interface GetCheckoutOptionsResponse {
      /** Whether any payment method is configured and available for payment. */
      paymentMethodConfigured?: boolean;
      /** Whether coupons are accepted at checkout. */
      acceptCoupons?: boolean;
      /** Whether premium services are enabled. Enabled for free if site does not sell any paid tickets. Selling tickets for a fee requires a premium feature "events_sell_tickets". */
      premiumServices?: boolean;
      /** Whether there are any paid tickets available for sale. */
      paidTickets?: boolean;
      /** Whether gift cards are accepted at checkout. */
      acceptGiftCards?: boolean;
  }
  interface ListAvailableTicketsRequest {
      /** Event ID. If not provided, available tickets for all events in the site will be returned. */
      eventId?: string;
      /** Offset. */
      offset?: number;
      /** Limit. */
      limit?: number;
      /**
       * Sort order.
       * Default: `created:asc`.
       */
      sort?: string;
      /**
       * Only used in tests.
       * @internal
       */
      overrideRequestTime?: Date | null;
      state?: State$5[];
  }
  enum State$5 {
      INCLUDE_HIDDEN_NOT_ON_SALE = "INCLUDE_HIDDEN_NOT_ON_SALE"
  }
  interface ListAvailableTicketsResponse {
      /** Ticket definitions meta data. */
      metaData?: ResponseMetaData$1;
      /** Ticket definitions. */
      definitions?: TicketDefinition$2[];
  }
  interface ResponseMetaData$1 {
      /** Number of items in the response. */
      count?: number;
      /** Offset of items. */
      offset?: number;
      /** Total number of matching items. */
      total?: number;
  }
  interface TicketDefinition$2 {
      /** Ticket definition ID. */
      _id?: string;
      /** Ticket price. */
      price?: Money$5;
      /** Whether the ticket is free (read only). */
      free?: boolean;
      /** Ticket name. */
      name?: string;
      /** Ticket description. */
      description?: string;
      /** Limit of tickets that can be purchased per checkout. If tickets are unlimited in the definition, the limit per checkout is 20 tickets. */
      limitPerCheckout?: number;
      /** Custom sort index. */
      orderIndex?: number;
      /** Event and ticket policies. */
      policy?: string;
      /** Sensitive dashboard data. */
      dashboard?: Dashboard$4;
      /** Event ID associated with the ticket. */
      eventId?: string;
      /**
       * Configuration of the fixed-rate Wix service fee that is applied at checkout to each ticket sold.
       * @readonly
       */
      wixFeeConfig?: WixFeeConfig$1;
      /** Ticket sale period. */
      salePeriod?: TicketSalePeriod$1;
      /**
       * Ticket sale status.
       * @readonly
       */
      saleStatus?: TicketSaleStatus$1;
      /** Ticket state. */
      state?: State$5[];
      /** Ticket pricing. */
      pricing?: TicketPricing$1;
  }
  interface Dashboard$4 {
      /** Whether ticket is hidden and cannot be sold. */
      hidden?: boolean;
      /**
       * Number of tickets sold and reserved.
       * @deprecated
       */
      sold?: number;
      /** Whether the ticket has limited quantity. */
      limited?: boolean;
      /** Ticket limit. `NULL` if the tickets are unlimited. */
      quantity?: number | null;
      /** Number of unsold tickets. `NULL` if the tickets are unlimited. */
      unsold?: number | null;
      /** Number of tickets sold. */
      ticketsSold?: number;
      /** Number of tickets reserved. */
      ticketsReserved?: number;
  }
  interface WixFeeConfig$1 {
      /** Fee calculation method. */
      type?: FeeType$1;
  }
  interface TicketSalePeriod$1 {
      /** Ticket sale start timestamp. */
      startDate?: Date | null;
      /** Ticket sale end timestamp. */
      endDate?: Date | null;
      /** Whether to hide this ticket if it's not on sale */
      hideNotOnSale?: boolean;
  }
  enum TicketSaleStatus$1 {
      /** Ticket sale is scheduled to start. */
      SALE_SCHEDULED = "SALE_SCHEDULED",
      /** Ticket sale has started. */
      SALE_STARTED = "SALE_STARTED",
      /** Ticket sale has ended. */
      SALE_ENDED = "SALE_ENDED"
  }
  interface TicketPricing$1 extends TicketPricingPriceOneOf$1 {
      /** Ticket price which is read only. */
      fixedPrice?: Money$5;
      /** Min price per ticket, customizable. */
      minPrice?: Money$5;
      /** Ticket pricing options. */
      pricingOptions?: PricingOptions$2;
      /**
       * Ticket pricing type.
       * @readonly
       */
      pricingType?: Type$4;
  }
  /** @oneof */
  interface TicketPricingPriceOneOf$1 {
      /** Ticket price which is read only. */
      fixedPrice?: Money$5;
      /** Min price per ticket, customizable. */
      minPrice?: Money$5;
      /** Ticket pricing options. */
      pricingOptions?: PricingOptions$2;
  }
  interface PricingOptions$2 {
      /** Multiple ticket pricing options. */
      options?: PricingOption$1[];
  }
  interface PricingOption$1 {
      /** Ticket pricing option ID. */
      _id?: string | null;
      /** Ticket pricing option name. */
      name?: string | null;
      /** Ticket pricing option price. */
      price?: Money$5;
  }
  enum Type$4 {
      STANDARD = "STANDARD",
      DONATION = "DONATION"
  }
  interface QueryAvailableTicketsRequest {
      /** Offset. */
      offset?: number;
      /** Limit. */
      limit?: number;
      /** Ticket definition. */
      filter?: Record<string, any> | null;
      fieldset?: TicketDefinitionFieldset$1[];
      /**
       * Sort order.
       * Default: `created:asc`.
       */
      sort?: string;
  }
  enum TicketDefinitionFieldset$1 {
      /** Include `policy` in the response. */
      POLICY = "POLICY",
      /** Include `dashboard` in the response. */
      DASHBOARD = "DASHBOARD"
  }
  interface QueryAvailableTicketsResponse {
      /** Ticket definitions meta data. */
      metaData?: ResponseMetaData$1;
      /** Ticket definitions. */
      definitions?: TicketDefinition$2[];
  }
  interface CreateReservationRequest {
      /** Event ID to which the reservation belongs. */
      eventId: string;
      /** Tickets to reserve. */
      ticketQuantities?: TicketReservationQuantity[];
      /** Whether to ignore the available ticket limits upon reservation. */
      ignoreLimits?: boolean;
      /**
       * Only used in tests.
       * @internal
       */
      overrideRequestTime?: Date | null;
      /** Whether to allow reservation for hidden tickets. */
      allowHiddenTickets?: boolean;
      /**
       * Whether to exclude Wix fee.
       * @internal
       */
      excludeFee?: boolean;
      /**
       * Whether to skip `ticketQuantities.ticketDetails.priceOverride` min validation.
       * @internal
       */
      skipPriceOverrideValidation?: boolean;
  }
  interface TicketReservationQuantity {
      /** Ticket definition ID. */
      ticketDefinitionId?: string;
      /** Quantity of tickets to reserve. */
      quantity?: number;
      /** Override the predefined ticket price. */
      priceOverride?: string | null;
      /** Optional ticket details */
      ticketDetails?: TicketDetails$1[];
  }
  interface CreateReservationResponse {
      /** Reservation ID. */
      _id?: string;
      /** Reservation expiration timestamp. */
      expires?: Date | null;
      /** Ticket reservations. */
      reservations?: TicketReservation[];
      /** Reservation invoice. */
      invoice?: Invoice;
  }
  interface TicketReservation {
      /** Quantity of reserved tickets. */
      quantity?: number;
      /** An object containing ticket information. */
      ticket?: TicketDefinition$2;
      /** Optional ticket details. */
      ticketDetails?: TicketDetails$1[];
  }
  interface CancelReservationRequest {
      /** Event ID to which the reservation belongs. */
      eventId: string;
      /** Reservation ID. */
      _id: string;
  }
  interface CancelReservationResponse {
  }
  interface GetInvoiceRequest {
      /** Event ID to which the invoice belongs. */
      eventId: string;
      /** Reservation ID. */
      reservationId: string;
      /** Optional discount to be applied on the returned invoice. */
      withDiscount?: DiscountRequest;
      /** Optional benefit granted by the pricing plan to be applied on the returned invoice. */
      paidPlanBenefit?: PaidPlanBenefit;
      /**
       * Gift card code.
       * @internal
       */
      giftCardCode?: string | null;
  }
  interface DiscountRequest {
      /** Discount coupon code. */
      couponCode?: string;
  }
  interface PaidPlanBenefit {
      /** Pricing plan ID. */
      planOrderId?: string;
      /** Pricing plan benefit ID. */
      benefitId?: string;
  }
  interface GetInvoiceResponse {
      /** Invoice with applied discount. */
      invoice?: Invoice;
      /** Discount errors, if relevant. */
      discountErrors?: DiscountErrors;
      /** Reservation expiration time. */
      expires?: Date | null;
      /**
       * Reservation status. Possible values:
       * - `RESERVATION_PENDING`: The reservation is pending confirmation. It will expire after a certain amount of time.
       * - `RESERVATION_CONFIRMED`: The reservation is confirmed and will not expire.
       * - `RESERVATION_CANCELED`: The reservation is canceled because it's not paid.
       * - `RESERVATION_CANCELED_MANUALLY`: The reservation is canceled manually by the buyer.
       * - `RESERVATION_EXPIRED`: The reservation has expired.
       */
      reservationStatus?: ReservationStatus$1;
      /** Whether this reservation is already used in checkout. */
      reservationOccupied?: boolean;
      /** Ticket reservations. */
      reservations?: TicketReservation[];
      /**
       * Gift card payments.
       * @internal
       */
      giftCardPaymentDetails?: GiftCardPaymentDetails[];
      /**
       * Balance summary.
       * @internal
       */
      balanceSummary?: BalanceSummary;
      /**
       * Gift card errors, if relevant.
       * @internal
       */
      giftCardErrors?: GiftCardErrors;
  }
  interface DiscountErrors {
      /** Object containing error information. */
      error?: Error[];
  }
  interface Error {
      /** A code identifying the error type. */
      code?: string;
  }
  interface GiftCardErrors {
      /** Error. */
      error?: GiftCardErrorsError[];
  }
  interface GiftCardErrorsError {
      code?: string;
  }
  interface CheckoutRequest {
      /** Event ID to which the checkout belongs. */
      eventId: string;
      /** Ticket reservation ID. */
      reservationId?: string;
      /** Member ID (if empty - no site member is associated to this order). */
      memberId?: string;
      /** Discount to apply on the invoice. */
      discount?: DiscountRequest;
      /**
       * Deprecated.
       * @internal
       * @deprecated
       */
      silent?: boolean;
      /**
       * Deprecated.
       * @internal
       * @deprecated
       */
      payInPerson?: boolean;
      /** Buyer details. */
      buyer?: Buyer;
      /** Guest details. */
      guests?: Guest$2[];
      /** Benefit granted by the pricing plan. */
      paidPlanBenefit?: PaidPlanBenefit;
      /** Options controlling the checkout process. */
      options?: CheckoutOptions;
      /**
       * Only used in tests.
       * @internal
       */
      overrideRequestTime?: Date | null;
      /**
       * Gift card code.
       * @internal
       */
      giftCardCode?: string | null;
  }
  interface Buyer {
      /** Buyer first name. */
      firstName?: string;
      /** Buyer last name. */
      lastName?: string;
      /** Buyer email. */
      email?: string;
  }
  interface Guest$2 {
      /** Specific guest info. */
      form?: FormResponse$3;
  }
  interface CheckoutOptions {
      /** Whether to ignore settings to notify contacts or users. */
      silent?: boolean;
      /** Whether the payment is to be done in person between the buyer and the merchant. When true, the completed order is created with status OFFLINE_PENDING and inPerson payment method. */
      payInPerson?: boolean;
      /** Whether to ignore form validation. */
      ignoreFormValidation?: boolean;
      /**
       * URL which overrides default payment redirect URL.
       * @internal
       */
      paymentRedirectUrl?: string | null;
      /** Marks payment as already paid */
      markAsPaid?: boolean | null;
  }
  interface CheckoutResponse {
      /** Created order. */
      order?: Order;
      /**
       * Order expiration time.
       * **Note:** Only applicable to orders with the `INITIATED` status.
       */
      expires?: Date | null;
      /** Ticket reservations. */
      reservations?: TicketReservation[];
      /** Order page URL. */
      orderPageUrl?: string | null;
  }
  interface OrderInitiated {
      /** Order initiated timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Site language when Order initiated */
      language?: string | null;
      /** Locale in which Order was created. */
      locale?: string | null;
      /** Event ID to which the order belongs. */
      eventId?: string;
      /** Unique order number. */
      orderNumber?: string;
      /** Contact ID associated with this order. */
      contactId?: string;
      /** Member ID associated with this order. */
      memberId?: string | null;
      /**
       * Order created timestamp.
       * @readonly
       */
      created?: Date | null;
      /**
       * Order updated timestamp.
       * @readonly
       */
      updated?: Date | null;
      /** Guest first name. */
      firstName?: string;
      /** Guest last name. */
      lastName?: string;
      /** Guest email address. */
      email?: string;
      /** Checkout form response. */
      checkoutForm?: FormResponse$3;
      /**
       * Order status. Possible values:
       * - `FREE`: The order is confirmed, no payment is required.
       * - `PENDING`: The order was paid, but the payment gateway suspended the payment.
       * - `PAID`: The order is paid.
       * - `OFFLINE_PENDING`: The order is confirmed but has to be paid in cash and the status is manually updated to `PAID`.
       * - `INITIATED`: The order is awaiting for payment.
       * - `CANCELED`: The order is canceled.
       * - `DECLINED`: The order is payment is declined.
       */
      status?: OrderStatus$1;
      /** Invoice. */
      invoice?: Invoice;
      /** Reservation ID associated with this order. */
      reservationId?: string;
      /** Order was marked as paid. */
      markedAsPaid?: boolean | null;
  }
  interface UpdateCheckoutRequest {
      /** Event ID to which the checkout belongs. */
      eventId: string;
      /** Unique order number. */
      orderNumber: string;
      /** Buyer details. */
      buyer?: Buyer;
      /** Guest details. */
      guests?: Guest$2[];
      /** Member ID (if empty - no site member is associated to this order). */
      memberId?: string | null;
      /** Discount to apply on the invoice. */
      discount?: DiscountRequest;
      /** Benefit granted by the pricing plan. */
      paidPlanBenefit?: PaidPlanBenefit;
      /**
       * Payment details id.
       * @internal
       */
      paymentDetailsId?: string | null;
      /**
       * Payment method.
       * @internal
       */
      paymentMethod?: string | null;
      /**
       * Gift card code.
       * @internal
       */
      giftCardCode?: string | null;
  }
  interface UpdateCheckoutResponse {
      /** Updated order. */
      order?: Order;
      /** Order page URL. */
      orderPageUrl?: string | null;
      /**
       * Payment response token.
       * @internal
       */
      chargeToken?: string | null;
      /**
       * Order page URL.
       * @internal
       */
      orderPageUrls?: OrderPageUrls;
  }
  interface OrderPageUrls {
      /** Success order page URL. */
      success?: string | null;
      /** Pending order page URL. */
      pending?: string | null;
      /** Canceled order page URL. */
      canceled?: string | null;
      /** Error order page URL. */
      error?: string | null;
  }
  interface PosCheckoutRequest {
      /** Event ID to which the checkout belongs. */
      eventId: string;
      /** Ticket reservation ID. */
      reservationId: string;
      /**
       * Payment details ID.
       * Not required if reservation total is 0. In this case the order will be created with status Free and no payment.
       */
      paymentDetailsId?: string | null;
  }
  interface PosCheckoutResponse {
      /** Created order. */
      order?: Order;
      /** Time when the order expires, applies to orders with status = INITIATED. */
      expires?: Date | null;
      /** Ticket reservations. */
      reservations?: TicketReservation[];
  }
  /**
   * Retrieves a list of orders, including ticket data.
   * @public
   * @param options - An object representing the available options for retrieving a list of orders.
   * @permissionId WIX_EVENTS.READ_ORDERS
   * @adminMethod
   */
  function listOrders(options?: ListOrdersOptions): Promise<ListOrdersResponse>;
  interface ListOrdersOptions {
      /** Offset. */
      offset?: number;
      /** Limit. */
      limit?: number;
      /**
       * Predefined sets of fields to return.
       * - `TICKETS`: Returns `tickets`.
       * - `DETAILS`: Returns `reservationId`, `snapshotId`, `created`, `firstName`, `lastName`, `confirmed`, `status`, `method`, `ticketsQuantity`, `totalPrice`, `ticketsPdf`, `archived`, `fullName`.
       * - `FORM` : Returns `checkoutForm`.
       * - `INVOICE`: Returns `invoice`.
       *
       * Default: If `fieldset` is not included in the request,  `orderNumber`, `eventId`, `contactId`, `memberId`, `anonymized`, `fullyCheckedIn` are returned.
       */
      fieldset?: OrderFieldset[];
      /**
       * Order status. Possible values:
       * - `FREE`: The order is confirmed, no payment is required.
       * - `PENDING`: The order was paid, but the payment gateway suspended the payment.
       * - `PAID`: The order is paid.
       * - `OFFLINE_PENDING`: The order is confirmed but has to be paid in cash and the status is manually updated to `PAID`.
       * - `INITIATED`: The order is awaiting for payment.
       * - `CANCELED`: The order is canceled.
       * - `DECLINED`: The order is payment is declined.
       */
      status?: OrderStatus$1[];
      /**
       * Deprecated: use tag = CONFIRMED
       * @internal
       * @deprecated
       */
      confirmed?: boolean | null;
      /** Event ID to which the order belongs. */
      eventId?: string[];
      /** Order number. */
      orderNumber?: string[];
      /** Site member ID. */
      memberId?: string[];
      /**
       * Deprecated: use tag = MEMBER
       * @internal
       * @deprecated
       */
      membersOnly?: boolean;
      /** Field facets. */
      facet?: string[];
      /**
       * Deprecated: use tag = ARCHIVED / NON_ARCHIVED
       * @internal
       * @deprecated
       */
      archived?: boolean | null;
      /** Search filter. You can search `fullName`, `email` and `orderNumber`. */
      searchPhrase?: string;
      /** Event creator ID. */
      eventCreatorId?: string[];
      /**
       * Deprecated: use tag = FULLY_CHECKED_IN / NOT_FULLY_CHECKED_IN
       * @internal
       * @deprecated
       */
      fullyCheckedIn?: boolean | null;
      /**
       * Sort order.
       * Default: `created:asc`.
       */
      sort?: string;
      /** Order tag. */
      tag?: OrderTag[];
      /** Guest contact IDs. */
      contactId?: string[];
  }
  /**
   * Retrieves an order, including ticket data.
   * <!--
   * >The fieldsets in this function are restricted and only run if you elevate permissions using the [wix-auth.elevate()](https://www.wix.com/velo/reference/wix-auth/elevate) function.
   * -->
   * @public
   * @requiredField identifiers
   * @requiredField identifiers.eventId
   * @requiredField identifiers.orderNumber
   * @param options - An object representing the available options for getting an order.
   * @param identifiers - An object containing identifiers for the order to be retrieved.
   * @permissionId WIX_EVENTS.READ_ORDERS
   * @adminMethod
   * @returns Requested order.
   */
  function getOrder(identifiers: GetOrderIdentifiers, options?: GetOrderOptions): Promise<Order>;
  interface GetOrderIdentifiers {
      /** Event ID to which the order belongs. */
      eventId: string;
      /** Unique order number. */
      orderNumber: string;
  }
  interface GetOrderOptions {
      /**
       * Predefined sets of fields to return.
       * - `TICKETS`: Returns `tickets`.
       * - `DETAILS`: Returns `reservationId`, `snapshotId`, `created`, `firstName`, `lastName`, `confirmed`, `status`, `method`, `ticketsQuantity`, `totalPrice`, `ticketsPdf`, `archived`, `fullName`.
       * - `FORM` : Returns `checkoutForm`.
       * - `INVOICE`: Returns `invoice`.
       *
       * Default: If `fieldset` is not included in the request,  `orderNumber`, `eventId`, `contactId`, `memberId`, `anonymized`, `fullyCheckedIn` are returned.
       */
      fieldset?: OrderFieldset[];
  }
  /**
   * Updates an order.
   * @public
   * @requiredField identifiers
   * @requiredField identifiers.eventId
   * @requiredField identifiers.orderNumber
   * @param options - An object representing the available options for updating an order.
   * @param identifiers - An object containing identifiers for the order to be updated.
   * @permissionId WIX_EVENTS.MANAGE_ORDERS
   * @adminMethod
   */
  function updateOrder(identifiers: UpdateOrderIdentifiers, options?: UpdateOrderOptions): Promise<UpdateOrderResponse>;
  interface UpdateOrderIdentifiers {
      /** Event ID to which the order belongs. */
      eventId: string;
      /** Unique order number. */
      orderNumber: string;
  }
  interface UpdateOrderOptions {
      /**
       * Set of field paths to update.
       * @internal
       */
      fields?: string[];
      /** Checkout form. */
      checkoutForm?: FormResponse$3;
      /** Whether order is archived. */
      archived?: boolean;
      /**
       * Only used in tests.
       * @internal
       */
      expires?: Date | null;
      /**
       * @internal
       * @deprecated
       * @targetRemovalDate 2026-06-01
       */
      silent?: boolean | null;
  }
  /**
   * Archives multiple orders.
   * @public
   * @requiredField eventId
   * @param options - An object representing the available options for confirming an order.
   * @param eventId - Event ID to which the order belongs.
   * @permissionId WIX_EVENTS.MANAGE_ORDERS
   * @adminMethod
   */
  function bulkUpdateOrders(eventId: string, options?: BulkUpdateOrdersOptions): Promise<BulkUpdateOrdersResponse>;
  interface BulkUpdateOrdersOptions {
      /** Unique order number. */
      orderNumber?: string[];
      /**
       * Set of fields to update.
       * @internal
       */
      fields?: string[];
      /** Whether to archive the order. */
      archived?: boolean;
  }
  /**
   * Confirms an order.
   *
   *
   * This function changes order status from `INITIATED`, `PENDING`, `OFFLINE_PENDING` to `PAID`.
   * Confirming orders with `INITIATED` or `PENDING` status triggers an email with the tickets to the buyer (and to additional guests, if provided).
   * @public
   * @requiredField eventId
   * @param options - An object representing the available options for confirming an order.
   * @param eventId - Event ID to which the order belongs.
   * @permissionId WIX_EVENTS.MANAGE_ORDERS
   * @adminMethod
   */
  function confirmOrder(eventId: string, options?: ConfirmOrderOptions): Promise<ConfirmOrderResponse>;
  interface ConfirmOrderOptions {
      /** Order numbers. */
      orderNumber?: string[];
  }
  /**
   * Retrieves a summary of total ticket sales.
   * <!--
   * > Note: This function is restricted and only runs if you elevate permissions using the [wix-auth.elevate()](https://www.wix.com/velo/reference/wix-auth/elevate) function.
   * -->
   * @public
   * @param options - An object representing the available options for retrieving a summary of total ticket sales.
   * @permissionId WIX_EVENTS.READ_ORDERS
   * @adminMethod
   */
  function getSummary(options?: GetSummaryOptions): Promise<GetSummaryResponse>;
  interface GetSummaryOptions {
      /** Event ID. */
      eventId?: string | null;
  }
  /**
   * Returns invoice preview. Works only for PAID orders.
   * @internal
   * @requiredField identifiers
   * @requiredField identifiers.eventId
   * @requiredField identifiers.orderNumber
   * @permissionId WIX_EVENTS.READ_ORDERS
   * @adminMethod
   */
  function getInvoicePreview(identifiers: GetInvoicePreviewIdentifiers): Promise<RawHttpResponse>;
  interface GetInvoicePreviewIdentifiers {
      /** Event ID to which the invoice belongs. */
      eventId: string;
      /** Order number. */
      orderNumber: string;
  }
  /**
   * Captures authorized payment asynchronously.
   * Eventually order will become paid.
   * For orders with non-authorized payments request will fail.
   * @param orderNumber - Order number.
   * @public
   * @documentationMaturity preview
   * @requiredField orderNumber
   * @permissionId WIX_EVENTS.MANAGE_ORDERS
   * @adminMethod
   */
  function captureAuthorizedPayment(orderNumber: string, options?: CaptureAuthorizedPaymentOptions): Promise<void>;
  interface CaptureAuthorizedPaymentOptions {
      /** Event ID. */
      eventId?: string;
  }
  /**
   * Voids authorized payment asynchronously.
   * Eventually order will become voided.
   * For orders with non-authorized payments request will fail.
   * @param orderNumber - Order number.
   * @public
   * @documentationMaturity preview
   * @requiredField orderNumber
   * @permissionId WIX_EVENTS.MANAGE_ORDERS
   * @adminMethod
   */
  function voidAuthorizedPayment(orderNumber: string, options?: VoidAuthorizedPaymentOptions): Promise<void>;
  interface VoidAuthorizedPaymentOptions {
      /** Event ID. */
      eventId?: string;
  }
  /**
   * Retrieves checkout details.
   * @public
   * @permissionId WIX_EVENTS.READ_CHECKOUT
   */
  function getCheckoutOptions(): Promise<GetCheckoutOptionsResponse>;
  /**
   * Returns tickets available to reserve.
   * <!--
   * > Note: This function is restricted and only runs if you elevate permissions using the [wix-auth.elevate()](https://www.wix.com/velo/reference/wix-auth/elevate) function.
   * -->
   * @public
   * @param options - An object representing the available options for retrieving a list of tickets available for reservation.
   * @permissionId WIX_EVENTS.READ_CHECKOUT
   */
  function listAvailableTickets(options?: ListAvailableTicketsOptions): Promise<ListAvailableTicketsResponse>;
  interface ListAvailableTicketsOptions {
      /** Event ID. If not provided, available tickets for all events in the site will be returned. */
      eventId?: string;
      /** Offset. */
      offset?: number;
      /** Limit. */
      limit?: number;
      /**
       * Sort order.
       * Default: `created:asc`.
       */
      sort?: string;
      /**
       * Only used in tests.
       * @internal
       */
      overrideRequestTime?: Date | null;
      state?: State$5[];
  }
  /**
   * Returns tickets available to reserve.
   * <!--
   * > Note: The fieldsets in this function are restricted and only run if you elevate permissions using the [wix-auth.elevate()](https://www.wix.com/velo/reference/wix-auth/elevate) function.
   * -->
   * @public
   * @param options - An object representing the available options for retrieving a list of tickets available for reservation.
   * @permissionId WIX_EVENTS.READ_CHECKOUT
   */
  function queryAvailableTickets(options?: QueryAvailableTicketsOptions): Promise<QueryAvailableTicketsResponse>;
  interface QueryAvailableTicketsOptions {
      /** Offset. */
      offset?: number;
      /** Limit. */
      limit?: number;
      /** Ticket definition. */
      filter?: Record<string, any> | null;
      fieldset?: TicketDefinitionFieldset$1[];
      /**
       * Sort order.
       * Default: `created:asc`.
       */
      sort?: string;
  }
  /**
   * Reserves tickets for 20 minutes.
   *
   *
   * Reserved tickets are deducted from ticket stock and cannot be bought by another site visitor.
   * When the reservation expires, the tickets are added back to the stock.
   * @public
   * @requiredField eventId
   * @param options - An object representing the available options for creating a reservation.
   * @param eventId - Event ID to which the reservation belongs.
   * @permissionId WIX_EVENTS.CHECKOUT
   */
  function createReservation(eventId: string, options?: CreateReservationOptions): Promise<CreateReservationResponse>;
  interface CreateReservationOptions {
      /** Tickets to reserve. */
      ticketQuantities?: TicketReservationQuantity[];
      /** Whether to ignore the available ticket limits upon reservation. */
      ignoreLimits?: boolean;
      /**
       * Only used in tests.
       * @internal
       */
      overrideRequestTime?: Date | null;
      /** Whether to allow reservation for hidden tickets. */
      allowHiddenTickets?: boolean;
      /**
       * Whether to exclude Wix fee.
       * @internal
       */
      excludeFee?: boolean;
      /**
       * Whether to skip `ticketQuantities.ticketDetails.priceOverride` min validation.
       * @internal
       */
      skipPriceOverrideValidation?: boolean;
  }
  /**
   * Cancels ticket reservation and returns tickets to stock.
   * <!--
   * > Note: This function is restricted and only runs if you elevate permissions using the [wix-auth.elevate()](https://www.wix.com/velo/reference/wix-auth/elevate) function.
   * -->
   * @param _id - Reservation ID.
   * @public
   * @requiredField _id
   * @requiredField eventId
   * @param identifiers - An object containing identifiers for the reservation to be cancelled.
   * @param eventId - Event ID to which the reservation belongs.
   * @permissionId WIX_EVENTS.CHECKOUT
   */
  function cancelReservation(_id: string, eventId: string): Promise<void>;
  /**
   * Generates a preview of an invoice, including the given coupon or pricing plan.
   * @param reservationId - Reservation ID.
   * @public
   * @requiredField eventId
   * @requiredField reservationId
   * @param options - An object representing the available options for generating a preview of a reservation invoice.
   * @param identifiers - An object containing identifiers for the reservation invoice preview to be generated.
   * @param eventId - Event ID to which the invoice belongs.
   * @permissionId WIX_EVENTS.READ_INVOICE
   */
  function getInvoice(reservationId: string, eventId: string, options?: GetInvoiceOptions): Promise<GetInvoiceResponse>;
  interface GetInvoiceOptions {
      /** Optional discount to be applied on the returned invoice. */
      withDiscount?: DiscountRequest;
      /** Optional benefit granted by the pricing plan to be applied on the returned invoice. */
      paidPlanBenefit?: PaidPlanBenefit;
      /**
       * Gift card code.
       * @internal
       */
      giftCardCode?: string | null;
  }
  /**
   * Checkouts the reserved tickets.
   *
   *
   * Creates an order and associates it with a site visitor contact.
   * Guest details are received from the [Registration Form](https://www.wix.com/velo/reference/wix-events-v2/forms/introduction) input fields.
   *
   * There is a possibility to use a separate ready-made Wix checkout form where the user will be redirected from your non-Wix site or a custom ticket picker created with Velo.
   * To build the checkout form path, get your event base URL by using the [`getEvent()`](https://www.wix.com/velo/reference/wix-events-backend/wixevents/getevent) function and add the following path:
   * `/{{EVENT_PAGE_SLUG}}/{{SLUG}}/ticket-form?reservationId={{YOUR_RESERVATION_ID}}`
   *
   * Example:  `https://johndoe.wixsite.com/weddings/event-details/doe-wedding/ticket-form?reservationId=2be6d34a-2a1e-459f-897b-b4a66e73f69a`
   * @public
   * @requiredField eventId
   * @requiredField options.guests.form
   * @param options - An object representing the available options for checking out a reserved ticket.
   * @param eventId - Event ID to which the checkout belongs.
   * @permissionId WIX_EVENTS.CHECKOUT
   */
  function checkout(eventId: string, options?: CheckoutOptionsForRequest): Promise<CheckoutResponse>;
  interface CheckoutOptionsForRequest {
      /** Ticket reservation ID. */
      reservationId?: string;
      /** Member ID (if empty - no site member is associated to this order). */
      memberId?: string;
      /** Discount to apply on the invoice. */
      discount?: DiscountRequest;
      /**
       * Deprecated.
       * @internal
       * @deprecated
       */
      silent?: boolean;
      /**
       * Deprecated.
       * @internal
       * @deprecated
       */
      payInPerson?: boolean;
      /** Buyer details. */
      buyer?: Buyer;
      /** Guest details. */
      guests?: Guest$2[];
      /** Benefit granted by the pricing plan. */
      paidPlanBenefit?: PaidPlanBenefit;
      /** Options controlling the checkout process. */
      options?: CheckoutOptions;
      /**
       * Only used in tests.
       * @internal
       */
      overrideRequestTime?: Date | null;
      /**
       * Gift card code.
       * @internal
       */
      giftCardCode?: string | null;
  }
  /**
   * Updates order and tickets.
   *
   *
   * Only applicable for orders with `INITIATED`, `PENDING`, `OFFLINE_PENDING` statuses.
   * @param orderNumber - Unique order number.
   * @public
   * @requiredField eventId
   * @requiredField orderNumber
   * @param options - An object representing the available options for updating an order and tickets.
   * @param identifiers - An object containing identifiers for the order and tickets to be updated.
   * @param eventId - Event ID to which the checkout belongs.
   * @permissionId WIX_EVENTS.CHECKOUT
   */
  function updateCheckout(orderNumber: string, eventId: string, options?: UpdateCheckoutOptions): Promise<UpdateCheckoutResponse>;
  interface UpdateCheckoutOptions {
      /** Buyer details. */
      buyer?: Buyer;
      /** Guest details. */
      guests?: Guest$2[];
      /** Member ID (if empty - no site member is associated to this order). */
      memberId?: string | null;
      /** Discount to apply on the invoice. */
      discount?: DiscountRequest;
      /** Benefit granted by the pricing plan. */
      paidPlanBenefit?: PaidPlanBenefit;
      /**
       * Payment details id.
       * @internal
       */
      paymentDetailsId?: string | null;
      /**
       * Payment method.
       * @internal
       */
      paymentMethod?: string | null;
      /**
       * Gift card code.
       * @internal
       */
      giftCardCode?: string | null;
  }
  /**
   * Creates order with payment details already initiated via Cashier Pay API.
   * @public
   * @requiredField eventId
   * @requiredField options.reservationId
   * @param eventId - Event ID to which the checkout belongs.
   * @permissionId WIX_EVENTS.MANAGE_ORDERS
   * @adminMethod
   */
  function posCheckout(eventId: string, options?: PosCheckoutOptions): Promise<PosCheckoutResponse>;
  interface PosCheckoutOptions {
      /** Ticket reservation ID. */
      reservationId: string;
      /**
       * Payment details ID.
       * Not required if reservation total is 0. In this case the order will be created with status Free and no payment.
       */
      paymentDetailsId?: string | null;
  }
  
  type eventsV1Order_universal_d_Order = Order;
  type eventsV1Order_universal_d_Invoice = Invoice;
  type eventsV1Order_universal_d_Discount = Discount;
  type eventsV1Order_universal_d_DiscountItem = DiscountItem;
  type eventsV1Order_universal_d_DiscountItemDiscountOneOf = DiscountItemDiscountOneOf;
  type eventsV1Order_universal_d_CouponDiscount = CouponDiscount;
  type eventsV1Order_universal_d_PaidPlanDiscount = PaidPlanDiscount;
  type eventsV1Order_universal_d_PaidPlanDiscountDiscountOneOf = PaidPlanDiscountDiscountOneOf;
  type eventsV1Order_universal_d_PercentDiscount = PercentDiscount;
  type eventsV1Order_universal_d_Tax = Tax;
  type eventsV1Order_universal_d_Fee = Fee;
  type eventsV1Order_universal_d_FeeName = FeeName;
  const eventsV1Order_universal_d_FeeName: typeof FeeName;
  type eventsV1Order_universal_d_PaymentDetails = PaymentDetails;
  type eventsV1Order_universal_d_PaymentTransaction = PaymentTransaction;
  type eventsV1Order_universal_d_ScheduledActionEnumAction = ScheduledActionEnumAction;
  const eventsV1Order_universal_d_ScheduledActionEnumAction: typeof ScheduledActionEnumAction;
  type eventsV1Order_universal_d_Action = Action;
  const eventsV1Order_universal_d_Action: typeof Action;
  type eventsV1Order_universal_d_GiftCardPaymentDetails = GiftCardPaymentDetails;
  type eventsV1Order_universal_d_BalanceSummary = BalanceSummary;
  type eventsV1Order_universal_d_OrderDeleted = OrderDeleted;
  type eventsV1Order_universal_d_OrderType = OrderType;
  const eventsV1Order_universal_d_OrderType: typeof OrderType;
  type eventsV1Order_universal_d_ListOrdersRequest = ListOrdersRequest;
  type eventsV1Order_universal_d_OrderFieldset = OrderFieldset;
  const eventsV1Order_universal_d_OrderFieldset: typeof OrderFieldset;
  type eventsV1Order_universal_d_OrderTag = OrderTag;
  const eventsV1Order_universal_d_OrderTag: typeof OrderTag;
  type eventsV1Order_universal_d_ListOrdersResponse = ListOrdersResponse;
  type eventsV1Order_universal_d_OrderFacets = OrderFacets;
  type eventsV1Order_universal_d_OrderFacetCounts = OrderFacetCounts;
  type eventsV1Order_universal_d_GetOrderRequest = GetOrderRequest;
  type eventsV1Order_universal_d_GetOrderResponse = GetOrderResponse;
  type eventsV1Order_universal_d_UpdateOrderRequest = UpdateOrderRequest;
  type eventsV1Order_universal_d_UpdateOrderResponse = UpdateOrderResponse;
  type eventsV1Order_universal_d_BulkUpdateOrdersRequest = BulkUpdateOrdersRequest;
  type eventsV1Order_universal_d_BulkUpdateOrdersResponse = BulkUpdateOrdersResponse;
  type eventsV1Order_universal_d_ConfirmOrderRequest = ConfirmOrderRequest;
  type eventsV1Order_universal_d_ConfirmOrderResponse = ConfirmOrderResponse;
  type eventsV1Order_universal_d_GetSummaryRequest = GetSummaryRequest;
  type eventsV1Order_universal_d_GetSummaryResponse = GetSummaryResponse;
  type eventsV1Order_universal_d_TicketSales = TicketSales;
  type eventsV1Order_universal_d_GetInvoicePreviewRequest = GetInvoicePreviewRequest;
  type eventsV1Order_universal_d_RawHttpResponse = RawHttpResponse;
  type eventsV1Order_universal_d_HeadersEntry = HeadersEntry;
  type eventsV1Order_universal_d_GetPaymentInfoRequest = GetPaymentInfoRequest;
  type eventsV1Order_universal_d_GetPaymentInfoResponse = GetPaymentInfoResponse;
  type eventsV1Order_universal_d_PaymentTransactionSummary = PaymentTransactionSummary;
  type eventsV1Order_universal_d_PaymentTransactionEvent = PaymentTransactionEvent;
  type eventsV1Order_universal_d_CaptureAuthorizedPaymentRequest = CaptureAuthorizedPaymentRequest;
  type eventsV1Order_universal_d_CaptureAuthorizedPaymentResponse = CaptureAuthorizedPaymentResponse;
  type eventsV1Order_universal_d_VoidAuthorizedPaymentRequest = VoidAuthorizedPaymentRequest;
  type eventsV1Order_universal_d_VoidAuthorizedPaymentResponse = VoidAuthorizedPaymentResponse;
  type eventsV1Order_universal_d_OrderConfirmed = OrderConfirmed;
  type eventsV1Order_universal_d_OrderPaid = OrderPaid;
  type eventsV1Order_universal_d_GetCheckoutOptionsRequest = GetCheckoutOptionsRequest;
  type eventsV1Order_universal_d_GetCheckoutOptionsResponse = GetCheckoutOptionsResponse;
  type eventsV1Order_universal_d_ListAvailableTicketsRequest = ListAvailableTicketsRequest;
  type eventsV1Order_universal_d_ListAvailableTicketsResponse = ListAvailableTicketsResponse;
  type eventsV1Order_universal_d_QueryAvailableTicketsRequest = QueryAvailableTicketsRequest;
  type eventsV1Order_universal_d_QueryAvailableTicketsResponse = QueryAvailableTicketsResponse;
  type eventsV1Order_universal_d_CreateReservationRequest = CreateReservationRequest;
  type eventsV1Order_universal_d_TicketReservationQuantity = TicketReservationQuantity;
  type eventsV1Order_universal_d_CreateReservationResponse = CreateReservationResponse;
  type eventsV1Order_universal_d_TicketReservation = TicketReservation;
  type eventsV1Order_universal_d_CancelReservationRequest = CancelReservationRequest;
  type eventsV1Order_universal_d_CancelReservationResponse = CancelReservationResponse;
  type eventsV1Order_universal_d_GetInvoiceRequest = GetInvoiceRequest;
  type eventsV1Order_universal_d_DiscountRequest = DiscountRequest;
  type eventsV1Order_universal_d_PaidPlanBenefit = PaidPlanBenefit;
  type eventsV1Order_universal_d_GetInvoiceResponse = GetInvoiceResponse;
  type eventsV1Order_universal_d_DiscountErrors = DiscountErrors;
  type eventsV1Order_universal_d_Error = Error;
  type eventsV1Order_universal_d_GiftCardErrors = GiftCardErrors;
  type eventsV1Order_universal_d_GiftCardErrorsError = GiftCardErrorsError;
  type eventsV1Order_universal_d_CheckoutRequest = CheckoutRequest;
  type eventsV1Order_universal_d_Buyer = Buyer;
  type eventsV1Order_universal_d_CheckoutOptions = CheckoutOptions;
  type eventsV1Order_universal_d_CheckoutResponse = CheckoutResponse;
  type eventsV1Order_universal_d_OrderInitiated = OrderInitiated;
  type eventsV1Order_universal_d_UpdateCheckoutRequest = UpdateCheckoutRequest;
  type eventsV1Order_universal_d_UpdateCheckoutResponse = UpdateCheckoutResponse;
  type eventsV1Order_universal_d_OrderPageUrls = OrderPageUrls;
  type eventsV1Order_universal_d_PosCheckoutRequest = PosCheckoutRequest;
  type eventsV1Order_universal_d_PosCheckoutResponse = PosCheckoutResponse;
  const eventsV1Order_universal_d_listOrders: typeof listOrders;
  type eventsV1Order_universal_d_ListOrdersOptions = ListOrdersOptions;
  const eventsV1Order_universal_d_getOrder: typeof getOrder;
  type eventsV1Order_universal_d_GetOrderIdentifiers = GetOrderIdentifiers;
  type eventsV1Order_universal_d_GetOrderOptions = GetOrderOptions;
  const eventsV1Order_universal_d_updateOrder: typeof updateOrder;
  type eventsV1Order_universal_d_UpdateOrderIdentifiers = UpdateOrderIdentifiers;
  type eventsV1Order_universal_d_UpdateOrderOptions = UpdateOrderOptions;
  const eventsV1Order_universal_d_bulkUpdateOrders: typeof bulkUpdateOrders;
  type eventsV1Order_universal_d_BulkUpdateOrdersOptions = BulkUpdateOrdersOptions;
  const eventsV1Order_universal_d_confirmOrder: typeof confirmOrder;
  type eventsV1Order_universal_d_ConfirmOrderOptions = ConfirmOrderOptions;
  const eventsV1Order_universal_d_getSummary: typeof getSummary;
  type eventsV1Order_universal_d_GetSummaryOptions = GetSummaryOptions;
  const eventsV1Order_universal_d_getInvoicePreview: typeof getInvoicePreview;
  type eventsV1Order_universal_d_GetInvoicePreviewIdentifiers = GetInvoicePreviewIdentifiers;
  const eventsV1Order_universal_d_captureAuthorizedPayment: typeof captureAuthorizedPayment;
  type eventsV1Order_universal_d_CaptureAuthorizedPaymentOptions = CaptureAuthorizedPaymentOptions;
  const eventsV1Order_universal_d_voidAuthorizedPayment: typeof voidAuthorizedPayment;
  type eventsV1Order_universal_d_VoidAuthorizedPaymentOptions = VoidAuthorizedPaymentOptions;
  const eventsV1Order_universal_d_getCheckoutOptions: typeof getCheckoutOptions;
  const eventsV1Order_universal_d_listAvailableTickets: typeof listAvailableTickets;
  type eventsV1Order_universal_d_ListAvailableTicketsOptions = ListAvailableTicketsOptions;
  const eventsV1Order_universal_d_queryAvailableTickets: typeof queryAvailableTickets;
  type eventsV1Order_universal_d_QueryAvailableTicketsOptions = QueryAvailableTicketsOptions;
  const eventsV1Order_universal_d_createReservation: typeof createReservation;
  type eventsV1Order_universal_d_CreateReservationOptions = CreateReservationOptions;
  const eventsV1Order_universal_d_cancelReservation: typeof cancelReservation;
  const eventsV1Order_universal_d_getInvoice: typeof getInvoice;
  type eventsV1Order_universal_d_GetInvoiceOptions = GetInvoiceOptions;
  const eventsV1Order_universal_d_checkout: typeof checkout;
  type eventsV1Order_universal_d_CheckoutOptionsForRequest = CheckoutOptionsForRequest;
  const eventsV1Order_universal_d_updateCheckout: typeof updateCheckout;
  type eventsV1Order_universal_d_UpdateCheckoutOptions = UpdateCheckoutOptions;
  const eventsV1Order_universal_d_posCheckout: typeof posCheckout;
  type eventsV1Order_universal_d_PosCheckoutOptions = PosCheckoutOptions;
  namespace eventsV1Order_universal_d {
    export {
      eventsV1Order_universal_d_Order as Order,
      FormResponse$3 as FormResponse,
      InputValue$3 as InputValue,
      FormattedAddress$3 as FormattedAddress,
      Address$7 as Address,
      AddressStreetOneOf$7 as AddressStreetOneOf,
      StreetAddress$7 as StreetAddress,
      AddressLocation$7 as AddressLocation,
      Subdivision$7 as Subdivision,
      SubdivisionType$7 as SubdivisionType,
      StandardDetails$3 as StandardDetails,
      OrderStatus$1 as OrderStatus,
      Money$5 as Money,
      TicketingTicket$1 as TicketingTicket,
      CheckIn$2 as CheckIn,
      GuestDetails$1 as GuestDetails,
      ChannelType$1 as ChannelType,
      TicketDetails$1 as TicketDetails,
      eventsV1Order_universal_d_Invoice as Invoice,
      Item$1 as Item,
      eventsV1Order_universal_d_Discount as Discount,
      eventsV1Order_universal_d_DiscountItem as DiscountItem,
      eventsV1Order_universal_d_DiscountItemDiscountOneOf as DiscountItemDiscountOneOf,
      eventsV1Order_universal_d_CouponDiscount as CouponDiscount,
      eventsV1Order_universal_d_PaidPlanDiscount as PaidPlanDiscount,
      eventsV1Order_universal_d_PaidPlanDiscountDiscountOneOf as PaidPlanDiscountDiscountOneOf,
      eventsV1Order_universal_d_PercentDiscount as PercentDiscount,
      eventsV1Order_universal_d_Tax as Tax,
      TaxType$3 as TaxType,
      eventsV1Order_universal_d_Fee as Fee,
      eventsV1Order_universal_d_FeeName as FeeName,
      FeeType$1 as FeeType,
      eventsV1Order_universal_d_PaymentDetails as PaymentDetails,
      eventsV1Order_universal_d_PaymentTransaction as PaymentTransaction,
      eventsV1Order_universal_d_ScheduledActionEnumAction as ScheduledActionEnumAction,
      eventsV1Order_universal_d_Action as Action,
      eventsV1Order_universal_d_GiftCardPaymentDetails as GiftCardPaymentDetails,
      eventsV1Order_universal_d_BalanceSummary as BalanceSummary,
      eventsV1Order_universal_d_OrderDeleted as OrderDeleted,
      eventsV1Order_universal_d_OrderType as OrderType,
      Ticket$1 as Ticket,
      OnlineConferencingLogin$3 as OnlineConferencingLogin,
      eventsV1Order_universal_d_ListOrdersRequest as ListOrdersRequest,
      eventsV1Order_universal_d_OrderFieldset as OrderFieldset,
      eventsV1Order_universal_d_OrderTag as OrderTag,
      eventsV1Order_universal_d_ListOrdersResponse as ListOrdersResponse,
      FacetCounts$5 as FacetCounts,
      eventsV1Order_universal_d_OrderFacets as OrderFacets,
      eventsV1Order_universal_d_OrderFacetCounts as OrderFacetCounts,
      Counts$2 as Counts,
      eventsV1Order_universal_d_GetOrderRequest as GetOrderRequest,
      eventsV1Order_universal_d_GetOrderResponse as GetOrderResponse,
      CalendarLinks$4 as CalendarLinks,
      eventsV1Order_universal_d_UpdateOrderRequest as UpdateOrderRequest,
      eventsV1Order_universal_d_UpdateOrderResponse as UpdateOrderResponse,
      OrderUpdated$1 as OrderUpdated,
      eventsV1Order_universal_d_BulkUpdateOrdersRequest as BulkUpdateOrdersRequest,
      eventsV1Order_universal_d_BulkUpdateOrdersResponse as BulkUpdateOrdersResponse,
      eventsV1Order_universal_d_ConfirmOrderRequest as ConfirmOrderRequest,
      eventsV1Order_universal_d_ConfirmOrderResponse as ConfirmOrderResponse,
      eventsV1Order_universal_d_GetSummaryRequest as GetSummaryRequest,
      eventsV1Order_universal_d_GetSummaryResponse as GetSummaryResponse,
      eventsV1Order_universal_d_TicketSales as TicketSales,
      eventsV1Order_universal_d_GetInvoicePreviewRequest as GetInvoicePreviewRequest,
      eventsV1Order_universal_d_RawHttpResponse as RawHttpResponse,
      eventsV1Order_universal_d_HeadersEntry as HeadersEntry,
      eventsV1Order_universal_d_GetPaymentInfoRequest as GetPaymentInfoRequest,
      eventsV1Order_universal_d_GetPaymentInfoResponse as GetPaymentInfoResponse,
      eventsV1Order_universal_d_PaymentTransactionSummary as PaymentTransactionSummary,
      eventsV1Order_universal_d_PaymentTransactionEvent as PaymentTransactionEvent,
      eventsV1Order_universal_d_CaptureAuthorizedPaymentRequest as CaptureAuthorizedPaymentRequest,
      eventsV1Order_universal_d_CaptureAuthorizedPaymentResponse as CaptureAuthorizedPaymentResponse,
      eventsV1Order_universal_d_VoidAuthorizedPaymentRequest as VoidAuthorizedPaymentRequest,
      eventsV1Order_universal_d_VoidAuthorizedPaymentResponse as VoidAuthorizedPaymentResponse,
      MessageEnvelope$8 as MessageEnvelope,
      IdentificationData$8 as IdentificationData,
      IdentificationDataIdOneOf$8 as IdentificationDataIdOneOf,
      WebhookIdentityType$8 as WebhookIdentityType,
      eventsV1Order_universal_d_OrderConfirmed as OrderConfirmed,
      eventsV1Order_universal_d_OrderPaid as OrderPaid,
      ReservationCreated$1 as ReservationCreated,
      ReservationStatus$1 as ReservationStatus,
      TicketQuantity$1 as TicketQuantity,
      ReservationCount$1 as ReservationCount,
      ReservationUpdated$1 as ReservationUpdated,
      eventsV1Order_universal_d_GetCheckoutOptionsRequest as GetCheckoutOptionsRequest,
      eventsV1Order_universal_d_GetCheckoutOptionsResponse as GetCheckoutOptionsResponse,
      eventsV1Order_universal_d_ListAvailableTicketsRequest as ListAvailableTicketsRequest,
      State$5 as State,
      eventsV1Order_universal_d_ListAvailableTicketsResponse as ListAvailableTicketsResponse,
      ResponseMetaData$1 as ResponseMetaData,
      TicketDefinition$2 as TicketDefinition,
      Dashboard$4 as Dashboard,
      WixFeeConfig$1 as WixFeeConfig,
      TicketSalePeriod$1 as TicketSalePeriod,
      TicketSaleStatus$1 as TicketSaleStatus,
      TicketPricing$1 as TicketPricing,
      TicketPricingPriceOneOf$1 as TicketPricingPriceOneOf,
      PricingOptions$2 as PricingOptions,
      PricingOption$1 as PricingOption,
      Type$4 as Type,
      eventsV1Order_universal_d_QueryAvailableTicketsRequest as QueryAvailableTicketsRequest,
      TicketDefinitionFieldset$1 as TicketDefinitionFieldset,
      eventsV1Order_universal_d_QueryAvailableTicketsResponse as QueryAvailableTicketsResponse,
      eventsV1Order_universal_d_CreateReservationRequest as CreateReservationRequest,
      eventsV1Order_universal_d_TicketReservationQuantity as TicketReservationQuantity,
      eventsV1Order_universal_d_CreateReservationResponse as CreateReservationResponse,
      eventsV1Order_universal_d_TicketReservation as TicketReservation,
      eventsV1Order_universal_d_CancelReservationRequest as CancelReservationRequest,
      eventsV1Order_universal_d_CancelReservationResponse as CancelReservationResponse,
      eventsV1Order_universal_d_GetInvoiceRequest as GetInvoiceRequest,
      eventsV1Order_universal_d_DiscountRequest as DiscountRequest,
      eventsV1Order_universal_d_PaidPlanBenefit as PaidPlanBenefit,
      eventsV1Order_universal_d_GetInvoiceResponse as GetInvoiceResponse,
      eventsV1Order_universal_d_DiscountErrors as DiscountErrors,
      eventsV1Order_universal_d_Error as Error,
      eventsV1Order_universal_d_GiftCardErrors as GiftCardErrors,
      eventsV1Order_universal_d_GiftCardErrorsError as GiftCardErrorsError,
      eventsV1Order_universal_d_CheckoutRequest as CheckoutRequest,
      eventsV1Order_universal_d_Buyer as Buyer,
      Guest$2 as Guest,
      eventsV1Order_universal_d_CheckoutOptions as CheckoutOptions,
      eventsV1Order_universal_d_CheckoutResponse as CheckoutResponse,
      eventsV1Order_universal_d_OrderInitiated as OrderInitiated,
      eventsV1Order_universal_d_UpdateCheckoutRequest as UpdateCheckoutRequest,
      eventsV1Order_universal_d_UpdateCheckoutResponse as UpdateCheckoutResponse,
      eventsV1Order_universal_d_OrderPageUrls as OrderPageUrls,
      eventsV1Order_universal_d_PosCheckoutRequest as PosCheckoutRequest,
      eventsV1Order_universal_d_PosCheckoutResponse as PosCheckoutResponse,
      eventsV1Order_universal_d_listOrders as listOrders,
      eventsV1Order_universal_d_ListOrdersOptions as ListOrdersOptions,
      eventsV1Order_universal_d_getOrder as getOrder,
      eventsV1Order_universal_d_GetOrderIdentifiers as GetOrderIdentifiers,
      eventsV1Order_universal_d_GetOrderOptions as GetOrderOptions,
      eventsV1Order_universal_d_updateOrder as updateOrder,
      eventsV1Order_universal_d_UpdateOrderIdentifiers as UpdateOrderIdentifiers,
      eventsV1Order_universal_d_UpdateOrderOptions as UpdateOrderOptions,
      eventsV1Order_universal_d_bulkUpdateOrders as bulkUpdateOrders,
      eventsV1Order_universal_d_BulkUpdateOrdersOptions as BulkUpdateOrdersOptions,
      eventsV1Order_universal_d_confirmOrder as confirmOrder,
      eventsV1Order_universal_d_ConfirmOrderOptions as ConfirmOrderOptions,
      eventsV1Order_universal_d_getSummary as getSummary,
      eventsV1Order_universal_d_GetSummaryOptions as GetSummaryOptions,
      eventsV1Order_universal_d_getInvoicePreview as getInvoicePreview,
      eventsV1Order_universal_d_GetInvoicePreviewIdentifiers as GetInvoicePreviewIdentifiers,
      eventsV1Order_universal_d_captureAuthorizedPayment as captureAuthorizedPayment,
      eventsV1Order_universal_d_CaptureAuthorizedPaymentOptions as CaptureAuthorizedPaymentOptions,
      eventsV1Order_universal_d_voidAuthorizedPayment as voidAuthorizedPayment,
      eventsV1Order_universal_d_VoidAuthorizedPaymentOptions as VoidAuthorizedPaymentOptions,
      eventsV1Order_universal_d_getCheckoutOptions as getCheckoutOptions,
      eventsV1Order_universal_d_listAvailableTickets as listAvailableTickets,
      eventsV1Order_universal_d_ListAvailableTicketsOptions as ListAvailableTicketsOptions,
      eventsV1Order_universal_d_queryAvailableTickets as queryAvailableTickets,
      eventsV1Order_universal_d_QueryAvailableTicketsOptions as QueryAvailableTicketsOptions,
      eventsV1Order_universal_d_createReservation as createReservation,
      eventsV1Order_universal_d_CreateReservationOptions as CreateReservationOptions,
      eventsV1Order_universal_d_cancelReservation as cancelReservation,
      eventsV1Order_universal_d_getInvoice as getInvoice,
      eventsV1Order_universal_d_GetInvoiceOptions as GetInvoiceOptions,
      eventsV1Order_universal_d_checkout as checkout,
      eventsV1Order_universal_d_CheckoutOptionsForRequest as CheckoutOptionsForRequest,
      eventsV1Order_universal_d_updateCheckout as updateCheckout,
      eventsV1Order_universal_d_UpdateCheckoutOptions as UpdateCheckoutOptions,
      eventsV1Order_universal_d_posCheckout as posCheckout,
      eventsV1Order_universal_d_PosCheckoutOptions as PosCheckoutOptions,
    };
  }
  
  interface RichContent {
      /**
       * Rich content ID.
       * @readonly
       */
      _id?: string | null;
      /**
       * Revision number, which increments by 1 each time the rich content is updated. To prevent conflicting changes, the existing revision must be used when updating rich content.
       * @readonly
       */
      revision?: string | null;
      /**
       * Date and time when rich content was created.
       * @readonly
       */
      _createdDate?: Date | null;
      /**
       * Date and time the rich content was updated.
       * @readonly
       */
      _updatedDate?: Date | null;
      /** ID of the event to which rich content is applied. */
      eventId?: string | null;
      /** Field name whose value uses rich content. For the event description, specify the `about` value. */
      fieldName?: string | null;
      /**
       * Rich content of the event description.
       *
       * <widget src="https://apps.wix.com/_serverless/ricos-playground-services/goto/api-component" plugins="video.spoiler.linkPreview.link.lineSpacing.indent.image.html.heading.hashtag.giphy.gallery.file.emoji.divider.collapsibleList.codeBlock.audio.ai" exampleid="6ff78d07-c535-4602-b50d-6f06055f4148">
       * <a href="https://dev.wix.com/docs/ricos/api-reference/ricos-document">See Ricos document reference</a>
       * </widget>
       */
      content?: V1RichContent;
      /**
       * Custom field data for the rich content object.
       *
       * **Note:** You must configure extended fields using schema plugin extensions in your app's dashboard before you can access the extended fields with API calls.
       */
      extendedFields?: ExtendedFields$2;
  }
  interface V1RichContent {
      /** Node objects representing a rich content document. */
      nodes?: Node[];
      /** Object metadata. */
      metadata?: Metadata;
      /** Global styling for header, paragraph, block quote, and code block nodes in the object. */
      documentStyle?: DocumentStyle;
  }
  interface Node extends NodeDataOneOf {
      /** Data for a button node. */
      buttonData?: ButtonData;
      /** Data for a code block node. */
      codeBlockData?: CodeBlockData;
      /** Data for a divider node. */
      dividerData?: DividerData;
      /** Data for a file node. */
      fileData?: FileData;
      /** Data for a gallery node. */
      galleryData?: GalleryData;
      /** Data for a GIF node. */
      gifData?: GIFData;
      /** Data for a heading node. */
      headingData?: HeadingData;
      /** Data for an embedded HTML node. */
      htmlData?: HTMLData;
      /** Data for an image node. */
      imageData?: ImageData;
      /** Data for a link preview node. */
      linkPreviewData?: LinkPreviewData;
      /** Data for a map node. */
      mapData?: MapData;
      /** Data for a paragraph node. */
      paragraphData?: ParagraphData;
      /** Data for a poll node. */
      pollData?: PollData;
      /** Data for a text node. Used to apply decorations to text. */
      textData?: TextData;
      /** Data for an app embed node. */
      appEmbedData?: AppEmbedData;
      /** Data for a video node. */
      videoData?: VideoData;
      /** Data for an oEmbed node. */
      embedData?: EmbedData;
      /** Data for a collapsible list node. */
      collapsibleListData?: CollapsibleListData;
      /** Data for a table node. */
      tableData?: TableData;
      /** Data for a table cell node. */
      tableCellData?: TableCellData;
      /** Data for a custom external node. */
      externalData?: Record<string, any> | null;
      /** Data for an audio node. */
      audioData?: AudioData;
      /** Data for an ordered list node. */
      orderedListData?: OrderedListData;
      /** Data for a bulleted list node. */
      bulletedListData?: BulletedListData;
      /** Data for a block quote node. */
      blockquoteData?: BlockquoteData;
      /** Data for a caption node. */
      captionData?: CaptionData;
      /** Node type. Use `APP_EMBED` for nodes that embed content from other Wix apps. Use `EMBED` to embed content in [oEmbed](https://oembed.com/) format. */
      type?: NodeType;
      /** Node ID. */
      _id?: string;
      /** A list of child nodes. */
      nodes?: Node[];
      /** Padding and background color styling for the node. */
      style?: NodeStyle;
  }
  /** @oneof */
  interface NodeDataOneOf {
      /** Data for a button node. */
      buttonData?: ButtonData;
      /** Data for a code block node. */
      codeBlockData?: CodeBlockData;
      /** Data for a divider node. */
      dividerData?: DividerData;
      /** Data for a file node. */
      fileData?: FileData;
      /** Data for a gallery node. */
      galleryData?: GalleryData;
      /** Data for a GIF node. */
      gifData?: GIFData;
      /** Data for a heading node. */
      headingData?: HeadingData;
      /** Data for an embedded HTML node. */
      htmlData?: HTMLData;
      /** Data for an image node. */
      imageData?: ImageData;
      /** Data for a link preview node. */
      linkPreviewData?: LinkPreviewData;
      /** Data for a map node. */
      mapData?: MapData;
      /** Data for a paragraph node. */
      paragraphData?: ParagraphData;
      /** Data for a poll node. */
      pollData?: PollData;
      /** Data for a text node. Used to apply decorations to text. */
      textData?: TextData;
      /** Data for an app embed node. */
      appEmbedData?: AppEmbedData;
      /** Data for a video node. */
      videoData?: VideoData;
      /** Data for an oEmbed node. */
      embedData?: EmbedData;
      /** Data for a collapsible list node. */
      collapsibleListData?: CollapsibleListData;
      /** Data for a table node. */
      tableData?: TableData;
      /** Data for a table cell node. */
      tableCellData?: TableCellData;
      /** Data for a custom external node. */
      externalData?: Record<string, any> | null;
      /** Data for an audio node. */
      audioData?: AudioData;
      /** Data for an ordered list node. */
      orderedListData?: OrderedListData;
      /** Data for a bulleted list node. */
      bulletedListData?: BulletedListData;
      /** Data for a block quote node. */
      blockquoteData?: BlockquoteData;
      /** Data for a caption node. */
      captionData?: CaptionData;
  }
  enum NodeType {
      PARAGRAPH = "PARAGRAPH",
      TEXT = "TEXT",
      HEADING = "HEADING",
      BULLETED_LIST = "BULLETED_LIST",
      ORDERED_LIST = "ORDERED_LIST",
      LIST_ITEM = "LIST_ITEM",
      BLOCKQUOTE = "BLOCKQUOTE",
      CODE_BLOCK = "CODE_BLOCK",
      VIDEO = "VIDEO",
      DIVIDER = "DIVIDER",
      FILE = "FILE",
      GALLERY = "GALLERY",
      GIF = "GIF",
      HTML = "HTML",
      IMAGE = "IMAGE",
      LINK_PREVIEW = "LINK_PREVIEW",
      MAP = "MAP",
      POLL = "POLL",
      APP_EMBED = "APP_EMBED",
      BUTTON = "BUTTON",
      COLLAPSIBLE_LIST = "COLLAPSIBLE_LIST",
      TABLE = "TABLE",
      EMBED = "EMBED",
      COLLAPSIBLE_ITEM = "COLLAPSIBLE_ITEM",
      COLLAPSIBLE_ITEM_TITLE = "COLLAPSIBLE_ITEM_TITLE",
      COLLAPSIBLE_ITEM_BODY = "COLLAPSIBLE_ITEM_BODY",
      TABLE_CELL = "TABLE_CELL",
      TABLE_ROW = "TABLE_ROW",
      EXTERNAL = "EXTERNAL",
      AUDIO = "AUDIO",
      CAPTION = "CAPTION"
  }
  interface NodeStyle {
      /** The top padding value in pixels. */
      paddingTop?: string | null;
      /** The bottom padding value in pixels. */
      paddingBottom?: string | null;
      /** The background color as a hexadecimal value. */
      backgroundColor?: string | null;
  }
  interface ButtonData {
      /** Styling for the button's container. */
      containerData?: PluginContainerData;
      /** The button type. */
      type?: Type$3;
      /** Styling for the button. */
      styles?: Styles;
      /** The text to display on the button. */
      text?: string | null;
      /** Button link details. */
      link?: Link;
  }
  interface Border {
      /** Border width in pixels. */
      width?: number | null;
      /** Border radius in pixels. */
      radius?: number | null;
  }
  interface Colors {
      /** The text color as a hexadecimal value. */
      text?: string | null;
      /** The border color as a hexadecimal value. */
      border?: string | null;
      /** The background color as a hexadecimal value. */
      background?: string | null;
  }
  interface PluginContainerData {
      /** The width of the node when it's displayed. */
      width?: PluginContainerDataWidth;
      /** The node's alignment within its container. */
      alignment?: PluginContainerDataAlignment;
      /** Spoiler cover settings for the node. */
      spoiler?: Spoiler;
      /** The height of the node when it's displayed. */
      height?: Height;
      /** Sets whether text should wrap around this node when it's displayed. If `textWrap` is `false`, the node takes up the width of its container. Defaults to `true` for all node types except 'DIVIVDER' where it defaults to `false`. */
      textWrap?: boolean | null;
  }
  enum WidthType {
      /** Width matches the content width */
      CONTENT = "CONTENT",
      /** Small Width */
      SMALL = "SMALL",
      /** Width will match the original asset width */
      ORIGINAL = "ORIGINAL",
      /** coast-to-coast display */
      FULL_WIDTH = "FULL_WIDTH"
  }
  interface PluginContainerDataWidth extends PluginContainerDataWidthDataOneOf {
      /**
       * One of the following predefined width options:
       * `CONTENT`: The width of the container matches the content width.
       * `SMALL`: A small width.
       * `ORIGINAL`: For `imageData` containers only. The width of the container matches the original image width.
       * `FULL_WIDTH`: For `imageData` containers only. The image container takes up the full width of the screen.
       */
      size?: WidthType;
      /** A custom width value in pixels. */
      custom?: string | null;
  }
  /** @oneof */
  interface PluginContainerDataWidthDataOneOf {
      /**
       * One of the following predefined width options:
       * `CONTENT`: The width of the container matches the content width.
       * `SMALL`: A small width.
       * `ORIGINAL`: For `imageData` containers only. The width of the container matches the original image width.
       * `FULL_WIDTH`: For `imageData` containers only. The image container takes up the full width of the screen.
       */
      size?: WidthType;
      /** A custom width value in pixels. */
      custom?: string | null;
  }
  enum PluginContainerDataAlignment {
      /** Center Alignment */
      CENTER = "CENTER",
      /** Left Alignment */
      LEFT = "LEFT",
      /** Right Alignment */
      RIGHT = "RIGHT"
  }
  interface Spoiler {
      /** Sets whether the spoiler cover is enabled for this node. Defaults to `false`. */
      enabled?: boolean | null;
      /** The description displayed on top of the spoiler cover. */
      description?: string | null;
      /** The text for the button used to remove the spoiler cover. */
      buttonText?: string | null;
  }
  interface Height {
      /** A custom height value in pixels. */
      custom?: string | null;
  }
  enum Type$3 {
      /** Regular link button */
      LINK = "LINK",
      /** Triggers custom action that is defined in plugin configuration by the consumer */
      ACTION = "ACTION"
  }
  interface Styles {
      /** Border attributes. */
      border?: Border;
      /** Color attributes. */
      colors?: Colors;
  }
  interface Link extends LinkDataOneOf {
      /** The absolute URL for the linked document. */
      url?: string;
      /** The target node's ID. Used for linking to another node in this object. */
      anchor?: string;
      /**
       * he HTML `target` attribute value for the link. This property defines where the linked document opens as follows:
       * `SELF` - Default. Opens the linked document in the same frame as the link.
       * `BLANK` - Opens the linked document in a new browser tab or window.
       * `PARENT` - Opens the linked document in the link's parent frame.
       * `TOP` - Opens the linked document in the full body of the link's browser tab or window.
       */
      target?: Target;
      /** The HTML `rel` attribute value for the link. This object specifies the relationship between the current document and the linked document. */
      rel?: Rel;
      /** A serialized object used for a custom or external link panel. */
      customData?: string | null;
  }
  /** @oneof */
  interface LinkDataOneOf {
      /** The absolute URL for the linked document. */
      url?: string;
      /** The target node's ID. Used for linking to another node in this object. */
      anchor?: string;
  }
  enum Target {
      /** Opens the linked document in the same frame as it was clicked (this is default) */
      SELF = "SELF",
      /** Opens the linked document in a new window or tab */
      BLANK = "BLANK",
      /** Opens the linked document in the parent frame */
      PARENT = "PARENT",
      /** Opens the linked document in the full body of the window */
      TOP = "TOP"
  }
  interface Rel {
      /** Indicates to search engine crawlers not to follow the link. Defaults to `false`. */
      nofollow?: boolean | null;
      /** Indicates to search engine crawlers that the link is a paid placement such as sponsored content or an advertisement. Defaults to `false`. */
      sponsored?: boolean | null;
      /** Indicates that this link is user-generated content and isn't necessarily trusted or endorsed by the page’s author. For example, a link in a fourm post. Defaults to `false`. */
      ugc?: boolean | null;
      /** Indicates that this link protect referral information from being passed to the target website. */
      noreferrer?: boolean | null;
  }
  interface CodeBlockData {
      /** Styling for the code block's text. */
      textStyle?: TextStyle;
  }
  interface TextStyle {
      /** Text alignment. Defaults to `AUTO`. */
      textAlignment?: TextAlignment;
      /** A CSS `line-height` value for the text expressed as a ratio relative to the font size. For example, if the font size is 20px, a `lineHeight` value of `'1.5'`` results in a line height of 30px. */
      lineHeight?: string | null;
  }
  enum TextAlignment {
      /** browser default, eqivalent to `initial` */
      AUTO = "AUTO",
      /** Left align */
      LEFT = "LEFT",
      /** Right align */
      RIGHT = "RIGHT",
      /** Center align */
      CENTER = "CENTER",
      /** Text is spaced to line up its left and right edges to the left and right edges of the line box, except for the last line */
      JUSTIFY = "JUSTIFY"
  }
  interface DividerData {
      /** Styling for the divider's container. */
      containerData?: PluginContainerData;
      /** Divider line style. */
      lineStyle?: LineStyle;
      /** Divider width. */
      width?: Width;
      /** Divider alignment. */
      alignment?: Alignment;
  }
  enum LineStyle {
      /** Single Line */
      SINGLE = "SINGLE",
      /** Double Line */
      DOUBLE = "DOUBLE",
      /** Dashed Line */
      DASHED = "DASHED",
      /** Dotted Line */
      DOTTED = "DOTTED"
  }
  enum Width {
      /** Large line */
      LARGE = "LARGE",
      /** Medium line */
      MEDIUM = "MEDIUM",
      /** Small line */
      SMALL = "SMALL"
  }
  enum Alignment {
      /** Center alignment */
      CENTER = "CENTER",
      /** Left alignment */
      LEFT = "LEFT",
      /** Right alignment */
      RIGHT = "RIGHT"
  }
  interface FileData {
      /** Styling for the file's container. */
      containerData?: PluginContainerData;
      /** The source for the file's data. */
      src?: FileSource;
      /** File name. */
      name?: string | null;
      /** File type. */
      type?: string | null;
      /**
       * Use `sizeInKb` instead.
       * @deprecated
       */
      size?: number | null;
      /** Settings for PDF files. */
      pdfSettings?: PDFSettings;
      /** File MIME type. */
      mimeType?: string | null;
      /** File path. */
      path?: string | null;
      /** File size in KB. */
      sizeInKb?: string | null;
  }
  enum ViewMode {
      /** No PDF view */
      NONE = "NONE",
      /** Full PDF view */
      FULL = "FULL",
      /** Mini PDF view */
      MINI = "MINI"
  }
  interface FileSource extends FileSourceDataOneOf {
      /** The absolute URL for the file's source. */
      url?: string | null;
      /**
       * Custom ID. Use `id` instead.
       * @deprecated
       */
      custom?: string | null;
      /** An ID that's resolved to a URL by a resolver function. */
      _id?: string | null;
      /** Indicates whether the file's source is private. Defaults to `false`. */
      private?: boolean | null;
  }
  /** @oneof */
  interface FileSourceDataOneOf {
      /** The absolute URL for the file's source. */
      url?: string | null;
      /**
       * Custom ID. Use `id` instead.
       * @deprecated
       */
      custom?: string | null;
      /** An ID that's resolved to a URL by a resolver function. */
      _id?: string | null;
  }
  interface PDFSettings {
      /**
       * PDF view mode. One of the following:
       * `NONE` : The PDF isn't displayed.
       * `FULL` : A full page view of the PDF is displayed.
       * `MINI` : A mini view of the PDF is displayed.
       */
      viewMode?: ViewMode;
      /** Sets whether the PDF download button is disabled. Defaults to `false`. */
      disableDownload?: boolean | null;
      /** Sets whether the PDF print button is disabled. Defaults to `false`. */
      disablePrint?: boolean | null;
  }
  interface GalleryData {
      /** Styling for the gallery's container. */
      containerData?: PluginContainerData;
      /** The items in the gallery. */
      items?: Item[];
      /** Options for defining the gallery's appearance. */
      options?: GalleryOptions;
      /** Sets whether the gallery's expand button is disabled. Defaults to `false`. */
      disableExpand?: boolean | null;
      /** Sets whether the gallery's download button is disabled. Defaults to `false`. */
      disableDownload?: boolean | null;
  }
  interface Media {
      /** The source for the media's data. */
      src?: FileSource;
      /** Media width in pixels. */
      width?: number | null;
      /** Media height in pixels. */
      height?: number | null;
      /** Media duration in seconds. Only relevant for audio and video files. */
      duration?: number | null;
  }
  interface Image {
      /** Image file details. */
      media?: Media;
      /** Link details for images that are links. */
      link?: Link;
  }
  interface Video {
      /** Video file details. */
      media?: Media;
      /** Video thumbnail file details. */
      thumbnail?: Media;
  }
  interface Item extends ItemDataOneOf {
      /** An image item. */
      image?: Image;
      /** A video item. */
      video?: Video;
      /** Item title. */
      title?: string | null;
      /** Item's alternative text. */
      altText?: string | null;
  }
  /** @oneof */
  interface ItemDataOneOf {
      /** An image item. */
      image?: Image;
      /** A video item. */
      video?: Video;
  }
  interface GalleryOptions {
      /** Gallery layout. */
      layout?: Layout;
      /** Styling for gallery items. */
      item?: ItemStyle;
      /** Styling for gallery thumbnail images. */
      thumbnails?: Thumbnails;
  }
  enum LayoutType {
      /** Collage type */
      COLLAGE = "COLLAGE",
      /** Masonry type */
      MASONRY = "MASONRY",
      /** Grid type */
      GRID = "GRID",
      /** Thumbnail type */
      THUMBNAIL = "THUMBNAIL",
      /** Slider type */
      SLIDER = "SLIDER",
      /** Slideshow type */
      SLIDESHOW = "SLIDESHOW",
      /** Panorama type */
      PANORAMA = "PANORAMA",
      /** Column type */
      COLUMN = "COLUMN",
      /** Magic type */
      MAGIC = "MAGIC",
      /** Fullsize images type */
      FULLSIZE = "FULLSIZE"
  }
  enum Orientation {
      /** Rows Orientation */
      ROWS = "ROWS",
      /** Columns Orientation */
      COLUMNS = "COLUMNS"
  }
  enum Crop {
      /** Crop to fill */
      FILL = "FILL",
      /** Crop to fit */
      FIT = "FIT"
  }
  enum ThumbnailsAlignment {
      /** Top alignment */
      TOP = "TOP",
      /** Right alignment */
      RIGHT = "RIGHT",
      /** Bottom alignment */
      BOTTOM = "BOTTOM",
      /** Left alignment */
      LEFT = "LEFT",
      /** No thumbnail */
      NONE = "NONE"
  }
  interface Layout {
      /** Gallery layout type. */
      type?: LayoutType;
      /** Sets whether horizontal scroll is enabled. Defaults to `true` unless the layout `type` is set to `GRID` or `COLLAGE`. */
      horizontalScroll?: boolean | null;
      /** Gallery orientation. */
      orientation?: Orientation;
      /** The number of columns to display on full size screens. */
      numberOfColumns?: number | null;
      /** The number of columns to display on mobile screens. */
      mobileNumberOfColumns?: number | null;
  }
  interface ItemStyle {
      /** Desirable dimension for each item in pixels (behvaior changes according to gallery type) */
      targetSize?: number | null;
      /** Item ratio */
      ratio?: number | null;
      /** Sets how item images are cropped. */
      crop?: Crop;
      /** The spacing between items in pixels. */
      spacing?: number | null;
  }
  interface Thumbnails {
      /** Thumbnail alignment. */
      placement?: ThumbnailsAlignment;
      /** Spacing between thumbnails in pixels. */
      spacing?: number | null;
  }
  interface GIFData {
      /** Styling for the GIF's container. */
      containerData?: PluginContainerData;
      /** The source of the full size GIF. */
      original?: GIF;
      /** The source of the downsized GIF. */
      downsized?: GIF;
      /** Height in pixels. */
      height?: number;
      /** Width in pixels. */
      width?: number;
  }
  interface GIF {
      /** GIF format URL. */
      gif?: string | null;
      /** MP4 format URL. */
      mp4?: string | null;
      /** Thumbnail URL. */
      still?: string | null;
  }
  interface HeadingData {
      /** Heading level from 1-6. */
      level?: number;
      /** Styling for the heading text. */
      textStyle?: TextStyle;
      /** Indentation level from 1-4. */
      indentation?: number | null;
  }
  interface HTMLData extends HTMLDataDataOneOf {
      /** The URL for the HTML code for the node. */
      url?: string;
      /** The HTML code for the node. */
      html?: string;
      /**
       * Whether this is an AdSense element. Use `source` instead.
       * @deprecated
       */
      isAdsense?: boolean | null;
      /** Styling for the HTML node's container. */
      containerData?: PluginContainerData;
      /** The type of HTML code. */
      source?: Source;
  }
  /** @oneof */
  interface HTMLDataDataOneOf {
      /** The URL for the HTML code for the node. */
      url?: string;
      /** The HTML code for the node. */
      html?: string;
      /**
       * Whether this is an AdSense element. Use `source` instead.
       * @deprecated
       */
      isAdsense?: boolean | null;
  }
  enum Source {
      HTML = "HTML",
      ADSENSE = "ADSENSE"
  }
  interface ImageData {
      /** Styling for the image's container. */
      containerData?: PluginContainerData;
      /** Image file details. */
      image?: Media;
      /** Link details for images that are links. */
      link?: Link;
      /** Sets whether the image expands to full screen when clicked. Defaults to `false`. */
      disableExpand?: boolean | null;
      /** Image's alternative text. */
      altText?: string | null;
      /**
       * Deprecated: use Caption node instead.
       * @deprecated
       */
      caption?: string | null;
      /** Sets whether the image's download button is disabled. Defaults to `false`. */
      disableDownload?: boolean | null;
  }
  interface LinkPreviewData {
      /** Styling for the link preview's container. */
      containerData?: PluginContainerData;
      /** Link details. */
      link?: Link;
      /** Preview title. */
      title?: string | null;
      /** Preview thumbnail URL. */
      thumbnailUrl?: string | null;
      /** Preview description. */
      description?: string | null;
      /** The preview content as HTML. */
      html?: string | null;
  }
  interface MapData {
      /** Styling for the map's container. */
      containerData?: PluginContainerData;
      /** Map settings. */
      mapSettings?: MapSettings;
  }
  interface MapSettings {
      /** The address to display on the map. */
      address?: string | null;
      /** Sets whether the map is draggable. */
      draggable?: boolean | null;
      /** Sets whether the location marker is visible. */
      marker?: boolean | null;
      /** Sets whether street view control is enabled. */
      streetViewControl?: boolean | null;
      /** Sets whether zoom control is enabled. */
      zoomControl?: boolean | null;
      /** Location latitude. */
      lat?: number | null;
      /** Location longitude. */
      lng?: number | null;
      /** Location name. */
      locationName?: string | null;
      /** Sets whether view mode control is enabled. */
      viewModeControl?: boolean | null;
      /** Initial zoom value. */
      initialZoom?: number | null;
      /** Map type. `HYBRID` is a combination of the `ROADMAP` and `SATELLITE` map types. */
      mapType?: MapType;
  }
  enum MapType {
      /** Roadmap map type */
      ROADMAP = "ROADMAP",
      /** Satellite map type */
      SATELITE = "SATELITE",
      /** Hybrid map type */
      HYBRID = "HYBRID",
      /** Terrain map type */
      TERRAIN = "TERRAIN"
  }
  interface ParagraphData {
      /** Styling for the paragraph text. */
      textStyle?: TextStyle;
      /** Indentation level from 1-4. */
      indentation?: number | null;
      /** Paragraph level */
      level?: number | null;
  }
  interface PollData {
      /** Styling for the poll's container. */
      containerData?: PluginContainerData;
      /** Poll data. */
      poll?: Poll;
      /** Layout settings for the poll and voting options. */
      layout?: PollDataLayout;
      /** Styling for the poll and voting options. */
      design?: Design;
  }
  enum ViewRole {
      /** Only Poll creator can view the results */
      CREATOR = "CREATOR",
      /** Anyone who voted can see the results */
      VOTERS = "VOTERS",
      /** Anyone can see the results, even if one didn't vote */
      EVERYONE = "EVERYONE"
  }
  enum VoteRole {
      /** Logged in member */
      SITE_MEMBERS = "SITE_MEMBERS",
      /** Anyone */
      ALL = "ALL"
  }
  interface Permissions {
      /** Sets who can view the poll results. */
      view?: ViewRole;
      /** Sets who can vote. */
      vote?: VoteRole;
      /** Sets whether one voter can vote multiple times. Defaults to `false`. */
      allowMultipleVotes?: boolean | null;
  }
  interface Option {
      /** Option ID. */
      _id?: string | null;
      /** Option title. */
      title?: string | null;
      /** The image displayed with the option. */
      image?: Media;
  }
  interface Settings$3 {
      /** Permissions settings for voting. */
      permissions?: Permissions;
      /** Sets whether voters are displayed in the vote results. Defaults to `true`. */
      showVoters?: boolean | null;
      /** Sets whether the vote count is displayed. Defaults to `true`. */
      showVotesCount?: boolean | null;
  }
  enum PollLayoutType {
      /** List */
      LIST = "LIST",
      /** Grid */
      GRID = "GRID"
  }
  enum PollLayoutDirection {
      /** Left-to-right */
      LTR = "LTR",
      /** Right-to-left */
      RTL = "RTL"
  }
  interface PollLayout {
      /** The layout for displaying the voting options. */
      type?: PollLayoutType;
      /** The direction of the text displayed in the voting options. Text can be displayed either right-to-left or left-to-right. */
      direction?: PollLayoutDirection;
      /** Sets whether to display the main poll image. Defaults to `false`. */
      enableImage?: boolean | null;
  }
  interface OptionLayout {
      /** Sets whether to display option images. Defaults to `false`. */
      enableImage?: boolean | null;
  }
  enum BackgroundType {
      /** Color background type */
      COLOR = "COLOR",
      /** Image background type */
      IMAGE = "IMAGE",
      /** Gradiant background type */
      GRADIENT = "GRADIENT"
  }
  interface Gradient {
      /** The gradient angle in degrees. */
      angle?: number | null;
      /** The start color as a hexademical value. */
      startColor?: string | null;
      /** The end color as a hexademical value. */
      lastColor?: string | null;
  }
  interface Background extends BackgroundBackgroundOneOf {
      /** The background color as a hexademical value. */
      color?: string | null;
      /** An image to use for the background. */
      image?: Media;
      /** Details for a gradient background. */
      gradient?: Gradient;
      /** Background type. For each option, include the relevant details. */
      type?: BackgroundType;
  }
  /** @oneof */
  interface BackgroundBackgroundOneOf {
      /** The background color as a hexademical value. */
      color?: string | null;
      /** An image to use for the background. */
      image?: Media;
      /** Details for a gradient background. */
      gradient?: Gradient;
  }
  interface PollDesign {
      /** Background styling. */
      background?: Background;
      /** Border radius in pixels. */
      borderRadius?: number | null;
  }
  interface OptionDesign {
      /** Border radius in pixels. */
      borderRadius?: number | null;
  }
  interface Poll {
      /** Poll ID. */
      _id?: string | null;
      /** Poll title. */
      title?: string | null;
      /** Poll creator ID. */
      creatorId?: string | null;
      /** Main poll image. */
      image?: Media;
      /** Voting options. */
      options?: Option[];
      /** The poll's permissions and display settings. */
      settings?: Settings$3;
  }
  interface PollDataLayout {
      /** Poll layout settings. */
      poll?: PollLayout;
      /** Voting otpions layout settings. */
      options?: OptionLayout;
  }
  interface Design {
      /** Styling for the poll. */
      poll?: PollDesign;
      /** Styling for voting options. */
      options?: OptionDesign;
  }
  interface TextData {
      /** The text to apply decorations to. */
      text?: string;
      /** The decorations to apply. */
      decorations?: Decoration[];
  }
  /** Adds appearence changes to text */
  interface Decoration extends DecorationDataOneOf {
      /** Data for an anchor link decoration. */
      anchorData?: AnchorData;
      /** Data for a color decoration. */
      colorData?: ColorData;
      /** Data for an external link decoration. */
      linkData?: LinkData;
      /** Data for a mention decoration. */
      mentionData?: MentionData;
      /** Data for a font size decoration. */
      fontSizeData?: FontSizeData;
      /** Font weight for a bold decoration. */
      fontWeightValue?: number | null;
      /** Data for an italic decoration. Defaults to `true`. */
      italicData?: boolean | null;
      /** Data for an underline decoration. Defaults to `true`. */
      underlineData?: boolean | null;
      /** Data for a spoiler decoration. */
      spoilerData?: SpoilerData;
      /** The type of decoration to apply. */
      type?: DecorationType;
  }
  /** @oneof */
  interface DecorationDataOneOf {
      /** Data for an anchor link decoration. */
      anchorData?: AnchorData;
      /** Data for a color decoration. */
      colorData?: ColorData;
      /** Data for an external link decoration. */
      linkData?: LinkData;
      /** Data for a mention decoration. */
      mentionData?: MentionData;
      /** Data for a font size decoration. */
      fontSizeData?: FontSizeData;
      /** Font weight for a bold decoration. */
      fontWeightValue?: number | null;
      /** Data for an italic decoration. Defaults to `true`. */
      italicData?: boolean | null;
      /** Data for an underline decoration. Defaults to `true`. */
      underlineData?: boolean | null;
      /** Data for a spoiler decoration. */
      spoilerData?: SpoilerData;
  }
  enum DecorationType {
      BOLD = "BOLD",
      ITALIC = "ITALIC",
      UNDERLINE = "UNDERLINE",
      SPOILER = "SPOILER",
      ANCHOR = "ANCHOR",
      MENTION = "MENTION",
      LINK = "LINK",
      COLOR = "COLOR",
      FONT_SIZE = "FONT_SIZE",
      EXTERNAL = "EXTERNAL"
  }
  interface AnchorData {
      /** The target node's ID. */
      anchor?: string;
  }
  interface ColorData {
      /** The text's background color as a hexadecimal value. */
      background?: string | null;
      /** The text's foreground color as a hexadecimal value. */
      foreground?: string | null;
  }
  interface LinkData {
      /** Link details. */
      link?: Link;
  }
  interface MentionData {
      /** The mentioned user's name. */
      name?: string;
      /** The version of the user's name that appears after the `@` character in the mention. */
      slug?: string;
      /** Mentioned user's ID. */
      _id?: string | null;
  }
  interface FontSizeData {
      /** The units used for the font size. */
      unit?: FontType;
      /** Font size value. */
      value?: number | null;
  }
  enum FontType {
      PX = "PX",
      EM = "EM"
  }
  interface SpoilerData {
      /** Spoiler ID. */
      _id?: string | null;
  }
  interface AppEmbedData extends AppEmbedDataAppDataOneOf {
      /** Data for embedded Wix Bookings content. */
      bookingData?: BookingData;
      /** Data for embedded Wix Events content. */
      eventData?: EventData;
      /** The type of Wix App content being embedded. */
      type?: AppType;
      /** The ID of the embedded content. */
      itemId?: string | null;
      /** The name of the embedded content. */
      name?: string | null;
      /**
       * Deprecated: Use `image` instead.
       * @deprecated
       */
      imageSrc?: string | null;
      /** The URL for the embedded content. */
      url?: string | null;
      /** An image for the embedded content. */
      image?: Media;
  }
  /** @oneof */
  interface AppEmbedDataAppDataOneOf {
      /** Data for embedded Wix Bookings content. */
      bookingData?: BookingData;
      /** Data for embedded Wix Events content. */
      eventData?: EventData;
  }
  enum AppType {
      PRODUCT = "PRODUCT",
      EVENT = "EVENT",
      BOOKING = "BOOKING"
  }
  interface BookingData {
      /** Booking duration in minutes. */
      durations?: string | null;
  }
  interface EventData {
      /** Event schedule. */
      scheduling?: string | null;
      /** Event location. */
      location?: string | null;
  }
  interface VideoData {
      /** Styling for the video's container. */
      containerData?: PluginContainerData;
      /** Video details. */
      video?: Media;
      /** Video thumbnail details. */
      thumbnail?: Media;
      /** Sets whether the video's download button is disabled. Defaults to `false`. */
      disableDownload?: boolean | null;
      /** Video title. */
      title?: string | null;
      /** Video options. */
      options?: PlaybackOptions;
  }
  interface PlaybackOptions {
      /** Sets whether the media will automatically start playing. */
      autoPlay?: boolean | null;
      /** Sets whether media's will be looped. */
      playInLoop?: boolean | null;
      /** Sets whether media's controls will be shown. */
      showControls?: boolean | null;
  }
  interface EmbedData {
      /** Styling for the oEmbed node's container. */
      containerData?: PluginContainerData;
      /** An [oEmbed](https://www.oembed.com) object. */
      oembed?: Oembed;
      /** Origin asset source. */
      src?: string | null;
  }
  interface Oembed {
      /** The resource type. */
      type?: string | null;
      /** The width of the resource specified in the `url` property in pixels. */
      width?: number | null;
      /** The height of the resource specified in the `url` property in pixels. */
      height?: number | null;
      /** Resource title. */
      title?: string | null;
      /** The source URL for the resource. */
      url?: string | null;
      /** HTML for embedding a video player. The HTML should have no padding or margins. */
      html?: string | null;
      /** The name of the author or owner of the resource. */
      authorName?: string | null;
      /** The URL for the author or owner of the resource. */
      authorUrl?: string | null;
      /** The name of the resource provider. */
      providerName?: string | null;
      /** The URL for the resource provider. */
      providerUrl?: string | null;
      /** The URL for a thumbnail image for the resource. If this property is defined, `thumbnailWidth` and `thumbnailHeight` must also be defined. */
      thumbnailUrl?: string | null;
      /** The width of the resource's thumbnail image. If this property is defined, `thumbnailUrl` and `thumbnailHeight` must also be defined. */
      thumbnailWidth?: string | null;
      /** The height of the resource's thumbnail image. If this property is defined, `thumbnailUrl` and `thumbnailWidth`must also be defined. */
      thumbnailHeight?: string | null;
      /** The URL for an embedded viedo. */
      videoUrl?: string | null;
      /** The oEmbed version number.  This value must be `1.0`. */
      version?: string | null;
  }
  interface CollapsibleListData {
      /** Styling for the collapsible list's container. */
      containerData?: PluginContainerData;
      /** If `true`, only one item can be expanded at a time. Defaults to `false`. */
      expandOnlyOne?: boolean | null;
      /** Sets which items are expanded when the page loads. */
      initialExpandedItems?: InitialExpandedItems;
      /** The direction of the text in the list. Either left-to-right or right-to-left. */
      direction?: Direction;
      /** If `true`, The collapsible item will appear in search results as an FAQ. */
      isQapageData?: boolean | null;
  }
  enum InitialExpandedItems {
      /** First item will be expended initally */
      FIRST = "FIRST",
      /** All items will expended initally */
      ALL = "ALL",
      /** All items collapsed initally */
      NONE = "NONE"
  }
  enum Direction {
      /** Left-to-right */
      LTR = "LTR",
      /** Right-to-left */
      RTL = "RTL"
  }
  interface TableData {
      /** Styling for the table's container. */
      containerData?: PluginContainerData;
      /** The table's dimensions. */
      dimensions?: Dimensions;
      /**
       * Deprecated: Use `rowHeader` and `columnHeader` instead.
       * @deprecated
       */
      header?: boolean | null;
      /** Sets whether the table's first row is a header. Defaults to `false`. */
      rowHeader?: boolean | null;
      /** Sets whether the table's first column is a header. Defaults to `false`. */
      columnHeader?: boolean | null;
  }
  interface Dimensions {
      /** An array representing relative width of each column in relation to the other columns. */
      colsWidthRatio?: number[];
      /** An array representing the height of each row in pixels. */
      rowsHeight?: number[];
      /** An array representing the minimum width of each column in pixels. */
      colsMinWidth?: number[];
  }
  interface TableCellData {
      /** Styling for the cell's background color and text alignment. */
      cellStyle?: CellStyle;
      /** The cell's border colors. */
      borderColors?: BorderColors;
  }
  enum VerticalAlignment {
      /** Top alignment */
      TOP = "TOP",
      /** Middle alignment */
      MIDDLE = "MIDDLE",
      /** Bottom alignment */
      BOTTOM = "BOTTOM"
  }
  interface CellStyle {
      /** Vertical alignment for the cell's text. */
      verticalAlignment?: VerticalAlignment;
      /** Cell background color as a hexadecimal value. */
      backgroundColor?: string | null;
  }
  interface BorderColors {
      /** Left border color as a hexadecimal value. */
      left?: string | null;
      /** Right border color as a hexadecimal value. */
      right?: string | null;
      /** Top border color as a hexadecimal value. */
      top?: string | null;
      /** Bottom border color as a hexadecimal value. */
      bottom?: string | null;
  }
  /**
   * `NullValue` is a singleton enumeration to represent the null value for the
   * `Value` type union.
   *
   * The JSON representation for `NullValue` is JSON `null`.
   */
  enum NullValue {
      /** Null value. */
      NULL_VALUE = "NULL_VALUE"
  }
  /**
   * `ListValue` is a wrapper around a repeated field of values.
   *
   * The JSON representation for `ListValue` is JSON array.
   */
  interface ListValue {
      /** Repeated field of dynamically typed values. */
      values?: any[];
  }
  interface AudioData {
      /** Styling for the audio node's container. */
      containerData?: PluginContainerData;
      /** Audio file details. */
      audio?: Media;
      /** Sets whether the audio node's download button is disabled. Defaults to `false`. */
      disableDownload?: boolean | null;
      /** Cover image. */
      coverImage?: Media;
      /** Track name. */
      name?: string | null;
      /** Author name. */
      authorName?: string | null;
      /** An HTML version of the audio node. */
      html?: string | null;
  }
  interface OrderedListData {
      /** Indentation level from 0-4. */
      indentation?: number;
      /** Offset level from 0-4. */
      offset?: number | null;
      /** List start number. */
      start?: number | null;
  }
  interface BulletedListData {
      /** Indentation level from 0-4. */
      indentation?: number;
      /** Offset level from 0-4. */
      offset?: number | null;
  }
  interface BlockquoteData {
      /** Indentation level from 1-4. */
      indentation?: number;
  }
  interface CaptionData {
      textStyle?: TextStyle;
  }
  interface Metadata {
      /** Schema version. */
      version?: number;
      /**
       * When the object was created.
       * @readonly
       * @deprecated
       */
      createdTimestamp?: Date | null;
      /**
       * When the object was most recently updated.
       * @deprecated
       */
      updatedTimestamp?: Date | null;
      /** Object ID. */
      _id?: string | null;
  }
  interface DocumentStyle {
      /** Styling for H1 nodes. */
      headerOne?: TextNodeStyle;
      /** Styling for H2 nodes. */
      headerTwo?: TextNodeStyle;
      /** Styling for H3 nodes. */
      headerThree?: TextNodeStyle;
      /** Styling for H4 nodes. */
      headerFour?: TextNodeStyle;
      /** Styling for H5 nodes. */
      headerFive?: TextNodeStyle;
      /** Styling for H6 nodes. */
      headerSix?: TextNodeStyle;
      /** Styling for paragraph nodes. */
      paragraph?: TextNodeStyle;
      /** Styling for block quote nodes. */
      blockquote?: TextNodeStyle;
      /** Styling for code block nodes. */
      codeBlock?: TextNodeStyle;
  }
  interface TextNodeStyle {
      /** The decorations to apply to the node. */
      decorations?: Decoration[];
      /** Padding and background color for the node. */
      nodeStyle?: NodeStyle;
      /** Line height for text in the node. */
      lineHeight?: string | null;
  }
  interface ExtendedFields$2 {
      /**
       * Extended field data. Each key corresponds to the namespace of the app that created the extended fields.
       * The value of each key is structured according to the schema defined when the extended fields were configured.
       *
       * You can only access fields for which you have the appropriate permissions.
       *
       * Learn more about [extended fields](https://dev.wix.com/docs/rest/articles/getting-started/extended-fields).
       */
      namespaces?: Record<string, Record<string, any>>;
  }
  interface CreateRichContentRequest {
      /** Rich content details. */
      richContent: RichContent;
  }
  interface CreateRichContentResponse {
      /** Created rich content. */
      richContent?: RichContent;
  }
  interface GetRichContentRequest {
      /** Rich content ID. */
      richContentId: string;
  }
  interface GetRichContentResponse {
      /** The requested rich content. */
      richContent?: RichContent;
  }
  interface FindRichContentBySlugRequest {
      /** The event slug */
      eventSlug: string;
      /** The field name */
      fieldName: string;
  }
  interface FindRichContentBySlugResponse {
      /** The RichContent */
      richContent?: RichContent;
  }
  interface UpdateRichContentRequest {
      /** Fields to update. */
      richContent: RichContent;
      /**
       * FieldMask to be applied to the RichContent.
       * @internal
       */
      fieldMask?: string[];
  }
  interface UpdateRichContentResponse {
      /** Updated rich content. */
      richContent?: RichContent;
  }
  interface DeleteRichContentRequest {
      /** ID of rich content to delete. */
      richContentId: string;
  }
  interface DeleteRichContentResponse {
  }
  interface QueryRichContentsRequest {
      /** WQL expression. */
      query?: CursorQuery$1;
  }
  interface CursorQuery$1 extends CursorQueryPagingMethodOneOf$1 {
      /**
       * Cursor paging options.
       *
       * Learn more about [cursor paging](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#cursor-paging).
       */
      cursorPaging?: CursorPaging$5;
      /**
       * Filter object.
       *
       * Learn more about the [filter section](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#the-filter-section).
       */
      filter?: Record<string, any> | null;
      /**
       * Sort object.
       *
       * Learn more about the [sort section](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#the-sort-section).
       */
      sort?: Sorting$5[];
  }
  /** @oneof */
  interface CursorQueryPagingMethodOneOf$1 {
      /**
       * Cursor paging options.
       *
       * Learn more about [cursor paging](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#cursor-paging).
       */
      cursorPaging?: CursorPaging$5;
  }
  interface Sorting$5 {
      /** Name of the field to sort by. */
      fieldName?: string;
      /** Sort order. */
      order?: SortOrder$5;
      /**
       * When `field_name` is a property of repeated field that is marked as `MATCH_ITEMS` and sort should be done by
       * a specific element from a collection, filter can/should be provided to ensure correct sort value is picked.
       *
       * If multiple filters are provided, they are combined with AND operator.
       *
       * Example:
       * Given we have document like {"id": "1", "nestedField": [{"price": 10, "region": "EU"}, {"price": 20, "region": "US"}]}
       * and `nestedField` is marked as `MATCH_ITEMS`, to ensure that sorting is done by correct region, filter should be
       * { fieldName: "nestedField.price", "select_items_by": [{"nestedField.region": "US"}] }
       * @internal
       */
      selectItemsBy?: Record<string, any>[] | null;
  }
  enum SortOrder$5 {
      ASC = "ASC",
      DESC = "DESC"
  }
  interface CursorPaging$5 {
      /** Maximum number of items to return in the results. */
      limit?: number | null;
      /**
       * Pointer to the next or previous page in the list of results.
       *
       * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
       * Not relevant for the first request.
       */
      cursor?: string | null;
  }
  interface QueryRichContentsResponse {
      /** List of RichContents. */
      richContents?: RichContent[];
      /** Paging metadata */
      pagingMetadata?: CursorPagingMetadata$1;
  }
  interface CursorPagingMetadata$1 {
      /** Number of items returned in current page. */
      count?: number | null;
      /** Cursor strings that point to the next page, previous page, or both. */
      cursors?: Cursors$5;
      /**
       * Whether there are more pages to retrieve following the current page.
       *
       * + `true`: Another page of results can be retrieved.
       * + `false`: This is the last page.
       */
      hasNext?: boolean | null;
      /**
       * Total number of items matching the filter.
       * Available only on the first page of *Search* results, not included in *Query* or *List* results.
       * If the Search results span multiple pages, the value of `total` will exceed the number of items returned on the first page.
       * @internal
       */
      total?: number | null;
  }
  interface Cursors$5 {
      /** Cursor string pointing to the next page in the list of results. */
      next?: string | null;
      /** Cursor pointing to the previous page in the list of results. */
      prev?: string | null;
  }
  interface QueryRichContentRequest {
      /** Query options. See [API Query Language](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language) for more details. */
      query?: CursorQuery$1;
  }
  interface QueryRichContentResponse {
      /** List of rich content entities. */
      richContent?: RichContent[];
      /** Paging metadata. */
      pagingMetadata?: CursorPagingMetadata$1;
  }
  interface EventCopied$2 {
      /** Event created timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Event ID. */
      eventId?: string;
      /** Event location. */
      location?: Location$4;
      /** Event schedule configuration. */
      scheduleConfig?: ScheduleConfig$4;
      /** Event title. */
      title?: string;
      /** Event creator user ID. */
      userId?: string | null;
      /** Event status. */
      status?: EventStatus$4;
      /** Instance ID. Indicates the original app instance which current event was derived from. */
      derivedFromInstanceId?: string | null;
      /** Event ID. Indicates the original event which current event was derived from. */
      derivedFromEventId?: string | null;
      /**
       * Map of copied ticket definitions from original event.
       * Key represents ticket def id in the original event.
       * Value represents ticket def id in the newly created event.
       */
      ticketDefinitions?: Record<string, string>;
  }
  interface Location$4 {
      /** Location name. */
      name?: string | null;
      /** Location map coordinates. */
      coordinates?: MapCoordinates$4;
      /** Single line address representation. */
      address?: string | null;
      /** Location type. */
      type?: LocationType$4;
      /**
       * Full address derived from formatted single line `address`.
       * When `full_address` is used to create or update the event, deprecated `address` and `coordinates` are ignored.
       * If provided `full_address` has empty `formatted_address` or `coordinates`, it will be auto-completed using Atlas service.
       *
       * Migration notes:
       * - `full_address.formatted_address` is equivalent to `address`.
       * - `full_address.geocode` is equivalent to `coordinates`.
       */
      fullAddress?: Address$6;
      /**
       * Defines event location as TBD (To Be Determined).
       * When event location is not yet defined, `name` is displayed instead of location address.
       * `coordinates`, `address`, `type` and `full_address` are not required when location is TBD.
       */
      tbd?: boolean | null;
  }
  interface MapCoordinates$4 {
      /** Latitude. */
      lat?: number;
      /** Longitude. */
      lng?: number;
  }
  enum LocationType$4 {
      VENUE = "VENUE",
      ONLINE = "ONLINE"
  }
  /** Physical address */
  interface Address$6 extends AddressStreetOneOf$6 {
      /** a break down of the street to number and street name */
      streetAddress?: StreetAddress$6;
      /** Main address line (usually street and number) as free text */
      addressLine1?: string | null;
      /** country code */
      country?: string | null;
      /** subdivision (usually state or region) code according to ISO 3166-2 */
      subdivision?: string | null;
      /** city name */
      city?: string | null;
      /** zip/postal code */
      postalCode?: string | null;
      /** Free text providing more detailed address info. Usually contains Apt, Suite, Floor */
      addressLine2?: string | null;
      /** A string containing the human-readable address of this location */
      formatted?: string | null;
      /** coordinates of the physical address */
      location?: AddressLocation$6;
      /** country full-name */
      countryFullname?: string | null;
      /** multi-level subdivisions from top to bottom */
      subdivisions?: Subdivision$6[];
  }
  /** @oneof */
  interface AddressStreetOneOf$6 {
      /** a break down of the street to number and street name */
      streetAddress?: StreetAddress$6;
      /** Main address line (usually street and number) as free text */
      addressLine?: string | null;
  }
  interface StreetAddress$6 {
      /** street number */
      number?: string;
      /** street name */
      name?: string;
      /**
       * apartment number
       * @internal
       */
      apt?: string;
  }
  interface AddressLocation$6 {
      /** address latitude coordinates */
      latitude?: number | null;
      /** address longitude coordinates */
      longitude?: number | null;
  }
  interface Subdivision$6 {
      /** subdivision short code */
      code?: string;
      /** subdivision full-name */
      name?: string;
      /**
       * subdivision level
       * @internal
       */
      type?: SubdivisionType$6;
      /**
       * free text description of subdivision type
       * @internal
       */
      typeInfo?: string | null;
  }
  enum SubdivisionType$6 {
      UNKNOWN_SUBDIVISION_TYPE = "UNKNOWN_SUBDIVISION_TYPE",
      /** State */
      ADMINISTRATIVE_AREA_LEVEL_1 = "ADMINISTRATIVE_AREA_LEVEL_1",
      /** County */
      ADMINISTRATIVE_AREA_LEVEL_2 = "ADMINISTRATIVE_AREA_LEVEL_2",
      /** City/town */
      ADMINISTRATIVE_AREA_LEVEL_3 = "ADMINISTRATIVE_AREA_LEVEL_3",
      /** Neighborhood/quarter */
      ADMINISTRATIVE_AREA_LEVEL_4 = "ADMINISTRATIVE_AREA_LEVEL_4",
      /** Street/block */
      ADMINISTRATIVE_AREA_LEVEL_5 = "ADMINISTRATIVE_AREA_LEVEL_5",
      /** ADMINISTRATIVE_AREA_LEVEL_0. Indicates the national political entity, and is typically the highest order type returned by the Geocoder. */
      COUNTRY = "COUNTRY"
  }
  interface ScheduleConfig$4 {
      /**
       * Defines event as TBD (To Be Determined) schedule.
       * When event time is not yet defined, TBD message is displayed instead of event start and end times.
       * `startDate`, `endDate` and `timeZoneId` are not required when schedule is TBD.
       */
      scheduleTbd?: boolean;
      /** TBD message. */
      scheduleTbdMessage?: string | null;
      /** Event start timestamp. */
      startDate?: Date | null;
      /** Event end timestamp. */
      endDate?: Date | null;
      /** Event time zone ID in TZ database format, e.g., `EST`, `America/Los_Angeles`. */
      timeZoneId?: string | null;
      /** Whether end date is hidden in the formatted schedule. */
      endDateHidden?: boolean;
      /** Whether time zone is displayed in formatted schedule. */
      showTimeZone?: boolean;
      /** Event recurrences. */
      recurrences?: Recurrences$4;
  }
  interface Recurrences$4 {
      /** Event occurrences. */
      occurrences?: Occurrence$4[];
      /**
       * Recurring event category ID.
       * @readonly
       */
      categoryId?: string | null;
      /**
       * Recurrence status.
       * @readonly
       */
      status?: Status$4;
  }
  interface Occurrence$4 {
      /** Event start timestamp. */
      startDate?: Date | null;
      /** Event end timestamp. */
      endDate?: Date | null;
      /** Event time zone ID in TZ database format, e.g., `EST`, `America/Los_Angeles`. */
      timeZoneId?: string | null;
      /** Whether time zone is displayed in formatted schedule. */
      showTimeZone?: boolean;
  }
  enum Status$4 {
      /** Event occurs only once. */
      ONE_TIME = "ONE_TIME",
      /** Event is recurring. */
      RECURRING = "RECURRING",
      /** Marks the next upcoming occurrence of the recurring event. */
      RECURRING_NEXT = "RECURRING_NEXT",
      /** Marks the most recent ended occurrence of the recurring event. */
      RECURRING_LAST_ENDED = "RECURRING_LAST_ENDED",
      /** Marks the most recent canceled occurrence of the recurring event. */
      RECURRING_LAST_CANCELED = "RECURRING_LAST_CANCELED"
  }
  enum EventStatus$4 {
      /** Event is public and scheduled to start */
      SCHEDULED = "SCHEDULED",
      /** Event has started */
      STARTED = "STARTED",
      /** Event has ended */
      ENDED = "ENDED",
      /** Event was canceled */
      CANCELED = "CANCELED",
      /** Event is not public and needs to be published */
      DRAFT = "DRAFT"
  }
  interface Empty$4 {
  }
  interface EventDeleted$3 {
      /** Event deleted timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Event ID. */
      eventId?: string;
      /** Event title. */
      title?: string;
      /** Event creator user ID. */
      userId?: string | null;
      /**
       * Event categories.
       * @internal
       */
      categories?: string[];
  }
  interface GetOrCreateRichContentRequest {
      /** The event id */
      eventId?: string;
      /** The field name */
      fieldName?: string;
      /** HTML content to be converted to RichContent */
      content?: string;
  }
  interface GetOrCreateRichContentResponse {
      /** The RichContent */
      richContent?: RichContent;
  }
  interface CountRichContentItemsRequest {
      filter?: Record<string, any> | null;
  }
  interface CountRichContentItemsResponse {
      count?: number;
  }
  interface DomainEvent$4 extends DomainEventBodyOneOf$4 {
      createdEvent?: EntityCreatedEvent$4;
      updatedEvent?: EntityUpdatedEvent$4;
      deletedEvent?: EntityDeletedEvent$4;
      actionEvent?: ActionEvent$4;
      /**
       * Unique event ID.
       * Allows clients to ignore duplicate webhooks.
       */
      _id?: string;
      /**
       * Assumes actions are also always typed to an entity_type
       * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
       */
      entityFqdn?: string;
      /**
       * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
       * This is although the created/updated/deleted notion is duplication of the oneof types
       * Example: created/updated/deleted/started/completed/email_opened
       */
      slug?: string;
      /** ID of the entity associated with the event. */
      entityId?: string;
      /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
      eventTime?: Date | null;
      /**
       * Whether the event was triggered as a result of a privacy regulation application
       * (for example, GDPR).
       */
      triggeredByAnonymizeRequest?: boolean | null;
      /** If present, indicates the action that triggered the event. */
      originatedFrom?: string | null;
      /**
       * A sequence number defining the order of updates to the underlying entity.
       * For example, given that some entity was updated at 16:00 and than again at 16:01,
       * it is guaranteed that the sequence number of the second update is strictly higher than the first.
       * As the consumer, you can use this value to ensure that you handle messages in the correct order.
       * To do so, you will need to persist this number on your end, and compare the sequence number from the
       * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
       */
      entityEventSequence?: string | null;
  }
  /** @oneof */
  interface DomainEventBodyOneOf$4 {
      createdEvent?: EntityCreatedEvent$4;
      updatedEvent?: EntityUpdatedEvent$4;
      deletedEvent?: EntityDeletedEvent$4;
      actionEvent?: ActionEvent$4;
  }
  interface EntityCreatedEvent$4 {
      entityAsJson?: string;
      /**
       * Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity
       * @internal
       */
      triggeredByUndelete?: boolean | null;
      /** Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity */
      restoreInfo?: RestoreInfo$4;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface RestoreInfo$4 {
      deletedDate?: Date | null;
  }
  interface EntityUpdatedEvent$4 {
      /**
       * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
       * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
       * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
       */
      currentEntityAsJson?: string;
      /**
       * This field is currently part of the of the EntityUpdatedEvent msg, but scala/node libraries which implements the domain events standard
       * wont populate it / have any reference to it in the API.
       * The main reason for it is that fetching the old entity from the DB will have a performance hit on an update operation so unless truly needed,
       * the developer should send only the new (current) entity.
       * An additional reason is not wanting to send this additional entity over the wire (kafka) since in some cases it can be really big
       * Developers that must reflect the old entity will have to implement their own domain event sender mechanism which will follow the DomainEvent proto message.
       * @internal
       * @deprecated
       */
      previousEntityAsJson?: string | null;
      /**
       * WIP - This property will hold both names and previous values of the updated fields of the entity.
       * For more details please see [adr](https://docs.google.com/document/d/1PdqsOM20Ph2HAkmx8zvUnzzk3Sekp3BR9h34wSvsRnI/edit#heading=h.phlw87mh2imx) or [issue](https://github.com/wix-private/nile-tracker/issues/363)
       * @internal
       */
      modifiedFields?: Record<string, any>;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface EntityDeletedEvent$4 {
      /**
       * Indicates if the entity is sent to trash-bin. only available when trash-bin is enabled
       * @internal
       */
      movedToTrash?: boolean | null;
      /** Entity that was deleted */
      deletedEntityAsJson?: string | null;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface ActionEvent$4 {
      bodyAsJson?: string;
  }
  interface MessageEnvelope$7 {
      /** App instance ID. */
      instanceId?: string | null;
      /** Event type. */
      eventType?: string;
      /** The identification type and identity data. */
      identity?: IdentificationData$7;
      /** Stringify payload. */
      data?: string;
  }
  interface IdentificationData$7 extends IdentificationDataIdOneOf$7 {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
      /** @readonly */
      identityType?: WebhookIdentityType$7;
  }
  /** @oneof */
  interface IdentificationDataIdOneOf$7 {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
  }
  enum WebhookIdentityType$7 {
      UNKNOWN = "UNKNOWN",
      ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
      MEMBER = "MEMBER",
      WIX_USER = "WIX_USER",
      APP = "APP"
  }
  /**
   * Creates rich content, such as for an event description.
   *
   * This method passes rich content value to the description of an already created event.
   * @param richContent - Rich content details.
   * @public
   * @documentationMaturity preview
   * @requiredField richContent
   * @requiredField richContent.content
   * @requiredField richContent.fieldName
   * @permissionId WIX_EVENTS.MANAGE_EVENTS
   * @adminMethod
   * @returns Created rich content.
   */
  function createRichContent(richContent: RichContent): Promise<RichContent>;
  /**
   * Retrieves rich content of an event's field.
   * @param richContentId - Rich content ID.
   * @public
   * @documentationMaturity preview
   * @requiredField richContentId
   * @permissionId WIX_EVENTS.READ_EVENTS
   * @returns The requested rich content.
   */
  function getRichContent(richContentId: string): Promise<RichContent>;
  /**
   * Retrieves a RichContent by event_slug and field_name. Return empty response if not found.
   * @public
   * @documentationMaturity preview
   * @requiredField identifiers
   * @requiredField identifiers.eventSlug
   * @requiredField identifiers.fieldName
   * @permissionId WIX_EVENTS.READ_EVENTS
   * @deprecated
   * @targetRemovalDate 2025-01-01
   */
  function findRichContentBySlug(identifiers: FindRichContentBySlugIdentifiers): Promise<FindRichContentBySlugResponse>;
  interface FindRichContentBySlugIdentifiers {
      /** The event slug */
      eventSlug: string;
      /** The field name */
      fieldName: string;
  }
  /**
   * Updates rich content of an event description.
   *
   * Each time rich content is updated, `revision` increments by 1. The current `revision` must be passed when updating rich content. This ensures you're working with the latest rich content and prevents unintended overwrites.
   * @param _id - Rich content ID.
   * @public
   * @documentationMaturity preview
   * @requiredField _id
   * @requiredField richContent
   * @requiredField richContent.revision
   * @permissionId WIX_EVENTS.MANAGE_EVENTS
   * @adminMethod
   * @returns Updated rich content.
   */
  function updateRichContent(_id: string | null, richContent: UpdateRichContent, options?: UpdateRichContentOptions): Promise<RichContent>;
  interface UpdateRichContent {
      /**
       * Rich content ID.
       * @readonly
       */
      _id?: string | null;
      /**
       * Revision number, which increments by 1 each time the rich content is updated. To prevent conflicting changes, the existing revision must be used when updating rich content.
       * @readonly
       */
      revision?: string | null;
      /**
       * Date and time when rich content was created.
       * @readonly
       */
      _createdDate?: Date | null;
      /**
       * Date and time the rich content was updated.
       * @readonly
       */
      _updatedDate?: Date | null;
      /** ID of the event to which rich content is applied. */
      eventId?: string | null;
      /** Field name whose value uses rich content. For the event description, specify the `about` value. */
      fieldName?: string | null;
      /**
       * Rich content of the event description.
       *
       * <widget src="https://apps.wix.com/_serverless/ricos-playground-services/goto/api-component" plugins="video.spoiler.linkPreview.link.lineSpacing.indent.image.html.heading.hashtag.giphy.gallery.file.emoji.divider.collapsibleList.codeBlock.audio.ai" exampleid="6ff78d07-c535-4602-b50d-6f06055f4148">
       * <a href="https://dev.wix.com/docs/ricos/api-reference/ricos-document">See Ricos document reference</a>
       * </widget>
       */
      content?: V1RichContent;
      /**
       * Custom field data for the rich content object.
       *
       * **Note:** You must configure extended fields using schema plugin extensions in your app's dashboard before you can access the extended fields with API calls.
       */
      extendedFields?: ExtendedFields$2;
  }
  interface UpdateRichContentOptions {
      /**
       * FieldMask to be applied to the RichContent.
       * @internal
       */
      fieldMask?: string[];
  }
  /**
   * Deletes rich content from the event description.
   * @param richContentId - ID of rich content to delete.
   * @public
   * @documentationMaturity preview
   * @requiredField richContentId
   * @permissionId WIX_EVENTS.MANAGE_EVENTS
   * @adminMethod
   */
  function deleteRichContent(richContentId: string): Promise<void>;
  /** @public
   * @documentationMaturity preview
   * @permissionId WIX_EVENTS.READ_EVENTS
   * @deprecated
   * @replacedBy QueryRichContent
   * @targetRemovalDate 2025-01-01
   */
  function queryRichContents(options?: QueryRichContentsOptions): Promise<QueryRichContentsResponse>;
  interface QueryRichContentsOptions {
      /** WQL expression. */
      query?: CursorQuery$1;
  }
  /**
   * Creates a query to retrieve a list of rich content entities.
   *
   * The `queryRichContent()` function builds a query to retrieve a list of events and returns a `RichContentQueryBuilder` object.
   *
   * The returned object contains the query definition, which is typically used to run the query using the `find()` function.
   *
   * You can refine the query by chaining `RichContentQueryBuilder` functions onto the query. `RichContentQueryBuilder` functions enable you to sort, filter, and control the results `queryRichContent()` returns.
   *
   * `queryRichContent()` runs with these `RichContentQueryBuilder` defaults, which you can override:
   *
   * - `skip(0)`
   * - `limit(50)`
   * - `descending("_createdDate")`
   * The functions that are chained to `queryRichContent()` are applied in the order they're called. For example, if you apply ascending('eventId') and then descending('id'), the results are sorted first by the event ID, and then, if there are multiple results with the same event ID, the items are sorted by ID.
   * @public
   * @documentationMaturity preview
   * @permissionId WIX_EVENTS.READ_EVENTS
   */
  function queryRichContent(): RichContentQueryBuilder;
  interface QueryCursorResult$4 {
      cursors: Cursors$5;
      hasNext: () => boolean;
      hasPrev: () => boolean;
      length: number;
      pageSize: number;
  }
  interface RichContentQueryResult extends QueryCursorResult$4 {
      items: RichContent[];
      query: RichContentQueryBuilder;
      next: () => Promise<RichContentQueryResult>;
      prev: () => Promise<RichContentQueryResult>;
  }
  interface RichContentQueryBuilder {
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       * @documentationMaturity preview
       */
      eq: (propertyName: '_id' | 'eventId' | 'fieldName', value: any) => RichContentQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       * @documentationMaturity preview
       */
      ne: (propertyName: '_id' | 'eventId' | 'fieldName', value: any) => RichContentQueryBuilder;
      /** @param propertyName - Property whose value is compared with `string`.
       * @param string - String to compare against. Case-insensitive.
       * @documentationMaturity preview
       */
      startsWith: (propertyName: '_id' | 'eventId' | 'fieldName', value: string) => RichContentQueryBuilder;
      /** @param propertyName - Property whose value is compared with `values`.
       * @param values - List of values to compare against.
       * @documentationMaturity preview
       */
      hasSome: (propertyName: '_id' | 'eventId' | 'fieldName', value: any[]) => RichContentQueryBuilder;
      /** @documentationMaturity preview */
      in: (propertyName: '_id' | 'eventId' | 'fieldName', value: any) => RichContentQueryBuilder;
      /** @documentationMaturity preview */
      exists: (propertyName: '_id' | 'eventId' | 'fieldName', value: boolean) => RichContentQueryBuilder;
      /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments.
       * @documentationMaturity preview
       */
      ascending: (...propertyNames: Array<'_id' | 'eventId' | 'fieldName'>) => RichContentQueryBuilder;
      /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments.
       * @documentationMaturity preview
       */
      descending: (...propertyNames: Array<'_id' | 'eventId' | 'fieldName'>) => RichContentQueryBuilder;
      /** @param limit - Number of items to return, which is also the `pageSize` of the results object.
       * @documentationMaturity preview
       */
      limit: (limit: number) => RichContentQueryBuilder;
      /** @param cursor - A pointer to specific record
       * @documentationMaturity preview
       */
      skipTo: (cursor: string) => RichContentQueryBuilder;
      /** @documentationMaturity preview */
      find: () => Promise<RichContentQueryResult>;
  }
  /** @internal
   * @documentationMaturity preview
   * @adminMethod
   */
  function countRichContentItems(options?: CountRichContentItemsOptions): Promise<CountRichContentItemsResponse>;
  interface CountRichContentItemsOptions {
      filter?: Record<string, any> | null;
  }
  
  type eventsV1RichContent_universal_d_RichContent = RichContent;
  type eventsV1RichContent_universal_d_V1RichContent = V1RichContent;
  type eventsV1RichContent_universal_d_Node = Node;
  type eventsV1RichContent_universal_d_NodeDataOneOf = NodeDataOneOf;
  type eventsV1RichContent_universal_d_NodeType = NodeType;
  const eventsV1RichContent_universal_d_NodeType: typeof NodeType;
  type eventsV1RichContent_universal_d_NodeStyle = NodeStyle;
  type eventsV1RichContent_universal_d_ButtonData = ButtonData;
  type eventsV1RichContent_universal_d_Border = Border;
  type eventsV1RichContent_universal_d_Colors = Colors;
  type eventsV1RichContent_universal_d_PluginContainerData = PluginContainerData;
  type eventsV1RichContent_universal_d_WidthType = WidthType;
  const eventsV1RichContent_universal_d_WidthType: typeof WidthType;
  type eventsV1RichContent_universal_d_PluginContainerDataWidth = PluginContainerDataWidth;
  type eventsV1RichContent_universal_d_PluginContainerDataWidthDataOneOf = PluginContainerDataWidthDataOneOf;
  type eventsV1RichContent_universal_d_PluginContainerDataAlignment = PluginContainerDataAlignment;
  const eventsV1RichContent_universal_d_PluginContainerDataAlignment: typeof PluginContainerDataAlignment;
  type eventsV1RichContent_universal_d_Spoiler = Spoiler;
  type eventsV1RichContent_universal_d_Height = Height;
  type eventsV1RichContent_universal_d_Styles = Styles;
  type eventsV1RichContent_universal_d_Link = Link;
  type eventsV1RichContent_universal_d_LinkDataOneOf = LinkDataOneOf;
  type eventsV1RichContent_universal_d_Target = Target;
  const eventsV1RichContent_universal_d_Target: typeof Target;
  type eventsV1RichContent_universal_d_Rel = Rel;
  type eventsV1RichContent_universal_d_CodeBlockData = CodeBlockData;
  type eventsV1RichContent_universal_d_TextStyle = TextStyle;
  type eventsV1RichContent_universal_d_TextAlignment = TextAlignment;
  const eventsV1RichContent_universal_d_TextAlignment: typeof TextAlignment;
  type eventsV1RichContent_universal_d_DividerData = DividerData;
  type eventsV1RichContent_universal_d_LineStyle = LineStyle;
  const eventsV1RichContent_universal_d_LineStyle: typeof LineStyle;
  type eventsV1RichContent_universal_d_Width = Width;
  const eventsV1RichContent_universal_d_Width: typeof Width;
  type eventsV1RichContent_universal_d_Alignment = Alignment;
  const eventsV1RichContent_universal_d_Alignment: typeof Alignment;
  type eventsV1RichContent_universal_d_FileData = FileData;
  type eventsV1RichContent_universal_d_ViewMode = ViewMode;
  const eventsV1RichContent_universal_d_ViewMode: typeof ViewMode;
  type eventsV1RichContent_universal_d_FileSource = FileSource;
  type eventsV1RichContent_universal_d_FileSourceDataOneOf = FileSourceDataOneOf;
  type eventsV1RichContent_universal_d_PDFSettings = PDFSettings;
  type eventsV1RichContent_universal_d_GalleryData = GalleryData;
  type eventsV1RichContent_universal_d_Media = Media;
  type eventsV1RichContent_universal_d_Image = Image;
  type eventsV1RichContent_universal_d_Video = Video;
  type eventsV1RichContent_universal_d_Item = Item;
  type eventsV1RichContent_universal_d_ItemDataOneOf = ItemDataOneOf;
  type eventsV1RichContent_universal_d_GalleryOptions = GalleryOptions;
  type eventsV1RichContent_universal_d_LayoutType = LayoutType;
  const eventsV1RichContent_universal_d_LayoutType: typeof LayoutType;
  type eventsV1RichContent_universal_d_Orientation = Orientation;
  const eventsV1RichContent_universal_d_Orientation: typeof Orientation;
  type eventsV1RichContent_universal_d_Crop = Crop;
  const eventsV1RichContent_universal_d_Crop: typeof Crop;
  type eventsV1RichContent_universal_d_ThumbnailsAlignment = ThumbnailsAlignment;
  const eventsV1RichContent_universal_d_ThumbnailsAlignment: typeof ThumbnailsAlignment;
  type eventsV1RichContent_universal_d_Layout = Layout;
  type eventsV1RichContent_universal_d_ItemStyle = ItemStyle;
  type eventsV1RichContent_universal_d_Thumbnails = Thumbnails;
  type eventsV1RichContent_universal_d_GIFData = GIFData;
  type eventsV1RichContent_universal_d_GIF = GIF;
  type eventsV1RichContent_universal_d_HeadingData = HeadingData;
  type eventsV1RichContent_universal_d_HTMLData = HTMLData;
  type eventsV1RichContent_universal_d_HTMLDataDataOneOf = HTMLDataDataOneOf;
  type eventsV1RichContent_universal_d_Source = Source;
  const eventsV1RichContent_universal_d_Source: typeof Source;
  type eventsV1RichContent_universal_d_ImageData = ImageData;
  type eventsV1RichContent_universal_d_LinkPreviewData = LinkPreviewData;
  type eventsV1RichContent_universal_d_MapData = MapData;
  type eventsV1RichContent_universal_d_MapSettings = MapSettings;
  type eventsV1RichContent_universal_d_MapType = MapType;
  const eventsV1RichContent_universal_d_MapType: typeof MapType;
  type eventsV1RichContent_universal_d_ParagraphData = ParagraphData;
  type eventsV1RichContent_universal_d_PollData = PollData;
  type eventsV1RichContent_universal_d_ViewRole = ViewRole;
  const eventsV1RichContent_universal_d_ViewRole: typeof ViewRole;
  type eventsV1RichContent_universal_d_VoteRole = VoteRole;
  const eventsV1RichContent_universal_d_VoteRole: typeof VoteRole;
  type eventsV1RichContent_universal_d_Permissions = Permissions;
  type eventsV1RichContent_universal_d_Option = Option;
  type eventsV1RichContent_universal_d_PollLayoutType = PollLayoutType;
  const eventsV1RichContent_universal_d_PollLayoutType: typeof PollLayoutType;
  type eventsV1RichContent_universal_d_PollLayoutDirection = PollLayoutDirection;
  const eventsV1RichContent_universal_d_PollLayoutDirection: typeof PollLayoutDirection;
  type eventsV1RichContent_universal_d_PollLayout = PollLayout;
  type eventsV1RichContent_universal_d_OptionLayout = OptionLayout;
  type eventsV1RichContent_universal_d_BackgroundType = BackgroundType;
  const eventsV1RichContent_universal_d_BackgroundType: typeof BackgroundType;
  type eventsV1RichContent_universal_d_Gradient = Gradient;
  type eventsV1RichContent_universal_d_Background = Background;
  type eventsV1RichContent_universal_d_BackgroundBackgroundOneOf = BackgroundBackgroundOneOf;
  type eventsV1RichContent_universal_d_PollDesign = PollDesign;
  type eventsV1RichContent_universal_d_OptionDesign = OptionDesign;
  type eventsV1RichContent_universal_d_Poll = Poll;
  type eventsV1RichContent_universal_d_PollDataLayout = PollDataLayout;
  type eventsV1RichContent_universal_d_Design = Design;
  type eventsV1RichContent_universal_d_TextData = TextData;
  type eventsV1RichContent_universal_d_Decoration = Decoration;
  type eventsV1RichContent_universal_d_DecorationDataOneOf = DecorationDataOneOf;
  type eventsV1RichContent_universal_d_DecorationType = DecorationType;
  const eventsV1RichContent_universal_d_DecorationType: typeof DecorationType;
  type eventsV1RichContent_universal_d_AnchorData = AnchorData;
  type eventsV1RichContent_universal_d_ColorData = ColorData;
  type eventsV1RichContent_universal_d_LinkData = LinkData;
  type eventsV1RichContent_universal_d_MentionData = MentionData;
  type eventsV1RichContent_universal_d_FontSizeData = FontSizeData;
  type eventsV1RichContent_universal_d_FontType = FontType;
  const eventsV1RichContent_universal_d_FontType: typeof FontType;
  type eventsV1RichContent_universal_d_SpoilerData = SpoilerData;
  type eventsV1RichContent_universal_d_AppEmbedData = AppEmbedData;
  type eventsV1RichContent_universal_d_AppEmbedDataAppDataOneOf = AppEmbedDataAppDataOneOf;
  type eventsV1RichContent_universal_d_AppType = AppType;
  const eventsV1RichContent_universal_d_AppType: typeof AppType;
  type eventsV1RichContent_universal_d_BookingData = BookingData;
  type eventsV1RichContent_universal_d_EventData = EventData;
  type eventsV1RichContent_universal_d_VideoData = VideoData;
  type eventsV1RichContent_universal_d_PlaybackOptions = PlaybackOptions;
  type eventsV1RichContent_universal_d_EmbedData = EmbedData;
  type eventsV1RichContent_universal_d_Oembed = Oembed;
  type eventsV1RichContent_universal_d_CollapsibleListData = CollapsibleListData;
  type eventsV1RichContent_universal_d_InitialExpandedItems = InitialExpandedItems;
  const eventsV1RichContent_universal_d_InitialExpandedItems: typeof InitialExpandedItems;
  type eventsV1RichContent_universal_d_Direction = Direction;
  const eventsV1RichContent_universal_d_Direction: typeof Direction;
  type eventsV1RichContent_universal_d_TableData = TableData;
  type eventsV1RichContent_universal_d_Dimensions = Dimensions;
  type eventsV1RichContent_universal_d_TableCellData = TableCellData;
  type eventsV1RichContent_universal_d_VerticalAlignment = VerticalAlignment;
  const eventsV1RichContent_universal_d_VerticalAlignment: typeof VerticalAlignment;
  type eventsV1RichContent_universal_d_CellStyle = CellStyle;
  type eventsV1RichContent_universal_d_BorderColors = BorderColors;
  type eventsV1RichContent_universal_d_NullValue = NullValue;
  const eventsV1RichContent_universal_d_NullValue: typeof NullValue;
  type eventsV1RichContent_universal_d_ListValue = ListValue;
  type eventsV1RichContent_universal_d_AudioData = AudioData;
  type eventsV1RichContent_universal_d_OrderedListData = OrderedListData;
  type eventsV1RichContent_universal_d_BulletedListData = BulletedListData;
  type eventsV1RichContent_universal_d_BlockquoteData = BlockquoteData;
  type eventsV1RichContent_universal_d_CaptionData = CaptionData;
  type eventsV1RichContent_universal_d_Metadata = Metadata;
  type eventsV1RichContent_universal_d_DocumentStyle = DocumentStyle;
  type eventsV1RichContent_universal_d_TextNodeStyle = TextNodeStyle;
  type eventsV1RichContent_universal_d_CreateRichContentRequest = CreateRichContentRequest;
  type eventsV1RichContent_universal_d_CreateRichContentResponse = CreateRichContentResponse;
  type eventsV1RichContent_universal_d_GetRichContentRequest = GetRichContentRequest;
  type eventsV1RichContent_universal_d_GetRichContentResponse = GetRichContentResponse;
  type eventsV1RichContent_universal_d_FindRichContentBySlugRequest = FindRichContentBySlugRequest;
  type eventsV1RichContent_universal_d_FindRichContentBySlugResponse = FindRichContentBySlugResponse;
  type eventsV1RichContent_universal_d_UpdateRichContentRequest = UpdateRichContentRequest;
  type eventsV1RichContent_universal_d_UpdateRichContentResponse = UpdateRichContentResponse;
  type eventsV1RichContent_universal_d_DeleteRichContentRequest = DeleteRichContentRequest;
  type eventsV1RichContent_universal_d_DeleteRichContentResponse = DeleteRichContentResponse;
  type eventsV1RichContent_universal_d_QueryRichContentsRequest = QueryRichContentsRequest;
  type eventsV1RichContent_universal_d_QueryRichContentsResponse = QueryRichContentsResponse;
  type eventsV1RichContent_universal_d_QueryRichContentRequest = QueryRichContentRequest;
  type eventsV1RichContent_universal_d_QueryRichContentResponse = QueryRichContentResponse;
  type eventsV1RichContent_universal_d_GetOrCreateRichContentRequest = GetOrCreateRichContentRequest;
  type eventsV1RichContent_universal_d_GetOrCreateRichContentResponse = GetOrCreateRichContentResponse;
  type eventsV1RichContent_universal_d_CountRichContentItemsRequest = CountRichContentItemsRequest;
  type eventsV1RichContent_universal_d_CountRichContentItemsResponse = CountRichContentItemsResponse;
  const eventsV1RichContent_universal_d_createRichContent: typeof createRichContent;
  const eventsV1RichContent_universal_d_getRichContent: typeof getRichContent;
  const eventsV1RichContent_universal_d_findRichContentBySlug: typeof findRichContentBySlug;
  type eventsV1RichContent_universal_d_FindRichContentBySlugIdentifiers = FindRichContentBySlugIdentifiers;
  const eventsV1RichContent_universal_d_updateRichContent: typeof updateRichContent;
  type eventsV1RichContent_universal_d_UpdateRichContent = UpdateRichContent;
  type eventsV1RichContent_universal_d_UpdateRichContentOptions = UpdateRichContentOptions;
  const eventsV1RichContent_universal_d_deleteRichContent: typeof deleteRichContent;
  const eventsV1RichContent_universal_d_queryRichContents: typeof queryRichContents;
  type eventsV1RichContent_universal_d_QueryRichContentsOptions = QueryRichContentsOptions;
  const eventsV1RichContent_universal_d_queryRichContent: typeof queryRichContent;
  type eventsV1RichContent_universal_d_RichContentQueryResult = RichContentQueryResult;
  type eventsV1RichContent_universal_d_RichContentQueryBuilder = RichContentQueryBuilder;
  const eventsV1RichContent_universal_d_countRichContentItems: typeof countRichContentItems;
  type eventsV1RichContent_universal_d_CountRichContentItemsOptions = CountRichContentItemsOptions;
  namespace eventsV1RichContent_universal_d {
    export {
      eventsV1RichContent_universal_d_RichContent as RichContent,
      eventsV1RichContent_universal_d_V1RichContent as V1RichContent,
      eventsV1RichContent_universal_d_Node as Node,
      eventsV1RichContent_universal_d_NodeDataOneOf as NodeDataOneOf,
      eventsV1RichContent_universal_d_NodeType as NodeType,
      eventsV1RichContent_universal_d_NodeStyle as NodeStyle,
      eventsV1RichContent_universal_d_ButtonData as ButtonData,
      eventsV1RichContent_universal_d_Border as Border,
      eventsV1RichContent_universal_d_Colors as Colors,
      eventsV1RichContent_universal_d_PluginContainerData as PluginContainerData,
      eventsV1RichContent_universal_d_WidthType as WidthType,
      eventsV1RichContent_universal_d_PluginContainerDataWidth as PluginContainerDataWidth,
      eventsV1RichContent_universal_d_PluginContainerDataWidthDataOneOf as PluginContainerDataWidthDataOneOf,
      eventsV1RichContent_universal_d_PluginContainerDataAlignment as PluginContainerDataAlignment,
      eventsV1RichContent_universal_d_Spoiler as Spoiler,
      eventsV1RichContent_universal_d_Height as Height,
      Type$3 as Type,
      eventsV1RichContent_universal_d_Styles as Styles,
      eventsV1RichContent_universal_d_Link as Link,
      eventsV1RichContent_universal_d_LinkDataOneOf as LinkDataOneOf,
      eventsV1RichContent_universal_d_Target as Target,
      eventsV1RichContent_universal_d_Rel as Rel,
      eventsV1RichContent_universal_d_CodeBlockData as CodeBlockData,
      eventsV1RichContent_universal_d_TextStyle as TextStyle,
      eventsV1RichContent_universal_d_TextAlignment as TextAlignment,
      eventsV1RichContent_universal_d_DividerData as DividerData,
      eventsV1RichContent_universal_d_LineStyle as LineStyle,
      eventsV1RichContent_universal_d_Width as Width,
      eventsV1RichContent_universal_d_Alignment as Alignment,
      eventsV1RichContent_universal_d_FileData as FileData,
      eventsV1RichContent_universal_d_ViewMode as ViewMode,
      eventsV1RichContent_universal_d_FileSource as FileSource,
      eventsV1RichContent_universal_d_FileSourceDataOneOf as FileSourceDataOneOf,
      eventsV1RichContent_universal_d_PDFSettings as PDFSettings,
      eventsV1RichContent_universal_d_GalleryData as GalleryData,
      eventsV1RichContent_universal_d_Media as Media,
      eventsV1RichContent_universal_d_Image as Image,
      eventsV1RichContent_universal_d_Video as Video,
      eventsV1RichContent_universal_d_Item as Item,
      eventsV1RichContent_universal_d_ItemDataOneOf as ItemDataOneOf,
      eventsV1RichContent_universal_d_GalleryOptions as GalleryOptions,
      eventsV1RichContent_universal_d_LayoutType as LayoutType,
      eventsV1RichContent_universal_d_Orientation as Orientation,
      eventsV1RichContent_universal_d_Crop as Crop,
      eventsV1RichContent_universal_d_ThumbnailsAlignment as ThumbnailsAlignment,
      eventsV1RichContent_universal_d_Layout as Layout,
      eventsV1RichContent_universal_d_ItemStyle as ItemStyle,
      eventsV1RichContent_universal_d_Thumbnails as Thumbnails,
      eventsV1RichContent_universal_d_GIFData as GIFData,
      eventsV1RichContent_universal_d_GIF as GIF,
      eventsV1RichContent_universal_d_HeadingData as HeadingData,
      eventsV1RichContent_universal_d_HTMLData as HTMLData,
      eventsV1RichContent_universal_d_HTMLDataDataOneOf as HTMLDataDataOneOf,
      eventsV1RichContent_universal_d_Source as Source,
      eventsV1RichContent_universal_d_ImageData as ImageData,
      eventsV1RichContent_universal_d_LinkPreviewData as LinkPreviewData,
      eventsV1RichContent_universal_d_MapData as MapData,
      eventsV1RichContent_universal_d_MapSettings as MapSettings,
      eventsV1RichContent_universal_d_MapType as MapType,
      eventsV1RichContent_universal_d_ParagraphData as ParagraphData,
      eventsV1RichContent_universal_d_PollData as PollData,
      eventsV1RichContent_universal_d_ViewRole as ViewRole,
      eventsV1RichContent_universal_d_VoteRole as VoteRole,
      eventsV1RichContent_universal_d_Permissions as Permissions,
      eventsV1RichContent_universal_d_Option as Option,
      Settings$3 as Settings,
      eventsV1RichContent_universal_d_PollLayoutType as PollLayoutType,
      eventsV1RichContent_universal_d_PollLayoutDirection as PollLayoutDirection,
      eventsV1RichContent_universal_d_PollLayout as PollLayout,
      eventsV1RichContent_universal_d_OptionLayout as OptionLayout,
      eventsV1RichContent_universal_d_BackgroundType as BackgroundType,
      eventsV1RichContent_universal_d_Gradient as Gradient,
      eventsV1RichContent_universal_d_Background as Background,
      eventsV1RichContent_universal_d_BackgroundBackgroundOneOf as BackgroundBackgroundOneOf,
      eventsV1RichContent_universal_d_PollDesign as PollDesign,
      eventsV1RichContent_universal_d_OptionDesign as OptionDesign,
      eventsV1RichContent_universal_d_Poll as Poll,
      eventsV1RichContent_universal_d_PollDataLayout as PollDataLayout,
      eventsV1RichContent_universal_d_Design as Design,
      eventsV1RichContent_universal_d_TextData as TextData,
      eventsV1RichContent_universal_d_Decoration as Decoration,
      eventsV1RichContent_universal_d_DecorationDataOneOf as DecorationDataOneOf,
      eventsV1RichContent_universal_d_DecorationType as DecorationType,
      eventsV1RichContent_universal_d_AnchorData as AnchorData,
      eventsV1RichContent_universal_d_ColorData as ColorData,
      eventsV1RichContent_universal_d_LinkData as LinkData,
      eventsV1RichContent_universal_d_MentionData as MentionData,
      eventsV1RichContent_universal_d_FontSizeData as FontSizeData,
      eventsV1RichContent_universal_d_FontType as FontType,
      eventsV1RichContent_universal_d_SpoilerData as SpoilerData,
      eventsV1RichContent_universal_d_AppEmbedData as AppEmbedData,
      eventsV1RichContent_universal_d_AppEmbedDataAppDataOneOf as AppEmbedDataAppDataOneOf,
      eventsV1RichContent_universal_d_AppType as AppType,
      eventsV1RichContent_universal_d_BookingData as BookingData,
      eventsV1RichContent_universal_d_EventData as EventData,
      eventsV1RichContent_universal_d_VideoData as VideoData,
      eventsV1RichContent_universal_d_PlaybackOptions as PlaybackOptions,
      eventsV1RichContent_universal_d_EmbedData as EmbedData,
      eventsV1RichContent_universal_d_Oembed as Oembed,
      eventsV1RichContent_universal_d_CollapsibleListData as CollapsibleListData,
      eventsV1RichContent_universal_d_InitialExpandedItems as InitialExpandedItems,
      eventsV1RichContent_universal_d_Direction as Direction,
      eventsV1RichContent_universal_d_TableData as TableData,
      eventsV1RichContent_universal_d_Dimensions as Dimensions,
      eventsV1RichContent_universal_d_TableCellData as TableCellData,
      eventsV1RichContent_universal_d_VerticalAlignment as VerticalAlignment,
      eventsV1RichContent_universal_d_CellStyle as CellStyle,
      eventsV1RichContent_universal_d_BorderColors as BorderColors,
      eventsV1RichContent_universal_d_NullValue as NullValue,
      eventsV1RichContent_universal_d_ListValue as ListValue,
      eventsV1RichContent_universal_d_AudioData as AudioData,
      eventsV1RichContent_universal_d_OrderedListData as OrderedListData,
      eventsV1RichContent_universal_d_BulletedListData as BulletedListData,
      eventsV1RichContent_universal_d_BlockquoteData as BlockquoteData,
      eventsV1RichContent_universal_d_CaptionData as CaptionData,
      eventsV1RichContent_universal_d_Metadata as Metadata,
      eventsV1RichContent_universal_d_DocumentStyle as DocumentStyle,
      eventsV1RichContent_universal_d_TextNodeStyle as TextNodeStyle,
      ExtendedFields$2 as ExtendedFields,
      eventsV1RichContent_universal_d_CreateRichContentRequest as CreateRichContentRequest,
      eventsV1RichContent_universal_d_CreateRichContentResponse as CreateRichContentResponse,
      eventsV1RichContent_universal_d_GetRichContentRequest as GetRichContentRequest,
      eventsV1RichContent_universal_d_GetRichContentResponse as GetRichContentResponse,
      eventsV1RichContent_universal_d_FindRichContentBySlugRequest as FindRichContentBySlugRequest,
      eventsV1RichContent_universal_d_FindRichContentBySlugResponse as FindRichContentBySlugResponse,
      eventsV1RichContent_universal_d_UpdateRichContentRequest as UpdateRichContentRequest,
      eventsV1RichContent_universal_d_UpdateRichContentResponse as UpdateRichContentResponse,
      eventsV1RichContent_universal_d_DeleteRichContentRequest as DeleteRichContentRequest,
      eventsV1RichContent_universal_d_DeleteRichContentResponse as DeleteRichContentResponse,
      eventsV1RichContent_universal_d_QueryRichContentsRequest as QueryRichContentsRequest,
      CursorQuery$1 as CursorQuery,
      CursorQueryPagingMethodOneOf$1 as CursorQueryPagingMethodOneOf,
      Sorting$5 as Sorting,
      SortOrder$5 as SortOrder,
      CursorPaging$5 as CursorPaging,
      eventsV1RichContent_universal_d_QueryRichContentsResponse as QueryRichContentsResponse,
      CursorPagingMetadata$1 as CursorPagingMetadata,
      Cursors$5 as Cursors,
      eventsV1RichContent_universal_d_QueryRichContentRequest as QueryRichContentRequest,
      eventsV1RichContent_universal_d_QueryRichContentResponse as QueryRichContentResponse,
      EventCopied$2 as EventCopied,
      Location$4 as Location,
      MapCoordinates$4 as MapCoordinates,
      LocationType$4 as LocationType,
      Address$6 as Address,
      AddressStreetOneOf$6 as AddressStreetOneOf,
      StreetAddress$6 as StreetAddress,
      AddressLocation$6 as AddressLocation,
      Subdivision$6 as Subdivision,
      SubdivisionType$6 as SubdivisionType,
      ScheduleConfig$4 as ScheduleConfig,
      Recurrences$4 as Recurrences,
      Occurrence$4 as Occurrence,
      Status$4 as Status,
      EventStatus$4 as EventStatus,
      Empty$4 as Empty,
      EventDeleted$3 as EventDeleted,
      eventsV1RichContent_universal_d_GetOrCreateRichContentRequest as GetOrCreateRichContentRequest,
      eventsV1RichContent_universal_d_GetOrCreateRichContentResponse as GetOrCreateRichContentResponse,
      eventsV1RichContent_universal_d_CountRichContentItemsRequest as CountRichContentItemsRequest,
      eventsV1RichContent_universal_d_CountRichContentItemsResponse as CountRichContentItemsResponse,
      DomainEvent$4 as DomainEvent,
      DomainEventBodyOneOf$4 as DomainEventBodyOneOf,
      EntityCreatedEvent$4 as EntityCreatedEvent,
      RestoreInfo$4 as RestoreInfo,
      EntityUpdatedEvent$4 as EntityUpdatedEvent,
      EntityDeletedEvent$4 as EntityDeletedEvent,
      ActionEvent$4 as ActionEvent,
      MessageEnvelope$7 as MessageEnvelope,
      IdentificationData$7 as IdentificationData,
      IdentificationDataIdOneOf$7 as IdentificationDataIdOneOf,
      WebhookIdentityType$7 as WebhookIdentityType,
      eventsV1RichContent_universal_d_createRichContent as createRichContent,
      eventsV1RichContent_universal_d_getRichContent as getRichContent,
      eventsV1RichContent_universal_d_findRichContentBySlug as findRichContentBySlug,
      eventsV1RichContent_universal_d_FindRichContentBySlugIdentifiers as FindRichContentBySlugIdentifiers,
      eventsV1RichContent_universal_d_updateRichContent as updateRichContent,
      eventsV1RichContent_universal_d_UpdateRichContent as UpdateRichContent,
      eventsV1RichContent_universal_d_UpdateRichContentOptions as UpdateRichContentOptions,
      eventsV1RichContent_universal_d_deleteRichContent as deleteRichContent,
      eventsV1RichContent_universal_d_queryRichContents as queryRichContents,
      eventsV1RichContent_universal_d_QueryRichContentsOptions as QueryRichContentsOptions,
      eventsV1RichContent_universal_d_queryRichContent as queryRichContent,
      eventsV1RichContent_universal_d_RichContentQueryResult as RichContentQueryResult,
      eventsV1RichContent_universal_d_RichContentQueryBuilder as RichContentQueryBuilder,
      eventsV1RichContent_universal_d_countRichContentItems as countRichContentItems,
      eventsV1RichContent_universal_d_CountRichContentItemsOptions as CountRichContentItemsOptions,
    };
  }
  
  interface Rsvp {
      /** RSVP ID. */
      _id?: string;
      /** Event ID to which RSVP belongs. */
      eventId?: string;
      /** Contact ID associated with this RSVP. */
      contactId?: string;
      /** Member ID associated with this RSVP. */
      memberId?: string;
      /** RSVP created timestamp. */
      created?: Date | null;
      /** RSVP modified timestamp. */
      modified?: Date | null;
      /** First name. */
      firstName?: string;
      /** Last name. */
      lastName?: string;
      /** Guest email. */
      email?: string;
      /** RSVP form response. */
      rsvpForm?: FormResponse$2;
      /**
       * RSVP response status. Possible values:
       * - `Yes`
       * - `No`
       * - `Waiting`: a guest is in the waitlist.
       */
      status?: RsvpStatus$1;
      /** Total number of attendees. */
      totalGuests?: number;
      /** List of guests. */
      guests?: Guest$1[];
      /** Whether RSVP is anonymized by GDPR delete. */
      anonymized?: boolean;
      /**
       * Language in which Rsvp was created.
       * @internal
       * @readonly
       */
      language?: string | null;
      /**
       * Locale in which Rsvp was created.
       * @internal
       * @readonly
       */
      locale?: string | null;
  }
  interface FormResponse$2 {
      /** Input form fields. */
      inputValues?: InputValue$2[];
  }
  interface InputValue$2 {
      /** Form field name. */
      inputName?: string;
      /** Form field value. */
      value?: string;
      /** Multiple form field values. */
      values?: string[];
      /**
       * Int or floating point number value.
       * @internal
       */
      number?: number | null;
      /**
       * Date/time value.
       * @internal
       */
      dateTime?: Date | null;
      /**
       * Address type value.
       * @internal
       */
      address?: FormattedAddress$2;
  }
  interface FormattedAddress$2 {
      /** One line address representation. */
      formatted?: string;
      /** Address components (optional). */
      address?: Address$5;
  }
  /** Physical address */
  interface Address$5 extends AddressStreetOneOf$5 {
      /** Street name and number. */
      streetAddress?: StreetAddress$5;
      /** Main address line, usually street and number as free text. */
      addressLine1?: string | null;
      /** Country code. */
      country?: string | null;
      /** Subdivision shorthand. Usually, a short code (2 or 3 letters) that represents a state, region, prefecture, or province. e.g. NY */
      subdivision?: string | null;
      /** City name. */
      city?: string | null;
      /** Zip/postal code. */
      postalCode?: string | null;
      /** Free text providing more detailed address info. Usually contains Apt, Suite, and Floor. */
      addressLine2?: string | null;
      /**
       * A string containing the full address of this location.
       * @internal
       */
      formatted?: string | null;
      /**
       * Coordinates of the physical address.
       * @internal
       */
      location?: AddressLocation$5;
      /**
       * Country full name.
       * @internal
       */
      countryFullname?: string | null;
      /**
       * Subdivision full name.
       * @internal
       */
      subdivisionFullname?: string | null;
      /**
       * Multi-level subdivisions from top to bottom.
       * @internal
       */
      subdivisions?: Subdivision$5[];
  }
  /** @oneof */
  interface AddressStreetOneOf$5 {
      /** Street name and number. */
      streetAddress?: StreetAddress$5;
      /** Main address line, usually street and number as free text. */
      addressLine?: string | null;
  }
  interface StreetAddress$5 {
      /** Street number. */
      number?: string;
      /** Street name. */
      name?: string;
      /**
       * Apartment number.
       * @internal
       */
      apt?: string;
      /**
       * Optional address line 1
       * @internal
       */
      formattedAddressLine?: string | null;
  }
  interface AddressLocation$5 {
      /** Address latitude. */
      latitude?: number | null;
      /** Address longitude. */
      longitude?: number | null;
  }
  interface Subdivision$5 {
      /** Short subdivision code. */
      code?: string;
      /** Subdivision full name. */
      name?: string;
      /**
       * Subdivision level
       * @internal
       */
      type?: SubdivisionType$5;
      /**
       * Free text description of subdivision type.
       * @internal
       */
      typeInfo?: string | null;
      /**
       * Standard organizations details (e.g. ISO).
       * @internal
       */
      standardDetails?: StandardDetails$2;
  }
  enum SubdivisionType$5 {
      UNKNOWN_SUBDIVISION_TYPE = "UNKNOWN_SUBDIVISION_TYPE",
      /** State */
      ADMINISTRATIVE_AREA_LEVEL_1 = "ADMINISTRATIVE_AREA_LEVEL_1",
      /** County */
      ADMINISTRATIVE_AREA_LEVEL_2 = "ADMINISTRATIVE_AREA_LEVEL_2",
      /** City/town */
      ADMINISTRATIVE_AREA_LEVEL_3 = "ADMINISTRATIVE_AREA_LEVEL_3",
      /** Neighborhood/quarter */
      ADMINISTRATIVE_AREA_LEVEL_4 = "ADMINISTRATIVE_AREA_LEVEL_4",
      /** Street/block */
      ADMINISTRATIVE_AREA_LEVEL_5 = "ADMINISTRATIVE_AREA_LEVEL_5",
      /** ADMINISTRATIVE_AREA_LEVEL_0. Indicates the national political entity, and is typically the highest order type returned by the Geocoder. */
      COUNTRY = "COUNTRY"
  }
  /** Subdivision Concordance values */
  interface StandardDetails$2 {
      /** subdivision iso-3166-2 code according to [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). e.g. US-NY, GB-SCT, NO-30 */
      iso31662?: string | null;
  }
  enum RsvpStatus$1 {
      YES = "YES",
      NO = "NO",
      WAITING = "WAITING"
  }
  interface Guest$1 {
      /** Index in the RSVP guest list. */
      index?: number;
      /** Guest full name. */
      fullName?: string;
      /** Guest check-in. */
      checkIn?: CheckIn$1;
      /** Unique guest ID per RSVP. */
      _id?: number;
  }
  interface CheckIn$1 {
      /** Time of check-in */
      created?: Date | null;
  }
  interface ListRsvpRequest {
      /** Number of items to skip. See [Pagination](https://dev.wix.com/api/rest/getting-started/pagination). */
      offset?: number;
      /** Number of items to load. See [Pagination](https://dev.wix.com/api/rest/getting-started/pagination). */
      limit?: number;
      /**
       * Set of fields to return. Possible values:
       * - `DETAILS`: Returns `created`, `modified`, `firstName`, `lastName` fields.
       * - `FORM`: Returns `rsvpForm` field.
       * - `CONTACT_DETAILS`: Returns `email` field.
       */
      fieldset?: RsvpFieldset[];
      /** Event ID to which RSVP belongs. */
      eventId?: string[];
      /** RSVP ID. */
      rsvpId?: string[];
      /**
       * RSVP response status. Possible values:
       * - `Yes`
       * - `No`
       * - `Waiting`: a guest is in the waitlist.
       */
      status?: RsvpStatus$1[];
      /** Site member ID. */
      memberId?: string[];
      /**
       * Deprecated: use tag = MEMBER
       * @internal
       * @deprecated
       */
      membersOnly?: boolean;
      /**
       * Facet counts to include in the response.
       * See [supported facets](https://dev.wix.com/api/rest/wix-events/wix-events/filter-and-sort#wix-events_wix-events_filter-and-sort_list-query-rsvps).
       */
      facet?: string[];
      /** Textual search filter - search is performed on "full_name" and "email". */
      searchPhrase?: string;
      /** Event creator id filter, by default any. */
      eventCreatorId?: string[];
      /**
       * Sort order, defaults to `"created:asc"`.
       * See [supported fields](https://dev.wix.com/api/rest/wix-events/wix-events/filter-and-sort#wix-events_wix-events_filter-and-sort_list-query-rsvps).
       */
      sort?: string;
      /** Contact ID. */
      contactId?: string[];
      /** RSVP tag */
      tag?: RsvpTag[];
  }
  enum RsvpFieldset {
      /** Include RSVP details including: `created`, `modified`, `firstName`, `lastName`, `status`, `totalGuests`, `guests`, and `annonymized`. */
      DETAILS = "DETAILS",
      /** Include RSVP form. */
      FORM = "FORM",
      /** Include RSVP email. */
      CONTACT_DETAILS = "CONTACT_DETAILS"
  }
  enum RsvpTag {
      /** Return only RSVPs of all guests that are fully checked-in. */
      FULLY_CHECKED_IN = "FULLY_CHECKED_IN",
      /** Return only RSVPs of all guests that aren't fully checked-in. */
      NOT_FULLY_CHECKED_IN = "NOT_FULLY_CHECKED_IN",
      /** Return only RSVPs of guests that are members. */
      MEMBER = "MEMBER"
  }
  interface ListRsvpResponse {
      /** Total RSVPs matching the given filters. */
      total?: number;
      /** Offset. */
      offset?: number;
      /** Limit. */
      limit?: number;
      /** RSVP list. */
      rsvps?: Rsvp[];
      /** Facet query result. */
      facets?: Record<string, FacetCounts$4>;
      /** Rsvp data enriched facets. */
      rsvpFacets?: RsvpFacets;
  }
  interface FacetCounts$4 {
      /** Facet counts aggregated per value. */
      counts?: Record<string, number>;
  }
  interface RsvpFacets {
      /** Filter facets. */
      facets?: Record<string, RsvpFacetCounts>;
  }
  interface RsvpFacetCounts {
      /** Facet totals, aggregated per filter. */
      counts?: Record<string, Counts$1>;
  }
  interface Counts$1 {
      /** Number of RSVPs. */
      count?: number;
      /** Number of guests within RSVPs. */
      guests?: number;
      /** Number of guests who have checked-in. */
      guestsCheckIn?: number;
  }
  interface QueryRsvpRequest {
      /** Offset. See [Pagination](https://dev.wix.com/api/rest/getting-started/pagination). */
      offset?: number;
      /** Limit. See [Pagination](https://dev.wix.com/api/rest/getting-started/pagination). */
      limit?: number;
      /**
       * Set of fields to return. Possible values:
       * - `DETAILS`: Returns `created`, `modified`, `firstName`, `lastName` fields.
       * - `FORM`: Returns `rsvpForm` field.
       * - `CONTACT_DETAILS`: Returns `email` field.
       */
      fieldset?: RsvpFieldset[];
      /** Filter. See [supported fields and operators](https://dev.wix.com/api/rest/wix-events/wix-events/filter-and-sort#wix-events_wix-events_filter-and-sort_list-query-rsvps). */
      filter?: Record<string, any> | null;
      /** Site member ID. */
      memberId?: string[];
      /**
       * Deprecated: use tag = MEMBER
       * @internal
       * @deprecated
       */
      membersOnly?: boolean;
      /**
       * Filter facets to include in the response.
       * See [supported facets](https://dev.wix.com/api/rest/wix-events/wix-events/filter-and-sort#wix-events_wix-events_filter-and-sort_list-query-rsvps).
       */
      facet?: string[];
      /** Textual search filter - search is performed on "guests.full_name". */
      searchPhrase?: string;
      /** Event creator ID. */
      eventCreatorId?: string[];
      /**
       * Sort order, defaults to `"created:asc"`.
       * See [supported fields](https://dev.wix.com/api/rest/wix-events/wix-events/filter-and-sort#wix-events_wix-events_filter-and-sort_list-query-rsvps).
       */
      sort?: string;
      /** Contact ID. */
      contactId?: string[];
      /** RSVP tag */
      tag?: RsvpTag[];
  }
  interface QueryRsvpResponse {
      /** Total RSVPs matching the given filters. */
      total?: number;
      /** Offset. */
      offset?: number;
      /** Limit. */
      limit?: number;
      /** RSVP list. */
      rsvps?: Rsvp[];
      /** Facet query result. */
      facets?: Record<string, FacetCounts$4>;
      /** Rsvp data enriched facets. */
      rsvpFacets?: RsvpFacets;
  }
  interface GetRsvpRequest$1 {
      /** Event ID to which RSVP belongs. */
      eventId?: string;
      /** RSVP ID. */
      rsvpId: string;
      /**
       * Set of fields to return. Possible values:
       * - `DETAILS`: Returns `created`, `modified`, `firstName`, `lastName` fields.
       * - `FORM`: Returns `rsvpForm` field.
       * - `CONTACT_DETAILS`: Returns `email` field.
       */
      fieldset?: RsvpFieldset[];
  }
  interface GetRsvpResponse$1 {
      /** RSVP. */
      rsvp?: Rsvp;
  }
  interface CreateRsvpRequest$1 {
      /** Event ID to which RSVP belongs. */
      eventId?: string;
      /** RSVP form response. */
      form?: FormResponse$2;
      /**
       * RSVP response status. Possible values:
       * - `Yes`
       * - `No`
       * - `Waiting`: a guest is in the waitlist.
       */
      status?: RsvpStatus$1;
      /** Member ID of the RSVP. */
      memberId?: string | null;
      /**
       * Add RSVP options.
       * **Note:** WIX_EVENTS.MANAGE_RSVP permission is required.
       */
      options?: ModificationOptions$1;
  }
  interface ModificationOptions$1 {
      /** Whether to ignore notification settings (when hen true, no notifications to contact or user are sent). */
      silent?: boolean;
      /** Whether to create/update regardless of event guest limit. */
      ignoreLimits?: boolean;
      /** Whether to ignore the form validation. */
      ignoreFormValidation?: boolean;
  }
  interface CreateRsvpResponse$1 {
      /** Created RSVP. */
      rsvp?: Rsvp;
      /** "Add to calendar" links. */
      calendarLinks?: CalendarLinks$3;
  }
  interface CalendarLinks$3 {
      /** "Add to Google calendar" URL. */
      google?: string;
      /** "Download ICS calendar file" URL. */
      ics?: string;
  }
  interface RsvpCreated {
      /** RSVP created timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Site language when RSVP created */
      language?: string | null;
      /** Notifications silenced for this domain event. */
      silent?: boolean | null;
      /**
       * Locale in which Rsvp was created.
       * @internal
       */
      locale?: string | null;
      /** Event ID to which RSVP belongs. */
      eventId?: string;
      /** RSVP ID. */
      rsvpId?: string;
      /** Contact ID associated with this RSVP. */
      contactId?: string;
      /** Member ID associated with this RSVP. */
      memberId?: string | null;
      /** Guest first name. */
      firstName?: string;
      /** Guest last name. */
      lastName?: string;
      /** Guest email. */
      email?: string;
      /** RSVP form response. */
      rsvpForm?: FormResponse$2;
      /**
       * RSVP response status. Possible values:
       * - `Yes`
       * - `No`
       * - `Waiting`: a guest is in the waitlist.
       */
      status?: RsvpStatus$1;
      /** List of all guests. */
      guests?: Guest$1[];
      /** URL and password to online conference */
      onlineConferencingLogin?: OnlineConferencingLogin$2;
  }
  interface OnlineConferencingLogin$2 {
      /**
       * Link URL to the online conference.
       * @readonly
       */
      link?: string;
      /**
       * Password for the online conference.
       * @readonly
       */
      password?: string | null;
  }
  interface UpdateRsvpRequest$1 {
      /** Event ID to which RSVP belongs. */
      eventId: string;
      /** RSVP ID. */
      rsvpId: string;
      /**
       * Set of field paths, specifying which parts of RSVP to update.
       * @internal
       */
      fields: string[];
      /** RSVP form response. */
      rsvpForm?: FormResponse$2;
      /**
       * RSVP response status. Possible values:
       * - `Yes`
       * - `No`
       * - `Waiting`: a guest is in the waitlist.
       */
      status?: RsvpStatus$1;
      /**
       * Update RSVP options.
       * WIX_EVENTS.MANAGE_RSVP permission is required.
       */
      options?: ModificationOptions$1;
  }
  interface UpdateRsvpResponse$1 {
      /** Updated RSVP. */
      rsvp?: Rsvp;
  }
  interface RsvpUpdated {
      /** RSVP updated timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Site language when RSVP created */
      language?: string | null;
      /** Locale in which Rsvp was created. */
      locale?: string | null;
      /** Event ID to which RSVP belongs. */
      eventId?: string;
      /** RSVP ID. */
      rsvpId?: string;
      /** Contact ID associated with this RSVP. */
      contactId?: string;
      /** Member ID associated with this RSVP. */
      memberId?: string | null;
      /** RSVP created timestamp. */
      created?: Date | null;
      /** Guest first name. */
      firstName?: string;
      /** Guest last name. */
      lastName?: string;
      /** Guest email. */
      email?: string;
      /** RSVP form response. */
      rsvpForm?: FormResponse$2;
      /**
       * RSVP response status. Possible values:
       * - `Yes`
       * - `No`
       * - `Waiting`: a guest is in the waitlist.
       */
      status?: RsvpStatus$1;
      /** List of the guests. */
      guests?: Guest$1[];
      /** URL and password to online conference */
      onlineConferencingLogin?: OnlineConferencingLogin$2;
      /** Notifications silenced for this domain event. */
      silent?: boolean | null;
  }
  interface BulkUpdateRsvpRequest$1 {
      /** Event ID to which RSVP belongs. */
      eventId: string;
      /** RSVPs to update. */
      rsvpId?: string[];
      /**
       * Set of fields to update.
       * @internal
       */
      fields?: string[];
      /**
       * New RSVP response status. Possible values:
       * - `Yes`
       * - `No`
       * - `Waiting`: a guest is in the waitlist.
       */
      status?: RsvpStatus$1;
  }
  interface BulkUpdateRsvpResponse$1 {
      /** Updated RSVPs. */
      rsvps?: Rsvp[];
  }
  interface BulkUpdateRsvpContactIdRequest$1 {
      /** RSVPs to update. */
      rsvps?: BulkUpdateRsvpContactIdRequestRsvp[];
      /** New RSVP contact ID. */
      contactId?: string | null;
  }
  interface BulkUpdateRsvpContactIdRequestRsvp {
      /** Event ID. */
      eventId?: string | null;
      /** Rsvp ID. */
      rsvpId?: string | null;
  }
  interface BulkUpdateRsvpContactIdResponse$1 {
  }
  interface DeleteRsvpRequest$1 {
      /** Event ID to which RSVP belongs. */
      eventId: string;
      /** RSVPs to delete. */
      rsvps?: string[];
  }
  interface DeleteRsvpResponse$1 {
  }
  interface RsvpDeleted {
      /** RSVP deleted timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Event ID to which RSVP belongs. */
      eventId?: string;
      /** RSVP ID. */
      rsvpId?: string;
      /** Contact ID associated with this RSVP. */
      contactId?: string;
      /** Member ID associated with this RSVP. */
      memberId?: string | null;
      /** Whether RSVP was anonymized by GDPR delete. */
      anonymized?: boolean;
  }
  interface CheckInRsvpRequest {
      /** Event ID to which RSVP belongs. */
      eventId: string;
      /** RSVP ID to check-in. */
      rsvpId: string;
      /** Guest IDs to check-in. */
      guestId?: number[];
  }
  interface CheckInRsvpResponse {
      /** Updated RSVP. */
      rsvp?: Rsvp;
  }
  interface DeleteRsvpCheckInRequest {
      /** Event ID to which RSVP belongs. */
      eventId: string;
      /** RSVP ID to delete check-in. */
      rsvpId: string;
      /** Guest IDs to delete check-in. */
      guestId?: number[];
  }
  interface DeleteRsvpCheckInResponse {
      /** Updated RSVP. */
      rsvp?: Rsvp;
  }
  interface FindRsvpSummaryRequest {
      /** Event id. */
      eventId?: string | null;
      /** Consistent read. */
      consistentRead?: boolean | null;
  }
  interface FindRsvpSummaryResponse {
      /** RSVP summary. */
      rsvpSummary?: RsvpSummary$3;
  }
  interface RsvpSummary$3 {
      /** Total number of RSVPs. */
      total?: number;
      /** Number of RSVPs with status `YES`. */
      yes?: number;
      /** Number of RSVPs with status `NO`. */
      no?: number;
      /** Number of RSVPs in waitlist. */
      waitlist?: number;
  }
  interface CountRsvpAttendingGuestsRequest {
      /** Event id. */
      eventId?: string | null;
      /** Consistent read. */
      consistentRead?: boolean | null;
  }
  interface CountRsvpAttendingGuestsResponse {
      /** RSVP attending guest count. */
      count?: number | null;
  }
  interface MessageEnvelope$6 {
      /** App instance ID. */
      instanceId?: string | null;
      /** Event type. */
      eventType?: string;
      /** The identification type and identity data. */
      identity?: IdentificationData$6;
      /** Stringify payload. */
      data?: string;
  }
  interface IdentificationData$6 extends IdentificationDataIdOneOf$6 {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
      /** @readonly */
      identityType?: WebhookIdentityType$6;
  }
  /** @oneof */
  interface IdentificationDataIdOneOf$6 {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
  }
  enum WebhookIdentityType$6 {
      UNKNOWN = "UNKNOWN",
      ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
      MEMBER = "MEMBER",
      WIX_USER = "WIX_USER",
      APP = "APP"
  }
  /**
   * Retrieves a list of up to 100 RSVPs.
   * @public
   * @param options - Optional fields.
   * @permissionId WIX_EVENTS.READ_RSVP
   * @adminMethod
   */
  function listRsvp(options?: ListRsvpOptions): Promise<ListRsvpResponse>;
  interface ListRsvpOptions {
      /** Number of items to skip. See [Pagination](https://dev.wix.com/api/rest/getting-started/pagination). */
      offset?: number;
      /** Number of items to load. See [Pagination](https://dev.wix.com/api/rest/getting-started/pagination). */
      limit?: number;
      /**
       * Set of fields to return. Possible values:
       * - `DETAILS`: Returns `created`, `modified`, `firstName`, `lastName` fields.
       * - `FORM`: Returns `rsvpForm` field.
       * - `CONTACT_DETAILS`: Returns `email` field.
       */
      fieldset?: RsvpFieldset[];
      /** Event ID to which RSVP belongs. */
      eventId?: string[];
      /** RSVP ID. */
      rsvpId?: string[];
      /**
       * RSVP response status. Possible values:
       * - `Yes`
       * - `No`
       * - `Waiting`: a guest is in the waitlist.
       */
      status?: RsvpStatus$1[];
      /** Site member ID. */
      memberId?: string[];
      /**
       * Deprecated: use tag = MEMBER
       * @internal
       * @deprecated
       */
      membersOnly?: boolean;
      /**
       * Facet counts to include in the response.
       * See [supported facets](https://dev.wix.com/api/rest/wix-events/wix-events/filter-and-sort#wix-events_wix-events_filter-and-sort_list-query-rsvps).
       */
      facet?: string[];
      /** Textual search filter - search is performed on "full_name" and "email". */
      searchPhrase?: string;
      /** Event creator id filter, by default any. */
      eventCreatorId?: string[];
      /**
       * Sort order, defaults to `"created:asc"`.
       * See [supported fields](https://dev.wix.com/api/rest/wix-events/wix-events/filter-and-sort#wix-events_wix-events_filter-and-sort_list-query-rsvps).
       */
      sort?: string;
      /** Contact ID. */
      contactId?: string[];
      /** RSVP tag */
      tag?: RsvpTag[];
  }
  /**
   * Retrieves a list of up to 100 RSVPs.
   * @public
   * @param options - Optional fields.
   * @permissionId WIX_EVENTS.READ_RSVP
   * @adminMethod
   */
  function queryRsvp(options?: QueryRsvpOptions): Promise<QueryRsvpResponse>;
  interface QueryRsvpOptions {
      /** Offset. See [Pagination](https://dev.wix.com/api/rest/getting-started/pagination). */
      offset?: number;
      /** Limit. See [Pagination](https://dev.wix.com/api/rest/getting-started/pagination). */
      limit?: number;
      /**
       * Set of fields to return. Possible values:
       * - `DETAILS`: Returns `created`, `modified`, `firstName`, `lastName` fields.
       * - `FORM`: Returns `rsvpForm` field.
       * - `CONTACT_DETAILS`: Returns `email` field.
       */
      fieldset?: RsvpFieldset[];
      /** Filter. See [supported fields and operators](https://dev.wix.com/api/rest/wix-events/wix-events/filter-and-sort#wix-events_wix-events_filter-and-sort_list-query-rsvps). */
      filter?: Record<string, any> | null;
      /** Site member ID. */
      memberId?: string[];
      /**
       * Deprecated: use tag = MEMBER
       * @internal
       * @deprecated
       */
      membersOnly?: boolean;
      /**
       * Filter facets to include in the response.
       * See [supported facets](https://dev.wix.com/api/rest/wix-events/wix-events/filter-and-sort#wix-events_wix-events_filter-and-sort_list-query-rsvps).
       */
      facet?: string[];
      /** Textual search filter - search is performed on "guests.full_name". */
      searchPhrase?: string;
      /** Event creator ID. */
      eventCreatorId?: string[];
      /**
       * Sort order, defaults to `"created:asc"`.
       * See [supported fields](https://dev.wix.com/api/rest/wix-events/wix-events/filter-and-sort#wix-events_wix-events_filter-and-sort_list-query-rsvps).
       */
      sort?: string;
      /** Contact ID. */
      contactId?: string[];
      /** RSVP tag */
      tag?: RsvpTag[];
  }
  /**
   * Retrieves an RSVP.
   * @param rsvpId - RSVP ID.
   * @public
   * @requiredField rsvpId
   * @param options - Optional fields.
   * @permissionId WIX_EVENTS.READ_RSVP
   * @adminMethod
   * @returns RSVP.
   */
  function getRsvp$1(rsvpId: string, options?: GetRsvpOptions$1): Promise<Rsvp>;
  interface GetRsvpOptions$1 {
      /** Event ID to which RSVP belongs. */
      eventId?: string;
      /**
       * Set of fields to return. Possible values:
       * - `DETAILS`: Returns `created`, `modified`, `firstName`, `lastName` fields.
       * - `FORM`: Returns `rsvpForm` field.
       * - `CONTACT_DETAILS`: Returns `email` field.
       */
      fieldset?: RsvpFieldset[];
  }
  /**
   * Creates an RSVP, associated with a contact of the site.
   * @public
   * @param options - Optional fields.
   * @permissionId WIX_EVENTS.CREATE_RSVP
   */
  function createRsvp$1(options?: CreateRsvpOptions$1): Promise<CreateRsvpResponse$1>;
  interface CreateRsvpOptions$1 {
      /** Event ID to which RSVP belongs. */
      eventId?: string;
      /** RSVP form response. */
      form?: FormResponse$2;
      /**
       * RSVP response status. Possible values:
       * - `Yes`
       * - `No`
       * - `Waiting`: a guest is in the waitlist.
       */
      status?: RsvpStatus$1;
      /** Member ID of the RSVP. */
      memberId?: string | null;
      /**
       * Add RSVP options.
       * **Note:** WIX_EVENTS.MANAGE_RSVP permission is required.
       */
      options?: ModificationOptions$1;
  }
  /**
   * Updates an RSVP.
   * @param rsvpId - RSVP ID.
   * @public
   * @requiredField eventId
   * @requiredField rsvpId
   * @param eventId - Event ID to which RSVP belongs.
   * @param options - Optional fields.
   * @permissionId WIX_EVENTS.MANAGE_RSVP
   * @adminMethod
   */
  function updateRsvp$1(rsvpId: string, eventId: string, options?: UpdateRsvpOptions$1): Promise<UpdateRsvpResponse$1>;
  interface UpdateRsvpOptions$1 {
      /**
       * Set of field paths, specifying which parts of RSVP to update.
       * @internal
       */
      fields: string[];
      /** RSVP form response. */
      rsvpForm?: FormResponse$2;
      /**
       * RSVP response status. Possible values:
       * - `Yes`
       * - `No`
       * - `Waiting`: a guest is in the waitlist.
       */
      status?: RsvpStatus$1;
      /**
       * Update RSVP options.
       * WIX_EVENTS.MANAGE_RSVP permission is required.
       */
      options?: ModificationOptions$1;
  }
  /**
   * Updates statuses of multiple RSVPs.
   * @public
   * @requiredField eventId
   * @param eventId - Event ID to which RSVP belongs.
   * @param options - Optional fields.
   * @permissionId WIX_EVENTS.MANAGE_RSVP
   * @adminMethod
   */
  function bulkUpdateRsvp$1(eventId: string, options?: BulkUpdateRsvpOptions$1): Promise<BulkUpdateRsvpResponse$1>;
  interface BulkUpdateRsvpOptions$1 {
      /** RSVPs to update. */
      rsvpId?: string[];
      /**
       * Set of fields to update.
       * @internal
       */
      fields?: string[];
      /**
       * New RSVP response status. Possible values:
       * - `Yes`
       * - `No`
       * - `Waiting`: a guest is in the waitlist.
       */
      status?: RsvpStatus$1;
  }
  /**
   * Deletes an RSVP.
   * @public
   * @requiredField eventId
   * @param eventId - Event ID to which RSVP belongs.
   * @param options - Optional fields.
   * @permissionId WIX_EVENTS.MANAGE_RSVP
   * @adminMethod
   */
  function deleteRsvp$1(eventId: string, options?: DeleteRsvpOptions): Promise<void>;
  interface DeleteRsvpOptions {
      /** RSVPs to delete. When not defined, all RSVPs associated with this event are deleted. */
      rsvps?: string[];
  }
  /**
   * Checks-in an RSVP.
   * @public
   * @requiredField eventId
   * @requiredField options.rsvpId
   * @param eventId - Event ID to which RSVP belongs.
   * @param options - Optional fields.
   * @permissionId WIX_EVENTS.CHECK_IN
   * @adminMethod
   */
  function checkInRsvp(eventId: string, options?: CheckInRsvpOptions): Promise<CheckInRsvpResponse>;
  interface CheckInRsvpOptions {
      /** RSVP ID to check-in. */
      rsvpId: string;
      /** Guest IDs to check-in. */
      guestId?: number[];
  }
  /**
   * Deletes an RSVP check-in.
   * @public
   * @requiredField eventId
   * @requiredField options.rsvpId
   * @param eventId - Event ID to which RSVP belongs.
   * @param options - Optional fields.
   * @permissionId WIX_EVENTS.CHECK_IN
   * @adminMethod
   */
  function deleteRsvpCheckIn(eventId: string, options?: DeleteRsvpCheckInOptions): Promise<DeleteRsvpCheckInResponse>;
  interface DeleteRsvpCheckInOptions {
      /** RSVP ID to delete check-in. */
      rsvpId: string;
      /** Guest IDs to delete check-in. */
      guestId?: number[];
  }
  
  type eventsV1Rsvp_universal_d_Rsvp = Rsvp;
  type eventsV1Rsvp_universal_d_ListRsvpRequest = ListRsvpRequest;
  type eventsV1Rsvp_universal_d_RsvpFieldset = RsvpFieldset;
  const eventsV1Rsvp_universal_d_RsvpFieldset: typeof RsvpFieldset;
  type eventsV1Rsvp_universal_d_RsvpTag = RsvpTag;
  const eventsV1Rsvp_universal_d_RsvpTag: typeof RsvpTag;
  type eventsV1Rsvp_universal_d_ListRsvpResponse = ListRsvpResponse;
  type eventsV1Rsvp_universal_d_RsvpFacets = RsvpFacets;
  type eventsV1Rsvp_universal_d_RsvpFacetCounts = RsvpFacetCounts;
  type eventsV1Rsvp_universal_d_QueryRsvpRequest = QueryRsvpRequest;
  type eventsV1Rsvp_universal_d_QueryRsvpResponse = QueryRsvpResponse;
  type eventsV1Rsvp_universal_d_RsvpCreated = RsvpCreated;
  type eventsV1Rsvp_universal_d_RsvpUpdated = RsvpUpdated;
  type eventsV1Rsvp_universal_d_BulkUpdateRsvpContactIdRequestRsvp = BulkUpdateRsvpContactIdRequestRsvp;
  type eventsV1Rsvp_universal_d_RsvpDeleted = RsvpDeleted;
  type eventsV1Rsvp_universal_d_CheckInRsvpRequest = CheckInRsvpRequest;
  type eventsV1Rsvp_universal_d_CheckInRsvpResponse = CheckInRsvpResponse;
  type eventsV1Rsvp_universal_d_DeleteRsvpCheckInRequest = DeleteRsvpCheckInRequest;
  type eventsV1Rsvp_universal_d_DeleteRsvpCheckInResponse = DeleteRsvpCheckInResponse;
  type eventsV1Rsvp_universal_d_FindRsvpSummaryRequest = FindRsvpSummaryRequest;
  type eventsV1Rsvp_universal_d_FindRsvpSummaryResponse = FindRsvpSummaryResponse;
  type eventsV1Rsvp_universal_d_CountRsvpAttendingGuestsRequest = CountRsvpAttendingGuestsRequest;
  type eventsV1Rsvp_universal_d_CountRsvpAttendingGuestsResponse = CountRsvpAttendingGuestsResponse;
  const eventsV1Rsvp_universal_d_listRsvp: typeof listRsvp;
  type eventsV1Rsvp_universal_d_ListRsvpOptions = ListRsvpOptions;
  const eventsV1Rsvp_universal_d_queryRsvp: typeof queryRsvp;
  type eventsV1Rsvp_universal_d_QueryRsvpOptions = QueryRsvpOptions;
  type eventsV1Rsvp_universal_d_DeleteRsvpOptions = DeleteRsvpOptions;
  const eventsV1Rsvp_universal_d_checkInRsvp: typeof checkInRsvp;
  type eventsV1Rsvp_universal_d_CheckInRsvpOptions = CheckInRsvpOptions;
  const eventsV1Rsvp_universal_d_deleteRsvpCheckIn: typeof deleteRsvpCheckIn;
  type eventsV1Rsvp_universal_d_DeleteRsvpCheckInOptions = DeleteRsvpCheckInOptions;
  namespace eventsV1Rsvp_universal_d {
    export {
      eventsV1Rsvp_universal_d_Rsvp as Rsvp,
      FormResponse$2 as FormResponse,
      InputValue$2 as InputValue,
      FormattedAddress$2 as FormattedAddress,
      Address$5 as Address,
      AddressStreetOneOf$5 as AddressStreetOneOf,
      StreetAddress$5 as StreetAddress,
      AddressLocation$5 as AddressLocation,
      Subdivision$5 as Subdivision,
      SubdivisionType$5 as SubdivisionType,
      StandardDetails$2 as StandardDetails,
      RsvpStatus$1 as RsvpStatus,
      Guest$1 as Guest,
      CheckIn$1 as CheckIn,
      eventsV1Rsvp_universal_d_ListRsvpRequest as ListRsvpRequest,
      eventsV1Rsvp_universal_d_RsvpFieldset as RsvpFieldset,
      eventsV1Rsvp_universal_d_RsvpTag as RsvpTag,
      eventsV1Rsvp_universal_d_ListRsvpResponse as ListRsvpResponse,
      FacetCounts$4 as FacetCounts,
      eventsV1Rsvp_universal_d_RsvpFacets as RsvpFacets,
      eventsV1Rsvp_universal_d_RsvpFacetCounts as RsvpFacetCounts,
      Counts$1 as Counts,
      eventsV1Rsvp_universal_d_QueryRsvpRequest as QueryRsvpRequest,
      eventsV1Rsvp_universal_d_QueryRsvpResponse as QueryRsvpResponse,
      GetRsvpRequest$1 as GetRsvpRequest,
      GetRsvpResponse$1 as GetRsvpResponse,
      CreateRsvpRequest$1 as CreateRsvpRequest,
      ModificationOptions$1 as ModificationOptions,
      CreateRsvpResponse$1 as CreateRsvpResponse,
      CalendarLinks$3 as CalendarLinks,
      eventsV1Rsvp_universal_d_RsvpCreated as RsvpCreated,
      OnlineConferencingLogin$2 as OnlineConferencingLogin,
      UpdateRsvpRequest$1 as UpdateRsvpRequest,
      UpdateRsvpResponse$1 as UpdateRsvpResponse,
      eventsV1Rsvp_universal_d_RsvpUpdated as RsvpUpdated,
      BulkUpdateRsvpRequest$1 as BulkUpdateRsvpRequest,
      BulkUpdateRsvpResponse$1 as BulkUpdateRsvpResponse,
      BulkUpdateRsvpContactIdRequest$1 as BulkUpdateRsvpContactIdRequest,
      eventsV1Rsvp_universal_d_BulkUpdateRsvpContactIdRequestRsvp as BulkUpdateRsvpContactIdRequestRsvp,
      BulkUpdateRsvpContactIdResponse$1 as BulkUpdateRsvpContactIdResponse,
      DeleteRsvpRequest$1 as DeleteRsvpRequest,
      DeleteRsvpResponse$1 as DeleteRsvpResponse,
      eventsV1Rsvp_universal_d_RsvpDeleted as RsvpDeleted,
      eventsV1Rsvp_universal_d_CheckInRsvpRequest as CheckInRsvpRequest,
      eventsV1Rsvp_universal_d_CheckInRsvpResponse as CheckInRsvpResponse,
      eventsV1Rsvp_universal_d_DeleteRsvpCheckInRequest as DeleteRsvpCheckInRequest,
      eventsV1Rsvp_universal_d_DeleteRsvpCheckInResponse as DeleteRsvpCheckInResponse,
      eventsV1Rsvp_universal_d_FindRsvpSummaryRequest as FindRsvpSummaryRequest,
      eventsV1Rsvp_universal_d_FindRsvpSummaryResponse as FindRsvpSummaryResponse,
      RsvpSummary$3 as RsvpSummary,
      eventsV1Rsvp_universal_d_CountRsvpAttendingGuestsRequest as CountRsvpAttendingGuestsRequest,
      eventsV1Rsvp_universal_d_CountRsvpAttendingGuestsResponse as CountRsvpAttendingGuestsResponse,
      MessageEnvelope$6 as MessageEnvelope,
      IdentificationData$6 as IdentificationData,
      IdentificationDataIdOneOf$6 as IdentificationDataIdOneOf,
      WebhookIdentityType$6 as WebhookIdentityType,
      eventsV1Rsvp_universal_d_listRsvp as listRsvp,
      eventsV1Rsvp_universal_d_ListRsvpOptions as ListRsvpOptions,
      eventsV1Rsvp_universal_d_queryRsvp as queryRsvp,
      eventsV1Rsvp_universal_d_QueryRsvpOptions as QueryRsvpOptions,
      getRsvp$1 as getRsvp,
      GetRsvpOptions$1 as GetRsvpOptions,
      createRsvp$1 as createRsvp,
      CreateRsvpOptions$1 as CreateRsvpOptions,
      updateRsvp$1 as updateRsvp,
      UpdateRsvpOptions$1 as UpdateRsvpOptions,
      bulkUpdateRsvp$1 as bulkUpdateRsvp,
      BulkUpdateRsvpOptions$1 as BulkUpdateRsvpOptions,
      deleteRsvp$1 as deleteRsvp,
      eventsV1Rsvp_universal_d_DeleteRsvpOptions as DeleteRsvpOptions,
      eventsV1Rsvp_universal_d_checkInRsvp as checkInRsvp,
      eventsV1Rsvp_universal_d_CheckInRsvpOptions as CheckInRsvpOptions,
      eventsV1Rsvp_universal_d_deleteRsvpCheckIn as deleteRsvpCheckIn,
      eventsV1Rsvp_universal_d_DeleteRsvpCheckInOptions as DeleteRsvpCheckInOptions,
    };
  }
  
  interface TicketingTicket {
      /** A unique ticket number which is assigned automatically when creating a ticket. */
      ticketNumber?: string;
      /** Associated order number. */
      orderNumber?: string;
      /** Ticket definition ID. */
      ticketDefinitionId?: string;
      /** Ticket name. */
      name?: string;
      /** Ticket price. */
      price?: Money$4;
      /**
       * Whether ticket requires payment.
       * @readonly
       */
      free?: boolean;
      /** Ticket and event policies. */
      policy?: string;
      /**
       * @internal
       * @internal
       * @deprecated
       */
      qrCode?: string;
      /** Ticket check-in. */
      checkIn?: CheckIn;
      /**
       * Associated order status. Possible values:
       * - `FREE`: The order is confirmed, no payment is required.
       * - `PENDING`: The order was paid, but the payment gateway suspended the payment.
       * - `PAID`: The order is paid.
       * - `OFFLINE_PENDING`: The order is confirmed but has to be paid in cash and the status is manually updated to `PAID`.
       * - `INITIATED`: The order is awaiting for payment.
       * - `CANCELED`: The order is canceled.
       * - `DECLINED`: The order is declined.
       */
      orderStatus?: OrderStatus;
      /** Whether order and ticket are visible in order list. */
      orderArchived?: boolean;
      /** Buyer full name. */
      orderFullName?: string;
      /** Guest full name. */
      guestFullName?: string | null;
      /** Guest personal details. */
      guestDetails?: GuestDetails;
      /** Whether the ticket is visible in an order. */
      archived?: boolean;
      /**
       * @internal
       * @internal
       * @deprecated
       */
      ticketPdf?: string;
      /** Ticket owner member ID. */
      memberId?: string | null;
      /**
       * Whether ticket was anonymized by GDPR delete.
       * Anonymized tickets no longer contain personally identifiable information (PII).
       */
      anonymized?: boolean;
      /**
       * Ticket check-in URL.
       * Shown as QR code image in PDF.
       *
       * Format: `https://www.wixevents.com/check-in/{ticket number},{event id}`
       *
       * Example: `https://www.wixevents.com/check-in/AAAA-AAAA-BB021,00000000-0000-0000-0000-000000000000`
       */
      checkInUrl?: string;
      /** URL for ticket PDF download. */
      ticketPdfUrl?: string;
      /** Associated order checkout channel type. */
      channel?: ChannelType;
      /**
       * An URL to download a ticket in the `.pkpass` format for Apple Wallet.
       * @readonly
       */
      walletPassUrl?: string;
      /**
       * Additional ticket details.
       * @internal
       * @readonly
       */
      ticketDetails?: TicketDetails;
  }
  interface Money$4 {
      /**
       * *Deprecated:** Use `value` instead.
       * @deprecated
       */
      amount?: string;
      /** Currency in the [ISO 4217](https://www.iso.org/iso-4217-currency-codes.html) format. For example, `USD`. */
      currency?: string;
      /** Monetary amount. Decimal string with a period as a decimal separator (e.g., 3.99). Optionally, starts with a single (-), to indicate that the amount is negative. */
      value?: string | null;
  }
  interface CheckIn {
      /** Time of a ticket check-in. */
      created?: Date | null;
  }
  enum OrderStatus {
      /** Order status not available for this request fieldset. */
      NA_ORDER_STATUS = "NA_ORDER_STATUS",
      /** Order is confirmed and payment isn't required. */
      FREE = "FREE",
      /** Order is paid for but the payment gateway has suspended the payment. */
      PENDING = "PENDING",
      /** Order is paid via a payment gateway. */
      PAID = "PAID",
      /** Order is confirmed but must be paid via offline payment. Status needs to be manually updated to `PAID`. */
      OFFLINE_PENDING = "OFFLINE_PENDING",
      /** Order is awaiting payment at the cashier. */
      INITIATED = "INITIATED",
      /** Order is canceled. */
      CANCELED = "CANCELED",
      /** Order payment is declined. */
      DECLINED = "DECLINED",
      /** Order payment is authorized. */
      AUTHORIZED = "AUTHORIZED",
      /** Order payment is voided. */
      VOIDED = "VOIDED",
      /** Order is partially paid with less than the total amount. */
      PARTIALLY_PAID = "PARTIALLY_PAID"
  }
  interface GuestDetails {
      /** Whether ticket belongs to assigned guest. */
      guestAssigned?: boolean;
      /** Guest first name. */
      firstName?: string | null;
      /** Guest last name. */
      lastName?: string | null;
      /** Guest email. */
      email?: string | null;
      /** Full form response. */
      form?: FormResponse$1;
      /** Contact ID associated with this guest. */
      contactId?: string | null;
      /** Guest phone number. */
      phone?: string | null;
  }
  interface FormResponse$1 {
      /** Form field inputs. */
      inputValues?: InputValue$1[];
  }
  interface InputValue$1 {
      /** Form field input name. */
      inputName?: string;
      /** Form field value. */
      value?: string;
      /** Form field values. */
      values?: string[];
      /**
       * Int or floating point number value.
       * @internal
       */
      number?: number | null;
      /**
       * Date/time value.
       * @internal
       */
      dateTime?: Date | null;
      /**
       * Address type value.
       * @internal
       */
      address?: FormattedAddress$1;
  }
  interface FormattedAddress$1 {
      /** One line address representation. */
      formatted?: string;
      /** Address components (optional). */
      address?: Address$4;
  }
  /** Physical address */
  interface Address$4 extends AddressStreetOneOf$4 {
      /** Street name and number. */
      streetAddress?: StreetAddress$4;
      /** Main address line, usually street and number as free text. */
      addressLine1?: string | null;
      /** Country code. */
      country?: string | null;
      /** Subdivision shorthand. Usually, a short code (2 or 3 letters) that represents a state, region, prefecture, or province. e.g. NY */
      subdivision?: string | null;
      /** City name. */
      city?: string | null;
      /** Zip/postal code. */
      postalCode?: string | null;
      /** Free text providing more detailed address info. Usually contains Apt, Suite, and Floor. */
      addressLine2?: string | null;
      /**
       * A string containing the full address of this location.
       * @internal
       */
      formatted?: string | null;
      /**
       * Coordinates of the physical address.
       * @internal
       */
      location?: AddressLocation$4;
      /**
       * Country full name.
       * @internal
       */
      countryFullname?: string | null;
      /**
       * Subdivision full name.
       * @internal
       */
      subdivisionFullname?: string | null;
      /**
       * Multi-level subdivisions from top to bottom.
       * @internal
       */
      subdivisions?: Subdivision$4[];
  }
  /** @oneof */
  interface AddressStreetOneOf$4 {
      /** Street name and number. */
      streetAddress?: StreetAddress$4;
      /** Main address line, usually street and number as free text. */
      addressLine?: string | null;
  }
  interface StreetAddress$4 {
      /** Street number. */
      number?: string;
      /** Street name. */
      name?: string;
      /**
       * Apartment number.
       * @internal
       */
      apt?: string;
      /**
       * Optional address line 1
       * @internal
       */
      formattedAddressLine?: string | null;
  }
  interface AddressLocation$4 {
      /** Address latitude. */
      latitude?: number | null;
      /** Address longitude. */
      longitude?: number | null;
  }
  interface Subdivision$4 {
      /** Short subdivision code. */
      code?: string;
      /** Subdivision full name. */
      name?: string;
      /**
       * Subdivision level
       * @internal
       */
      type?: SubdivisionType$4;
      /**
       * Free text description of subdivision type.
       * @internal
       */
      typeInfo?: string | null;
      /**
       * Standard organizations details (e.g. ISO).
       * @internal
       */
      standardDetails?: StandardDetails$1;
  }
  enum SubdivisionType$4 {
      UNKNOWN_SUBDIVISION_TYPE = "UNKNOWN_SUBDIVISION_TYPE",
      /** State */
      ADMINISTRATIVE_AREA_LEVEL_1 = "ADMINISTRATIVE_AREA_LEVEL_1",
      /** County */
      ADMINISTRATIVE_AREA_LEVEL_2 = "ADMINISTRATIVE_AREA_LEVEL_2",
      /** City/town */
      ADMINISTRATIVE_AREA_LEVEL_3 = "ADMINISTRATIVE_AREA_LEVEL_3",
      /** Neighborhood/quarter */
      ADMINISTRATIVE_AREA_LEVEL_4 = "ADMINISTRATIVE_AREA_LEVEL_4",
      /** Street/block */
      ADMINISTRATIVE_AREA_LEVEL_5 = "ADMINISTRATIVE_AREA_LEVEL_5",
      /** ADMINISTRATIVE_AREA_LEVEL_0. Indicates the national political entity, and is typically the highest order type returned by the Geocoder. */
      COUNTRY = "COUNTRY"
  }
  /** Subdivision Concordance values */
  interface StandardDetails$1 {
      /** subdivision iso-3166-2 code according to [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). e.g. US-NY, GB-SCT, NO-30 */
      iso31662?: string | null;
  }
  enum ChannelType {
      /** Buyer created the order via an online channel such as a website or mobile app. */
      ONLINE = "ONLINE",
      /** Sales person created the order and collected the money. */
      OFFLINE_POS = "OFFLINE_POS"
  }
  interface TicketDetails {
      /** Unique seat id in the event venue. */
      seatId?: string | null;
      /**
       * Optional sector name.
       * @internal
       * @readonly
       */
      sectorName?: string | null;
      /**
       * Area name.
       * @internal
       * @readonly
       */
      areaName?: string | null;
      /**
       * Table name.
       * @internal
       * @readonly
       */
      tableName?: string | null;
      /**
       * Row label.
       * @internal
       * @readonly
       */
      rowNumber?: string | null;
      /**
       * Seat label in a row or table.
       * @internal
       * @readonly
       */
      seatNumber?: string | null;
      /**
       * Optional sector label.
       * @readonly
       */
      sectionLabel?: string | null;
      /**
       * Area label.
       * @readonly
       */
      areaLabel?: string | null;
      /**
       * Table label.
       * @readonly
       */
      tableLabel?: string | null;
      /**
       * Row label.
       * @readonly
       */
      rowLabel?: string | null;
      /**
       * Seat label in a row or table.
       * @readonly
       */
      seatLabel?: string | null;
      /** Number of places in the spot. If not provided - defaults to 1. */
      capacity?: number | null;
      /** Custom pricing of ticket. */
      priceOverride?: string | null;
      /** Pricing option id. */
      pricingOptionId?: string | null;
      /**
       * Pricing option name.
       * @readonly
       */
      pricingOptionName?: string | null;
  }
  interface ListTicketsRequest {
      /** Event IDs. */
      eventId: string[];
      /** Offset. See [Pagination](/wix-events-v2/pagination). */
      offset?: number;
      /** Number of items to load per page. See [Pagination](https://dev.wix.com/api/rest/getting-started/pagination). */
      limit?: number;
      /**
       * Deprecated, use `sort` instead.
       * Sort order. Defaults to "ticket_number:asc".
       * See [supported fields](https://dev.wix.com/api/rest/wix-events/wix-events/filter-and-sort#wix-events_wix-events_filter-and-sort_list-tickets).
       * @internal
       * @deprecated
       */
      order?: string;
      /** Order numbers. */
      orderNumber?: string[];
      /** Ticket numbers. */
      ticketNumber?: string[];
      /** Searches in the `orderFullName`, `guestFullName`, and `ticketNumber` fields. */
      searchPhrase?: string;
      /** Order statuses. */
      orderStatus?: OrderStatus[];
      /**
       * Deprecated, use `ORDER_ARCHIVED` / `ORDER_ACTIVE` state filter instead.
       * @internal
       * @deprecated
       */
      orderArchived?: boolean | null;
      /**
       * Deprecated, use `CHECKED_IN` / `NON_CHECKED_IN` state filter instead.
       * @internal
       * @deprecated
       */
      checkedIn?: boolean | null;
      /**
       * Predefined sets of fields to return.
       * - `TICKET_DETAILS`: Returns `ticketNumber`, `orderNumber`, `ticketDefinitionId`, `name`, `price`, `free`, `policy`, `qrCode`, `checkIn`, `orderStatus`, `orderArchived`, `archived`, `orderFullName`, `ticketPdf`, `checkInUrl` and `ticketPdfUrl`.
       * - `GUEST_DETAILS`: Returns `guestDetails`.
       * - `GUEST_FORM`: Returns `guestDetails.form`.
       *
       * Default: If a fieldset is not included in the request, returns only the `memberId` and `anonymized` fields.
       */
      fieldset?: TicketFieldset[];
      /**
       * Ticket states. Possible values:
       * - `ORDER_ARCHIVED`: Returns tickets of the archived orders.
       * - `ORDER_ACTIVE`: Returns tickets of the non-archived orders.
       * - `TICKET_ARCHIVED`: Returns archived tickets.
       * - `TICKET_ACTIVE`: Returns non-archived tickets.
       * - `CHECKED_IN`: Returns checked-in tickets.
       * - `NON_CHECKED_IN`: Returns tickets that are not checked in.
       * - `FREE`: Returns free tickets.
       * - `PAID`: Return paid tickets.
       * - `MEMBER`: Return members' tickets.
       */
      state?: State$4[];
      /** Site member IDs. */
      memberId?: string[];
      /** Filter facets. */
      facet?: string[];
      /** Sort order. Defaults to "ticket_number:asc". */
      sort?: string;
      /** Guest contact IDs. */
      contactId?: string[];
      /** Ticket definition IDs. */
      ticketDefinitionId?: string[];
  }
  enum TicketFieldset {
      /** Include guest details in the ticket response. */
      GUEST_DETAILS = "GUEST_DETAILS",
      /** Include ticket details in the ticket response. */
      TICKET_DETAILS = "TICKET_DETAILS",
      /** Include individual guest form in the ticket response. */
      GUEST_FORM = "GUEST_FORM"
  }
  enum State$4 {
      /** Returns only archived orders' tickets. */
      ORDER_ARCHIVED = "ORDER_ARCHIVED",
      /** Returns only non-archived orders' tickets. */
      ORDER_ACTIVE = "ORDER_ACTIVE",
      /** Returns only archived tickets. */
      TICKET_ARCHIVED = "TICKET_ARCHIVED",
      /** Returns only non-archived tickets. */
      TICKET_ACTIVE = "TICKET_ACTIVE",
      /** Returns only checked-in tickets. */
      CHECKED_IN = "CHECKED_IN",
      /** Returns only non-checked-in tickets. */
      NON_CHECKED_IN = "NON_CHECKED_IN",
      /** Returns only free tickets. */
      FREE = "FREE",
      /** Returns only paid tickets. */
      PAID = "PAID",
      /** Returns only member tickets. */
      MEMBER = "MEMBER"
  }
  interface ListTicketsResponse {
      /** Total tickets matching the given filters. */
      total?: number;
      /** Offset. */
      offset?: number;
      /** Limit. */
      limit?: number;
      /** Tickets. */
      tickets?: TicketingTicket[];
      /** Facets. */
      facets?: Record<string, FacetCounts$3>;
      /**
       * Ticket data enriched facets.
       * @internal
       */
      ticketFacets?: TicketFacets;
  }
  interface FacetCounts$3 {
      /** Facet counts aggregated per value. */
      counts?: Record<string, number>;
  }
  interface TicketFacets {
      /** Filter facets. */
      facets?: Record<string, TicketFacetCounts>;
  }
  interface TicketFacetCounts {
      /** Facet totals, aggregated per filter. */
      counts?: Record<string, Counts>;
  }
  interface Counts {
      /** Number of tickets. */
      count?: number;
      /** Number of checked in tickets. */
      checkedIn?: number;
  }
  interface GetTicketRequest {
      /** Event ID to which the ticket belongs. */
      eventId: string;
      /** A unique ticket number which is assigned automatically when creating a ticket. */
      ticketNumber: string;
      /**
       * Predefined sets of fields to return.
       * - `TICKET_DETAILS`: Returns `ticketNumber`, `orderNumber`, `ticketDefinitionId`, `name`, `price`, `free`, `policy`, `qrCode`, `checkIn`, `orderStatus`, `orderArchived`, `archived`, `orderFullName`, `ticketPdf`, `checkInUrl` and `ticketPdfUrl`.
       * - `GUEST_DETAILS`: Returns `guestDetails`.
       * - `GUEST_FORM`: Returns `guestDetails.form`.
       *
       * Default: If a fieldset is not included in the request, returns only the `memberId` and `anonymized` fields.
       */
      fieldset?: TicketFieldset[];
  }
  interface GetTicketResponse {
      /** Ticket. */
      ticket?: TicketingTicket;
  }
  interface CheckInTicketRequest {
      /** Event ID to which the ticket belongs. */
      eventId: string;
      /**
       * Deprecated, use individual ticket numbers.
       * @internal
       * @deprecated
       */
      orderNumber?: string;
      /** Tickets to check-in. */
      ticketNumber?: string[];
  }
  interface CheckInTicketResponse {
      /** Updated tickets. */
      tickets?: TicketingTicket[];
  }
  interface OrderUpdated {
      /** Order updated timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Site language when Order initiated */
      language?: string | null;
      /** Locale in which Order was created. */
      locale?: string | null;
      /** Event ID to which the ticket belongs. */
      eventId?: string;
      /** Unique order number. */
      orderNumber?: string;
      /** Contact ID associated with this order. */
      contactId?: string;
      /** Member ID associated with this order. */
      memberId?: string | null;
      /**
       * Order created timestamp.
       * @readonly
       */
      created?: Date | null;
      /**
       * Order updated timestamp.
       * @readonly
       */
      updated?: Date | null;
      /** Buyer first name. */
      firstName?: string;
      /** Buyer last name. */
      lastName?: string;
      /** Buyer email. */
      email?: string;
      /** Checkout form response. */
      checkoutForm?: FormResponse$1;
      /** Whether order is confirmed - occurs once payment gateway processes the payment and funds reach merchant's account. */
      confirmed?: boolean;
      /** Order status. */
      status?: OrderStatus;
      /** Payment method used for paid tickets purchase, i.e. "payPal", "creditCard", etc. */
      method?: string | null;
      /** Tickets generated after payment. */
      tickets?: Ticket[];
      /** Whether order was archived and excluded from results. */
      archived?: boolean;
      /** Whether event was triggered by GDPR delete request. */
      triggeredByAnonymizeRequest?: boolean;
  }
  interface Ticket {
      /** Unique issued ticket number. */
      ticketNumber?: string;
      /** Ticket definition ID. */
      ticketDefinitionId?: string;
      /** Ticket check-in. */
      checkIn?: CheckIn;
      /** Ticket price. */
      price?: Money$4;
      /** Whether ticket is archived. */
      archived?: boolean;
      /** Guest first name. */
      firstName?: string | null;
      /** Guest last name. */
      lastName?: string | null;
      /** Guest email. */
      email?: string | null;
      /** Contact ID associated with this ticket. */
      contactId?: string | null;
      /** Whether ticket is confirmed */
      confirmed?: boolean;
      /** Member ID associated with this ticket. */
      memberId?: string | null;
      /** Ticket form response (only assigned tickets contain separate forms). */
      form?: FormResponse$1;
      /** Ticket name. */
      ticketName?: string;
      /** Anonymized tickets no longer contain personally identifiable information (PII). */
      anonymized?: boolean;
      /** URL and password to online conference */
      onlineConferencingLogin?: OnlineConferencingLogin$1;
  }
  interface OnlineConferencingLogin$1 {
      /**
       * Link URL to the online conference.
       * @readonly
       */
      link?: string;
      /**
       * Password for the online conference.
       * @readonly
       */
      password?: string | null;
  }
  interface DeleteTicketCheckInRequest {
      /** Event ID to which the ticket belongs. */
      eventId: string;
      /**
       * Deprecated, use individual ticket numbers.
       * @internal
       * @deprecated
       */
      orderNumber?: string;
      /** Ticket numbers which check-ins to delete. */
      ticketNumber?: string[];
  }
  interface DeleteTicketCheckInResponse {
      /** Updated tickets. */
      tickets?: TicketingTicket[];
  }
  interface UpdateTicketRequest {
      /** Event ID to which the ticket belongs. */
      eventId: string;
      /** A unique ticket number which is assigned automatically when creating a ticket. */
      ticketNumber: string;
      /**
       * Set of field paths, specifying which parts of this resource to update.
       * When `fields` is empty, the request is interpreted as a full update.
       * Behavior follows [google.protobuf.FieldMask](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#google.protobuf.FieldMask) semantics.
       * @internal
       */
      fields?: string[];
      /**
       * Deprecated. Use `guestDetails.form`
       * @internal
       * @deprecated
       */
      checkoutForm?: FormResponse$1;
      /** Whether to archive the tickets. */
      archived?: boolean;
      /** Assigned guest details. */
      guestDetails?: GuestDetailsUpdate;
  }
  interface GuestDetailsUpdate {
      /** Form of a guest assigned to a ticket. */
      form?: FormResponse$1;
  }
  interface UpdateTicketResponse {
      /** Updated ticket. */
      ticket?: TicketingTicket;
  }
  interface BulkUpdateTicketsRequest {
      /** Event ID to which the ticket belongs. */
      eventId: string;
      /** A unique ticket number which is assigned automatically when creating a ticket. */
      ticketNumber?: string[];
      /** Whether tickets are archived. */
      archived?: boolean;
  }
  interface BulkUpdateTicketsResponse {
      /** Updated tickets. */
      tickets?: TicketingTicket[];
  }
  interface GetDemoTicketRequest {
      /** Ticket definition ID. */
      definitionId?: string;
  }
  interface GetDemoTicketResponse {
      /** Ticket. */
      ticket?: TicketingTicket;
  }
  interface MessageEnvelope$5 {
      /** App instance ID. */
      instanceId?: string | null;
      /** Event type. */
      eventType?: string;
      /** The identification type and identity data. */
      identity?: IdentificationData$5;
      /** Stringify payload. */
      data?: string;
  }
  interface IdentificationData$5 extends IdentificationDataIdOneOf$5 {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
      /** @readonly */
      identityType?: WebhookIdentityType$5;
  }
  /** @oneof */
  interface IdentificationDataIdOneOf$5 {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
  }
  enum WebhookIdentityType$5 {
      UNKNOWN = "UNKNOWN",
      ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
      MEMBER = "MEMBER",
      WIX_USER = "WIX_USER",
      APP = "APP"
  }
  /**
   * Retrieves a list of up to 100 tickets.
   *
   * <!--
   * >**Note:** This function is restricted and only runs if you elevate permissions using the [wix-auth.elevate()](https://www.wix.com/velo/reference/wix-auth/elevate) function.
   * -->
   * @param eventId - Event IDs.
   * @public
   * @requiredField eventId
   * @param options - Options for defining the returned list of tickets.
   * @permissionId WIX_EVENTS.READ_TICKETS
   * @adminMethod
   */
  function listTickets(eventId: string[], options?: ListTicketsOptions): Promise<ListTicketsResponse>;
  interface ListTicketsOptions {
      /**
       *
       * Offset. See [Pagination](/wix-events-v2/pagination).
       */
      offset?: number;
      /** Number of items to load per page. See [Pagination](/wix-events-v2/pagination).   */
      limit?: number;
      /**
       * Deprecated, use `sort` instead.
       * Sort order. Defaults to "ticket_number:asc".
       * See [supported fields](https://dev.wix.com/api/rest/wix-events/wix-events/filter-and-sort#wix-events_wix-events_filter-and-sort_list-tickets).
       * @internal
       * @deprecated
       */
      order?: string;
      /** Order numbers. */
      orderNumber?: string[];
      /** Ticket numbers. */
      ticketNumber?: string[];
      /** Textual search filter - search is performed on `"orderFullName"`, `"guestFullName"`, and `"ticketNumber"`. */
      searchPhrase?: string;
      /** Order statuses. */
      orderStatus?: OrderStatus[];
      /**
       * Deprecated, use `ORDER_ARCHIVED` / `ORDER_ACTIVE` state filter instead.
       * @internal
       * @deprecated
       */
      orderArchived?: boolean | null;
      /**
       * Deprecated, use `CHECKED_IN` / `NON_CHECKED_IN` state filter instead.
       * @internal
       * @deprecated
       */
      checkedIn?: boolean | null;
      /**
       * Predefined sets of fields to return.
       * - `TICKET_DETAILS`: Returns `ticketNumber`, `orderNumber`, `ticketDefinitionId`, `name`, `price`, `free`, `policy`, `qrCode`, `checkIn`, `orderStatus`, `orderArchived`, `archived`, `orderFullName`, `ticketPdf`, `checkInUrl` and `ticketPdfUrl`.
       * - `GUEST_DETAILS`: Returns `guestDetails`.
       * - `GUEST_FORM`: Returns `guestDetails.form`.
       *
       * Default: If a fieldset is not included in the request, returns only the `memberId` and `anonymized` fields.
       */
      fieldset?: TicketFieldset[];
      /**
       * Ticket states. Possible values:
       * - `ORDER_ARCHIVED`: Returns tickets of the archived orders.
       * - `ORDER_ACTIVE`: Returns tickets of the non-archived orders.
       * - `TICKET_ARCHIVED`: Returns archived tickets.
       * - `TICKET_ACTIVE`: Returns non-archived tickets.
       * - `CHECKED_IN`: Returns checked-in tickets.
       * - `NON_CHECKED_IN`: Returns tickets that are not checked in.
       * - `FREE`: Returns free tickets.
       * - `PAID`: Return paid tickets.
       * - `MEMBER`: Return members' tickets.
       */
      state?: State$4[];
      /** Site member IDs. */
      memberId?: string[];
      /** Filter facets. */
      facet?: string[];
      /**
       * Sort order.
       *
       * Default: `"ticketNumber"`:`"asc"`.
       */
      sort?: string;
      /** Guest contact IDs. */
      contactId?: string[];
      /** Ticket definition IDs. */
      ticketDefinitionId?: string[];
  }
  /**
   * Retrieves a ticket by the unique ticket number.
   * @public
   * @requiredField identifiers
   * @requiredField identifiers.eventId
   * @requiredField identifiers.ticketNumber
   * @param identifiers - Details for the ticket to retrieve.
   * @param options - Options for the returned ticket data.
   * @permissionId WIX_EVENTS.READ_TICKET_DETAILS
   * @adminMethod
   * @returns Ticket.
   */
  function getTicket(identifiers: GetTicketIdentifiers, options?: GetTicketOptions): Promise<TicketingTicket>;
  interface GetTicketIdentifiers {
      /** Event ID to which the ticket belongs. */
      eventId: string;
      /** A unique ticket number which is assigned automatically when creating a ticket. */
      ticketNumber: string;
  }
  interface GetTicketOptions {
      /**
       * Predefined sets of fields to return.
       * - `TICKET_DETAILS`: Returns `ticketNumber`, `orderNumber`, `ticketDefinitionId`, `name`, `price`, `free`, `policy`, `qrCode`, `checkIn`, `orderStatus`, `orderArchived`, `archived`, `orderFullName`, `ticketPdf`, `checkInUrl` and `ticketPdfUrl`.
       * - `GUEST_DETAILS`: Returns `guestDetails`.
       * - `GUEST_FORM`: Returns `guestDetails.form`.
       *
       * Default: If a fieldset is not included in the request, returns only the `memberId` and `anonymized` fields.
       */
      fieldset?: TicketFieldset[];
  }
  /**
   * Checks in 1 or more tickets.
   * @public
   * @requiredField eventId
   * @param eventId - Event ID to which the ticket belongs.
   * @param options - Options for tickets to check-in.
   * @permissionId WIX_EVENTS.CHECK-IN
   * @adminMethod
   */
  function checkInTickets(eventId: string, options?: CheckInTicketsOptions): Promise<CheckInTicketResponse>;
  interface CheckInTicketsOptions {
      /**
       * Deprecated, use individual ticket numbers.
       * @internal
       * @deprecated
       */
      orderNumber?: string;
      /** Tickets to check-in. */
      ticketNumber?: string[];
  }
  /**
   * Deletes check-ins for 1 or more tickets.
   * @public
   * @requiredField eventId
   * @param eventId - Event ID to which the ticket belongs.
   * @param options - Options for tickets to delete.
   * @permissionId WIX_EVENTS.CHECK-IN
   * @adminMethod
   */
  function deleteTicketCheckIns(eventId: string, options?: DeleteTicketCheckInsOptions): Promise<DeleteTicketCheckInResponse>;
  interface DeleteTicketCheckInsOptions {
      /**
       * Deprecated, use individual ticket numbers.
       * @internal
       * @deprecated
       */
      orderNumber?: string;
      /** Ticket numbers which check-ins to delete. */
      ticketNumber?: string[];
  }
  /**
   * Updates a ticket.
   * @public
   * @requiredField identifiers
   * @requiredField identifiers.eventId
   * @requiredField identifiers.ticketNumber
   * @param identifiers - Details for the ticket to update.
   * @param options - Ticket details to update.
   * @permissionId WIX_EVENTS.MANAGE_TICKETS
   * @adminMethod
   */
  function updateTicket(identifiers: UpdateTicketIdentifiers, options?: UpdateTicketOptions): Promise<UpdateTicketResponse>;
  interface UpdateTicketIdentifiers {
      /** Event ID to which the ticket belongs. */
      eventId: string;
      /** A unique ticket number which is assigned automatically when creating a ticket. */
      ticketNumber: string;
  }
  interface UpdateTicketOptions {
      /**
       * Set of field paths, specifying which parts of this resource to update.
       * When `fields` is empty, the request is interpreted as a full update.
       * Behavior follows [google.protobuf.FieldMask](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#google.protobuf.FieldMask) semantics.
       * @internal
       */
      fields?: string[];
      /**
       * Deprecated. Use `guestDetails.form`
       * @internal
       * @deprecated
       */
      checkoutForm?: FormResponse$1;
      /** Whether to archive the ticket. */
      archived?: boolean;
      /** Assigned guest details. */
      guestDetails?: GuestDetailsUpdate;
  }
  /**
   * Archives multiple tickets.
   * @public
   * @requiredField eventId
   * @param options - Options for updating the tickets.
   * @param eventId - Event ID to which the ticket belongs.
   * @permissionId WIX_EVENTS.MANAGE_TICKETS
   * @adminMethod
   */
  function bulkUpdateTickets(eventId: string, options?: BulkUpdateTicketsOptions): Promise<BulkUpdateTicketsResponse>;
  interface BulkUpdateTicketsOptions {
      /** A unique ticket number which is assigned automatically when creating a ticket. */
      ticketNumber?: string[];
      /** Whether tickets are archived. */
      archived?: boolean;
  }
  
  type eventsV1Ticket_universal_d_TicketingTicket = TicketingTicket;
  type eventsV1Ticket_universal_d_CheckIn = CheckIn;
  type eventsV1Ticket_universal_d_OrderStatus = OrderStatus;
  const eventsV1Ticket_universal_d_OrderStatus: typeof OrderStatus;
  type eventsV1Ticket_universal_d_GuestDetails = GuestDetails;
  type eventsV1Ticket_universal_d_ChannelType = ChannelType;
  const eventsV1Ticket_universal_d_ChannelType: typeof ChannelType;
  type eventsV1Ticket_universal_d_TicketDetails = TicketDetails;
  type eventsV1Ticket_universal_d_ListTicketsRequest = ListTicketsRequest;
  type eventsV1Ticket_universal_d_TicketFieldset = TicketFieldset;
  const eventsV1Ticket_universal_d_TicketFieldset: typeof TicketFieldset;
  type eventsV1Ticket_universal_d_ListTicketsResponse = ListTicketsResponse;
  type eventsV1Ticket_universal_d_TicketFacets = TicketFacets;
  type eventsV1Ticket_universal_d_TicketFacetCounts = TicketFacetCounts;
  type eventsV1Ticket_universal_d_Counts = Counts;
  type eventsV1Ticket_universal_d_GetTicketRequest = GetTicketRequest;
  type eventsV1Ticket_universal_d_GetTicketResponse = GetTicketResponse;
  type eventsV1Ticket_universal_d_CheckInTicketRequest = CheckInTicketRequest;
  type eventsV1Ticket_universal_d_CheckInTicketResponse = CheckInTicketResponse;
  type eventsV1Ticket_universal_d_OrderUpdated = OrderUpdated;
  type eventsV1Ticket_universal_d_Ticket = Ticket;
  type eventsV1Ticket_universal_d_DeleteTicketCheckInRequest = DeleteTicketCheckInRequest;
  type eventsV1Ticket_universal_d_DeleteTicketCheckInResponse = DeleteTicketCheckInResponse;
  type eventsV1Ticket_universal_d_UpdateTicketRequest = UpdateTicketRequest;
  type eventsV1Ticket_universal_d_GuestDetailsUpdate = GuestDetailsUpdate;
  type eventsV1Ticket_universal_d_UpdateTicketResponse = UpdateTicketResponse;
  type eventsV1Ticket_universal_d_BulkUpdateTicketsRequest = BulkUpdateTicketsRequest;
  type eventsV1Ticket_universal_d_BulkUpdateTicketsResponse = BulkUpdateTicketsResponse;
  type eventsV1Ticket_universal_d_GetDemoTicketRequest = GetDemoTicketRequest;
  type eventsV1Ticket_universal_d_GetDemoTicketResponse = GetDemoTicketResponse;
  const eventsV1Ticket_universal_d_listTickets: typeof listTickets;
  type eventsV1Ticket_universal_d_ListTicketsOptions = ListTicketsOptions;
  const eventsV1Ticket_universal_d_getTicket: typeof getTicket;
  type eventsV1Ticket_universal_d_GetTicketIdentifiers = GetTicketIdentifiers;
  type eventsV1Ticket_universal_d_GetTicketOptions = GetTicketOptions;
  const eventsV1Ticket_universal_d_checkInTickets: typeof checkInTickets;
  type eventsV1Ticket_universal_d_CheckInTicketsOptions = CheckInTicketsOptions;
  const eventsV1Ticket_universal_d_deleteTicketCheckIns: typeof deleteTicketCheckIns;
  type eventsV1Ticket_universal_d_DeleteTicketCheckInsOptions = DeleteTicketCheckInsOptions;
  const eventsV1Ticket_universal_d_updateTicket: typeof updateTicket;
  type eventsV1Ticket_universal_d_UpdateTicketIdentifiers = UpdateTicketIdentifiers;
  type eventsV1Ticket_universal_d_UpdateTicketOptions = UpdateTicketOptions;
  const eventsV1Ticket_universal_d_bulkUpdateTickets: typeof bulkUpdateTickets;
  type eventsV1Ticket_universal_d_BulkUpdateTicketsOptions = BulkUpdateTicketsOptions;
  namespace eventsV1Ticket_universal_d {
    export {
      eventsV1Ticket_universal_d_TicketingTicket as TicketingTicket,
      Money$4 as Money,
      eventsV1Ticket_universal_d_CheckIn as CheckIn,
      eventsV1Ticket_universal_d_OrderStatus as OrderStatus,
      eventsV1Ticket_universal_d_GuestDetails as GuestDetails,
      FormResponse$1 as FormResponse,
      InputValue$1 as InputValue,
      FormattedAddress$1 as FormattedAddress,
      Address$4 as Address,
      AddressStreetOneOf$4 as AddressStreetOneOf,
      StreetAddress$4 as StreetAddress,
      AddressLocation$4 as AddressLocation,
      Subdivision$4 as Subdivision,
      SubdivisionType$4 as SubdivisionType,
      StandardDetails$1 as StandardDetails,
      eventsV1Ticket_universal_d_ChannelType as ChannelType,
      eventsV1Ticket_universal_d_TicketDetails as TicketDetails,
      eventsV1Ticket_universal_d_ListTicketsRequest as ListTicketsRequest,
      eventsV1Ticket_universal_d_TicketFieldset as TicketFieldset,
      State$4 as State,
      eventsV1Ticket_universal_d_ListTicketsResponse as ListTicketsResponse,
      FacetCounts$3 as FacetCounts,
      eventsV1Ticket_universal_d_TicketFacets as TicketFacets,
      eventsV1Ticket_universal_d_TicketFacetCounts as TicketFacetCounts,
      eventsV1Ticket_universal_d_Counts as Counts,
      eventsV1Ticket_universal_d_GetTicketRequest as GetTicketRequest,
      eventsV1Ticket_universal_d_GetTicketResponse as GetTicketResponse,
      eventsV1Ticket_universal_d_CheckInTicketRequest as CheckInTicketRequest,
      eventsV1Ticket_universal_d_CheckInTicketResponse as CheckInTicketResponse,
      eventsV1Ticket_universal_d_OrderUpdated as OrderUpdated,
      eventsV1Ticket_universal_d_Ticket as Ticket,
      OnlineConferencingLogin$1 as OnlineConferencingLogin,
      eventsV1Ticket_universal_d_DeleteTicketCheckInRequest as DeleteTicketCheckInRequest,
      eventsV1Ticket_universal_d_DeleteTicketCheckInResponse as DeleteTicketCheckInResponse,
      eventsV1Ticket_universal_d_UpdateTicketRequest as UpdateTicketRequest,
      eventsV1Ticket_universal_d_GuestDetailsUpdate as GuestDetailsUpdate,
      eventsV1Ticket_universal_d_UpdateTicketResponse as UpdateTicketResponse,
      eventsV1Ticket_universal_d_BulkUpdateTicketsRequest as BulkUpdateTicketsRequest,
      eventsV1Ticket_universal_d_BulkUpdateTicketsResponse as BulkUpdateTicketsResponse,
      eventsV1Ticket_universal_d_GetDemoTicketRequest as GetDemoTicketRequest,
      eventsV1Ticket_universal_d_GetDemoTicketResponse as GetDemoTicketResponse,
      MessageEnvelope$5 as MessageEnvelope,
      IdentificationData$5 as IdentificationData,
      IdentificationDataIdOneOf$5 as IdentificationDataIdOneOf,
      WebhookIdentityType$5 as WebhookIdentityType,
      eventsV1Ticket_universal_d_listTickets as listTickets,
      eventsV1Ticket_universal_d_ListTicketsOptions as ListTicketsOptions,
      eventsV1Ticket_universal_d_getTicket as getTicket,
      eventsV1Ticket_universal_d_GetTicketIdentifiers as GetTicketIdentifiers,
      eventsV1Ticket_universal_d_GetTicketOptions as GetTicketOptions,
      eventsV1Ticket_universal_d_checkInTickets as checkInTickets,
      eventsV1Ticket_universal_d_CheckInTicketsOptions as CheckInTicketsOptions,
      eventsV1Ticket_universal_d_deleteTicketCheckIns as deleteTicketCheckIns,
      eventsV1Ticket_universal_d_DeleteTicketCheckInsOptions as DeleteTicketCheckInsOptions,
      eventsV1Ticket_universal_d_updateTicket as updateTicket,
      eventsV1Ticket_universal_d_UpdateTicketIdentifiers as UpdateTicketIdentifiers,
      eventsV1Ticket_universal_d_UpdateTicketOptions as UpdateTicketOptions,
      eventsV1Ticket_universal_d_bulkUpdateTickets as bulkUpdateTickets,
      eventsV1Ticket_universal_d_BulkUpdateTicketsOptions as BulkUpdateTicketsOptions,
    };
  }
  
  interface TicketDefinition$1 {
      /** Ticket definition ID. */
      _id?: string;
      /** Ticket price. */
      price?: Money$3;
      /** Whether the ticket is free (read only). */
      free?: boolean;
      /** Ticket name. */
      name?: string;
      /** Ticket description. */
      description?: string;
      /**
       * Limit of tickets that can be purchased per checkout.
       * Set to 20 for unlimited ticket definition.
       */
      limitPerCheckout?: number;
      /** Custom sort index. */
      orderIndex?: number;
      /** Policy information plain text block, as printed on the ticket. */
      policy?: string;
      /** Sensitive dashboard data. */
      dashboard?: Dashboard$3;
      /** Event ID associated with the ticket. */
      eventId?: string;
      /**
       * Configuration of the fixed-rate Wix ticket service fee that is applied at checkout to each ticket sold.
       * @readonly
       */
      wixFeeConfig?: WixFeeConfig;
      /** Ticket sale period. */
      salePeriod?: TicketSalePeriod;
      /**
       * Ticket sale status.
       * @readonly
       */
      saleStatus?: TicketSaleStatus;
      /** Ticket state. */
      state?: TicketDefinitionStateEnumState[];
      /** Ticket pricing. */
      pricing?: TicketPricing;
  }
  interface Money$3 {
      /**
       * @internal
       * @internal
       * @deprecated
       */
      amount?: string;
      /**
       * Three-letter currency code in
       * [ISO-4217 alphabetic](https://en.wikipedia.org/wiki/ISO_4217#Active_codes) format.
       */
      currency?: string;
      /** Monetary amount. Decimal string with a period as a decimal separator (e.g., 3.99). Optionally, starts with a single (-), to indicate that the amount is negative. */
      value?: string | null;
  }
  interface Dashboard$3 {
      /** Whether ticket is hidden and cannot be sold. */
      hidden?: boolean;
      /**
       * Number of tickets sold and reserved.
       * @deprecated
       */
      sold?: number;
      /** Whether the ticket has limited quantity. */
      limited?: boolean;
      /** Ticket limit. `NULL` for unlimited ticket definitions. */
      quantity?: number | null;
      /** Number of unsold tickets. `NULL` for unlimited ticket definitions. */
      unsold?: number | null;
      /** Number of tickets sold. */
      ticketsSold?: number;
      /** Number of tickets reserved. */
      ticketsReserved?: number;
  }
  interface WixFeeConfig {
      /**
       * Fee calculation method.
       *
       * Supported values: `"FEE_ADDED"`, `"FEE_INCLUDED"`, `"FEE_ADDED_AT_CHECKOUT"`
       *
       * Default: `"FEE_ADDED_AT_CHECKOUT"`
       */
      type?: FeeType;
  }
  enum FeeType {
      /** Fee is added to the ticket price at checkout. */
      FEE_ADDED = "FEE_ADDED",
      /** Seller absorbs the fee. It is deducted from the ticket price. */
      FEE_INCLUDED = "FEE_INCLUDED",
      /** Fee is added to the ticket price at checkout. */
      FEE_ADDED_AT_CHECKOUT = "FEE_ADDED_AT_CHECKOUT"
  }
  interface TicketSalePeriod {
      /** Ticket sale start timestamp. */
      startDate?: Date | null;
      /** Ticket sale end timestamp. */
      endDate?: Date | null;
      /** Whether to hide this ticket if it's not on sale */
      hideNotOnSale?: boolean;
  }
  enum TicketSaleStatus {
      /** Ticket sale is scheduled to start. */
      SALE_SCHEDULED = "SALE_SCHEDULED",
      /** Ticket sale has started. */
      SALE_STARTED = "SALE_STARTED",
      /** Ticket sale has ended. */
      SALE_ENDED = "SALE_ENDED"
  }
  enum TicketDefinitionStateEnumState {
      INCLUDE_HIDDEN_NOT_ON_SALE = "INCLUDE_HIDDEN_NOT_ON_SALE"
  }
  interface TicketPricing extends TicketPricingPriceOneOf {
      /** Ticket price which is read only. */
      fixedPrice?: Money$3;
      /** Min price per ticket, customizable. */
      minPrice?: Money$3;
      /** Ticket pricing options. */
      pricingOptions?: PricingOptions$1;
      /**
       * Ticket pricing type.
       * @readonly
       */
      pricingType?: Type$2;
  }
  /** @oneof */
  interface TicketPricingPriceOneOf {
      /** Ticket price which is read only. */
      fixedPrice?: Money$3;
      /** Min price per ticket, customizable. */
      minPrice?: Money$3;
      /** Ticket pricing options. */
      pricingOptions?: PricingOptions$1;
  }
  interface PricingOptions$1 {
      /** Multiple ticket pricing options. */
      options?: PricingOption[];
  }
  interface PricingOption {
      /** Ticket pricing option ID. */
      _id?: string | null;
      /** Ticket pricing option name. */
      name?: string | null;
      /** Ticket pricing option price. */
      price?: Money$3;
  }
  enum Type$2 {
      STANDARD = "STANDARD",
      DONATION = "DONATION"
  }
  interface QueryTicketDefinitionsRequest$1 {
      /** Offset. See [Pagination](https://dev.wix.com/api/rest/getting-started/pagination). */
      offset?: number;
      /** Limit. See [Pagination](https://dev.wix.com/api/rest/getting-started/pagination). */
      limit?: number;
      /** Set of fields to return in the response. See [fieldsets](https://dev.wix.com/api/rest/wix-events/wix-events/fieldset#wix-events_wix-events_fieldset_ticket-definition-fieldset). */
      fieldset?: TicketDefinitionFieldset[];
      /** Filter. See [supported fields and operators](https://dev.wix.com/api/rest/wix-events/wix-events/filter-and-sort#wix-events_wix-events_filter-and-sort_query-ticket-definitions). */
      filter?: Record<string, any> | null;
      /**
       * Sort order. Defaults to: "created:asc".
       * See [supported fields](https://dev.wix.com/api/rest/wix-events/wix-events/filter-and-sort#wix-events_wix-events_filter-and-sort_query-ticket-definitions).
       */
      sort?: string;
      /**
       * Filter facets to include in the response.
       * See [supported facets](https://dev.wix.com/api/rest/wix-events/wix-events/filter-and-sort#wix-events_wix-events_filter-and-sort_query-ticket-definitions).
       */
      facet?: string[];
  }
  enum TicketDefinitionFieldset {
      /** Include `policy` in the response. */
      POLICY = "POLICY",
      /** Include `dashboard` in the response. */
      DASHBOARD = "DASHBOARD"
  }
  interface QueryTicketDefinitionsResponse$1 {
      /** Total ticket definitions matching the given filters. */
      total?: number;
      /** Offset. */
      offset?: number;
      /** Limit. */
      limit?: number;
      /** Ticket definitions. */
      definitions?: TicketDefinition$1[];
      /** Filter facets. */
      facets?: Record<string, FacetCounts$2>;
  }
  interface FacetCounts$2 {
      /** Facet counts aggregated per value. */
      counts?: Record<string, number>;
  }
  interface QueryTicketDefinitionsV2Request {
      /** Query request object. */
      query?: QueryV2$3;
      /**
       * Consistent read.
       * @internal
       */
      consistentRead?: boolean | null;
  }
  interface QueryV2$3 extends QueryV2PagingMethodOneOf$3 {
      /** Paging options to limit and skip the number of items. */
      paging?: Paging$4;
      /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
      cursorPaging?: CursorPaging$4;
      /**
       * Filter object.
       *
       * Learn more about the [filter section](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#the-filter-section).
       */
      filter?: Record<string, any> | null;
      /**
       * Sort object.
       *
       * Learn more about the [sort section](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#the-sort-section).
       */
      sort?: Sorting$4[];
      /** Array of projected fields. A list of specific field names to return. If `fieldsets` are also specified, the union of `fieldsets` and `fields` is returned. */
      fields?: string[];
      /** Array of named, predefined sets of projected fields. A array of predefined named sets of fields to be returned. Specifying multiple `fieldsets` will return the union of fields from all sets. If `fields` are also specified, the union of `fieldsets` and `fields` is returned. */
      fieldsets?: string[];
  }
  /** @oneof */
  interface QueryV2PagingMethodOneOf$3 {
      /** Paging options to limit and skip the number of items. */
      paging?: Paging$4;
      /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
      cursorPaging?: CursorPaging$4;
  }
  interface Sorting$4 {
      /** Name of the field to sort by. */
      fieldName?: string;
      /** Sort order. */
      order?: SortOrder$4;
      /**
       * When `field_name` is a property of repeated field that is marked as `MATCH_ITEMS` and sort should be done by
       * a specific element from a collection, filter can/should be provided to ensure correct sort value is picked.
       *
       * If multiple filters are provided, they are combined with AND operator.
       *
       * Example:
       * Given we have document like {"id": "1", "nestedField": [{"price": 10, "region": "EU"}, {"price": 20, "region": "US"}]}
       * and `nestedField` is marked as `MATCH_ITEMS`, to ensure that sorting is done by correct region, filter should be
       * { fieldName: "nestedField.price", "select_items_by": [{"nestedField.region": "US"}] }
       * @internal
       */
      selectItemsBy?: Record<string, any>[] | null;
  }
  enum SortOrder$4 {
      ASC = "ASC",
      DESC = "DESC"
  }
  interface Paging$4 {
      /** Number of items to load. */
      limit?: number | null;
      /** Number of items to skip in the current sort order. */
      offset?: number | null;
  }
  interface CursorPaging$4 {
      /** Maximum number of items to return in the results. */
      limit?: number | null;
      /**
       * Pointer to the next or previous page in the list of results.
       *
       * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
       * Not relevant for the first request.
       */
      cursor?: string | null;
  }
  interface QueryTicketDefinitionsV2Response {
      /** Ticket definitions. */
      definitions?: TicketDefinition$1[];
      /** Paging metadata definitions. */
      metadata?: PagingMetadataV2$4;
  }
  interface PagingMetadataV2$4 {
      /** Number of items returned in the response. */
      count?: number | null;
      /** Offset that was requested. */
      offset?: number | null;
      /** Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set. */
      total?: number | null;
      /** Flag that indicates the server failed to calculate the `total` field. */
      tooManyToCount?: boolean | null;
      /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
      cursors?: Cursors$4;
      /**
       * Indicates if there are more results after the current page.
       * If `true`, another page of results can be retrieved.
       * If `false`, this is the last page.
       * @internal
       */
      hasNext?: boolean | null;
  }
  interface Cursors$4 {
      /** Cursor string pointing to the next page in the list of results. */
      next?: string | null;
      /** Cursor pointing to the previous page in the list of results. */
      prev?: string | null;
  }
  interface ListTicketDefinitionsRequest {
      /** Event ID. */
      eventId?: string[];
      /** Offset. */
      offset?: number;
      /** Paging limit. */
      limit?: number;
      /**
       * Predefined sets of fields to return.
       * - `DASHBOARD`: Returns `dashboard`.
       * - `POLICY`: Returns `policy`.
       *
       * Default: If `fieldset` is omitted from the request,  `id`, `price`, `free`, `name`, `limitPerCheckout`, `orderIndex`, `eventId`.
       *
       */
      fieldset?: TicketDefinitionFieldset[];
      /** Event creator ID. */
      eventCreatorId?: string[];
      /**
       * Filter by ticket definition state.
       *
       * Supported values: `"VISIBLE"`, `"HIDDEN"`, `"FREE"`, `"PAID"`
       */
      state?: State$3[];
      /**
       * Sort order.
       *
       * Default: `"created"`:`"asc"`
       */
      sort?: string;
      /**
       * Ticket sale status.
       *
       * Supported values: `"SALE_SCHEDULED"`, `"SALE_STARTED"`, `"SALE_ENDED"`
       */
      saleStatus?: TicketSaleStatus[];
      /** Filter facets. */
      facet?: string[];
      /**
       * Visible for coupons. For internal use.
       * @internal
       */
      visibleForCoupons?: boolean | null;
      /**
       * For internal use.
       * @internal
       */
      groupBy?: GroupBy;
      /**
       * Ticket definition ID.
       * @internal
       */
      _id?: string[];
  }
  enum State$3 {
      /** The ticket is available for purchase. */
      VISIBLE = "VISIBLE",
      /** The ticket is unavailable for purchase. */
      HIDDEN = "HIDDEN",
      /** The ticket price is 0. */
      FREE = "FREE",
      /** The ticket price is greater than 0. */
      PAID = "PAID"
  }
  enum GroupBy {
      /** No grouping. */
      NONE = "NONE",
      /** Groups by event created date with descending sorting. */
      EVENT_CREATED_DESC = "EVENT_CREATED_DESC",
      /** Groups by event created date with ascending sorting. */
      EVENT_CREATED_ASC = "EVENT_CREATED_ASC"
  }
  interface ListTicketDefinitionsResponse {
      /** Meta data. */
      metaData?: ResponseMetaData;
      /** Retrieved ticket definitions. */
      definitions?: TicketDefinition$1[];
      /** Filter facets. */
      facets?: Record<string, FacetCounts$2>;
  }
  interface ResponseMetaData {
      /** Number of items in the response. */
      count?: number;
      /** Offset of items. */
      offset?: number;
      /** Total number of matching items. */
      total?: number;
  }
  interface GetTicketDefinitionRequest$1 {
      /** Ticket definition ID. */
      definitionId: string;
      /**
       * Predefined sets of fields to return.
       * - `DASHBOARD`: Returns `dashboard`.
       * - `POLICY`: Returns `policy`.
       *
       * Default: If `fieldset` is omitted from the request,  `id`, `price`, `free`, `name`, `limitPerCheckout`, `orderIndex`, `eventId`.
       */
      fieldset?: TicketDefinitionFieldset[];
  }
  interface GetTicketDefinitionResponse$1 {
      /** Retrieved ticket definition. */
      definition?: TicketDefinition$1;
  }
  interface CreateTicketDefinitionRequest$1 {
      /** Event ID. */
      eventId: string;
      /** Ticket definition data. */
      definition: TicketDefinitionData;
  }
  interface TicketDefinitionData {
      /** Ticket name. */
      name?: string | null;
      /** Ticket price. */
      price?: Money$3;
      /** Ticket description. */
      description?: string | null;
      /** Whether this ticket type is limited in quantity. */
      limited?: boolean;
      /**
       * Limit for this ticket type.
       *
       * `NULL` for unlimited.
       */
      quantity?: number | null;
      /** Custom sort index for manual tickets ordering implementation. */
      orderIndex?: number;
      /** Policy information in plain text (as listed on the ticket). */
      policy?: string | null;
      /** Whether this ticket type is hidden to customers and cannot be purchased. */
      hidden?: boolean;
      /** Configuration of the fixed-rate Wix ticket service fee that is applied to each ticket sold. */
      wixFeeConfig?: WixFeeConfig;
      /** Ticket sale period. */
      salePeriod?: TicketSalePeriod;
      /** Ticket pricing. */
      pricing?: TicketPricing;
  }
  interface CreateTicketDefinitionResponse$1 {
      /** Created ticket definition. */
      definition?: TicketDefinition$1;
  }
  interface TicketDefinitionCreated {
      /** Ticket Definition created timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Ticket Definition ID. */
      ticketDefinitionId?: string;
      /** Event ID. */
      eventId?: string;
      /** Originated from. */
      originatedFrom?: OriginatedFrom;
  }
  interface OriginatedFrom {
      /** Instance ID. Indicates the original app instance which current entity originated from. */
      instanceId?: string;
      /** Event ID. Indicates the original event which current entity originated from. */
      eventId?: string;
      /** Event ID. Indicates the original entity which current entity originated from. */
      entityId?: string;
  }
  interface UpdateTicketDefinitionRequest$1 {
      /** Event ID. */
      eventId: string;
      /** Ticket definition ID. */
      definitionId: string;
      /** Ticket definition data. */
      definition?: TicketDefinitionData;
      /**
       * Set of field paths, specifying which parts of ticket definition to update.
       * @internal
       */
      fields?: string[];
  }
  interface UpdateTicketDefinitionResponse$1 {
      /** Updated ticket definition. */
      definition?: TicketDefinition$1;
  }
  interface TicketDefinitionUpdated {
      /** Ticket definition updated timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Ticket definition ID. */
      ticketDefinitionId?: string;
      /** Event ID. */
      eventId?: string;
  }
  interface DeleteTicketDefinitionRequest$1 extends DeleteTicketDefinitionRequestDeleteOneOf {
      /** Ticket definitions to delete. */
      byId?: ById;
      /** Whether to delete all event tickets. */
      all?: boolean;
      /** Event ID. */
      eventId: string;
  }
  /** @oneof */
  interface DeleteTicketDefinitionRequestDeleteOneOf {
      /** Ticket definitions to delete. */
      byId?: ById;
      /** Whether to delete all event tickets. */
      all?: boolean;
  }
  interface ById {
      /** Ticket definition IDs. */
      definitionId?: string[];
  }
  interface DeleteTicketDefinitionResponse$1 {
  }
  interface TicketDefinitionDeleted {
      /** Ticket definition deleted timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Ticket definition ID. */
      ticketDefinitionId?: string;
      /** Event ID. */
      eventId?: string;
  }
  interface ChangeCurrencyRequest$1 {
      /** Event ID. */
      eventId?: string;
      /** Event currency, in 3-letter [ISO-4217 alphabetic](https://en.wikipedia.org/wiki/ISO_4217#Active_codes) format. */
      currency: string;
  }
  interface ChangeCurrencyResponse$1 {
  }
  interface BulkCopyTicketDefinitionsByEventIdRequest$1 {
      /** Origin instance ID. */
      originInstanceId?: string | null;
      /** Origin Event ID. */
      originEventId?: string;
      /** Target Event ID. */
      targetEventId?: string;
  }
  interface BulkCopyTicketDefinitionsByEventIdResponse$1 {
      /** Copied ticket definitions. */
      definitions?: CopiedTicketDefinition$1[];
  }
  interface CopiedTicketDefinition$1 {
      /** Origin Ticket definition ID. */
      originTicketDefinitionId?: string;
      /** Ticket definition ID. */
      ticketDefinitionId?: string;
  }
  interface PaidTicketDefinitionExistsRequest {
  }
  interface PaidTicketDefinitionExistsResponse {
      /** Paid exists. */
      paidExists?: boolean;
  }
  interface MessageEnvelope$4 {
      /** App instance ID. */
      instanceId?: string | null;
      /** Event type. */
      eventType?: string;
      /** The identification type and identity data. */
      identity?: IdentificationData$4;
      /** Stringify payload. */
      data?: string;
  }
  interface IdentificationData$4 extends IdentificationDataIdOneOf$4 {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
      /** @readonly */
      identityType?: WebhookIdentityType$4;
  }
  /** @oneof */
  interface IdentificationDataIdOneOf$4 {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
  }
  enum WebhookIdentityType$4 {
      UNKNOWN = "UNKNOWN",
      ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
      MEMBER = "MEMBER",
      WIX_USER = "WIX_USER",
      APP = "APP"
  }
  /**
   * **Deprecated.** This function will continue to work until November 8, 2024, but a newer version is available. Use [`queryTicketDefinitions()`](/ticket-definitions-v2/query-ticket-definitions) function instead.
   * >**Migration Instructions**.
   * > If this function is already in your code, it will continue to work. To stay compatible with future changes, migrate to [`queryTicketDefinition()`](/ticket-definitions-v2/query-ticket-definitions).
   * > To migrate to the new function:
   * > 1. Add the new import statement:
   * > ```js
   * > import { ticketDefinitionsV2 } from 'wix-events.v2';
   * > ```
   * > 2. Look for any code that uses `ticketDefinitions.queryTicketDefinition()`, and replace it with `ticketDefinitionsV2.queryTicketDefinition()`. Update your code to work with the new `createTicketDefinition()` response properties.
   * > 3. Test your changes to make sure your code behaves as expected.
   *
   * Retrieves a list of up to 100 ticket definitions.
   * @public
   * @permissionId WIX_EVENTS.READ_TICKET_DEFINITIONS
   * @adminMethod
   */
  function queryTicketDefinitions$1(options?: QueryTicketDefinitionsOptions$1): Promise<QueryTicketDefinitionsResponse$1>;
  interface QueryTicketDefinitionsOptions$1 {
      /** Offset. See [Pagination](https://dev.wix.com/api/rest/getting-started/pagination). */
      offset?: number;
      /** Limit. See [Pagination](https://dev.wix.com/api/rest/getting-started/pagination). */
      limit?: number;
      /** Set of fields to return in the response. See [fieldsets](https://dev.wix.com/api/rest/wix-events/wix-events/fieldset#wix-events_wix-events_fieldset_ticket-definition-fieldset). */
      fieldset?: TicketDefinitionFieldset[];
      /** Filter. See [supported fields and operators](https://dev.wix.com/api/rest/wix-events/wix-events/filter-and-sort#wix-events_wix-events_filter-and-sort_query-ticket-definitions). */
      filter?: Record<string, any> | null;
      /**
       * Sort order. Defaults to: "created:asc".
       * See [supported fields](https://dev.wix.com/api/rest/wix-events/wix-events/filter-and-sort#wix-events_wix-events_filter-and-sort_query-ticket-definitions).
       */
      sort?: string;
      /**
       * Filter facets to include in the response.
       * See [supported facets](https://dev.wix.com/api/rest/wix-events/wix-events/filter-and-sort#wix-events_wix-events_filter-and-sort_query-ticket-definitions).
       */
      facet?: string[];
  }
  /**
   * **Deprecated.** This function will continue to work until October 29, 2024, but a newer version is available at [`queryTicketDefinitions()`](/ticket-definitions-v2/query-ticket-definitions).
   * >**Migration Instructions**.
   * > If this function is already in your code, it will continue to work. To stay compatible with future changes, migrate to [`queryTicketDefinitions()`](/ticket-definitions-v2/query-ticket-definitions).
   * > To migrate to the new function:
   * > 1. Add the new import statement:
   * > ```js
   * > import { ticketDefinitionsV2 } from 'wix-events.v2';
   * > ```
   * > 2. Look for any code that uses `ticketDefinitions.queryTicketDefinitions()`, and replace it with `ticketDefinitionsV2.queryTicketDefinitions()`. Update your code to work with the new `queryTicketDefinition()` response properties.
   * > 3. Test your changes to make sure your code behaves as expected.
   *
   * Retrieves a list of up to 1,000 ticket definitions, given the provided paging and filtering.
   * @public
   * @permissionId WIX_EVENTS.READ_TICKET_DEFINITIONS
   * @adminMethod
   */
  function queryTicketDefinitionsV2(options?: QueryTicketDefinitionsV2Options): DefinitionsQueryBuilder;
  interface QueryTicketDefinitionsV2Options {
      /**
       * Consistent read.
       * @internal
       */
      consistentRead?: boolean | null | undefined;
  }
  interface QueryCursorResult$3 {
      cursors: Cursors$4;
      hasNext: () => boolean;
      hasPrev: () => boolean;
      length: number;
      pageSize: number;
  }
  interface DefinitionsQueryResult extends QueryCursorResult$3 {
      items: TicketDefinition$1[];
      query: DefinitionsQueryBuilder;
      next: () => Promise<DefinitionsQueryResult>;
      prev: () => Promise<DefinitionsQueryResult>;
  }
  interface DefinitionsQueryBuilder {
      /** @param limit - Number of items to return, which is also the `pageSize` of the results object. */
      limit: (limit: number) => DefinitionsQueryBuilder;
      /** @param cursor - A pointer to specific record */
      skipTo: (cursor: string) => DefinitionsQueryBuilder;
      find: () => Promise<DefinitionsQueryResult>;
  }
  /**
   * **Deprecated.** This function will continue to work until November 8, 2024, but a substitute is available. Use the [`queryTicketDefinitions()`](/ticket-definitions-v2/query-ticket-definitions) function instead.
   * >**Migration Instructions**.
   * > If this function is already in your code, it will continue to work. To stay compatible with future changes, migrate to [`queryTicketDefinitions()`](/ticket-definitions-v2/query-ticket-definitions).
   * > To migrate to the new function:
   * > 1. Add the new import statement:
   * > ```js
   * > import { ticketDefinitionsV2 } from 'wix-events.v2';
   * > ```
   * > 2. Look for any code that uses `ticketDefinitions.queryTicketDefinitions()`, and replace it with `ticketDefinitionsV2.queryTicketDefinitions()`. Update your code to work with the new `queryTicketDefinition()` response properties.
   * > 3. Test your changes to make sure your code behaves as expected.
   *
   * Retrieves a list of up to 100 ticket definitions, with basic filter support.
   * @public
   * @param options - Details for the tickets to retrieve.
   * @permissionId WIX_EVENTS.READ_TICKET_DEFINITIONS
   * @adminMethod
   */
  function listTicketDefinitions(options?: ListTicketDefinitionsOptions): Promise<ListTicketDefinitionsResponse>;
  interface ListTicketDefinitionsOptions {
      /** Event ID. */
      eventId?: string[];
      /** Offset. */
      offset?: number;
      /** Paging limit. */
      limit?: number;
      /**
       * Predefined sets of fields to return.
       * - `DASHBOARD`: Returns `dashboard`.
       * - `POLICY`: Returns `policy`.
       *
       * Default: If `fieldset` is omitted from the request,  `id`, `price`, `free`, `name`, `limitPerCheckout`, `orderIndex`, `eventId`.
       */
      fieldset?: TicketDefinitionFieldset[];
      /** Event creator ID. */
      eventCreatorId?: string[];
      /**
       * Filter by ticket definition state.
       *
       * Supported values: `"VISIBLE"`, `"HIDDEN"`, `"FREE"`, `"PAID"`
       */
      state?: State$3[];
      /**
       * Sort order.
       *
       * Default: `"created"`:`"asc"`.
       *
       * See [Ticket Definitions Sort](/wix-events-v2/ticketdefinitions/ticket-definitions-sort) for more information.
       *
       *
       *
       *
       */
      sort?: string;
      /**
       * Ticket sale status.
       *
       * Supported values: `"SALE_SCHEDULED"`, `"SALE_STARTED"`, `"SALE_ENDED"`
       */
      saleStatus?: TicketSaleStatus[];
      /** Filter facets. */
      facet?: string[];
      /**
       * Visible for coupons. For internal use.
       * @internal
       */
      visibleForCoupons?: boolean | null;
      /**
       * For internal use.
       * @internal
       */
      groupBy?: GroupBy;
      /**
       * Ticket definition ID.
       * @internal
       */
      _id?: string[];
  }
  /**
   * **Deprecated.** This function will continue to work until November 8, 2024, but a newer version is available. Use the [`getTicketDefinition()`](/ticket-definitions-v2/get-ticket-definition) function instead.
   * >**Migration Instructions**.
   * > If this function is already in your code, it will continue to work. To stay compatible with future changes, migrate to [`getTicketDefinition()`](/ticket-definitions-v2/get-ticket-definition).
   * > To migrate to the new function:
   * > 1. Add the new import statement:
   * > ```js
   * > import { ticketDefinitionsV2 } from 'wix-events.v2';
   * > ```
   * > 2. Look for any code that uses `ticketDefinitions.getTicketDefinition()`, and replace it with `ticketDefinitionsV2.getTicketDefinition()`. Update your code to work with the new `getTicketDefinition()` response properties.
   * > 3. Test your changes to make sure your code behaves as expected.
   *
   * Retrieves a ticket definition.
   * @param definitionId - Ticket definition ID.
   * @public
   * @requiredField definitionId
   * @param options - Details for the ticket to retrieve.
   * @permissionId WIX_EVENTS.READ_TICKET_DEFINITIONS
   * @adminMethod
   * @returns Retrieved ticket definition.
   */
  function getTicketDefinition$1(definitionId: string, options?: GetTicketDefinitionOptions$1): Promise<TicketDefinition$1>;
  interface GetTicketDefinitionOptions$1 {
      /**
       * Predefined sets of fields to return.
       * - `DASHBOARD`: Returns `dashboard`.
       * - `POLICY`: Returns `policy`.
       *
       * Default: If `fieldset` is omitted from the request,  `id`, `price`, `free`, `name`, `limitPerCheckout`, `orderIndex`, `eventId`.
       */
      fieldset?: TicketDefinitionFieldset[];
  }
  /**
   * **Deprecated.** This function will continue to work until November 8, 2024, but a newer version is available. Use the [`createTicketDefinition()`](/ticket-definitions-v2/create-ticket-definition) function instead.
   * >**Migration Instructions**.
   * > If this function is already in your code, it will continue to work. To stay compatible with future changes, migrate to [`createTicketDefinition()`](/ticket-definitions-v2/create-ticket-definition).
   * > To migrate to the new function:
   * > 1. Add the new import statement:
   * > ```js
   * > import { ticketDefinitionsV2 } from 'wix-events.v2';
   * > ```
   * > 2. Look for any code that uses `ticketDefinitions.createTicketDefinition()`, and replace it with `ticketDefinitionsV2.createTicketDefinition()`. Update your code to work with the new `createTicketDefinition()` response properties.
   * > 3. Test your changes to make sure your code behaves as expected.
   *
   * Creates a ticket definition (and enables ticket sales).
   * @param eventId - Event ID.
   * @public
   * @requiredField eventId
   * @requiredField options
   * @requiredField options.definition
   * @requiredField options.definition.name
   * @permissionId WIX_EVENTS.MANAGE_TICKET_DEFINITIONS
   * @adminMethod
   */
  function createTicketDefinition$1(eventId: string, options: CreateTicketDefinitionOptions$1): Promise<CreateTicketDefinitionResponse$1>;
  interface CreateTicketDefinitionOptions$1 {
      /** Ticket definition data. */
      definition: TicketDefinitionData;
  }
  /**
   * **Deprecated.** This function will continue to work until November 8, 2024, but a newer version is available. Use the [`updateTicketDefinition()`](/ticket-definitions-v2/update-ticket-definition) function instead.
   * >**Migration Instructions**.
   * > If this function is already in your code, it will continue to work. To stay compatible with future changes, migrate to [`updateTicketDefinition()`](/ticket-definitions-v2/update-ticket-definition).
   * > To migrate to the new function:
   * > 1. Add the new import statement:
   * > ```js
   * > import { ticketDefinitionsV2 } from 'wix-events.v2';
   * > ```
   * > 2. Look for any code that uses `ticketDefinitions.updateTicketDefinition()`, and replace it with `ticketDefinitionsV2.updateTicketDefinition()`. Update your code to work with the new `updateTicketDefinition()` response properties.
   * > 3. Test your changes to make sure your code behaves as expected.
   *
   *
   * Updates a ticket definition.
   *
   * See [Partial Updates](/wix-events-v2/partial-updates) for more information.
   * @param definitionId - Ticket definition ID.
   * @param eventId - Event ID.
   * @public
   * @requiredField definitionId
   * @requiredField eventId
   * @requiredField options.definition.pricing
   * @param identifiers - Details of the ticket definition to update.
   * @param options - Ticket definition details to update.
   * @permissionId WIX_EVENTS.MANAGE_TICKET_DEFINITIONS
   * @adminMethod
   */
  function updateTicketDefinition$1(definitionId: string, eventId: string, options?: UpdateTicketDefinitionOptions$1): Promise<UpdateTicketDefinitionResponse$1>;
  interface UpdateTicketDefinitionOptions$1 {
      /** Ticket definition data. */
      definition?: TicketDefinitionData;
      /**
       * Set of field paths, specifying which parts of ticket definition to update.
       * @internal
       */
      fields?: string[];
  }
  /**
   * **Deprecated.** This function will continue to work until November 8, 2024, but a newer version is available. Use the [`deleteTicketDefinition()`](/ticket-definitions-v2/delete-ticket-definition) function instead.
   * >**Migration Instructions**.
   * > If this function is already in your code, it will continue to work. To stay compatible with future changes, migrate to [`deleteTicketDefinition()`](/ticket-definitions-v2/delete-ticket-definition).
   * > To migrate to the new function:
   * > 1. Add the new import statement:
   * > ```js
   * > import { ticketDefinitionsV2 } from 'wix-events.v2';
   * > ```
   * > 2. Look for any code that uses `ticketDefinitions.deleteTicketDefinition()`, and replace it with `ticketDefinitionsV2.deleteTicketDefinition()`. Update your code to work with the new `deleteTicketDefinition()` response properties.
   * > 3. Test your changes to make sure your code behaves as expected.
   *
   * Deletes a ticket definition.
   * @param eventId - Event ID.
   * @public
   * @requiredField eventId
   * @param options - Details of tickets to delete.
   * @permissionId WIX_EVENTS.MANAGE_TICKET_DEFINITIONS
   * @adminMethod
   */
  function deleteTicketDefinition$1(eventId: string, options?: DeleteTicketDefinitionOptions): Promise<void>;
  interface DeleteTicketDefinitionOptions extends DeleteTicketDefinitionRequestDeleteOneOf {
      /** Ticket definitions to delete. */
      byId?: ById;
      /** Whether to delete all event tickets. */
      all?: boolean;
  }
  /**
   * **Deprecated.** This function will continue to work until November 8, 2024, but a newer version is available at [`changeCurrency()`](/ticket-definitions-v2/change-currency).
   * >**Migration Instructions**.
   * > If this function is already in your code, it will continue to work. To stay compatible with future changes, migrate to [`changeCurrency()`](/ticket-definitions-v2/change-currency).
   * > To migrate to the new function:
   * > 1. Add the new import statement:
   * > ```js
   * > import { ticketDefinitionsV2 } from 'wix-events.v2';
   * > ```
   * > 2. Look for any code that uses `ticketDefinitions.changeCurrency()`, and replace it with `ticketDefinitionsV2.changeCurrency()`. Update your code to work with the new `changeCurrency()` response properties.
   * > 3. Test your changes to make sure your code behaves as expected.
   *
   * Changes the currency for all tickets per event.
   *
   * @public
   * @requiredField options.currency
   * @permissionId WIX_EVENTS.MANAGE_TICKET_DEFINITIONS
   * @adminMethod
   */
  function changeCurrency$1(options?: ChangeCurrencyOptions$1): Promise<void>;
  interface ChangeCurrencyOptions$1 {
      /** Event ID. */
      eventId?: string;
      /** Event currency, in 3-letter [ISO-4217 alphabetic](https://en.wikipedia.org/wiki/ISO_4217#Active_codes) format. */
      currency: string;
  }
  
  type eventsV1TicketDefinition_universal_d_WixFeeConfig = WixFeeConfig;
  type eventsV1TicketDefinition_universal_d_FeeType = FeeType;
  const eventsV1TicketDefinition_universal_d_FeeType: typeof FeeType;
  type eventsV1TicketDefinition_universal_d_TicketSalePeriod = TicketSalePeriod;
  type eventsV1TicketDefinition_universal_d_TicketSaleStatus = TicketSaleStatus;
  const eventsV1TicketDefinition_universal_d_TicketSaleStatus: typeof TicketSaleStatus;
  type eventsV1TicketDefinition_universal_d_TicketDefinitionStateEnumState = TicketDefinitionStateEnumState;
  const eventsV1TicketDefinition_universal_d_TicketDefinitionStateEnumState: typeof TicketDefinitionStateEnumState;
  type eventsV1TicketDefinition_universal_d_TicketPricing = TicketPricing;
  type eventsV1TicketDefinition_universal_d_TicketPricingPriceOneOf = TicketPricingPriceOneOf;
  type eventsV1TicketDefinition_universal_d_PricingOption = PricingOption;
  type eventsV1TicketDefinition_universal_d_TicketDefinitionFieldset = TicketDefinitionFieldset;
  const eventsV1TicketDefinition_universal_d_TicketDefinitionFieldset: typeof TicketDefinitionFieldset;
  type eventsV1TicketDefinition_universal_d_QueryTicketDefinitionsV2Request = QueryTicketDefinitionsV2Request;
  type eventsV1TicketDefinition_universal_d_QueryTicketDefinitionsV2Response = QueryTicketDefinitionsV2Response;
  type eventsV1TicketDefinition_universal_d_ListTicketDefinitionsRequest = ListTicketDefinitionsRequest;
  type eventsV1TicketDefinition_universal_d_GroupBy = GroupBy;
  const eventsV1TicketDefinition_universal_d_GroupBy: typeof GroupBy;
  type eventsV1TicketDefinition_universal_d_ListTicketDefinitionsResponse = ListTicketDefinitionsResponse;
  type eventsV1TicketDefinition_universal_d_ResponseMetaData = ResponseMetaData;
  type eventsV1TicketDefinition_universal_d_TicketDefinitionData = TicketDefinitionData;
  type eventsV1TicketDefinition_universal_d_TicketDefinitionCreated = TicketDefinitionCreated;
  type eventsV1TicketDefinition_universal_d_OriginatedFrom = OriginatedFrom;
  type eventsV1TicketDefinition_universal_d_TicketDefinitionUpdated = TicketDefinitionUpdated;
  type eventsV1TicketDefinition_universal_d_DeleteTicketDefinitionRequestDeleteOneOf = DeleteTicketDefinitionRequestDeleteOneOf;
  type eventsV1TicketDefinition_universal_d_ById = ById;
  type eventsV1TicketDefinition_universal_d_TicketDefinitionDeleted = TicketDefinitionDeleted;
  type eventsV1TicketDefinition_universal_d_PaidTicketDefinitionExistsRequest = PaidTicketDefinitionExistsRequest;
  type eventsV1TicketDefinition_universal_d_PaidTicketDefinitionExistsResponse = PaidTicketDefinitionExistsResponse;
  const eventsV1TicketDefinition_universal_d_queryTicketDefinitionsV2: typeof queryTicketDefinitionsV2;
  type eventsV1TicketDefinition_universal_d_QueryTicketDefinitionsV2Options = QueryTicketDefinitionsV2Options;
  type eventsV1TicketDefinition_universal_d_DefinitionsQueryResult = DefinitionsQueryResult;
  type eventsV1TicketDefinition_universal_d_DefinitionsQueryBuilder = DefinitionsQueryBuilder;
  const eventsV1TicketDefinition_universal_d_listTicketDefinitions: typeof listTicketDefinitions;
  type eventsV1TicketDefinition_universal_d_ListTicketDefinitionsOptions = ListTicketDefinitionsOptions;
  type eventsV1TicketDefinition_universal_d_DeleteTicketDefinitionOptions = DeleteTicketDefinitionOptions;
  namespace eventsV1TicketDefinition_universal_d {
    export {
      TicketDefinition$1 as TicketDefinition,
      Money$3 as Money,
      Dashboard$3 as Dashboard,
      eventsV1TicketDefinition_universal_d_WixFeeConfig as WixFeeConfig,
      eventsV1TicketDefinition_universal_d_FeeType as FeeType,
      eventsV1TicketDefinition_universal_d_TicketSalePeriod as TicketSalePeriod,
      eventsV1TicketDefinition_universal_d_TicketSaleStatus as TicketSaleStatus,
      eventsV1TicketDefinition_universal_d_TicketDefinitionStateEnumState as TicketDefinitionStateEnumState,
      eventsV1TicketDefinition_universal_d_TicketPricing as TicketPricing,
      eventsV1TicketDefinition_universal_d_TicketPricingPriceOneOf as TicketPricingPriceOneOf,
      PricingOptions$1 as PricingOptions,
      eventsV1TicketDefinition_universal_d_PricingOption as PricingOption,
      Type$2 as Type,
      QueryTicketDefinitionsRequest$1 as QueryTicketDefinitionsRequest,
      eventsV1TicketDefinition_universal_d_TicketDefinitionFieldset as TicketDefinitionFieldset,
      QueryTicketDefinitionsResponse$1 as QueryTicketDefinitionsResponse,
      FacetCounts$2 as FacetCounts,
      eventsV1TicketDefinition_universal_d_QueryTicketDefinitionsV2Request as QueryTicketDefinitionsV2Request,
      QueryV2$3 as QueryV2,
      QueryV2PagingMethodOneOf$3 as QueryV2PagingMethodOneOf,
      Sorting$4 as Sorting,
      SortOrder$4 as SortOrder,
      Paging$4 as Paging,
      CursorPaging$4 as CursorPaging,
      eventsV1TicketDefinition_universal_d_QueryTicketDefinitionsV2Response as QueryTicketDefinitionsV2Response,
      PagingMetadataV2$4 as PagingMetadataV2,
      Cursors$4 as Cursors,
      eventsV1TicketDefinition_universal_d_ListTicketDefinitionsRequest as ListTicketDefinitionsRequest,
      State$3 as State,
      eventsV1TicketDefinition_universal_d_GroupBy as GroupBy,
      eventsV1TicketDefinition_universal_d_ListTicketDefinitionsResponse as ListTicketDefinitionsResponse,
      eventsV1TicketDefinition_universal_d_ResponseMetaData as ResponseMetaData,
      GetTicketDefinitionRequest$1 as GetTicketDefinitionRequest,
      GetTicketDefinitionResponse$1 as GetTicketDefinitionResponse,
      CreateTicketDefinitionRequest$1 as CreateTicketDefinitionRequest,
      eventsV1TicketDefinition_universal_d_TicketDefinitionData as TicketDefinitionData,
      CreateTicketDefinitionResponse$1 as CreateTicketDefinitionResponse,
      eventsV1TicketDefinition_universal_d_TicketDefinitionCreated as TicketDefinitionCreated,
      eventsV1TicketDefinition_universal_d_OriginatedFrom as OriginatedFrom,
      UpdateTicketDefinitionRequest$1 as UpdateTicketDefinitionRequest,
      UpdateTicketDefinitionResponse$1 as UpdateTicketDefinitionResponse,
      eventsV1TicketDefinition_universal_d_TicketDefinitionUpdated as TicketDefinitionUpdated,
      DeleteTicketDefinitionRequest$1 as DeleteTicketDefinitionRequest,
      eventsV1TicketDefinition_universal_d_DeleteTicketDefinitionRequestDeleteOneOf as DeleteTicketDefinitionRequestDeleteOneOf,
      eventsV1TicketDefinition_universal_d_ById as ById,
      DeleteTicketDefinitionResponse$1 as DeleteTicketDefinitionResponse,
      eventsV1TicketDefinition_universal_d_TicketDefinitionDeleted as TicketDefinitionDeleted,
      ChangeCurrencyRequest$1 as ChangeCurrencyRequest,
      ChangeCurrencyResponse$1 as ChangeCurrencyResponse,
      BulkCopyTicketDefinitionsByEventIdRequest$1 as BulkCopyTicketDefinitionsByEventIdRequest,
      BulkCopyTicketDefinitionsByEventIdResponse$1 as BulkCopyTicketDefinitionsByEventIdResponse,
      CopiedTicketDefinition$1 as CopiedTicketDefinition,
      eventsV1TicketDefinition_universal_d_PaidTicketDefinitionExistsRequest as PaidTicketDefinitionExistsRequest,
      eventsV1TicketDefinition_universal_d_PaidTicketDefinitionExistsResponse as PaidTicketDefinitionExistsResponse,
      MessageEnvelope$4 as MessageEnvelope,
      IdentificationData$4 as IdentificationData,
      IdentificationDataIdOneOf$4 as IdentificationDataIdOneOf,
      WebhookIdentityType$4 as WebhookIdentityType,
      queryTicketDefinitions$1 as queryTicketDefinitions,
      QueryTicketDefinitionsOptions$1 as QueryTicketDefinitionsOptions,
      eventsV1TicketDefinition_universal_d_queryTicketDefinitionsV2 as queryTicketDefinitionsV2,
      eventsV1TicketDefinition_universal_d_QueryTicketDefinitionsV2Options as QueryTicketDefinitionsV2Options,
      eventsV1TicketDefinition_universal_d_DefinitionsQueryResult as DefinitionsQueryResult,
      eventsV1TicketDefinition_universal_d_DefinitionsQueryBuilder as DefinitionsQueryBuilder,
      eventsV1TicketDefinition_universal_d_listTicketDefinitions as listTicketDefinitions,
      eventsV1TicketDefinition_universal_d_ListTicketDefinitionsOptions as ListTicketDefinitionsOptions,
      getTicketDefinition$1 as getTicketDefinition,
      GetTicketDefinitionOptions$1 as GetTicketDefinitionOptions,
      createTicketDefinition$1 as createTicketDefinition,
      CreateTicketDefinitionOptions$1 as CreateTicketDefinitionOptions,
      updateTicketDefinition$1 as updateTicketDefinition,
      UpdateTicketDefinitionOptions$1 as UpdateTicketDefinitionOptions,
      deleteTicketDefinition$1 as deleteTicketDefinition,
      eventsV1TicketDefinition_universal_d_DeleteTicketDefinitionOptions as DeleteTicketDefinitionOptions,
      changeCurrency$1 as changeCurrency,
      ChangeCurrencyOptions$1 as ChangeCurrencyOptions,
    };
  }
  
  interface Policy {
      /**
       * Policy ID.
       * @readonly
       */
      _id?: string | null;
      /**
       * Revision number, which increments by 1 each time the policy is updated. The existing revision must be used when updating a policy to prevent conflicting changes. You'll get an error if you try to use the previous revision.
       * @readonly
       */
      revision?: string | null;
      /**
       * Date and time when the policy was created.
       * @readonly
       */
      _createdDate?: Date | null;
      /**
       * Date and time of the policy's latest update in.
       * @readonly
       */
      _updatedDate?: Date | null;
      /**
       * Policy name that is visible in the dashboard and checkout form.
       *
       * Min: 1 character
       *
       * Max: 40 characters
       */
      name?: string;
      /**
       * Policy body, usually containing various terms and conditions.
       *
       * Min: 1 character
       *
       * Max: 50000 characters.
       *
       * **Note**: You can format text using various HTML tags such as `<p>`, `<b>`, `<ul>`, etc.
       */
      body?: string;
      /** ID of the event to which the policy belongs. */
      eventId?: string;
  }
  interface CreatePolicyRequest {
      /** Policy info. */
      policy: Policy;
  }
  interface CreatePolicyResponse {
      /** Created policy. */
      policy?: Policy;
  }
  interface UpdatePolicyRequest {
      /** Policy to update. */
      policy: Policy;
      /**
       * Explicit list of fields to update.
       * @internal
       */
      mask?: string[];
  }
  interface UpdatePolicyResponse {
      /** The updated policy. */
      policy?: Policy;
  }
  interface UpdatePolicySortIndexRequest {
      /** Policy's ID */
      policyId?: string;
      /** The revision of the event policy. */
      revision?: string;
      /** The sort index of a policy to set. */
      sortIndex?: number;
  }
  interface UpdatePolicySortIndexResponse {
      /** The updated event policy. */
      policy?: Policy;
  }
  interface DeletePolicyRequest {
      /** ID of the policy to delete. */
      policyId: string;
  }
  interface DeletePolicyResponse {
  }
  interface QueryPoliciesRequest {
      /** Query options. See [API Query Langauge](https://dev.wix.com/api/rest/getting-started/api-query-language) for more details. */
      query: QueryV2$2;
  }
  interface QueryV2$2 extends QueryV2PagingMethodOneOf$2 {
      /** Pagination options. */
      paging?: Paging$3;
      /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
      cursorPaging?: CursorPaging$3;
      /** Filter object in the following format: <br/> `"filter" : { "fieldName1": "value1", "fieldName2":{"$operator":"value2"} }`. <br/> <br/> **Example:** <br/> `"filter" : { "id": "2224a9d1-79e6-4549-a5c5-bf7ce5aac1a5", "revision": {"$ne":"1"} }` <br/> <br/> See [supported fields and operators](https://dev.wix.com/api/rest/wix-events/policy-v2/filter-and-sort) for more information. */
      filter?: Record<string, any> | null;
      /** Sort object in the following format: <br/> `[{"fieldName":"sortField1"},{"fieldName":"sortField2","direction":"DESC"}]` <br/> <br/> **Example:** <br/> `[{"fieldName":"createdDate","direction":"DESC"}]` <br/> <br/> See [supported fields](https://dev.wix.com/api/rest/wix-events/policy-v2/filter-and-sort) for more information. */
      sort?: Sorting$3[];
  }
  /** @oneof */
  interface QueryV2PagingMethodOneOf$2 {
      /** Pagination options. */
      paging?: Paging$3;
      /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
      cursorPaging?: CursorPaging$3;
  }
  interface Sorting$3 {
      /** Name of the field to sort by. */
      fieldName?: string;
      /** Sort order (ASC/DESC). Defaults to ASC */
      order?: SortOrder$3;
  }
  enum SortOrder$3 {
      ASC = "ASC",
      DESC = "DESC"
  }
  interface Paging$3 {
      /** Number of items to load per page. */
      limit?: number | null;
      /** Number of items to skip in the current sort order. */
      offset?: number | null;
  }
  interface CursorPaging$3 {
      /** Number of items to load per page. */
      limit?: number | null;
      /**
       * Pointer to the next or previous page in the list of results.
       * You can get the relevant cursor token
       * from the `pagingMetadata` object in the previous call's response.
       * Not relevant for the first request.
       */
      cursor?: string | null;
  }
  interface QueryPoliciesResponse {
      /** Event policies. */
      policies?: Policy[];
      /** Query result's metadata. */
      metadata?: PagingMetadataV2$3;
  }
  interface PagingMetadataV2$3 {
      /** Number of items returned in the response. */
      count?: number | null;
      /** Offset that was requested. */
      offset?: number | null;
      /** Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set. */
      total?: number | null;
      /** Flag that indicates the server failed to calculate the `total` field. */
      tooManyToCount?: boolean | null;
      /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
      cursors?: Cursors$3;
  }
  interface Cursors$3 {
      /** Cursor pointing to next page in the list of results. */
      next?: string | null;
      /** Cursor pointing to previous page in the list of results. */
      prev?: string | null;
  }
  interface ReorderEventPoliciesRequest extends ReorderEventPoliciesRequestReferencePolicyOneOf {
      /** Move the given `policyId` before the specified policy. */
      beforePolicyId?: string;
      /** Move the given `policyId` after the specified policy. */
      afterPolicyId?: string;
      /** Event ID. */
      eventId: string;
      /** Event policy ID. */
      policyId: string;
  }
  /** @oneof */
  interface ReorderEventPoliciesRequestReferencePolicyOneOf {
      /**   */
      beforePolicyId?: string;
      /** Move the given `policyId` after the specified policy. */
      afterPolicyId?: string;
  }
  interface ReorderEventPoliciesResponse {
      /** Ordered event policies. */
      policies?: Policy[];
  }
  interface GetPolicyRequest {
      /** Policy ID. */
      policyId: string;
  }
  interface GetPolicyResponse {
      /** The requested policy. */
      policy?: Policy;
  }
  interface EventCopied$1 {
      /** Event created timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Event ID. */
      eventId?: string;
      /** Event location. */
      location?: Location$3;
      /** Event schedule configuration. */
      scheduleConfig?: ScheduleConfig$3;
      /** Event title. */
      title?: string;
      /** Event creator user ID. */
      userId?: string | null;
      /** Event status. */
      status?: EventStatus$3;
      /** Instance ID. Indicates the original app instance which current event was derived from. */
      derivedFromInstanceId?: string | null;
      /** Event ID. Indicates the original event which current event was derived from. */
      derivedFromEventId?: string | null;
      /**
       * Map of copied ticket definitions from original event.
       * Key represents ticket def id in the original event.
       * Value represents ticket def id in the newly created event.
       */
      ticketDefinitions?: Record<string, string>;
  }
  interface Location$3 {
      /** Location name. */
      name?: string | null;
      /** Location map coordinates. */
      coordinates?: MapCoordinates$3;
      /** Single line address representation. */
      address?: string | null;
      /** Location type. */
      type?: LocationType$3;
      /**
       * Full address derived from formatted single line `address`.
       * When `full_address` is used to create or update the event, deprecated `address` and `coordinates` are ignored.
       * If provided `full_address` has empty `formatted_address` or `coordinates`, it will be auto-completed using Atlas service.
       *
       * Migration notes:
       * - `full_address.formatted_address` is equivalent to `address`.
       * - `full_address.geocode` is equivalent to `coordinates`.
       */
      fullAddress?: Address$3;
      /**
       * Defines event location as TBD (To Be Determined).
       * When event location is not yet defined, `name` is displayed instead of location address.
       * `coordinates`, `address`, `type` and `full_address` are not required when location is TBD.
       */
      tbd?: boolean | null;
  }
  interface MapCoordinates$3 {
      /** Latitude. */
      lat?: number;
      /** Longitude. */
      lng?: number;
  }
  enum LocationType$3 {
      VENUE = "VENUE",
      ONLINE = "ONLINE"
  }
  /** Physical address */
  interface Address$3 extends AddressStreetOneOf$3 {
      /** a break down of the street to number and street name */
      streetAddress?: StreetAddress$3;
      /** Main address line (usually street and number) as free text */
      addressLine1?: string | null;
      /** country code */
      country?: string | null;
      /** subdivision (usually state or region) code according to ISO 3166-2 */
      subdivision?: string | null;
      /** city name */
      city?: string | null;
      /** zip/postal code */
      postalCode?: string | null;
      /** Free text providing more detailed address info. Usually contains Apt, Suite, Floor */
      addressLine2?: string | null;
      /** A string containing the human-readable address of this location */
      formatted?: string | null;
      /** coordinates of the physical address */
      location?: AddressLocation$3;
      /** country full-name */
      countryFullname?: string | null;
      /** multi-level subdivisions from top to bottom */
      subdivisions?: Subdivision$3[];
  }
  /** @oneof */
  interface AddressStreetOneOf$3 {
      /** a break down of the street to number and street name */
      streetAddress?: StreetAddress$3;
      /** Main address line (usually street and number) as free text */
      addressLine?: string | null;
  }
  interface StreetAddress$3 {
      /** street number */
      number?: string;
      /** street name */
      name?: string;
      /**
       * apartment number
       * @internal
       */
      apt?: string;
  }
  interface AddressLocation$3 {
      /** address latitude coordinates */
      latitude?: number | null;
      /** address longitude coordinates */
      longitude?: number | null;
  }
  interface Subdivision$3 {
      /** subdivision short code */
      code?: string;
      /** subdivision full-name */
      name?: string;
      /**
       * subdivision level
       * @internal
       */
      type?: SubdivisionType$3;
      /**
       * free text description of subdivision type
       * @internal
       */
      typeInfo?: string | null;
  }
  enum SubdivisionType$3 {
      UNKNOWN_SUBDIVISION_TYPE = "UNKNOWN_SUBDIVISION_TYPE",
      /** State */
      ADMINISTRATIVE_AREA_LEVEL_1 = "ADMINISTRATIVE_AREA_LEVEL_1",
      /** County */
      ADMINISTRATIVE_AREA_LEVEL_2 = "ADMINISTRATIVE_AREA_LEVEL_2",
      /** City/town */
      ADMINISTRATIVE_AREA_LEVEL_3 = "ADMINISTRATIVE_AREA_LEVEL_3",
      /** Neighborhood/quarter */
      ADMINISTRATIVE_AREA_LEVEL_4 = "ADMINISTRATIVE_AREA_LEVEL_4",
      /** Street/block */
      ADMINISTRATIVE_AREA_LEVEL_5 = "ADMINISTRATIVE_AREA_LEVEL_5",
      /** ADMINISTRATIVE_AREA_LEVEL_0. Indicates the national political entity, and is typically the highest order type returned by the Geocoder. */
      COUNTRY = "COUNTRY"
  }
  interface ScheduleConfig$3 {
      /**
       * Defines event as TBD (To Be Determined) schedule.
       * When event time is not yet defined, TBD message is displayed instead of event start and end times.
       * `startDate`, `endDate` and `timeZoneId` are not required when schedule is TBD.
       */
      scheduleTbd?: boolean;
      /** TBD message. */
      scheduleTbdMessage?: string | null;
      /** Event start timestamp. */
      startDate?: Date | null;
      /** Event end timestamp. */
      endDate?: Date | null;
      /** Event time zone ID in TZ database format, e.g., `EST`, `America/Los_Angeles`. */
      timeZoneId?: string | null;
      /** Whether end date is hidden in the formatted schedule. */
      endDateHidden?: boolean;
      /** Whether time zone is displayed in formatted schedule. */
      showTimeZone?: boolean;
      /** Event recurrences. */
      recurrences?: Recurrences$3;
  }
  interface Recurrences$3 {
      /** Event occurrences. */
      occurrences?: Occurrence$3[];
      /**
       * Recurring event category ID.
       * @readonly
       */
      categoryId?: string | null;
      /**
       * Recurrence status.
       * @readonly
       */
      status?: Status$3;
  }
  interface Occurrence$3 {
      /** Event start timestamp. */
      startDate?: Date | null;
      /** Event end timestamp. */
      endDate?: Date | null;
      /** Event time zone ID in TZ database format, e.g., `EST`, `America/Los_Angeles`. */
      timeZoneId?: string | null;
      /** Whether time zone is displayed in formatted schedule. */
      showTimeZone?: boolean;
  }
  enum Status$3 {
      /** Event occurs only once. */
      ONE_TIME = "ONE_TIME",
      /** Event is recurring. */
      RECURRING = "RECURRING",
      /** Marks the next upcoming occurrence of the recurring event. */
      RECURRING_NEXT = "RECURRING_NEXT",
      /** Marks the most recent ended occurrence of the recurring event. */
      RECURRING_LAST_ENDED = "RECURRING_LAST_ENDED",
      /** Marks the most recent canceled occurrence of the recurring event. */
      RECURRING_LAST_CANCELED = "RECURRING_LAST_CANCELED"
  }
  enum EventStatus$3 {
      /** Event is public and scheduled to start */
      SCHEDULED = "SCHEDULED",
      /** Event has started */
      STARTED = "STARTED",
      /** Event has ended */
      ENDED = "ENDED",
      /** Event was canceled */
      CANCELED = "CANCELED",
      /** Event is not public and needs to be published */
      DRAFT = "DRAFT"
  }
  interface Empty$3 {
  }
  interface GetPolicyFromTrashBinRequest {
      /** Policy ID. */
      policyId?: string;
  }
  interface GetPolicyFromTrashBinResponse {
      /** The requested policy. */
      policy?: Policy;
  }
  interface DomainEvent$3 extends DomainEventBodyOneOf$3 {
      createdEvent?: EntityCreatedEvent$3;
      updatedEvent?: EntityUpdatedEvent$3;
      deletedEvent?: EntityDeletedEvent$3;
      actionEvent?: ActionEvent$3;
      /**
       * Unique event ID.
       * Allows clients to ignore duplicate webhooks.
       */
      _id?: string;
      /**
       * Assumes actions are also always typed to an entity_type
       * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
       */
      entityFqdn?: string;
      /**
       * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
       * This is although the created/updated/deleted notion is duplication of the oneof types
       * Example: created/updated/deleted/started/completed/email_opened
       */
      slug?: string;
      /** ID of the entity associated with the event. */
      entityId?: string;
      /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
      eventTime?: Date | null;
      /**
       * Whether the event was triggered as a result of a privacy regulation application
       * (for example, GDPR).
       */
      triggeredByAnonymizeRequest?: boolean | null;
      /** If present, indicates the action that triggered the event. */
      originatedFrom?: string | null;
      /**
       * A sequence number defining the order of updates to the underlying entity.
       * For example, given that some entity was updated at 16:00 and than again at 16:01,
       * it is guaranteed that the sequence number of the second update is strictly higher than the first.
       * As the consumer, you can use this value to ensure that you handle messages in the correct order.
       * To do so, you will need to persist this number on your end, and compare the sequence number from the
       * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
       */
      entityEventSequence?: string | null;
  }
  /** @oneof */
  interface DomainEventBodyOneOf$3 {
      createdEvent?: EntityCreatedEvent$3;
      updatedEvent?: EntityUpdatedEvent$3;
      deletedEvent?: EntityDeletedEvent$3;
      actionEvent?: ActionEvent$3;
  }
  interface EntityCreatedEvent$3 {
      entityAsJson?: string;
      /**
       * Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity
       * @internal
       */
      triggeredByUndelete?: boolean | null;
      /** Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity */
      restoreInfo?: RestoreInfo$3;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface RestoreInfo$3 {
      deletedDate?: Date | null;
  }
  interface EntityUpdatedEvent$3 {
      /**
       * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
       * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
       * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
       */
      currentEntityAsJson?: string;
      /**
       * This field is currently part of the of the EntityUpdatedEvent msg, but scala/node libraries which implements the domain events standard
       * wont populate it / have any reference to it in the API.
       * The main reason for it is that fetching the old entity from the DB will have a performance hit on an update operation so unless truly needed,
       * the developer should send only the new (current) entity.
       * An additional reason is not wanting to send this additional entity over the wire (kafka) since in some cases it can be really big
       * Developers that must reflect the old entity will have to implement their own domain event sender mechanism which will follow the DomainEvent proto message.
       * @internal
       * @deprecated
       */
      previousEntityAsJson?: string | null;
      /**
       * WIP - This property will hold both names and values of the updated fields of the entity.
       * For more details please see [adr](https://docs.google.com/document/d/1PdqsOM20Ph2HAkmx8zvUnzzk3Sekp3BR9h34wSvsRnI/edit#heading=h.phlw87mh2imx) or [issue](https://github.com/wix-private/nile-tracker/issues/363)
       * @internal
       */
      modifiedFields?: Record<string, any>;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface EntityDeletedEvent$3 {
      /**
       * Indicates if the entity is sent to trash-bin. only available when trash-bin is enabled
       * @internal
       */
      movedToTrash?: boolean | null;
      /** Entity that was deleted */
      deletedEntityAsJson?: string | null;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface ActionEvent$3 {
      bodyAsJson?: string;
  }
  interface MessageEnvelope$3 {
      /** App instance ID. */
      instanceId?: string | null;
      /** Event type. */
      eventType?: string;
      /** The identification type and identity data. */
      identity?: IdentificationData$3;
      /** Stringify payload. */
      data?: string;
  }
  interface IdentificationData$3 extends IdentificationDataIdOneOf$3 {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
      /** @readonly */
      identityType?: WebhookIdentityType$3;
  }
  /** @oneof */
  interface IdentificationDataIdOneOf$3 {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
  }
  enum WebhookIdentityType$3 {
      UNKNOWN = "UNKNOWN",
      ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
      MEMBER = "MEMBER",
      WIX_USER = "WIX_USER",
      APP = "APP"
  }
  /**
   * Creates a policy.
   *
   *
   * <!--
   * >  Note: This function is restricted and only runs if you elevate permissions using the [wix-auth.elevate()](https://www.wix.com/velo/reference/wix-auth/elevate) function.
   * -->
   *
   * The `createPolicy()` function returns a Promise that resolves to the newly-created policy.
   *
   * You can create up to 3 policies per event. If you try to create more than 3, you'll get the "Maximum number of policies for the event has been reached" error.
   * @public
   * @requiredField policy
   * @requiredField policy.body
   * @requiredField policy.eventId
   * @requiredField policy.name
   * @param policy - Policy info.
   * @permissionId WIX_EVENTS.MANAGE_POLICIES
   * @adminMethod
   * @returns Created policy.
   */
  function createPolicy(policy: Policy): Promise<Policy>;
  /**
   * Updates a policy.
   *
   * <!--
   * > Note: This function is restricted and only runs if you elevate permissions using the [wix-auth.elevate()](https://www.wix.com/velo/reference/wix-auth/elevate) function.
   * -->
   *
   * The `updatePolicy()` function returns a Promise that resolves to the newly-updated policy.
   *
   * Each time the policy is updated, `revision` increments by 1. The existing `revision` must be included when updating the policy. This ensures you're working with the latest policy and prevents unintended overwrites.
   * @public
   * @requiredField _id
   * @requiredField policy
   * @requiredField policy.body
   * @requiredField policy.eventId
   * @requiredField policy.name
   * @requiredField policy.revision
   * @param policy - Policy to update.
   * @param _id - Policy ID.
   * @permissionId WIX_EVENTS.MANAGE_POLICIES
   * @adminMethod
   * @returns The updated policy.
   */
  function updatePolicy(_id: string | null, policy: UpdatePolicy, options?: UpdatePolicyOptions): Promise<Policy>;
  interface UpdatePolicy {
      /**
       * Policy ID.
       * @readonly
       */
      _id?: string | null;
      /**
       * Revision number, which increments by 1 each time the policy is updated. The existing revision must be used when updating a policy to prevent conflicting changes. You'll get an error if you try to use the previous revision.
       * @readonly
       */
      revision?: string | null;
      /**
       * Date policy was created.
       * @readonly
       */
      _createdDate?: Date | null;
      /**
       * Date and time of the policy's latest update in `yyyy-mm-ddThh:mm:sssZ` format.
       * @readonly
       */
      _updatedDate?: Date | null;
      /**
       * Policy name that is visible in the dashboard and checkout form.
       *
       * Min: 1 character
       *
       * Max: 40 characters
       */
      name?: string;
      /**
       * Policy body. Here you can enter various terms and conditions.
       *
       * Min: 1 character
       *
       * Max: 50000 characters
       *
       * **Note**: You can format text using various HTML tags such as `<p>`, `<b>`, `<ul>`, etc.
       */
      body?: string;
      /** ID of the event to which the policy belongs. */
      eventId?: string;
  }
  interface UpdatePolicyOptions {
      /**
       * Explicit list of fields to update.
       * @internal
       */
      mask?: string[];
  }
  /**
   * Permanently deletes a policy.
   *
   *
   * <!--
   * > Note: This function is restricted and only runs if you elevate permissions using the [wix-auth.elevate()](https://www.wix.com/velo/reference/wix-auth/elevate) function.
   * -->
   *
   * The `deletePolicy()` function returns a Promise that resolves when the specified policy is deleted.
   *
   * Deleted policies are not returned by the `getPolicy()` or `queryPolicies()` functions.
   * @public
   * @requiredField policyId
   * @param options - Options for Delete Policy function.
   * @param policyId - ID of the policy to delete.
   * @permissionId WIX_EVENTS.MANAGE_POLICIES
   * @adminMethod
   */
  function deletePolicy(policyId: string): Promise<void>;
  /**
   * Creates a query to retrieve a list of policies, given the provided paging and filter.
   *
   *
   * The `queryPolicies()` function builds a query to retrieve a list of policies and returns a [PoliciesQueryBuilder](https://www.wix.com/velo/reference/wix-events-v2/policies/policiesquerybuilder) object.
   *
   * The returned object contains the query definition which is typically used to run the query using the [`find()`](https://www.wix.com/velo/reference/wix-events-v2/policies/policiesquerybuilder/find) function.
   *
   * You can refine the query by chaining `PoliciesQueryBuilder` functions onto the query. `PoliciesQueryBuilder` functions enable you to sort, filter and control the results that `PoliciesQueryBuilder.find()` returns.
   *
   * The query runs with the following `PoliciesQueryBuilder` defaults that you can override:
   *
   * [`limit`](https://www.wix.com/velo/reference/wix-events-v2/policies/policiesquerybuilder/limit): `50`
   * [`descending`](https://www.wix.com/velo/reference/wix-events-v2/policies/policiesquerybuilder/descending): `_createdDate`
   *
   * The functions that are chained to `queryPolicies()` are applied in the order they are called. For example, if you sort on the `_createdDate` property in ascending order and then on the id property in descending order, the results are sorted by the created date and then, if there are multiple results with the same date, the items are sorted by the id.
   *
   * The table below shows which `PoliciesQueryBuilder` functions are supported for `queryPoliciesGuests()`. You can only use one filter function for each property. If a property is used in more than one filter, only the first filter will work.
   * @public
   * @permissionId WIX_EVENTS.READ_POLICIES
   */
  function queryPolicies(): PoliciesQueryBuilder;
  interface QueryCursorResult$2 {
      cursors: Cursors$3;
      hasNext: () => boolean;
      hasPrev: () => boolean;
      length: number;
      pageSize: number;
  }
  interface PoliciesQueryResult extends QueryCursorResult$2 {
      items: Policy[];
      query: PoliciesQueryBuilder;
      next: () => Promise<PoliciesQueryResult>;
      prev: () => Promise<PoliciesQueryResult>;
  }
  interface PoliciesQueryBuilder {
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       */
      eq: (propertyName: '_id' | 'revision' | '_createdDate' | '_updatedDate' | 'name' | 'body' | 'eventId', value: any) => PoliciesQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       */
      ne: (propertyName: '_id' | 'revision' | '_createdDate' | '_updatedDate' | 'name' | 'body' | 'eventId', value: any) => PoliciesQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       */
      ge: (propertyName: 'revision' | '_createdDate' | '_updatedDate', value: any) => PoliciesQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       */
      gt: (propertyName: 'revision' | '_createdDate' | '_updatedDate', value: any) => PoliciesQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       */
      le: (propertyName: 'revision' | '_createdDate' | '_updatedDate', value: any) => PoliciesQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       */
      lt: (propertyName: 'revision' | '_createdDate' | '_updatedDate', value: any) => PoliciesQueryBuilder;
      in: (propertyName: '_id' | 'revision' | '_createdDate' | '_updatedDate' | 'name' | 'body' | 'eventId', value: any) => PoliciesQueryBuilder;
      exists: (propertyName: '_id' | 'revision' | '_createdDate' | '_updatedDate' | 'name' | 'body' | 'eventId', value: boolean) => PoliciesQueryBuilder;
      /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments. */
      ascending: (...propertyNames: Array<'_id' | 'revision' | '_createdDate' | '_updatedDate' | 'name' | 'body' | 'eventId'>) => PoliciesQueryBuilder;
      /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments. */
      descending: (...propertyNames: Array<'_id' | 'revision' | '_createdDate' | '_updatedDate' | 'name' | 'body' | 'eventId'>) => PoliciesQueryBuilder;
      /** @param limit - Number of items to return, which is also the `pageSize` of the results object. */
      limit: (limit: number) => PoliciesQueryBuilder;
      /** @param cursor - A pointer to specific record */
      skipTo: (cursor: string) => PoliciesQueryBuilder;
      find: () => Promise<PoliciesQueryResult>;
  }
  /**
   * Changes policy order in an event dashboard and agreement checkbox on the checkout form.
   * For example, if we have 3 policies in the list, after using this function the 3rd policy will become the 1st, and other policies will move by 1 position. By default, the policies are arranged by the created date in descending order.
   *
   * >  **Note**: it is possible to use both `beforePolicyId` and `afterPolicyId` at the same time but only the last one defined will be executed.
   *
   * <!--
   * >  Note: This function is restricted and only runs if you elevate permissions using the [wix-auth.elevate()](https://www.wix.com/velo/reference/wix-auth/elevate) function.
   * -->
   *
   * The `reorderEventPolicies()` function returns a Promise that resolves to the newly-reordered policy.
   * @param policyId - Event policy ID.
   * @param eventId - Event ID.
   * @public
   * @requiredField eventId
   * @requiredField policyId
   * @param options - Options for Reorder Event Policies function.
   * @permissionId WIX_EVENTS.MANAGE_POLICIES
   * @adminMethod
   */
  function reorderEventPolicies(policyId: string, eventId: string, options?: ReorderEventPoliciesOptions): Promise<ReorderEventPoliciesResponse>;
  interface ReorderEventPoliciesOptions extends ReorderEventPoliciesRequestReferencePolicyOneOf {
      /** Move the given `policyId` before the specified policy. */
      beforePolicyId?: string;
      /** Move the given `policyId` after the specified policy. */
      afterPolicyId?: string;
  }
  /**
   * Retrieves a policy by ID.
   *
   *
   * The `getPolicy()` function returns a Promise that resolves to a policy whose ID matches the given ID.
   * @public
   * @requiredField policyId
   * @param policyId - Policy ID.
   * @permissionId WIX_EVENTS.READ_POLICIES
   * @returns The requested policy.
   */
  function getPolicy(policyId: string): Promise<Policy>;
  
  type eventsV2Policy_universal_d_Policy = Policy;
  type eventsV2Policy_universal_d_CreatePolicyRequest = CreatePolicyRequest;
  type eventsV2Policy_universal_d_CreatePolicyResponse = CreatePolicyResponse;
  type eventsV2Policy_universal_d_UpdatePolicyRequest = UpdatePolicyRequest;
  type eventsV2Policy_universal_d_UpdatePolicyResponse = UpdatePolicyResponse;
  type eventsV2Policy_universal_d_UpdatePolicySortIndexRequest = UpdatePolicySortIndexRequest;
  type eventsV2Policy_universal_d_UpdatePolicySortIndexResponse = UpdatePolicySortIndexResponse;
  type eventsV2Policy_universal_d_DeletePolicyRequest = DeletePolicyRequest;
  type eventsV2Policy_universal_d_DeletePolicyResponse = DeletePolicyResponse;
  type eventsV2Policy_universal_d_QueryPoliciesRequest = QueryPoliciesRequest;
  type eventsV2Policy_universal_d_QueryPoliciesResponse = QueryPoliciesResponse;
  type eventsV2Policy_universal_d_ReorderEventPoliciesRequest = ReorderEventPoliciesRequest;
  type eventsV2Policy_universal_d_ReorderEventPoliciesRequestReferencePolicyOneOf = ReorderEventPoliciesRequestReferencePolicyOneOf;
  type eventsV2Policy_universal_d_ReorderEventPoliciesResponse = ReorderEventPoliciesResponse;
  type eventsV2Policy_universal_d_GetPolicyRequest = GetPolicyRequest;
  type eventsV2Policy_universal_d_GetPolicyResponse = GetPolicyResponse;
  type eventsV2Policy_universal_d_GetPolicyFromTrashBinRequest = GetPolicyFromTrashBinRequest;
  type eventsV2Policy_universal_d_GetPolicyFromTrashBinResponse = GetPolicyFromTrashBinResponse;
  const eventsV2Policy_universal_d_createPolicy: typeof createPolicy;
  const eventsV2Policy_universal_d_updatePolicy: typeof updatePolicy;
  type eventsV2Policy_universal_d_UpdatePolicy = UpdatePolicy;
  type eventsV2Policy_universal_d_UpdatePolicyOptions = UpdatePolicyOptions;
  const eventsV2Policy_universal_d_deletePolicy: typeof deletePolicy;
  const eventsV2Policy_universal_d_queryPolicies: typeof queryPolicies;
  type eventsV2Policy_universal_d_PoliciesQueryResult = PoliciesQueryResult;
  type eventsV2Policy_universal_d_PoliciesQueryBuilder = PoliciesQueryBuilder;
  const eventsV2Policy_universal_d_reorderEventPolicies: typeof reorderEventPolicies;
  type eventsV2Policy_universal_d_ReorderEventPoliciesOptions = ReorderEventPoliciesOptions;
  const eventsV2Policy_universal_d_getPolicy: typeof getPolicy;
  namespace eventsV2Policy_universal_d {
    export {
      eventsV2Policy_universal_d_Policy as Policy,
      eventsV2Policy_universal_d_CreatePolicyRequest as CreatePolicyRequest,
      eventsV2Policy_universal_d_CreatePolicyResponse as CreatePolicyResponse,
      eventsV2Policy_universal_d_UpdatePolicyRequest as UpdatePolicyRequest,
      eventsV2Policy_universal_d_UpdatePolicyResponse as UpdatePolicyResponse,
      eventsV2Policy_universal_d_UpdatePolicySortIndexRequest as UpdatePolicySortIndexRequest,
      eventsV2Policy_universal_d_UpdatePolicySortIndexResponse as UpdatePolicySortIndexResponse,
      eventsV2Policy_universal_d_DeletePolicyRequest as DeletePolicyRequest,
      eventsV2Policy_universal_d_DeletePolicyResponse as DeletePolicyResponse,
      eventsV2Policy_universal_d_QueryPoliciesRequest as QueryPoliciesRequest,
      QueryV2$2 as QueryV2,
      QueryV2PagingMethodOneOf$2 as QueryV2PagingMethodOneOf,
      Sorting$3 as Sorting,
      SortOrder$3 as SortOrder,
      Paging$3 as Paging,
      CursorPaging$3 as CursorPaging,
      eventsV2Policy_universal_d_QueryPoliciesResponse as QueryPoliciesResponse,
      PagingMetadataV2$3 as PagingMetadataV2,
      Cursors$3 as Cursors,
      eventsV2Policy_universal_d_ReorderEventPoliciesRequest as ReorderEventPoliciesRequest,
      eventsV2Policy_universal_d_ReorderEventPoliciesRequestReferencePolicyOneOf as ReorderEventPoliciesRequestReferencePolicyOneOf,
      eventsV2Policy_universal_d_ReorderEventPoliciesResponse as ReorderEventPoliciesResponse,
      eventsV2Policy_universal_d_GetPolicyRequest as GetPolicyRequest,
      eventsV2Policy_universal_d_GetPolicyResponse as GetPolicyResponse,
      EventCopied$1 as EventCopied,
      Location$3 as Location,
      MapCoordinates$3 as MapCoordinates,
      LocationType$3 as LocationType,
      Address$3 as Address,
      AddressStreetOneOf$3 as AddressStreetOneOf,
      StreetAddress$3 as StreetAddress,
      AddressLocation$3 as AddressLocation,
      Subdivision$3 as Subdivision,
      SubdivisionType$3 as SubdivisionType,
      ScheduleConfig$3 as ScheduleConfig,
      Recurrences$3 as Recurrences,
      Occurrence$3 as Occurrence,
      Status$3 as Status,
      EventStatus$3 as EventStatus,
      Empty$3 as Empty,
      eventsV2Policy_universal_d_GetPolicyFromTrashBinRequest as GetPolicyFromTrashBinRequest,
      eventsV2Policy_universal_d_GetPolicyFromTrashBinResponse as GetPolicyFromTrashBinResponse,
      DomainEvent$3 as DomainEvent,
      DomainEventBodyOneOf$3 as DomainEventBodyOneOf,
      EntityCreatedEvent$3 as EntityCreatedEvent,
      RestoreInfo$3 as RestoreInfo,
      EntityUpdatedEvent$3 as EntityUpdatedEvent,
      EntityDeletedEvent$3 as EntityDeletedEvent,
      ActionEvent$3 as ActionEvent,
      MessageEnvelope$3 as MessageEnvelope,
      IdentificationData$3 as IdentificationData,
      IdentificationDataIdOneOf$3 as IdentificationDataIdOneOf,
      WebhookIdentityType$3 as WebhookIdentityType,
      eventsV2Policy_universal_d_createPolicy as createPolicy,
      eventsV2Policy_universal_d_updatePolicy as updatePolicy,
      eventsV2Policy_universal_d_UpdatePolicy as UpdatePolicy,
      eventsV2Policy_universal_d_UpdatePolicyOptions as UpdatePolicyOptions,
      eventsV2Policy_universal_d_deletePolicy as deletePolicy,
      eventsV2Policy_universal_d_queryPolicies as queryPolicies,
      eventsV2Policy_universal_d_PoliciesQueryResult as PoliciesQueryResult,
      eventsV2Policy_universal_d_PoliciesQueryBuilder as PoliciesQueryBuilder,
      eventsV2Policy_universal_d_reorderEventPolicies as reorderEventPolicies,
      eventsV2Policy_universal_d_ReorderEventPoliciesOptions as ReorderEventPoliciesOptions,
      eventsV2Policy_universal_d_getPolicy as getPolicy,
    };
  }
  
  interface V2Rsvp {
      /**
       * RSVP ID.
       * @readonly
       */
      _id?: string | null;
      /**
       * Revision number, which increments by 1 each time the RSVP is updated. To prevent conflicting changes, the existing revision must be used when updating the RSVP.
       * @readonly
       */
      revision?: string | null;
      /** Event ID to which the RSVP belongs. */
      eventId?: string | null;
      /**
       * Date and time when the RSVP was created.
       * @readonly
       */
      _createdDate?: Date | null;
      /**
       * Date and time when the RSVP was update.
       * @readonly
       */
      _updatedDate?: Date | null;
      /** Site member ID. You can override the field value when updating RSVP. Overriding member ID requires the **WIX_EVENTS.MANAGE_RSVP** permission. */
      memberId?: string | null;
      /** Contact ID of a guest who filled in the RSVP form. See [Contacts API](https://dev.wix.com/api/rest/contacts/contacts/contacts-v4) for more details. */
      contactId?: string | null;
      /** First name of a guest who filled in the RSVP form. */
      firstName?: string | null;
      /** Last name of a guest who filled in the RSVP form. */
      lastName?: string | null;
      /** Email of a guest who filled in the RSVP form. */
      email?: string | null;
      /** Event registration form. */
      form?: FormResponse;
      /** RSVP response status. */
      status?: RsvpStatus;
      /**
       * Total number of guests per 1 RSVP.
       * @readonly
       */
      totalGuests?: number | null;
      /**
       * Guest list.
       * @readonly
       */
      guestList?: GuestList;
      /**
       * Site language code in the [ISO 639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format.
       * @readonly
       */
      language?: string | null;
      /**
       * Locale in the [IETF BCP 47](https://en.wikipedia.org/wiki/IETF_language_tag) format.
       * @readonly
       */
      locale?: string | null;
      /**
       * Whether all guests are checked in.
       * @readonly
       */
      fullyCheckedIn?: boolean | null;
      /**
       * How many guests are checked in.
       * @readonly
       */
      checkedInGuestCount?: number | null;
      /** Additional guest details. */
      additionalGuestDetails?: AdditionalGuestDetails;
      /** Whether the notifications are disabled. */
      disableNotifications?: boolean | null;
      /**
       * Guest login details for accessing the online conference event.
       * @readonly
       */
      onlineConferencingLogin?: OnlineConferencingLogin;
      /**
       * Whether the RSVP is anonymized.
       * @readonly
       */
      anonymized?: boolean | null;
      /**
       * Email domain of a guest who filled in the RSVP form.
       * @internal
       * @readonly
       */
      emailDomain?: string | null;
      /**
       * Custom field data for the RSVP object.
       *
       * **Note:** You must configure extended fields using schema plugin extensions in your app's dashboard before you can access the extended fields with API calls.
       */
      extendedFields?: ExtendedFields$1;
  }
  interface FormResponse {
      inputValues?: InputValue[];
  }
  interface InputValue {
      inputName?: string;
      value?: string;
      values?: string[];
      /**
       * Int or floating point number value.
       * @internal
       */
      number?: number | null;
      /**
       * Date/time value.
       * @internal
       */
      dateTime?: Date | null;
      /**
       * Address type value.
       * @internal
       */
      address?: FormattedAddress;
  }
  interface FormattedAddress {
      /** One line address representation. */
      formatted?: string;
      /** Address components (optional). */
      address?: CommonAddress$2;
  }
  /** Physical address */
  interface CommonAddress$2 extends CommonAddressStreetOneOf$2 {
      /** Street name and number. */
      streetAddress?: CommonStreetAddress$2;
      /** Main address line, usually street and number as free text. */
      addressLine1?: string | null;
      /** Country code. */
      country?: string | null;
      /** Subdivision shorthand. Usually, a short code (2 or 3 letters) that represents a state, region, prefecture, or province. e.g. NY */
      subdivision?: string | null;
      /** City name. */
      city?: string | null;
      /** Zip/postal code. */
      postalCode?: string | null;
      /** Free text providing more detailed address info. Usually contains Apt, Suite, and Floor. */
      addressLine2?: string | null;
      /**
       * A string containing the full address of this location.
       * @internal
       */
      formatted?: string | null;
      /**
       * Coordinates of the physical address.
       * @internal
       */
      location?: CommonAddressLocation$2;
      /**
       * Country full name.
       * @internal
       */
      countryFullname?: string | null;
      /**
       * Subdivision full name.
       * @internal
       */
      subdivisionFullname?: string | null;
      /**
       * Multi-level subdivisions from top to bottom.
       * @internal
       */
      subdivisions?: CommonSubdivision$2[];
  }
  /** @oneof */
  interface CommonAddressStreetOneOf$2 {
      /** Street name and number. */
      streetAddress?: CommonStreetAddress$2;
      /** Main address line, usually street and number as free text. */
      addressLine?: string | null;
  }
  interface CommonStreetAddress$2 {
      /** Street number. */
      number?: string;
      /** Street name. */
      name?: string;
      /**
       * Apartment number.
       * @internal
       */
      apt?: string;
      /**
       * Optional address line 1
       * @internal
       */
      formattedAddressLine?: string | null;
  }
  interface CommonAddressLocation$2 {
      /** Address latitude. */
      latitude?: number | null;
      /** Address longitude. */
      longitude?: number | null;
  }
  interface CommonSubdivision$2 {
      /** Short subdivision code. */
      code?: string;
      /** Subdivision full name. */
      name?: string;
      /**
       * Subdivision level
       * @internal
       */
      type?: SubdivisionType$2;
      /**
       * Free text description of subdivision type.
       * @internal
       */
      typeInfo?: string | null;
      /**
       * Standard organizations details (e.g. ISO).
       * @internal
       */
      standardDetails?: StandardDetails;
  }
  enum SubdivisionType$2 {
      UNKNOWN_SUBDIVISION_TYPE = "UNKNOWN_SUBDIVISION_TYPE",
      /** State */
      ADMINISTRATIVE_AREA_LEVEL_1 = "ADMINISTRATIVE_AREA_LEVEL_1",
      /** County */
      ADMINISTRATIVE_AREA_LEVEL_2 = "ADMINISTRATIVE_AREA_LEVEL_2",
      /** City/town */
      ADMINISTRATIVE_AREA_LEVEL_3 = "ADMINISTRATIVE_AREA_LEVEL_3",
      /** Neighborhood/quarter */
      ADMINISTRATIVE_AREA_LEVEL_4 = "ADMINISTRATIVE_AREA_LEVEL_4",
      /** Street/block */
      ADMINISTRATIVE_AREA_LEVEL_5 = "ADMINISTRATIVE_AREA_LEVEL_5",
      /** ADMINISTRATIVE_AREA_LEVEL_0. Indicates the national political entity, and is typically the highest order type returned by the Geocoder. */
      COUNTRY = "COUNTRY"
  }
  /** Subdivision Concordance values */
  interface StandardDetails {
      /** subdivision iso-3166-2 code according to [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). e.g. US-NY, GB-SCT, NO-30 */
      iso31662?: string | null;
  }
  enum RsvpStatus {
      /** Unknown status. This value is not used. */
      UNKNOWN_RSVP_STATUS = "UNKNOWN_RSVP_STATUS",
      /** Guest is attending the event. */
      YES = "YES",
      /** Guest is not attending the event. */
      NO = "NO",
      /** Guest is in a waitlist. */
      WAITLIST = "WAITLIST"
  }
  interface GuestList {
      /** List of guests. */
      guests?: Guest[];
  }
  interface Guest {
      /** Index in the guest list. */
      index?: number | null;
      /** Full name. */
      fullName?: string | null;
      /** Check-in details. */
      checkInDetails?: CheckInDetails;
      /** Guest ID. */
      guestId?: number | null;
  }
  interface CheckInDetails {
      /** Whether the guest has checked in. */
      checkedIn?: boolean | null;
      /** Check-in date. */
      checkInDate?: Date | null;
  }
  interface AdditionalGuestDetails {
      /** Number of additional guests. */
      guestCount?: number | null;
      /** Names of additional guests. */
      guestNames?: string[] | null;
  }
  interface OnlineConferencingLogin {
      /**
       * Link URL to the online conference.
       * @readonly
       */
      link?: string;
      /**
       * Password for the online conference.
       * @readonly
       */
      password?: string | null;
  }
  interface ExtendedFields$1 {
      /**
       * Extended field data. Each key corresponds to the namespace of the app that created the extended fields.
       * The value of each key is structured according to the schema defined when the extended fields were configured.
       *
       * You can only access fields for which you have the appropriate permissions.
       *
       * Learn more about [extended fields](https://dev.wix.com/docs/rest/articles/getting-started/extended-fields).
       */
      namespaces?: Record<string, Record<string, any>>;
  }
  interface SearchRsvpsRequest {
      /** Search options. See [API Query Language](https://dev.wix.com/api/rest/getting-started/api-query-language) for more details. */
      search?: CursorSearch;
      /** Predefined sets of fields to return. */
      fields?: RequestedFields$1[];
  }
  interface CursorSearch extends CursorSearchPagingMethodOneOf {
      /**
       * Cursor paging options.
       *
       * Learn more about [cursor paging](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#cursor-paging).
       */
      cursorPaging?: CursorPaging$2;
      /**
       * Filter object.
       *
       * Learn more about [filtering](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#filters).
       */
      filter?: Record<string, any> | null;
      /**
       * Sort object.
       *
       * Learn more about [sorting](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#sorting).
       */
      sort?: Sorting$2[];
      /**
       * Logical groupings of data into facets, with summaries for each facet.
       * For example, use aggregations to allow site visitors to narrow down their search results by selecting specific categories.
       */
      aggregations?: Aggregation[];
      /** Free text to match in searchable fields. */
      search?: SearchDetails;
      /**
       * Time zone to adjust date-time-based filters and aggregations, in ISO 8601 (including offsets) or IANA time zone database (including time zone IDs) format.
       * Applies to all relevant filters and aggregations, unless overridden by providing timestamps including time zone. For example, "2023-12-20T10:52:34.795Z".
       */
      timeZone?: string | null;
  }
  /** @oneof */
  interface CursorSearchPagingMethodOneOf {
      /**
       * Cursor paging options.
       *
       * Learn more about [cursor paging](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#cursor-paging).
       */
      cursorPaging?: CursorPaging$2;
  }
  interface Sorting$2 {
      /** Name of the field to sort by. */
      fieldName?: string;
      /** Sort order. */
      order?: SortOrder$2;
      /**
       * When `field_name` is a property of repeated field that is marked as `MATCH_ITEMS` and sort should be done by
       * a specific element from a collection, filter can/should be provided to ensure correct sort value is picked.
       *
       * If multiple filters are provided, they are combined with AND operator.
       *
       * Example:
       * Given we have document like {"id": "1", "nestedField": [{"price": 10, "region": "EU"}, {"price": 20, "region": "US"}]}
       * and `nestedField` is marked as `MATCH_ITEMS`, to ensure that sorting is done by correct region, filter should be
       * { fieldName: "nestedField.price", "select_items_by": [{"nestedField.region": "US"}] }
       * @internal
       */
      selectItemsBy?: Record<string, any>[] | null;
  }
  enum SortOrder$2 {
      ASC = "ASC",
      DESC = "DESC"
  }
  interface Aggregation extends AggregationKindOneOf {
      /** A value aggregation calculates metrics such as count for specific fields within a dataset, providing insights into the overall distribution and key statistics of those values. For example, use a value aggregation to get the number (count) of products for each price listed in the store. */
      value?: ValueAggregation;
      /** A range aggregation calculates the count of the values from the specified field in the dataset that fall within the range of each bucket you define. For example, use a range aggregation to compare the number of reservations made for parties of 4 or less to the number of reservations made for parties with 5 or more. */
      range?: RangeAggregation;
      /** A scalar aggregation calculates a single numerical value from a dataset, summarizing the dataset into one key metric: `COUNT_DISTINCT`, `SUM`, `AVG`, `MIN`, or `MAX`. */
      scalar?: ScalarAggregation;
      /** A date histogram calculates the count of time values from the specified field in the dataset that fall within each time interval you define (hour, day, week, etc.) For example, use a date histogram to find how many reservations have been made at a restaurant each week. */
      dateHistogram?: DateHistogramAggregation;
      /** A nested aggregation is applied within the results of another aggregation. Rather than aggregating directly on the primary dataset, first group data using one aggregation and then apply another aggregation within each group. It allows for more complex analyses where you can summarize data at different levels of detail or hierarchy. For example, to get the number of products that are in stock and out of stock for each price listed, first perform a value aggregation on `discountedPriceNumeric`, and a second value aggregation on `inStock`. */
      nested?: NestedAggregation;
      /** Aggregation name displayed in the return. */
      name?: string | null;
      /** Type of aggregation to perform. */
      type?: AggregationType;
      /**
       * Field to aggregate by.
       * Use dot notation to specify a JSON path. For example, `order.address.streetName`.
       */
      fieldPath?: string;
  }
  /** @oneof */
  interface AggregationKindOneOf {
      /** A value aggregation calculates metrics such as count for specific fields within a dataset, providing insights into the overall distribution and key statistics of those values. For example, use a value aggregation to get the number (count) of products for each price listed in the store. */
      value?: ValueAggregation;
      /** A range aggregation calculates the count of the values from the specified field in the dataset that fall within the range of each bucket you define. For example, use a range aggregation to compare the number of reservations made for parties of 4 or less to the number of reservations made for parties with 5 or more. */
      range?: RangeAggregation;
      /** A scalar aggregation calculates a single numerical value from a dataset, summarizing the dataset into one key metric: `COUNT_DISTINCT`, `SUM`, `AVG`, `MIN`, or `MAX`. */
      scalar?: ScalarAggregation;
      /** A date histogram calculates the count of time values from the specified field in the dataset that fall within each time interval you define (hour, day, week, etc.) For example, use a date histogram to find how many reservations have been made at a restaurant each week. */
      dateHistogram?: DateHistogramAggregation;
      /** A nested aggregation is applied within the results of another aggregation. Rather than aggregating directly on the primary dataset, first group data using one aggregation and then apply another aggregation within each group. It allows for more complex analyses where you can summarize data at different levels of detail or hierarchy. For example, to get the number of products that are in stock and out of stock for each price listed, first perform a value aggregation on `discountedPriceNumeric`, and a second value aggregation on `inStock`. */
      nested?: NestedAggregation;
  }
  interface RangeBucket {
      /** Inclusive lower bound of the range. Required if `to` is not given. */
      from?: number | null;
      /** Exclusive upper bound of the range. Required if `from` is not given. */
      to?: number | null;
  }
  enum SortType {
      /** Number of matches in the results. */
      COUNT = "COUNT",
      /** Alphabetically by the field value. */
      VALUE = "VALUE"
  }
  enum SortDirection {
      /** Descending order. */
      DESC = "DESC",
      /** Ascending order. */
      ASC = "ASC"
  }
  enum MissingValues {
      /** Exclude missing values from the aggregation results. */
      EXCLUDE = "EXCLUDE",
      /** Include missing values in the aggregation results. */
      INCLUDE = "INCLUDE"
  }
  interface IncludeMissingValuesOptions {
      /**
       * Specify a custom name for the bucket containing the missing values.
       * Defaults: `"N/A"` for strings, `0` for integers, and `false` for booleans.
       */
      addToBucket?: string;
  }
  enum ScalarType {
      /** Unknown scalar type. This value is not used. */
      UNKNOWN_SCALAR_TYPE = "UNKNOWN_SCALAR_TYPE",
      /** Total number of distinct values. */
      COUNT_DISTINCT = "COUNT_DISTINCT",
      /** Minimum value. */
      MIN = "MIN",
      /** Maximum value. */
      MAX = "MAX",
      /** Sum of values. */
      SUM = "SUM",
      /** Average of values. */
      AVG = "AVG"
  }
  interface ValueAggregation extends ValueAggregationOptionsOneOf {
      /**
       * Whether to include or exclude missing values in the aggregation results.
       * Default: `EXCLUDE`.
       */
      includeOptions?: IncludeMissingValuesOptions;
      /** Sort type. */
      sortType?: SortType;
      /** Sort direction. */
      sortDirection?: SortDirection;
      /**
       * Number of aggregation results to return.
       * Min: `1`
       * Max: `250`
       * Default: `10`
       */
      limit?: number | null;
      /** Whether to include or exclude missing values from the aggregation results. Default: `EXCLUDE`. */
      missingValues?: MissingValues;
  }
  /** @oneof */
  interface ValueAggregationOptionsOneOf {
      /**
       * Whether to include or exclude missing values in the aggregation results.
       * Default: `EXCLUDE`.
       */
      includeOptions?: IncludeMissingValuesOptions;
  }
  enum NestedAggregationType {
      /** Unknown aggregation type. This value is not used. */
      UNKNOWN_AGGREGATION_TYPE = "UNKNOWN_AGGREGATION_TYPE",
      /** Calculates the distribution of a specific field's values within a dataset, providing insights into the overall distribution and key statistics of those values. */
      VALUE = "VALUE",
      /** Calculates the count of the values from the specified field in the dataset that fall within the range of each bucket you define. */
      RANGE = "RANGE",
      /** Calculates a single numerical value from a dataset, summarizing the dataset into one key metric: `COUNT_DISTINCT`, `SUM`, `AVG`, `MIN`, or `MAX`. */
      SCALAR = "SCALAR",
      /** Calculates the count of time values from the specified field in the dataset that fall within each time interval you define (hour, day, week, etc.). */
      DATE_HISTOGRAM = "DATE_HISTOGRAM"
  }
  interface RangeAggregation {
      /** List of range buckets. During aggregation each entity is placed in the first bucket its value falls into, based on the provided range bounds. */
      buckets?: RangeBucket[];
  }
  interface ScalarAggregation {
      /** Operator type for the scalar aggregation. */
      type?: ScalarType;
  }
  interface DateHistogramAggregation {
      /** Interval for date histogram aggregation */
      interval?: Interval;
  }
  enum Interval {
      /** Unknown interval. This value is not used. */
      UNKNOWN_INTERVAL = "UNKNOWN_INTERVAL",
      YEAR = "YEAR",
      MONTH = "MONTH",
      WEEK = "WEEK",
      DAY = "DAY",
      HOUR = "HOUR",
      MINUTE = "MINUTE",
      SECOND = "SECOND"
  }
  interface NestedAggregationItem extends NestedAggregationItemKindOneOf {
      /** A value aggregation calculates the distribution of a specific field's values within a dataset, providing insights into the overall distribution and key statistics of those values. For example, use a value aggregation to get the number (count) of orders for each order status. */
      value?: ValueAggregation;
      /** A range aggregation calculates the count of the values from the specified field in the dataset that fall within the range of each bucket you define. For example, use a range aggregation to compare the number of reservations made for parties of 4 or less to the number of reservations made for parties with 5 or more. If ranges overlap, a record that fits more than one range will only be counted in the first range that matches the criteria. */
      range?: RangeAggregation;
      /** A scalar aggregation calculates a single numerical value from a dataset, summarizing the dataset into one key metric: `COUNT_DISTINCT`, `SUM`, `AVG`, `MIN`, or `MAX`. */
      scalar?: ScalarAggregation;
      /** A date histogram calculates the count of time values from the specified field in the dataset that fall within each time interval you define (hour, day, week, etc.). For example, use a date histogram to determine how many reservations have been made at a restaurant each week. If ranges overlap, a record that fits more than one range will only be counted in the first range that matches the criteria. */
      dateHistogram?: DateHistogramAggregation;
      /** Unique, caller-defined aggregation name, returned in `aggregations.results`. */
      name?: string | null;
      /** Type of aggregation to perform. The matching aggregation field must be passed. */
      type?: NestedAggregationType;
      /**
       * Field to aggregate by.
       * Use dot notation to specify a JSON path. For example, `order.address.streetName`.
       */
      fieldPath?: string;
  }
  /** @oneof */
  interface NestedAggregationItemKindOneOf {
      /** A value aggregation calculates the distribution of a specific field's values within a dataset, providing insights into the overall distribution and key statistics of those values. For example, use a value aggregation to get the number (count) of orders for each order status. */
      value?: ValueAggregation;
      /** A range aggregation calculates the count of the values from the specified field in the dataset that fall within the range of each bucket you define. For example, use a range aggregation to compare the number of reservations made for parties of 4 or less to the number of reservations made for parties with 5 or more. If ranges overlap, a record that fits more than one range will only be counted in the first range that matches the criteria. */
      range?: RangeAggregation;
      /** A scalar aggregation calculates a single numerical value from a dataset, summarizing the dataset into one key metric: `COUNT_DISTINCT`, `SUM`, `AVG`, `MIN`, or `MAX`. */
      scalar?: ScalarAggregation;
      /** A date histogram calculates the count of time values from the specified field in the dataset that fall within each time interval you define (hour, day, week, etc.). For example, use a date histogram to determine how many reservations have been made at a restaurant each week. If ranges overlap, a record that fits more than one range will only be counted in the first range that matches the criteria. */
      dateHistogram?: DateHistogramAggregation;
  }
  enum AggregationType {
      /** Unknown type. This value is not used. */
      UNKNOWN_AGGREGATION_TYPE = "UNKNOWN_AGGREGATION_TYPE",
      /** Calculates the distribution of a specific field's values within a dataset, providing insights into the overall distribution and key statistics of those values. */
      VALUE = "VALUE",
      /** Calculates the count of the values from the specified field in the dataset that fall within the range of each bucket you define. */
      RANGE = "RANGE",
      /** Calculates a single numerical value from a dataset, summarizing the dataset into one key metric: `COUNT_DISTINCT`, `SUM`, `AVG`, `MIN`, or `MAX`. */
      SCALAR = "SCALAR",
      /** Calculates the count of time values from the specified field in the dataset that fall within each time interval you define (hour, day, week, etc.). */
      DATE_HISTOGRAM = "DATE_HISTOGRAM",
      /** Flattened list of aggregations, where each aggregation is nested within previous one. */
      NESTED = "NESTED"
  }
  /** Flattened list of aggregations, where each aggregation is nested within previous one. */
  interface NestedAggregation {
      /** Flattened list of aggregations, where each aggregation is nested within previous one. */
      nestedAggregations?: NestedAggregationItem[];
  }
  interface SearchDetails {
      /** Search mode. Defines the search logic for combining multiple terms in the `expression`. */
      mode?: Mode;
      /** Search term or expression. */
      expression?: string | null;
      /**
       * Fields to search in. If the array is empty, all searchable fields are searched.
       * Use dot notation to specify a JSON path. For example, For example, `order.address.streetName`.
       */
      fields?: string[];
      /** Whether to enable the search function to use an algorithm to automatically find results that are close to the search expression, such as typos and declensions. */
      fuzzy?: boolean;
  }
  enum Mode {
      /** At least one of the search terms must be present. */
      OR = "OR",
      /** Searches by all provided words. */
      AND = "AND"
  }
  interface CursorPaging$2 {
      /** Maximum number of items to return in the results. */
      limit?: number | null;
      /**
       * Pointer to the next or previous page in the list of results.
       *
       * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
       * Not relevant for the first request.
       */
      cursor?: string | null;
  }
  enum RequestedFields$1 {
      /** Unknown requested field. This value is not used. */
      UNKNOWN_REQUESTED_FIELD = "UNKNOWN_REQUESTED_FIELD",
      /** Returns `createdDate`, `updatedDate`, `firstName`, `lastName`, `totalGuests`, `guests`. */
      DETAILS = "DETAILS",
      /** Returns `form`. */
      FORM = "FORM",
      /** Returns `email`. */
      CONTACT_DETAILS = "CONTACT_DETAILS"
  }
  interface SearchRsvpsResponse {
      /** List of RSVPs. */
      rsvps?: V2Rsvp[];
      /** Metadata for the paginated results. */
      pagingMetadata?: CursorPagingMetadata;
      /** Aggregation data. */
      aggregationData?: AggregationData;
  }
  interface CursorPagingMetadata {
      /** Number of items returned in the response. */
      count?: number | null;
      /** Cursor strings that point to the next page, previous page, or both. */
      cursors?: Cursors$2;
      /**
       * Whether there are more pages to retrieve following the current page.
       *
       * + `true`: Another page of results can be retrieved.
       * + `false`: This is the last page.
       */
      hasNext?: boolean | null;
  }
  interface Cursors$2 {
      /** Cursor string pointing to the next page in the list of results. */
      next?: string | null;
      /** Cursor pointing to the previous page in the list of results. */
      prev?: string | null;
  }
  interface AggregationData {
      /** List of the aggregated data results. */
      results?: AggregationResults[];
  }
  interface ValueAggregationResult {
      /** Value of the field. */
      value?: string;
      /** Total number of entities with this value. */
      count?: number;
  }
  interface RangeAggregationResult {
      /** Inclusive lower bound of the range. */
      from?: number | null;
      /** Exclusive upper bound of the range. */
      to?: number | null;
      /** Count of entities in this range. */
      count?: number;
  }
  interface NestedAggregationResults extends NestedAggregationResultsResultOneOf {
      /** Value aggregation results. */
      values?: ValueResults;
      /** Range aggregation results. */
      ranges?: RangeResults;
      /** Scalar aggregation results. */
      scalar?: AggregationResultsScalarResult;
      /** Unique, caller-defined aggregation name, identifiable by the requested aggregation `name`. */
      name?: string;
      /** Aggregation type. */
      type?: AggregationType;
      /** Field which the data was aggregated by. */
      fieldPath?: string;
  }
  /** @oneof */
  interface NestedAggregationResultsResultOneOf {
      /** Value aggregation results. */
      values?: ValueResults;
      /** Range aggregation results. */
      ranges?: RangeResults;
      /** Scalar aggregation results. */
      scalar?: AggregationResultsScalarResult;
  }
  interface ValueResults {
      /** List of ranges returned in the same order as requested. */
      results?: ValueAggregationResult[];
  }
  interface RangeResults {
      /** List of ranges returned in same order as requested. */
      results?: RangeAggregationResult[];
  }
  interface AggregationResultsScalarResult {
      /** Type of scalar aggregation. */
      type?: ScalarType;
      /** Value of the scalar aggregation. */
      value?: number;
  }
  interface NestedValueAggregationResult {
      /** Value of the field. */
      value?: string;
      /** Nested aggregations. */
      nestedResults?: NestedAggregationResults;
  }
  interface ValueResult {
      /** Value of the field. */
      value?: string;
      /** Total number of entities with this value. */
      count?: number | null;
  }
  interface RangeResult {
      /** Inclusive lower bound of the range. */
      from?: number | null;
      /** Exclusive upper bound of the range. */
      to?: number | null;
      /** Total number of entities in this range. */
      count?: number | null;
  }
  interface ScalarResult {
      /** Value of the scalar aggregation. */
      value?: number;
  }
  interface NestedResultValue extends NestedResultValueResultOneOf {
      /** Value aggregation result. */
      value?: ValueResult;
      /** Range aggregation result. */
      range?: RangeResult;
      /** Scalar aggregation result. */
      scalar?: ScalarResult;
      /** Date histogram aggregation result. */
      dateHistogram?: ValueResult;
  }
  /** @oneof */
  interface NestedResultValueResultOneOf {
      /** Value aggregation result. */
      value?: ValueResult;
      /** Range aggregation result. */
      range?: RangeResult;
      /** Scalar aggregation result. */
      scalar?: ScalarResult;
      /** Date histogram aggregation result. */
      dateHistogram?: ValueResult;
  }
  interface Results {
      /** List of nested aggregations. */
      results?: Record<string, NestedResultValue>;
  }
  interface DateHistogramResult {
      /** Date in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format. */
      value?: string;
      /** Total number of entities in the bucket. */
      count?: number;
  }
  interface GroupByValueResults {
      /** List of value aggregations. */
      results?: NestedValueAggregationResult[];
  }
  interface DateHistogramResults {
      /** List of date histogram aggregations. */
      results?: DateHistogramResult[];
  }
  /** Results of `NESTED` aggregation type in a flattened array, identifiable by the requested aggregation `name`. */
  interface NestedResults {
      /** List of nested aggregations. */
      results?: Results[];
  }
  interface AggregationResults extends AggregationResultsResultOneOf {
      /** Value aggregation results. */
      values?: ValueResults;
      /** Range aggregation results. */
      ranges?: RangeResults;
      /** Scalar aggregation results. */
      scalar?: AggregationResultsScalarResult;
      /** Group by value aggregation results. */
      groupedByValue?: GroupByValueResults;
      /** Date histogram aggregation results. */
      dateHistogram?: DateHistogramResults;
      /** Nested aggregation results. */
      nested?: NestedResults;
      /** Aggregation name displayed in the return. */
      name?: string;
      /** Type of aggregation that was performed. */
      type?: AggregationType;
      /** Field which the data was aggregated by. */
      fieldPath?: string;
  }
  /** @oneof */
  interface AggregationResultsResultOneOf {
      /** Value aggregation results. */
      values?: ValueResults;
      /** Range aggregation results. */
      ranges?: RangeResults;
      /** Scalar aggregation results. */
      scalar?: AggregationResultsScalarResult;
      /** Group by value aggregation results. */
      groupedByValue?: GroupByValueResults;
      /** Date histogram aggregation results. */
      dateHistogram?: DateHistogramResults;
      /** Nested aggregation results. */
      nested?: NestedResults;
  }
  interface SearchRsvpsWithOffsetRequest {
      /** Search options. See [API Query Language](https://dev.wix.com/api/rest/getting-started/api-query-language) for more details. */
      search?: Search;
      /** Predefined sets of fields to return. */
      fields?: RequestedFields$1[];
  }
  interface Search extends SearchPagingMethodOneOf {
      /** Paging options to limit and offset the number of items. */
      paging?: Paging$2;
      /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not filter or sort. */
      cursorPaging?: CursorPaging$2;
      /**
       * Filter object.
       *
       * Learn more about [filtering](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#filters).
       */
      filter?: Record<string, any> | null;
      /**
       * Sort object.
       *
       * Learn more about [sorting](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#sorting).
       */
      sort?: Sorting$2[];
      /** Array of projected fields. A list of specific field names to return. If `fieldsets` are also specified, the union of `fieldsets` and `fields` is returned. */
      fields?: string[];
      /** Array of named, predefined sets of projected fields. A array of predefined named sets of fields to be returned. Specifying multiple `fieldsets` will return the union of fields from all sets. If `fields` are also specified, the union of `fieldsets` and `fields` is returned. */
      fieldsets?: string[];
      /**
       * Logical groupings of data into facets, with summaries for each facet.
       * For example, use aggregations to allow site visitors to narrow down their search results by selecting specific categories.
       */
      aggregations?: Aggregation[];
      /** Free text to match in searchable fields. */
      search?: SearchDetails;
      /**
       * Time zone to adjust date-time-based filters and aggregations, in ISO 8601 (including offsets) or IANA time zone database (including time zone IDs) format.
       * Applies to all relevant filters and aggregations, unless overridden by providing timestamps including time zone. For example, "2023-12-20T10:52:34.795Z".
       */
      timeZone?: string | null;
  }
  /** @oneof */
  interface SearchPagingMethodOneOf {
      /** Paging options to limit and offset the number of items. */
      paging?: Paging$2;
      /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not filter or sort. */
      cursorPaging?: CursorPaging$2;
  }
  interface Paging$2 {
      /** Number of items to load. */
      limit?: number | null;
      /** Number of items to skip in the current sort order. */
      offset?: number | null;
  }
  interface SearchRsvpsWithOffsetResponse {
      /** List of RSVPs. */
      rsvps?: V2Rsvp[];
      /** Metadata for the paginated results. */
      pagingMetadata?: PagingMetadataV2$2;
      /** Aggregation data. */
      aggregationData?: AggregationData;
  }
  interface PagingMetadataV2$2 {
      /** Number of items returned in the response. */
      count?: number | null;
      /** Offset that was requested. */
      offset?: number | null;
      /** Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set. */
      total?: number | null;
      /** Flag that indicates the server failed to calculate the `total` field. */
      tooManyToCount?: boolean | null;
      /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
      cursors?: Cursors$2;
      /**
       * Indicates if there are more results after the current page.
       * If `true`, another page of results can be retrieved.
       * If `false`, this is the last page.
       * @internal
       */
      hasNext?: boolean | null;
  }
  interface QueryRsvpsRequest {
      /** Query options. See [API Query Language](https://dev.wix.com/api/rest/getting-started/api-query-language) for more details. */
      query?: CursorQuery;
      /** Predefined sets of fields to return. */
      fields?: RequestedFields$1[];
  }
  interface CursorQuery extends CursorQueryPagingMethodOneOf {
      /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
      cursorPaging?: CursorPaging$2;
      /**
       * Filter object in the following format:
       * `"filter" : {
       * "fieldName1": "value1",
       * "fieldName2":{"$operator":"value2"}
       * }`
       * Example of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`, `$contains`
       */
      filter?: Record<string, any> | null;
      /**
       * Sort object in the following format:
       * `[{"fieldName":"sortField1","order":"ASC"},{"fieldName":"sortField2","order":"DESC"}]`
       */
      sort?: Sorting$2[];
  }
  /** @oneof */
  interface CursorQueryPagingMethodOneOf {
      /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
      cursorPaging?: CursorPaging$2;
  }
  interface QueryRsvpsResponse {
      /** List of RSVPs. */
      rsvps?: V2Rsvp[];
      /** Metadata for the paginated results. */
      pagingMetadata?: CursorPagingMetadata;
  }
  interface CountRsvpsRequest {
      /**
       * Filter object in the following format:
       * `"filter" : {
       * "fieldName1": "value1",
       * "fieldName2":{"$operator":"value2"}
       * }`
       * Example of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`, `$contains`
       */
      filter?: Record<string, any> | null;
      /** Search details. */
      search?: SearchDetails;
  }
  interface CountRsvpsResponse {
      /** Number of RSVPs. */
      count?: number;
  }
  interface GetRsvpRequest {
      /** RSVP ID. */
      rsvpId: string;
      /** Predefined sets of fields to return. */
      fields?: RequestedFields$1[];
  }
  interface GetRsvpResponse {
      /** The requested RSVP. */
      rsvp?: V2Rsvp;
  }
  interface CreateRsvpRequest {
      /** RSVP info. */
      rsvp: V2Rsvp;
      /** RSVP options. <br> The **WIX_EVENTS.MANAGE_RSVP** permission is required. */
      options?: ModificationOptions;
      /** Predefined sets of fields to return. */
      fields?: RequestedFields$1[];
  }
  interface ModificationOptions {
      /** Whether to create or update RSVP regardless of event's guest limit. */
      ignoreLimits?: boolean;
      /** Whether to ignore the form validation. */
      ignoreFormValidation?: boolean;
      /** Whether to ignore response status. */
      ignoreResponseStatus?: boolean;
      /** Whether to ignore additional guest names validation. */
      ignoreAdditionalGuestNames?: boolean;
  }
  interface CreateRsvpResponse {
      /** Created RSVP. */
      rsvp?: V2Rsvp;
      /** "Add to calendar" links. */
      calendarLinks?: CalendarLinks$2;
  }
  interface CalendarLinks$2 {
      /** "Add to Google calendar" URL. */
      google?: string;
      /** "Download ICS calendar file" URL. */
      ics?: string;
  }
  interface GuestLimitExceededData {
      /** Max rsvp guest list size. */
      maxRsvpSize?: number;
  }
  interface UpdateRsvpRequest {
      /** RSVP to update. */
      rsvp: V2Rsvp;
      /**
       * List of exact fields to update. For example, if you define only the `firstName`, all other fields are ignored.
       * @internal
       */
      fieldMask: string[];
      /** RSVP options. <br> The **WIX_EVENTS.MANAGE_RSVP** permission is required to pass these fields. */
      options?: ModificationOptions;
      /** Predefined sets of fields to return. */
      fields?: RequestedFields$1[];
  }
  interface UpdateRsvpResponse {
      /** Updated RSVP. */
      rsvp?: V2Rsvp;
  }
  interface DeleteRsvpRequest {
      /** ID of RSVP to delete. */
      rsvpId: string | null;
  }
  interface DeleteRsvpResponse {
  }
  interface BulkUpdateRsvpRequest {
      /** RSVPs to update. */
      rsvps: MaskedRsvp[];
      /** Whether to return the whole `rsvp` object in the response. If `false`, only metadata is returned. */
      returnEntity?: boolean;
      /** Predefined sets of fields to return. */
      fields?: RequestedFields$1[];
      /** RSVP options. <br> The **WIX_EVENTS.MANAGE_RSVP** permission is required to pass these fields. */
      options?: ModificationOptions;
  }
  interface MaskedRsvp {
      /** RSVP to update. */
      rsvp?: V2Rsvp;
      /**
       * Explicit list of fields to update.
       * @internal
       */
      fieldMask?: string[];
  }
  interface BulkUpdateRsvpResponse {
      /** Response of bulk update. */
      results?: BulkRsvpResult[];
      /** Response metadata. */
      bulkActionMetadata?: BulkActionMetadata;
  }
  interface ItemMetadata {
      /** Item ID. Should always be available, unless it's impossible (for example, when failing to create an item). */
      _id?: string | null;
      /** Index of the item within the request array. Allows for correlation between request and response items. */
      originalIndex?: number;
      /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
      success?: boolean;
      /** Details about the error in case of failure. */
      error?: ApplicationError;
  }
  interface ApplicationError {
      /** Error code. */
      code?: string;
      /** Description of the error. */
      description?: string;
      /** Data related to the error. */
      data?: Record<string, any> | null;
  }
  interface BulkRsvpResult {
      /** Item metadata. */
      itemMetadata?: ItemMetadata;
      /** Updated RSVP. */
      rsvp?: V2Rsvp;
  }
  interface BulkActionMetadata {
      /** Number of items that were successfully processed. */
      totalSuccesses?: number;
      /** Number of items that couldn't be processed. */
      totalFailures?: number;
      /** Number of failures without details because detailed failure threshold was exceeded. */
      undetailedFailures?: number;
  }
  interface BulkDeleteRsvpsByFilterRequest {
      /** Filter object. */
      filter: Record<string, any> | null;
      /** Search details. */
      search?: SearchDetails;
  }
  interface BulkDeleteRsvpsByFilterResponse {
      /** Job ID. Pass this ID to [Get Async Job](https://dev.wix.com/docs/rest/business-management/async-job/introduction) to retrieve job details and metadata. */
      jobId?: string;
  }
  interface CheckInRsvpGuestsRequest {
      /** ID of RSVP to check-in. */
      rsvpId: string | null;
      /** IDs of guests to check-in. */
      guestIds?: number[];
      /** Predefined sets of fields to return. */
      fields?: RequestedFields$1[];
  }
  interface CheckInRsvpGuestsResponse {
      /** Updated RSVP. */
      rsvp?: V2Rsvp;
  }
  interface CancelRsvpGuestsCheckInRequest {
      /** ID of RSVP to cancel check-in. */
      rsvpId: string;
      /** IDs of guests to check-in. */
      guestIds?: number[];
      /** Predefined sets of fields to return. */
      fields?: RequestedFields$1[];
  }
  interface CancelRsvpGuestsCheckInResponse {
      /** Updated RSVP. */
      rsvp?: V2Rsvp;
  }
  interface ListRsvpSummaryRequest {
      /** Event ID. */
      eventId: string[] | null;
      /**
       * Consistent read.
       * @internal
       */
      consistentRead?: boolean | null;
  }
  interface ListRsvpSummaryResponse {
      /** List of RSVP summary. */
      summaries?: V2RsvpSummary[];
  }
  interface V2RsvpSummary {
      /**
       * Event ID.
       * @readonly
       */
      eventId?: string | null;
      /**
       * Number of RSVPs that answered `yes`.
       * @readonly
       */
      yesGuestCount?: number | null;
      /**
       * Number of RSVPs that answered `no`.
       * @readonly
       */
      noGuestCount?: number | null;
      /**
       * Number of RSVPs that are in the waitlist.
       * @readonly
       */
      waitlistGuestCount?: number | null;
      /**
       * Total number of RSVPs.
       * @readonly
       */
      totalRsvpCount?: number | null;
  }
  interface CompareRsvpSummaryRequest {
      /** Event ID. */
      eventId?: string | null;
      /** Whether to apply fixes. */
      applyFix?: boolean | null;
  }
  interface CompareRsvpSummaryResponse {
      /** Actual Rsvp summary. */
      actualSummary?: V2RsvpSummary;
      /** Persisted Rsvp summary. */
      persistedSummary?: V2RsvpSummary;
  }
  interface EventCreated$2 {
      /** Event created timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Event ID. */
      eventId?: string;
      /** Event location. */
      location?: Location$2;
      /** Event schedule configuration. */
      scheduleConfig?: ScheduleConfig$2;
      /** Event title. */
      title?: string;
      /** Event creator user ID. */
      userId?: string | null;
      /** Event status. */
      status?: EventStatus$2;
      /** Instance ID. Indicates the original app instance which current event was derived from. */
      derivedFromInstanceId?: string | null;
      /** Event ID. Indicates the original event which current event was derived from. */
      derivedFromEventId?: string | null;
      /** Event that was created. */
      event?: Event$2;
  }
  interface Location$2 {
      /** Location name. */
      name?: string | null;
      /** Location map coordinates. */
      coordinates?: MapCoordinates$2;
      /** Single line address representation. */
      address?: string | null;
      /** Location type. */
      type?: LocationType$2;
      /**
       * Full address derived from formatted single line `address`.
       * When `full_address` is used to create or update the event, deprecated `address` and `coordinates` are ignored.
       * If provided `full_address` has empty `formatted_address` or `coordinates`, it will be auto-completed using Atlas service.
       *
       * Migration notes:
       * - `full_address.formatted_address` is equivalent to `address`.
       * - `full_address.geocode` is equivalent to `coordinates`.
       */
      fullAddress?: Address$2;
      /**
       * Defines event location as TBD (To Be Determined).
       * When event location is not yet defined, `name` is displayed instead of location address.
       * `coordinates`, `address`, `type` and `full_address` are not required when location is TBD.
       */
      tbd?: boolean | null;
  }
  interface MapCoordinates$2 {
      /** Latitude. */
      lat?: number;
      /** Longitude. */
      lng?: number;
  }
  enum LocationType$2 {
      VENUE = "VENUE",
      ONLINE = "ONLINE"
  }
  /** Physical address */
  interface Address$2 extends AddressStreetOneOf$2 {
      /** a break down of the street to number and street name */
      streetAddress?: StreetAddress$2;
      /** Main address line (usually street and number) as free text */
      addressLine1?: string | null;
      /** country code */
      country?: string | null;
      /** subdivision (usually state or region) code according to ISO 3166-2 */
      subdivision?: string | null;
      /** city name */
      city?: string | null;
      /** zip/postal code */
      postalCode?: string | null;
      /** Free text providing more detailed address info. Usually contains Apt, Suite, Floor */
      addressLine2?: string | null;
      /** A string containing the human-readable address of this location */
      formatted?: string | null;
      /** coordinates of the physical address */
      location?: AddressLocation$2;
      /** country full-name */
      countryFullname?: string | null;
      /** multi-level subdivisions from top to bottom */
      subdivisions?: Subdivision$2[];
  }
  /** @oneof */
  interface AddressStreetOneOf$2 {
      /** a break down of the street to number and street name */
      streetAddress?: StreetAddress$2;
      /** Main address line (usually street and number) as free text */
      addressLine?: string | null;
  }
  interface StreetAddress$2 {
      /** street number */
      number?: string;
      /** street name */
      name?: string;
      /**
       * apartment number
       * @internal
       */
      apt?: string;
  }
  interface AddressLocation$2 {
      /** address latitude coordinates */
      latitude?: number | null;
      /** address longitude coordinates */
      longitude?: number | null;
  }
  interface Subdivision$2 {
      /** subdivision short code */
      code?: string;
      /** subdivision full-name */
      name?: string;
      /**
       * subdivision level
       * @internal
       */
      type?: SubdivisionType$2;
      /**
       * free text description of subdivision type
       * @internal
       */
      typeInfo?: string | null;
  }
  interface ScheduleConfig$2 {
      /**
       * Defines event as TBD (To Be Determined) schedule.
       * When event time is not yet defined, TBD message is displayed instead of event start and end times.
       * `startDate`, `endDate` and `timeZoneId` are not required when schedule is TBD.
       */
      scheduleTbd?: boolean;
      /** TBD message. */
      scheduleTbdMessage?: string | null;
      /** Event start timestamp. */
      startDate?: Date | null;
      /** Event end timestamp. */
      endDate?: Date | null;
      /** Event time zone ID in TZ database format, e.g., `EST`, `America/Los_Angeles`. */
      timeZoneId?: string | null;
      /** Whether end date is hidden in the formatted schedule. */
      endDateHidden?: boolean;
      /** Whether time zone is displayed in formatted schedule. */
      showTimeZone?: boolean;
      /** Event recurrences. */
      recurrences?: Recurrences$2;
  }
  interface Recurrences$2 {
      /** Event occurrences. */
      occurrences?: Occurrence$2[];
      /**
       * Recurring event category ID.
       * @readonly
       */
      categoryId?: string | null;
      /**
       * Recurrence status.
       * @readonly
       */
      status?: Status$2;
  }
  interface Occurrence$2 {
      /** Event start timestamp. */
      startDate?: Date | null;
      /** Event end timestamp. */
      endDate?: Date | null;
      /** Event time zone ID in TZ database format, e.g., `EST`, `America/Los_Angeles`. */
      timeZoneId?: string | null;
      /** Whether time zone is displayed in formatted schedule. */
      showTimeZone?: boolean;
  }
  enum Status$2 {
      /** Event occurs only once. */
      ONE_TIME = "ONE_TIME",
      /** Event is recurring. */
      RECURRING = "RECURRING",
      /** Marks the next upcoming occurrence of the recurring event. */
      RECURRING_NEXT = "RECURRING_NEXT",
      /** Marks the most recent ended occurrence of the recurring event. */
      RECURRING_LAST_ENDED = "RECURRING_LAST_ENDED",
      /** Marks the most recent canceled occurrence of the recurring event. */
      RECURRING_LAST_CANCELED = "RECURRING_LAST_CANCELED"
  }
  enum EventStatus$2 {
      /** Event is public and scheduled to start */
      SCHEDULED = "SCHEDULED",
      /** Event has started */
      STARTED = "STARTED",
      /** Event has ended */
      ENDED = "ENDED",
      /** Event was canceled */
      CANCELED = "CANCELED",
      /** Event is not public and needs to be published */
      DRAFT = "DRAFT"
  }
  interface Event$2 {
      /**
       * Event ID.
       * @readonly
       */
      _id?: string;
      /** Event location. */
      location?: Location$2;
      /** Event scheduling. */
      scheduling?: Scheduling$2;
      /** Event title. */
      title?: string;
      /** Event description. */
      description?: string;
      /** Rich-text content displayed in Wix UI - "About Event" section (HTML). */
      about?: string;
      /** Main event image. */
      mainImage?: string;
      /** Event slug URL (generated from event title). */
      slug?: string;
      /** ISO 639-1 language code of the event (used in content translations). */
      language?: string;
      /** Event creation timestamp. */
      created?: Date | null;
      /** Event modified timestamp. */
      modified?: Date | null;
      /** Event status. */
      status?: EventStatus$2;
      /** RSVP or ticketing registration details. */
      registration?: Registration$2;
      /** "Add to calendar" URLs. */
      calendarLinks?: CalendarLinks$2;
      /** Event page URL components. */
      eventPageUrl?: SiteUrl$2;
      /** Event registration form. */
      form?: Form$2;
      /** Event dashboard summary of RSVP / ticket sales. */
      dashboard?: Dashboard$2;
      /** Instance ID of the site where event is hosted. */
      instanceId?: string;
      /** Guest list configuration. */
      guestListConfig?: GuestListConfig$2;
      /** Event creator user ID. */
      userId?: string;
      /** Event discussion feed. For internal use. */
      feed?: Feed$2;
      /** Online conferencing details. */
      onlineConferencing?: OnlineConferencing$2;
      /** SEO settings. */
      seoSettings?: SeoSettings$2;
      /** Assigned contacts label key. */
      assignedContactsLabel?: string | null;
      /** Agenda details. */
      agenda?: Agenda$2;
      /** Categories this event is assigned to. */
      categories?: Category$2[];
      /** Visual settings for event. */
      eventDisplaySettings?: EventDisplaySettings$2;
      /**
       * @internal
       * @readonly
       */
      customizableTickets?: boolean | null;
      /**
       * Labelling related data.
       * @internal
       */
      labellingSettings?: LabellingSettings$2;
  }
  interface Scheduling$2 {
      /** Schedule configuration. */
      config?: ScheduleConfig$2;
      /** Formatted schedule representation. */
      formatted?: string;
      /** Formatted start date of the event (empty for TBD schedules). */
      startDateFormatted?: string;
      /** Formatted start time of the event (empty for TBD schedules). */
      startTimeFormatted?: string;
      /** Formatted end date of the event (empty for TBD schedules or when end date is hidden). */
      endDateFormatted?: string;
      /** Formatted end time of the event (empty for TBD schedules or when end date is hidden). */
      endTimeFormatted?: string;
  }
  interface Registration$2 {
      /** Event type. */
      type?: EventType$2;
      /** Event registration status. */
      status?: RegistrationStatus$2;
      /** RSVP collection details. */
      rsvpCollection?: RsvpCollection$2;
      /** Ticketing details. */
      ticketing?: Ticketing$2;
      /** External registration details. */
      external?: ExternalEvent$2;
      /** Types of users allowed to register. */
      restrictedTo?: VisitorType$2;
      /** Initial event type which was set when creating an event. */
      initialType?: EventType$2;
  }
  enum EventType$2 {
      /** Type not available for this request fieldset */
      NA_EVENT_TYPE = "NA_EVENT_TYPE",
      /** Registration via RSVP */
      RSVP = "RSVP",
      /** Registration via ticket purchase */
      TICKETS = "TICKETS",
      /** External registration */
      EXTERNAL = "EXTERNAL",
      /** Registration not available */
      NO_REGISTRATION = "NO_REGISTRATION"
  }
  enum RegistrationStatus$2 {
      /** Registration status is not applicable */
      NA_REGISTRATION_STATUS = "NA_REGISTRATION_STATUS",
      /** Registration to event is closed */
      CLOSED = "CLOSED",
      /** Registration to event is closed manually */
      CLOSED_MANUALLY = "CLOSED_MANUALLY",
      /** Registration is open via RSVP */
      OPEN_RSVP = "OPEN_RSVP",
      /** Registration to event waitlist is open via RSVP */
      OPEN_RSVP_WAITLIST = "OPEN_RSVP_WAITLIST",
      /** Registration is open via ticket purchase */
      OPEN_TICKETS = "OPEN_TICKETS",
      /** Registration is open via external URL */
      OPEN_EXTERNAL = "OPEN_EXTERNAL",
      /** Registration will be open via RSVP */
      SCHEDULED_RSVP = "SCHEDULED_RSVP"
  }
  interface RsvpCollection$2 {
      /** RSVP collection configuration. */
      config?: RsvpCollectionConfig$2;
  }
  interface RsvpCollectionConfig$2 {
      /** Defines the supported RSVP statuses. */
      rsvpStatusOptions?: RsvpStatusOptions$2;
      /**
       * Total guest limit available to register to the event.
       * Additional guests per RSVP are counted towards total guests.
       */
      limit?: number | null;
      /** Whether a waitlist is opened when total guest limit is reached, allowing guests to create RSVP with WAITING RSVP status. */
      waitlist?: boolean;
      /** Registration start timestamp. */
      startDate?: Date | null;
      /** Registration end timestamp. */
      endDate?: Date | null;
  }
  enum RsvpStatusOptions$2 {
      /** Only YES RSVP status is available for RSVP registration */
      YES_ONLY = "YES_ONLY",
      /** YES and NO RSVP status options are available for the registration */
      YES_AND_NO = "YES_AND_NO"
  }
  interface Ticketing$2 {
      /**
       * Deprecated.
       * @deprecated
       */
      lowestPrice?: string | null;
      /**
       * Deprecated.
       * @deprecated
       */
      highestPrice?: string | null;
      /** Currency used in event transactions. */
      currency?: string | null;
      /** Ticketing configuration. */
      config?: TicketingConfig$2;
      /**
       * Price of lowest priced ticket.
       * @readonly
       */
      lowestTicketPrice?: Money$2;
      /**
       * Price of highest priced ticket.
       * @readonly
       */
      highestTicketPrice?: Money$2;
      /**
       * Formatted price of lowest priced ticket.
       * @readonly
       */
      lowestTicketPriceFormatted?: string | null;
      /**
       * Formatted price of highest priced ticket.
       * @readonly
       */
      highestTicketPriceFormatted?: string | null;
      /**
       * Whether all tickets are sold for this event.
       * @readonly
       */
      soldOut?: boolean | null;
  }
  interface TicketingConfig$2 {
      /** Whether the form must be filled out separately for each ticket. */
      guestAssignedTickets?: boolean;
      /** Tax configuration. */
      taxConfig?: TaxConfig$2;
      /** Limit of tickets that can be purchased per order, default 20. */
      ticketLimitPerOrder?: number;
      /**
       * App Id for external ticket stock management.
       * By default tickets stock is defined in TicketDefinition object.
       * If defined then limitation from TicketDefinition is ignored.
       * @internal
       */
      stockManagerAppId?: string | null;
      /** Duration for which the tickets being bought are reserved. */
      reservationDurationInMinutes?: number | null;
  }
  interface TaxConfig$2 {
      /** Tax application settings. */
      type?: TaxType$2;
      /** Tax name. */
      name?: string | null;
      /** Tax rate (e.g.,`21.55`). */
      rate?: string | null;
      /** Applies taxes for donations, default true. */
      appliesToDonations?: boolean | null;
  }
  enum TaxType$2 {
      /** Tax is included in the ticket price. */
      INCLUDED = "INCLUDED",
      /** Tax is added to the order at the checkout. */
      ADDED = "ADDED",
      /** Tax is added to the final total at the checkout. */
      ADDED_AT_CHECKOUT = "ADDED_AT_CHECKOUT"
  }
  interface Money$2 {
      /**
       * *Deprecated:** Use `value` instead.
       * @deprecated
       */
      amount?: string;
      /** ISO 4217 format of the currency e.g., `USD`. */
      currency?: string;
      /** Monetary amount. Decimal string with a period as a decimal separator (e.g., 3.99). Optionally, starts with a single (-), to indicate that the amount is negative. */
      value?: string | null;
  }
  interface ExternalEvent$2 {
      /** External event registration URL. */
      registration?: string;
  }
  enum VisitorType$2 {
      /** Site visitor (including member) */
      VISITOR = "VISITOR",
      /** Site member */
      MEMBER = "MEMBER",
      /** Site visitor or member */
      VISITOR_OR_MEMBER = "VISITOR_OR_MEMBER"
  }
  /** Site URL components */
  interface SiteUrl$2 {
      /**
       * Base URL. For premium sites, this will be the domain.
       * For free sites, this would be site URL (e.g `mysite.wixsite.com/mysite`)
       */
      base?: string;
      /** The path to that page - e.g `/my-events/weekly-meetup-2` */
      path?: string;
  }
  /**
   * The form defines which elements are rendered in the Wix UI during the registration process (RSVP or checkout).
   * It also contains customizable messages and labels.
   *
   *
   * A form is an ordered list of controls (blocks), which accept guest information into a field input.
   *
   * Each control contains one or more nested inputs. For example, `Name` control has two inputs:
   * - First Name
   * - Last Name
   *
   * By default, name and email controls are always required and are pinned to the top of the form.
   */
  interface Form$2 {
      /** Nested fields as an ordered list. */
      controls?: InputControl$2[];
      /** Set of configured form messages. */
      messages?: FormMessages$2;
  }
  /**
   * A block of nested fields.
   * Used to aggregate similar inputs like First Name and Last Name.
   */
  interface InputControl$2 {
      /** Field control type. */
      type?: InputControlType$2;
      /** Whether control is mandatory (such as name & email). When true, only label can be changed. */
      system?: boolean;
      /**
       * Deprecated: Use `id`.
       * @deprecated
       */
      name?: string;
      /** Child inputs. */
      inputs?: Input$2[];
      /**
       * Deprecated: use `inputs.label`.
       * @deprecated
       */
      label?: string;
      /** Field controls are sorted by this value in ascending order. */
      orderIndex?: number;
      /** Unique control ID. */
      _id?: string;
      /**
       * Whether input control is deleted.
       * @readonly
       */
      deleted?: boolean | null;
  }
  enum InputControlType$2 {
      /** Single text value field. */
      INPUT = "INPUT",
      /** Single text value field. */
      TEXTAREA = "TEXTAREA",
      /** Single-choice field of predefined values. */
      DROPDOWN = "DROPDOWN",
      /** Single-choice field of predefined values. */
      RADIO = "RADIO",
      /** Multiple-choice field of predefined values. */
      CHECKBOX = "CHECKBOX",
      /** First and last name fields. */
      NAME = "NAME",
      /** Additional guests and respective guest names fields. */
      GUEST_CONTROL = "GUEST_CONTROL",
      /** Single-line address field. */
      ADDRESS_SHORT = "ADDRESS_SHORT",
      /** Full address field. */
      ADDRESS_FULL = "ADDRESS_FULL",
      /** Year, month and day fields. */
      DATE = "DATE"
  }
  /** An input of one or multiple text values */
  interface Input$2 {
      /** Field name. */
      name?: string;
      /**
       * Deprecated: use `ValueType.TEXT_ARRAY`.
       * @deprecated
       */
      array?: boolean;
      /** Main field label */
      label?: string;
      /** Additional labels for multi-valued fields such as address. */
      additionalLabels?: Record<string, string>;
      /** Predefined choice options for fields, such as dropdown. */
      options?: string[];
      /** Whether field is mandatory. */
      mandatory?: boolean;
      /** Maximum number of accepted characters (relevant for text fields). */
      maxLength?: number;
      /**
       * Type which determines field format.
       * Used to validate submitted response.
       */
      type?: ValueType$2;
      /**
       * A maximum accepted values for array input.
       * Only applicable for inputs of valueType: TEXT_ARRAY.
       */
      maxSize?: number | null;
      /**
       * Preselected option.
       * Currently only applicable for dropdown.
       */
      defaultOptionSelection?: OptionSelection$2;
      /**
       * Additional labels for multi-valued fields such as address.
       * @readonly
       */
      labels?: Label$2[];
  }
  enum ValueType$2 {
      TEXT = "TEXT",
      NUMBER = "NUMBER",
      TEXT_ARRAY = "TEXT_ARRAY",
      DATE_TIME = "DATE_TIME",
      ADDRESS = "ADDRESS"
  }
  /**
   * Describes initially selected option when an input has multiple choices.
   * Defaults to first (0th) option if not configured.
   */
  interface OptionSelection$2 extends OptionSelectionSelectedOptionOneOf$2 {
      /** 0-based index from predefined `input.options` which is selected initially. */
      optionIndex?: number;
      /**
       * Placeholder hint describing expected choices (such as "Please select").
       * Considered an empty choice.
       */
      placeholderText?: string;
  }
  /** @oneof */
  interface OptionSelectionSelectedOptionOneOf$2 {
      /** 0-based index from predefined `input.options` which is selected initially. */
      optionIndex?: number;
      /**
       * Placeholder hint describing expected choices (such as "Please select").
       * Considered an empty choice.
       */
      placeholderText?: string;
  }
  interface Label$2 {
      /** Field name. */
      name?: string;
      /** Field label. */
      label?: string;
  }
  /**
   * Defines form messages shown in UI before, during, and after registration flow.
   * It enables configuration of form titles, response labels, "thank you" messages, and call-to-action texts.
   */
  interface FormMessages$2 {
      /** RSVP form messages. */
      rsvp?: RsvpFormMessages$2;
      /** Checkout form messages. */
      checkout?: CheckoutFormMessages$2;
      /** Messages shown when event registration is closed. */
      registrationClosed?: RegistrationClosedMessages$2;
      /** Messages shown when event tickets are unavailable. */
      ticketsUnavailable?: TicketsUnavailableMessages$2;
  }
  interface RsvpFormMessages$2 {
      /** Label text indicating RSVP `YES` response. */
      rsvpYesOption?: string;
      /** Label text indicating RSVP `NO` response. */
      rsvpNoOption?: string;
      /** Messages shown for RSVP = `YES`. */
      positiveMessages?: Positive$2;
      /** Messages shown for RSVP = `WAITING` (when event is full and waitlist is available). */
      waitlistMessages?: Positive$2;
      /** Messages shown for RSVP = `NO`. */
      negativeMessages?: Negative$2;
      /** "Submit form" call-to-action label text. */
      submitActionLabel?: string;
  }
  /** Confirmation messages shown after registration. */
  interface PositiveResponseConfirmation$2 {
      /** Confirmation message title. */
      title?: string;
      /** Confirmation message text. */
      message?: string;
      /** "Add to calendar" call-to-action label text. */
      addToCalendarActionLabel?: string;
      /** "Share event" call-to-action label text. */
      shareActionLabel?: string;
  }
  /** Confirmation messages shown after registration. */
  interface NegativeResponseConfirmation$2 {
      /** Confirmation message title. */
      title?: string;
      /** "Share event" call-to-action label text. */
      shareActionLabel?: string;
  }
  /** Set of messages shown during registration when RSVP response is positive. */
  interface Positive$2 {
      /** Main form title for positive response. */
      title?: string;
      /** Confirmation messages shown after registration. */
      confirmation?: PositiveResponseConfirmation$2;
  }
  /** A set of messages shown during registration with negative response */
  interface Negative$2 {
      /** Main form title for negative response. */
      title?: string;
      /** Confirmation messages shown after registration. */
      confirmation?: NegativeResponseConfirmation$2;
  }
  interface CheckoutFormMessages$2 {
      /** Main form title for response. */
      title?: string;
      /** Submit form call-to-action label text. */
      submitActionLabel?: string;
      /** Confirmation messages shown after checkout. */
      confirmation?: ResponseConfirmation$2;
  }
  /** Confirmation messages shown after checkout. */
  interface ResponseConfirmation$2 {
      /** Confirmation message title. */
      title?: string;
      /** Confirmation message text. */
      message?: string;
      /** "Download tickets" call-to-action label text. */
      downloadTicketsLabel?: string;
      /** "Add to calendar" call-to-action label text. */
      addToCalendarLabel?: string;
      /** "Share event" call-to-action label text. */
      shareEventLabel?: string;
  }
  interface RegistrationClosedMessages$2 {
      /** Message shown when event registration is closed. */
      message?: string;
      /** "Explore other events" call-to-action label text. */
      exploreEventsActionLabel?: string;
  }
  interface TicketsUnavailableMessages$2 {
      /** Message shown when event tickets are unavailable. */
      message?: string;
      /** "Explore other events" call-to-action label text. */
      exploreEventsActionLabel?: string;
  }
  interface Dashboard$2 {
      /** Guest RSVP summary. */
      rsvpSummary?: RsvpSummary$2;
      /**
       * Summary of revenue and tickets sold.
       * (Archived orders are not included).
       */
      ticketingSummary?: TicketingSummary$2;
  }
  interface RsvpSummary$2 {
      /** Total number of RSVPs. */
      total?: number;
      /** Number of RSVPs with status `YES`. */
      yes?: number;
      /** Number of RSVPs with status `NO`. */
      no?: number;
      /** Number of RSVPs in waitlist. */
      waitlist?: number;
  }
  interface TicketingSummary$2 {
      /** Number of tickets sold. */
      tickets?: number;
      /**
       * Total revenue, excluding fees.
       * (taxes and payment provider fees are not deducted.)
       */
      revenue?: Money$2;
      /** Whether currency is locked and cannot be changed (generally occurs after the first order in the specified currency has been created). */
      currencyLocked?: boolean;
      /** Number of orders placed. */
      orders?: number;
      /** Total balance of confirmed transactions. */
      totalSales?: Money$2;
  }
  interface GuestListConfig$2 {
      /** Whether members can see other members attending the event (defaults to true). */
      publicGuestList?: boolean;
  }
  interface Feed$2 {
      /** Event discussion feed token. */
      token?: string;
  }
  interface OnlineConferencing$2 {
      config?: OnlineConferencingConfig$2;
      session?: OnlineConferencingSession$2;
      /**
       * Configured conferencing provider name.
       * @internal
       * @readonly
       */
      providerName?: string;
  }
  interface OnlineConferencingConfig$2 {
      /**
       * Whether online conferencing is enabled (not supported for TBD schedules).
       * When enabled, links to join conferencing are generated and provided to guests.
       */
      enabled?: boolean;
      /** Conferencing provider ID. */
      providerId?: string | null;
      /** Conference type */
      conferenceType?: ConferenceType$2;
  }
  enum ConferenceType$2 {
      /** Everyone in the meeting can publish and subscribe video and audio. */
      MEETING = "MEETING",
      /** Guests can only subscribe to video and audio. */
      WEBINAR = "WEBINAR"
  }
  interface OnlineConferencingSession$2 {
      /**
       * Link for event host to start the online conference session.
       * @readonly
       */
      hostLink?: string;
      /**
       * Link for guests to join the online conference session.
       * @readonly
       */
      guestLink?: string;
      /**
       * The password required to join online conferencing session (when relevant).
       * @readonly
       */
      password?: string | null;
      /**
       * Indicates that session was created successfully on providers side.
       * @readonly
       */
      sessionCreated?: boolean | null;
      /**
       * Unique session id
       * @readonly
       */
      sessionId?: string | null;
  }
  interface SeoSettings$2 {
      /** URL slug */
      slug?: string;
      /** Advanced SEO data */
      advancedSeoData?: SeoSchema$2;
      /**
       * Hidden from SEO Site Map
       * @readonly
       */
      hidden?: boolean | null;
  }
  /**
   * The SEO schema object contains data about different types of meta tags. It makes sure that the information about your page is presented properly to search engines.
   * The search engines use this information for ranking purposes, or to display snippets in the search results.
   * This data will override other sources of tags (for example patterns) and will be included in the <head> section of the HTML document, while not being displayed on the page itself.
   */
  interface SeoSchema$2 {
      /** SEO tag information. */
      tags?: Tag$2[];
      /** SEO general settings. */
      settings?: Settings$2;
  }
  interface Keyword$2 {
      /** Keyword value. */
      term?: string;
      /** Whether the keyword is the main focus keyword. */
      isMain?: boolean;
      /** The source that added the keyword terms to the SEO settings. */
      origin?: string | null;
  }
  interface Tag$2 {
      /**
       * SEO tag type.
       *
       *
       * Supported values: `title`, `meta`, `script`, `link`.
       */
      type?: string;
      /**
       * A `{"key": "value"}` pair object where each SEO tag property (`"name"`, `"content"`, `"rel"`, `"href"`) contains a value.
       * For example: `{"name": "description", "content": "the description itself"}`.
       */
      props?: Record<string, any> | null;
      /** SEO tag meta data. For example, `{"height": 300, "width": 240}`. */
      meta?: Record<string, any> | null;
      /** SEO tag inner content. For example, `<title> inner content </title>`. */
      children?: string;
      /** Whether the tag is a custom tag. */
      custom?: boolean;
      /** Whether the tag is disabled. */
      disabled?: boolean;
  }
  interface Settings$2 {
      /**
       * Whether the Auto Redirect feature, which creates `301 redirects` on a slug change, is enabled.
       *
       *
       * Default: `false` (Auto Redirect is enabled.)
       */
      preventAutoRedirect?: boolean;
      /** User-selected keyword terms for a specific page. */
      keywords?: Keyword$2[];
  }
  interface Agenda$2 {
      /** Whether the schedule is enabled for the event. */
      enabled?: boolean;
      /**
       * Agenda page URL.
       * @readonly
       */
      pageUrl?: SiteUrl$2;
  }
  interface Category$2 {
      /**
       * Category ID.
       * @readonly
       */
      _id?: string;
      /** Category name. */
      name?: string;
      /**
       * Date and time when category was created.
       * @readonly
       */
      _createdDate?: Date | null;
      /**
       * Assigned events count. Deleted events are excluded.
       * @internal
       * @readonly
       * @deprecated
       */
      assignedEventsCount?: number | null;
      /**
       * The total number of draft and published events assigned to the category.
       * @readonly
       */
      counts?: CategoryCounts$2;
      /**
       * Category state. Possible values:
       *
       * `MANUAL`: Category is created manually by the user.
       * `AUTO`: Category is created automatically.
       * `RECURRING_EVENT`: Category is created automatically when publishing recurring events.
       * `HIDDEN`: Category can't be seen.
       *
       * Default: `MANUAL`.
       *
       * **Note:** The WIX_EVENTS.MANAGE_AUTO_CATEGORIES permission scope is required to use states other than `MANUAL`.
       */
      states?: State$2[];
      /**
       * Optionally client defined external ID.
       * @internal
       */
      externalId?: string | null;
  }
  interface CategoryCounts$2 {
      /** Total number of draft events assigned to the category. */
      assignedEventsCount?: number | null;
      /** Total number of published events assigned to the category. Deleted events are excluded. */
      assignedDraftEventsCount?: number | null;
  }
  enum State$2 {
      /** Created manually by the user. */
      MANUAL = "MANUAL",
      /** Created automatically. */
      AUTO = "AUTO",
      /** Created when publishing recurring events. */
      RECURRING_EVENT = "RECURRING_EVENT",
      /** Category is hidden. */
      HIDDEN = "HIDDEN",
      /** Category is used to store component events. */
      COMPONENT = "COMPONENT"
  }
  interface EventDisplaySettings$2 {
      /** Whether event details button is hidden. Only available for events with no registration. */
      hideEventDetailsButton?: boolean | null;
      /** Disables event details page visibility. If event has an external registration configured visitors will be redirected from this page. */
      hideEventDetailsPage?: boolean | null;
  }
  interface LabellingSettings$2 {
      /**
       * @internal
       * @readonly
       */
      assignedContactsLegacyLabelId?: string | null;
      /**
       * @internal
       * @readonly
       */
      assignedContactsLabelDeleted?: boolean | null;
  }
  interface Empty$2 {
  }
  interface EventDeleted$2 {
      /** Event deleted timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Event ID. */
      eventId?: string;
      /** Event title. */
      title?: string;
      /** Event creator user ID. */
      userId?: string | null;
      /**
       * Event categories.
       * @internal
       */
      categories?: string[];
  }
  interface DomainEvent$2 extends DomainEventBodyOneOf$2 {
      createdEvent?: EntityCreatedEvent$2;
      updatedEvent?: EntityUpdatedEvent$2;
      deletedEvent?: EntityDeletedEvent$2;
      actionEvent?: ActionEvent$2;
      /**
       * Unique event ID.
       * Allows clients to ignore duplicate webhooks.
       */
      _id?: string;
      /**
       * Assumes actions are also always typed to an entity_type
       * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
       */
      entityFqdn?: string;
      /**
       * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
       * This is although the created/updated/deleted notion is duplication of the oneof types
       * Example: created/updated/deleted/started/completed/email_opened
       */
      slug?: string;
      /** ID of the entity associated with the event. */
      entityId?: string;
      /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
      eventTime?: Date | null;
      /**
       * Whether the event was triggered as a result of a privacy regulation application
       * (for example, GDPR).
       */
      triggeredByAnonymizeRequest?: boolean | null;
      /** If present, indicates the action that triggered the event. */
      originatedFrom?: string | null;
      /**
       * A sequence number defining the order of updates to the underlying entity.
       * For example, given that some entity was updated at 16:00 and than again at 16:01,
       * it is guaranteed that the sequence number of the second update is strictly higher than the first.
       * As the consumer, you can use this value to ensure that you handle messages in the correct order.
       * To do so, you will need to persist this number on your end, and compare the sequence number from the
       * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
       */
      entityEventSequence?: string | null;
  }
  /** @oneof */
  interface DomainEventBodyOneOf$2 {
      createdEvent?: EntityCreatedEvent$2;
      updatedEvent?: EntityUpdatedEvent$2;
      deletedEvent?: EntityDeletedEvent$2;
      actionEvent?: ActionEvent$2;
  }
  interface EntityCreatedEvent$2 {
      entityAsJson?: string;
      /**
       * Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity
       * @internal
       */
      triggeredByUndelete?: boolean | null;
      /** Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity */
      restoreInfo?: RestoreInfo$2;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface RestoreInfo$2 {
      deletedDate?: Date | null;
  }
  interface EntityUpdatedEvent$2 {
      /**
       * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
       * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
       * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
       */
      currentEntityAsJson?: string;
      /**
       * This field is currently part of the of the EntityUpdatedEvent msg, but scala/node libraries which implements the domain events standard
       * wont populate it / have any reference to it in the API.
       * The main reason for it is that fetching the old entity from the DB will have a performance hit on an update operation so unless truly needed,
       * the developer should send only the new (current) entity.
       * An additional reason is not wanting to send this additional entity over the wire (kafka) since in some cases it can be really big
       * Developers that must reflect the old entity will have to implement their own domain event sender mechanism which will follow the DomainEvent proto message.
       * @internal
       * @deprecated
       */
      previousEntityAsJson?: string | null;
      /**
       * WIP - This property will hold both names and previous values of the updated fields of the entity.
       * For more details please see [adr](https://docs.google.com/document/d/1PdqsOM20Ph2HAkmx8zvUnzzk3Sekp3BR9h34wSvsRnI/edit#heading=h.phlw87mh2imx) or [issue](https://github.com/wix-private/nile-tracker/issues/363)
       * @internal
       */
      modifiedFields?: Record<string, any>;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface EntityDeletedEvent$2 {
      /**
       * Indicates if the entity is sent to trash-bin. only available when trash-bin is enabled
       * @internal
       */
      movedToTrash?: boolean | null;
      /** Entity that was deleted */
      deletedEntityAsJson?: string | null;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface ActionEvent$2 {
      bodyAsJson?: string;
  }
  interface BulkUpdateRsvpContactIdRequest {
      /** RSVP IDs. */
      rsvpIds?: string[] | null;
      /** New RSVP contact ID. */
      contactId?: string | null;
  }
  interface BulkUpdateRsvpContactIdResponse {
  }
  interface MessageEnvelope$2 {
      /** App instance ID. */
      instanceId?: string | null;
      /** Event type. */
      eventType?: string;
      /** The identification type and identity data. */
      identity?: IdentificationData$2;
      /** Stringify payload. */
      data?: string;
  }
  interface IdentificationData$2 extends IdentificationDataIdOneOf$2 {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
      /** @readonly */
      identityType?: WebhookIdentityType$2;
  }
  /** @oneof */
  interface IdentificationDataIdOneOf$2 {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
  }
  enum WebhookIdentityType$2 {
      UNKNOWN = "UNKNOWN",
      ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
      MEMBER = "MEMBER",
      WIX_USER = "WIX_USER",
      APP = "APP"
  }
  /**
   * Retrieves a list of RSVPs that match the provided search query and optionally performs aggregations on the data queried.
   *
   * To learn about working with _Search_ endpoints, see [API Query Language](https://dev.wix.com/api/rest/getting-started/api-query-language), [Sorting and Paging](https://dev.wix.com/api/rest/getting-started/pagination), and [Field Projection](https://dev.wix.com/api/rest/getting-started/field-projection).
   * @public
   * @documentationMaturity preview
   * @permissionId WIX_EVENTS.READ_RSVP
   * @adminMethod
   */
  function searchRsvps(options?: SearchRsvpsOptions): Promise<SearchRsvpsResponse>;
  interface SearchRsvpsOptions {
      /** Search options. See [API Query Language](https://dev.wix.com/api/rest/getting-started/api-query-language) for more details. */
      search?: CursorSearch;
      /** Predefined sets of fields to return. */
      fields?: RequestedFields$1[];
  }
  /**
   * Retrieves a list of RSVPs, given the provided paging, filtering, and sorting. Query RSVPs runs with these defaults, which you can override:
   *
   * - `createdDate` is sorted in `ASC` order
   * - `paging.limit` is `100`
   * - `paging.offset` is `0`
   *
   * For field support for filters and sorting, see [RSVP v2: Supported Filters and Sorting](https://dev.wix.com/docs/rest/business-solutions/events/rsvp-v2/filter-and-sort). To learn about working with Query endpoints, see [API Query Language](https://dev.wix.com/api/rest/getting-started/api-query-language).
   *
   * > **Note:** This method is quite slow. We suggest you using the following filter pairs for the most optimal speed:
   * > - `eventId` and `status`
   * > - `eventId` and `fullyCheckedIn`
   * > - `eventId` and `memberId`
   * > - `eventId` and `contactId`
   * > - `eventId` and `createdDate`
   * @public
   * @documentationMaturity preview
   * @permissionId WIX_EVENTS.READ_RSVP
   * @adminMethod
   */
  function queryRsvps(options?: QueryRsvpsOptions): RsvpsQueryBuilder;
  interface QueryRsvpsOptions {
      /** Predefined sets of fields to return. */
      fields?: RequestedFields$1[] | undefined;
  }
  interface QueryCursorResult$1 {
      cursors: Cursors$2;
      hasNext: () => boolean;
      hasPrev: () => boolean;
      length: number;
      pageSize: number;
  }
  interface RsvpsQueryResult extends QueryCursorResult$1 {
      items: V2Rsvp[];
      query: RsvpsQueryBuilder;
      next: () => Promise<RsvpsQueryResult>;
      prev: () => Promise<RsvpsQueryResult>;
  }
  interface RsvpsQueryBuilder {
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       * @documentationMaturity preview
       */
      eq: (propertyName: '_id' | 'eventId' | '_createdDate' | '_updatedDate' | 'memberId' | 'contactId' | 'status' | 'fullyCheckedIn', value: any) => RsvpsQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       * @documentationMaturity preview
       */
      ne: (propertyName: '_id' | 'eventId' | '_createdDate' | '_updatedDate' | 'memberId' | 'contactId' | 'status' | 'fullyCheckedIn', value: any) => RsvpsQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       * @documentationMaturity preview
       */
      ge: (propertyName: '_createdDate' | '_updatedDate', value: any) => RsvpsQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       * @documentationMaturity preview
       */
      gt: (propertyName: '_createdDate' | '_updatedDate', value: any) => RsvpsQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       * @documentationMaturity preview
       */
      le: (propertyName: '_createdDate' | '_updatedDate', value: any) => RsvpsQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       * @documentationMaturity preview
       */
      lt: (propertyName: '_createdDate' | '_updatedDate', value: any) => RsvpsQueryBuilder;
      /** @documentationMaturity preview */
      in: (propertyName: '_id' | 'eventId' | '_createdDate' | '_updatedDate' | 'memberId' | 'contactId' | 'status' | 'fullyCheckedIn', value: any) => RsvpsQueryBuilder;
      /** @documentationMaturity preview */
      exists: (propertyName: '_id' | 'eventId' | 'memberId' | 'contactId', value: boolean) => RsvpsQueryBuilder;
      /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments.
       * @documentationMaturity preview
       */
      ascending: (...propertyNames: Array<'_createdDate' | '_updatedDate' | 'status' | 'fullyCheckedIn'>) => RsvpsQueryBuilder;
      /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments.
       * @documentationMaturity preview
       */
      descending: (...propertyNames: Array<'_createdDate' | '_updatedDate' | 'status' | 'fullyCheckedIn'>) => RsvpsQueryBuilder;
      /** @param limit - Number of items to return, which is also the `pageSize` of the results object.
       * @documentationMaturity preview
       */
      limit: (limit: number) => RsvpsQueryBuilder;
      /** @param cursor - A pointer to specific record
       * @documentationMaturity preview
       */
      skipTo: (cursor: string) => RsvpsQueryBuilder;
      /** @documentationMaturity preview */
      find: () => Promise<RsvpsQueryResult>;
  }
  /**
   * Counts RSVPs given the provided filtering and searching.
   * @public
   * @documentationMaturity preview
   * @permissionId WIX_EVENTS.READ_RSVP
   * @adminMethod
   */
  function countRsvps(options?: CountRsvpsOptions): Promise<CountRsvpsResponse>;
  interface CountRsvpsOptions {
      /**
       * Filter object in the following format:
       * `"filter" : {
       * "fieldName1": "value1",
       * "fieldName2":{"$operator":"value2"}
       * }`
       * Example of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`, `$contains`
       */
      filter?: Record<string, any> | null;
      /** Search details. */
      search?: SearchDetails;
  }
  /**
   * Retrieves RSVP by ID.
   * @param rsvpId - RSVP ID.
   * @public
   * @documentationMaturity preview
   * @requiredField rsvpId
   * @permissionId WIX_EVENTS.READ_RSVP
   * @adminMethod
   * @returns The requested RSVP.
   */
  function getRsvp(rsvpId: string, options?: GetRsvpOptions): Promise<V2Rsvp>;
  interface GetRsvpOptions {
      /** Predefined sets of fields to return. */
      fields?: RequestedFields$1[];
  }
  /**
   * Creates RSVP.
   *
   * To create RSVP with multiple guests, you have to specify the `additionalGuests` and `guestNames` fields.
   * @param rsvp - RSVP info.
   * @public
   * @documentationMaturity preview
   * @requiredField rsvp
   * @requiredField rsvp.additionalGuestDetails.guestCount
   * @requiredField rsvp.email
   * @requiredField rsvp.eventId
   * @requiredField rsvp.firstName
   * @requiredField rsvp.lastName
   * @requiredField rsvp.status
   * @permissionId WIX_EVENTS.CREATE_RSVP
   * @returns Created RSVP.
   */
  function createRsvp(rsvp: V2Rsvp, options?: CreateRsvpOptions): Promise<V2Rsvp>;
  interface CreateRsvpOptions {
      /** RSVP options. <br> The **WIX_EVENTS.MANAGE_RSVP** permission is required. */
      options?: ModificationOptions;
      /** Predefined sets of fields to return. */
      fields?: RequestedFields$1[];
  }
  /**
   * Updates RSVP.
   *
   * Each time the RSVP is updated, `revision` increments by 1. The existing `revision` must be included when updating the RSVP. This ensures you're working with the latest RSVP and prevents unintended overwrites.
   * @param _id - RSVP ID.
   * @public
   * @documentationMaturity preview
   * @requiredField _id
   * @requiredField rsvp
   * @permissionId WIX_EVENTS.MANAGE_RSVP
   * @adminMethod
   * @returns Updated RSVP.
   */
  function updateRsvp(_id: string | null, rsvp: UpdateRsvp, options?: UpdateRsvpOptions): Promise<V2Rsvp>;
  interface UpdateRsvp {
      /**
       * RSVP ID.
       * @readonly
       */
      _id?: string | null;
      /**
       * Revision number, which increments by 1 each time the RSVP is updated. To prevent conflicting changes, the existing revision must be used when updating the RSVP.
       * @readonly
       */
      revision?: string | null;
      /** Event ID to which the RSVP belongs. */
      eventId?: string | null;
      /**
       * Date and time when the RSVP was created.
       * @readonly
       */
      _createdDate?: Date | null;
      /**
       * Date and time when the RSVP was update.
       * @readonly
       */
      _updatedDate?: Date | null;
      /** Site member ID. You can override the field value when updating RSVP. Overriding member ID requires the **WIX_EVENTS.MANAGE_RSVP** permission. */
      memberId?: string | null;
      /** Contact ID of a guest who filled in the RSVP form. See [Contacts API](https://dev.wix.com/api/rest/contacts/contacts/contacts-v4) for more details. */
      contactId?: string | null;
      /** First name of a guest who filled in the RSVP form. */
      firstName?: string | null;
      /** Last name of a guest who filled in the RSVP form. */
      lastName?: string | null;
      /** Email of a guest who filled in the RSVP form. */
      email?: string | null;
      /** Event registration form. */
      form?: FormResponse;
      /** RSVP response status. */
      status?: RsvpStatus;
      /**
       * Total number of guests per 1 RSVP.
       * @readonly
       */
      totalGuests?: number | null;
      /**
       * Guest list.
       * @readonly
       */
      guestList?: GuestList;
      /**
       * Site language code in the [ISO 639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format.
       * @readonly
       */
      language?: string | null;
      /**
       * Locale in the [IETF BCP 47](https://en.wikipedia.org/wiki/IETF_language_tag) format.
       * @readonly
       */
      locale?: string | null;
      /**
       * Whether all guests are checked in.
       * @readonly
       */
      fullyCheckedIn?: boolean | null;
      /**
       * How many guests are checked in.
       * @readonly
       */
      checkedInGuestCount?: number | null;
      /** Additional guest details. */
      additionalGuestDetails?: AdditionalGuestDetails;
      /** Whether the notifications are disabled. */
      disableNotifications?: boolean | null;
      /**
       * Guest login details for accessing the online conference event.
       * @readonly
       */
      onlineConferencingLogin?: OnlineConferencingLogin;
      /**
       * Whether the RSVP is anonymized.
       * @readonly
       */
      anonymized?: boolean | null;
      /**
       * Email domain of a guest who filled in the RSVP form.
       * @internal
       * @readonly
       */
      emailDomain?: string | null;
      /**
       * Custom field data for the RSVP object.
       *
       * **Note:** You must configure extended fields using schema plugin extensions in your app's dashboard before you can access the extended fields with API calls.
       */
      extendedFields?: ExtendedFields$1;
  }
  interface UpdateRsvpOptions {
      /**
       * List of exact fields to update. For example, if you define only the `firstName`, all other fields are ignored.
       * @internal
       */
      fieldMask: string[];
      /** RSVP options. <br> The **WIX_EVENTS.MANAGE_RSVP** permission is required to pass these fields. */
      options?: ModificationOptions;
      /** Predefined sets of fields to return. */
      fields?: RequestedFields$1[];
  }
  /**
   * Permanently deletes RSVP.
   * @param rsvpId - ID of RSVP to delete.
   * @public
   * @documentationMaturity preview
   * @requiredField rsvpId
   * @permissionId WIX_EVENTS.MANAGE_RSVP
   * @adminMethod
   */
  function deleteRsvp(rsvpId: string | null): Promise<void>;
  /**
   * Updates multiple RSVPs.
   *
   * You can update up to 100 RSVPs per request.
   * @param rsvps - RSVPs to update.
   * @public
   * @documentationMaturity preview
   * @requiredField rsvps
   * @requiredField rsvps.rsvp._id
   * @requiredField rsvps.rsvp.revision
   * @permissionId WIX_EVENTS.MANAGE_RSVP
   * @adminMethod
   */
  function bulkUpdateRsvp(rsvps: MaskedRsvp[], options?: BulkUpdateRsvpOptions): Promise<BulkUpdateRsvpResponse>;
  interface BulkUpdateRsvpOptions {
      /** Whether to return the whole `rsvp` object in the response. If `false`, only metadata is returned. */
      returnEntity?: boolean;
      /** Predefined sets of fields to return. */
      fields?: RequestedFields$1[];
      /** RSVP options. <br> The **WIX_EVENTS.MANAGE_RSVP** permission is required to pass these fields. */
      options?: ModificationOptions;
  }
  /**
   * Permanently deletes multiple RSVPs by filter.
   * @param filter - Filter object.
   * @public
   * @documentationMaturity preview
   * @requiredField filter
   * @permissionId WIX_EVENTS.MANAGE_RSVP
   * @adminMethod
   */
  function bulkDeleteRsvpsByFilter(filter: Record<string, any> | null, options?: BulkDeleteRsvpsByFilterOptions): Promise<BulkDeleteRsvpsByFilterResponse>;
  interface BulkDeleteRsvpsByFilterOptions {
      /** Search details. */
      search?: SearchDetails;
  }
  /**
   * Checks in RSVP guests.
   *
   * You can check in up to 11 guests per request.
   * @param rsvpId - ID of RSVP to check-in.
   * @public
   * @documentationMaturity preview
   * @requiredField rsvpId
   * @permissionId WIX_EVENTS.CHECK_IN
   * @adminMethod
   */
  function checkInRsvpGuests(rsvpId: string | null, options?: CheckInRsvpGuestsOptions): Promise<CheckInRsvpGuestsResponse>;
  interface CheckInRsvpGuestsOptions {
      /** IDs of guests to check-in. */
      guestIds?: number[];
      /** Predefined sets of fields to return. */
      fields?: RequestedFields$1[];
  }
  /**
   * Cancels the check-in of RSVP guests.
   *
   * If the request body is empty, cancels all check-ins from the RSVP. After the cancellation, the `guests.checkInDate` value becomes empty.
   *
   * You can cancel check-in of up to 11 guests per request.
   * @param rsvpId - ID of RSVP to cancel check-in.
   * @public
   * @documentationMaturity preview
   * @requiredField rsvpId
   * @permissionId WIX_EVENTS.CHECK_IN
   * @adminMethod
   */
  function cancelRsvpGuestsCheckIn(rsvpId: string, options?: CancelRsvpGuestsCheckInOptions): Promise<CancelRsvpGuestsCheckInResponse>;
  interface CancelRsvpGuestsCheckInOptions {
      /** IDs of guests to check-in. */
      guestIds?: number[];
      /** Predefined sets of fields to return. */
      fields?: RequestedFields$1[];
  }
  /**
   * Retrieves RSVP summary by ID.
   * @param eventId - Event ID.
   * @public
   * @documentationMaturity preview
   * @requiredField eventId
   * @permissionId WIX_EVENTS.READ_RSVP
   * @adminMethod
   */
  function listRsvpSummary(eventId: string[] | null, options?: ListRsvpSummaryOptions): Promise<ListRsvpSummaryResponse>;
  interface ListRsvpSummaryOptions {
      /**
       * Consistent read.
       * @internal
       */
      consistentRead?: boolean | null;
  }
  
  type eventsV2Rsvp_universal_d_V2Rsvp = V2Rsvp;
  type eventsV2Rsvp_universal_d_FormResponse = FormResponse;
  type eventsV2Rsvp_universal_d_InputValue = InputValue;
  type eventsV2Rsvp_universal_d_FormattedAddress = FormattedAddress;
  type eventsV2Rsvp_universal_d_StandardDetails = StandardDetails;
  type eventsV2Rsvp_universal_d_RsvpStatus = RsvpStatus;
  const eventsV2Rsvp_universal_d_RsvpStatus: typeof RsvpStatus;
  type eventsV2Rsvp_universal_d_GuestList = GuestList;
  type eventsV2Rsvp_universal_d_Guest = Guest;
  type eventsV2Rsvp_universal_d_CheckInDetails = CheckInDetails;
  type eventsV2Rsvp_universal_d_AdditionalGuestDetails = AdditionalGuestDetails;
  type eventsV2Rsvp_universal_d_OnlineConferencingLogin = OnlineConferencingLogin;
  type eventsV2Rsvp_universal_d_SearchRsvpsRequest = SearchRsvpsRequest;
  type eventsV2Rsvp_universal_d_CursorSearch = CursorSearch;
  type eventsV2Rsvp_universal_d_CursorSearchPagingMethodOneOf = CursorSearchPagingMethodOneOf;
  type eventsV2Rsvp_universal_d_Aggregation = Aggregation;
  type eventsV2Rsvp_universal_d_AggregationKindOneOf = AggregationKindOneOf;
  type eventsV2Rsvp_universal_d_RangeBucket = RangeBucket;
  type eventsV2Rsvp_universal_d_SortType = SortType;
  const eventsV2Rsvp_universal_d_SortType: typeof SortType;
  type eventsV2Rsvp_universal_d_SortDirection = SortDirection;
  const eventsV2Rsvp_universal_d_SortDirection: typeof SortDirection;
  type eventsV2Rsvp_universal_d_MissingValues = MissingValues;
  const eventsV2Rsvp_universal_d_MissingValues: typeof MissingValues;
  type eventsV2Rsvp_universal_d_IncludeMissingValuesOptions = IncludeMissingValuesOptions;
  type eventsV2Rsvp_universal_d_ScalarType = ScalarType;
  const eventsV2Rsvp_universal_d_ScalarType: typeof ScalarType;
  type eventsV2Rsvp_universal_d_ValueAggregation = ValueAggregation;
  type eventsV2Rsvp_universal_d_ValueAggregationOptionsOneOf = ValueAggregationOptionsOneOf;
  type eventsV2Rsvp_universal_d_NestedAggregationType = NestedAggregationType;
  const eventsV2Rsvp_universal_d_NestedAggregationType: typeof NestedAggregationType;
  type eventsV2Rsvp_universal_d_RangeAggregation = RangeAggregation;
  type eventsV2Rsvp_universal_d_ScalarAggregation = ScalarAggregation;
  type eventsV2Rsvp_universal_d_DateHistogramAggregation = DateHistogramAggregation;
  type eventsV2Rsvp_universal_d_Interval = Interval;
  const eventsV2Rsvp_universal_d_Interval: typeof Interval;
  type eventsV2Rsvp_universal_d_NestedAggregationItem = NestedAggregationItem;
  type eventsV2Rsvp_universal_d_NestedAggregationItemKindOneOf = NestedAggregationItemKindOneOf;
  type eventsV2Rsvp_universal_d_AggregationType = AggregationType;
  const eventsV2Rsvp_universal_d_AggregationType: typeof AggregationType;
  type eventsV2Rsvp_universal_d_NestedAggregation = NestedAggregation;
  type eventsV2Rsvp_universal_d_SearchDetails = SearchDetails;
  type eventsV2Rsvp_universal_d_Mode = Mode;
  const eventsV2Rsvp_universal_d_Mode: typeof Mode;
  type eventsV2Rsvp_universal_d_SearchRsvpsResponse = SearchRsvpsResponse;
  type eventsV2Rsvp_universal_d_CursorPagingMetadata = CursorPagingMetadata;
  type eventsV2Rsvp_universal_d_AggregationData = AggregationData;
  type eventsV2Rsvp_universal_d_ValueAggregationResult = ValueAggregationResult;
  type eventsV2Rsvp_universal_d_RangeAggregationResult = RangeAggregationResult;
  type eventsV2Rsvp_universal_d_NestedAggregationResults = NestedAggregationResults;
  type eventsV2Rsvp_universal_d_NestedAggregationResultsResultOneOf = NestedAggregationResultsResultOneOf;
  type eventsV2Rsvp_universal_d_ValueResults = ValueResults;
  type eventsV2Rsvp_universal_d_RangeResults = RangeResults;
  type eventsV2Rsvp_universal_d_AggregationResultsScalarResult = AggregationResultsScalarResult;
  type eventsV2Rsvp_universal_d_NestedValueAggregationResult = NestedValueAggregationResult;
  type eventsV2Rsvp_universal_d_ValueResult = ValueResult;
  type eventsV2Rsvp_universal_d_RangeResult = RangeResult;
  type eventsV2Rsvp_universal_d_ScalarResult = ScalarResult;
  type eventsV2Rsvp_universal_d_NestedResultValue = NestedResultValue;
  type eventsV2Rsvp_universal_d_NestedResultValueResultOneOf = NestedResultValueResultOneOf;
  type eventsV2Rsvp_universal_d_Results = Results;
  type eventsV2Rsvp_universal_d_DateHistogramResult = DateHistogramResult;
  type eventsV2Rsvp_universal_d_GroupByValueResults = GroupByValueResults;
  type eventsV2Rsvp_universal_d_DateHistogramResults = DateHistogramResults;
  type eventsV2Rsvp_universal_d_NestedResults = NestedResults;
  type eventsV2Rsvp_universal_d_AggregationResults = AggregationResults;
  type eventsV2Rsvp_universal_d_AggregationResultsResultOneOf = AggregationResultsResultOneOf;
  type eventsV2Rsvp_universal_d_SearchRsvpsWithOffsetRequest = SearchRsvpsWithOffsetRequest;
  type eventsV2Rsvp_universal_d_Search = Search;
  type eventsV2Rsvp_universal_d_SearchPagingMethodOneOf = SearchPagingMethodOneOf;
  type eventsV2Rsvp_universal_d_SearchRsvpsWithOffsetResponse = SearchRsvpsWithOffsetResponse;
  type eventsV2Rsvp_universal_d_QueryRsvpsRequest = QueryRsvpsRequest;
  type eventsV2Rsvp_universal_d_CursorQuery = CursorQuery;
  type eventsV2Rsvp_universal_d_CursorQueryPagingMethodOneOf = CursorQueryPagingMethodOneOf;
  type eventsV2Rsvp_universal_d_QueryRsvpsResponse = QueryRsvpsResponse;
  type eventsV2Rsvp_universal_d_CountRsvpsRequest = CountRsvpsRequest;
  type eventsV2Rsvp_universal_d_CountRsvpsResponse = CountRsvpsResponse;
  type eventsV2Rsvp_universal_d_GetRsvpRequest = GetRsvpRequest;
  type eventsV2Rsvp_universal_d_GetRsvpResponse = GetRsvpResponse;
  type eventsV2Rsvp_universal_d_CreateRsvpRequest = CreateRsvpRequest;
  type eventsV2Rsvp_universal_d_ModificationOptions = ModificationOptions;
  type eventsV2Rsvp_universal_d_CreateRsvpResponse = CreateRsvpResponse;
  type eventsV2Rsvp_universal_d_GuestLimitExceededData = GuestLimitExceededData;
  type eventsV2Rsvp_universal_d_UpdateRsvpRequest = UpdateRsvpRequest;
  type eventsV2Rsvp_universal_d_UpdateRsvpResponse = UpdateRsvpResponse;
  type eventsV2Rsvp_universal_d_DeleteRsvpRequest = DeleteRsvpRequest;
  type eventsV2Rsvp_universal_d_DeleteRsvpResponse = DeleteRsvpResponse;
  type eventsV2Rsvp_universal_d_BulkUpdateRsvpRequest = BulkUpdateRsvpRequest;
  type eventsV2Rsvp_universal_d_MaskedRsvp = MaskedRsvp;
  type eventsV2Rsvp_universal_d_BulkUpdateRsvpResponse = BulkUpdateRsvpResponse;
  type eventsV2Rsvp_universal_d_ItemMetadata = ItemMetadata;
  type eventsV2Rsvp_universal_d_ApplicationError = ApplicationError;
  type eventsV2Rsvp_universal_d_BulkRsvpResult = BulkRsvpResult;
  type eventsV2Rsvp_universal_d_BulkActionMetadata = BulkActionMetadata;
  type eventsV2Rsvp_universal_d_BulkDeleteRsvpsByFilterRequest = BulkDeleteRsvpsByFilterRequest;
  type eventsV2Rsvp_universal_d_BulkDeleteRsvpsByFilterResponse = BulkDeleteRsvpsByFilterResponse;
  type eventsV2Rsvp_universal_d_CheckInRsvpGuestsRequest = CheckInRsvpGuestsRequest;
  type eventsV2Rsvp_universal_d_CheckInRsvpGuestsResponse = CheckInRsvpGuestsResponse;
  type eventsV2Rsvp_universal_d_CancelRsvpGuestsCheckInRequest = CancelRsvpGuestsCheckInRequest;
  type eventsV2Rsvp_universal_d_CancelRsvpGuestsCheckInResponse = CancelRsvpGuestsCheckInResponse;
  type eventsV2Rsvp_universal_d_ListRsvpSummaryRequest = ListRsvpSummaryRequest;
  type eventsV2Rsvp_universal_d_ListRsvpSummaryResponse = ListRsvpSummaryResponse;
  type eventsV2Rsvp_universal_d_V2RsvpSummary = V2RsvpSummary;
  type eventsV2Rsvp_universal_d_CompareRsvpSummaryRequest = CompareRsvpSummaryRequest;
  type eventsV2Rsvp_universal_d_CompareRsvpSummaryResponse = CompareRsvpSummaryResponse;
  type eventsV2Rsvp_universal_d_BulkUpdateRsvpContactIdRequest = BulkUpdateRsvpContactIdRequest;
  type eventsV2Rsvp_universal_d_BulkUpdateRsvpContactIdResponse = BulkUpdateRsvpContactIdResponse;
  const eventsV2Rsvp_universal_d_searchRsvps: typeof searchRsvps;
  type eventsV2Rsvp_universal_d_SearchRsvpsOptions = SearchRsvpsOptions;
  const eventsV2Rsvp_universal_d_queryRsvps: typeof queryRsvps;
  type eventsV2Rsvp_universal_d_QueryRsvpsOptions = QueryRsvpsOptions;
  type eventsV2Rsvp_universal_d_RsvpsQueryResult = RsvpsQueryResult;
  type eventsV2Rsvp_universal_d_RsvpsQueryBuilder = RsvpsQueryBuilder;
  const eventsV2Rsvp_universal_d_countRsvps: typeof countRsvps;
  type eventsV2Rsvp_universal_d_CountRsvpsOptions = CountRsvpsOptions;
  const eventsV2Rsvp_universal_d_getRsvp: typeof getRsvp;
  type eventsV2Rsvp_universal_d_GetRsvpOptions = GetRsvpOptions;
  const eventsV2Rsvp_universal_d_createRsvp: typeof createRsvp;
  type eventsV2Rsvp_universal_d_CreateRsvpOptions = CreateRsvpOptions;
  const eventsV2Rsvp_universal_d_updateRsvp: typeof updateRsvp;
  type eventsV2Rsvp_universal_d_UpdateRsvp = UpdateRsvp;
  type eventsV2Rsvp_universal_d_UpdateRsvpOptions = UpdateRsvpOptions;
  const eventsV2Rsvp_universal_d_deleteRsvp: typeof deleteRsvp;
  const eventsV2Rsvp_universal_d_bulkUpdateRsvp: typeof bulkUpdateRsvp;
  type eventsV2Rsvp_universal_d_BulkUpdateRsvpOptions = BulkUpdateRsvpOptions;
  const eventsV2Rsvp_universal_d_bulkDeleteRsvpsByFilter: typeof bulkDeleteRsvpsByFilter;
  type eventsV2Rsvp_universal_d_BulkDeleteRsvpsByFilterOptions = BulkDeleteRsvpsByFilterOptions;
  const eventsV2Rsvp_universal_d_checkInRsvpGuests: typeof checkInRsvpGuests;
  type eventsV2Rsvp_universal_d_CheckInRsvpGuestsOptions = CheckInRsvpGuestsOptions;
  const eventsV2Rsvp_universal_d_cancelRsvpGuestsCheckIn: typeof cancelRsvpGuestsCheckIn;
  type eventsV2Rsvp_universal_d_CancelRsvpGuestsCheckInOptions = CancelRsvpGuestsCheckInOptions;
  const eventsV2Rsvp_universal_d_listRsvpSummary: typeof listRsvpSummary;
  type eventsV2Rsvp_universal_d_ListRsvpSummaryOptions = ListRsvpSummaryOptions;
  namespace eventsV2Rsvp_universal_d {
    export {
      eventsV2Rsvp_universal_d_V2Rsvp as V2Rsvp,
      eventsV2Rsvp_universal_d_FormResponse as FormResponse,
      eventsV2Rsvp_universal_d_InputValue as InputValue,
      eventsV2Rsvp_universal_d_FormattedAddress as FormattedAddress,
      CommonAddress$2 as CommonAddress,
      CommonAddressStreetOneOf$2 as CommonAddressStreetOneOf,
      CommonStreetAddress$2 as CommonStreetAddress,
      CommonAddressLocation$2 as CommonAddressLocation,
      CommonSubdivision$2 as CommonSubdivision,
      SubdivisionType$2 as SubdivisionType,
      eventsV2Rsvp_universal_d_StandardDetails as StandardDetails,
      eventsV2Rsvp_universal_d_RsvpStatus as RsvpStatus,
      eventsV2Rsvp_universal_d_GuestList as GuestList,
      eventsV2Rsvp_universal_d_Guest as Guest,
      eventsV2Rsvp_universal_d_CheckInDetails as CheckInDetails,
      eventsV2Rsvp_universal_d_AdditionalGuestDetails as AdditionalGuestDetails,
      eventsV2Rsvp_universal_d_OnlineConferencingLogin as OnlineConferencingLogin,
      ExtendedFields$1 as ExtendedFields,
      eventsV2Rsvp_universal_d_SearchRsvpsRequest as SearchRsvpsRequest,
      eventsV2Rsvp_universal_d_CursorSearch as CursorSearch,
      eventsV2Rsvp_universal_d_CursorSearchPagingMethodOneOf as CursorSearchPagingMethodOneOf,
      Sorting$2 as Sorting,
      SortOrder$2 as SortOrder,
      eventsV2Rsvp_universal_d_Aggregation as Aggregation,
      eventsV2Rsvp_universal_d_AggregationKindOneOf as AggregationKindOneOf,
      eventsV2Rsvp_universal_d_RangeBucket as RangeBucket,
      eventsV2Rsvp_universal_d_SortType as SortType,
      eventsV2Rsvp_universal_d_SortDirection as SortDirection,
      eventsV2Rsvp_universal_d_MissingValues as MissingValues,
      eventsV2Rsvp_universal_d_IncludeMissingValuesOptions as IncludeMissingValuesOptions,
      eventsV2Rsvp_universal_d_ScalarType as ScalarType,
      eventsV2Rsvp_universal_d_ValueAggregation as ValueAggregation,
      eventsV2Rsvp_universal_d_ValueAggregationOptionsOneOf as ValueAggregationOptionsOneOf,
      eventsV2Rsvp_universal_d_NestedAggregationType as NestedAggregationType,
      eventsV2Rsvp_universal_d_RangeAggregation as RangeAggregation,
      eventsV2Rsvp_universal_d_ScalarAggregation as ScalarAggregation,
      eventsV2Rsvp_universal_d_DateHistogramAggregation as DateHistogramAggregation,
      eventsV2Rsvp_universal_d_Interval as Interval,
      eventsV2Rsvp_universal_d_NestedAggregationItem as NestedAggregationItem,
      eventsV2Rsvp_universal_d_NestedAggregationItemKindOneOf as NestedAggregationItemKindOneOf,
      eventsV2Rsvp_universal_d_AggregationType as AggregationType,
      eventsV2Rsvp_universal_d_NestedAggregation as NestedAggregation,
      eventsV2Rsvp_universal_d_SearchDetails as SearchDetails,
      eventsV2Rsvp_universal_d_Mode as Mode,
      CursorPaging$2 as CursorPaging,
      RequestedFields$1 as RequestedFields,
      eventsV2Rsvp_universal_d_SearchRsvpsResponse as SearchRsvpsResponse,
      eventsV2Rsvp_universal_d_CursorPagingMetadata as CursorPagingMetadata,
      Cursors$2 as Cursors,
      eventsV2Rsvp_universal_d_AggregationData as AggregationData,
      eventsV2Rsvp_universal_d_ValueAggregationResult as ValueAggregationResult,
      eventsV2Rsvp_universal_d_RangeAggregationResult as RangeAggregationResult,
      eventsV2Rsvp_universal_d_NestedAggregationResults as NestedAggregationResults,
      eventsV2Rsvp_universal_d_NestedAggregationResultsResultOneOf as NestedAggregationResultsResultOneOf,
      eventsV2Rsvp_universal_d_ValueResults as ValueResults,
      eventsV2Rsvp_universal_d_RangeResults as RangeResults,
      eventsV2Rsvp_universal_d_AggregationResultsScalarResult as AggregationResultsScalarResult,
      eventsV2Rsvp_universal_d_NestedValueAggregationResult as NestedValueAggregationResult,
      eventsV2Rsvp_universal_d_ValueResult as ValueResult,
      eventsV2Rsvp_universal_d_RangeResult as RangeResult,
      eventsV2Rsvp_universal_d_ScalarResult as ScalarResult,
      eventsV2Rsvp_universal_d_NestedResultValue as NestedResultValue,
      eventsV2Rsvp_universal_d_NestedResultValueResultOneOf as NestedResultValueResultOneOf,
      eventsV2Rsvp_universal_d_Results as Results,
      eventsV2Rsvp_universal_d_DateHistogramResult as DateHistogramResult,
      eventsV2Rsvp_universal_d_GroupByValueResults as GroupByValueResults,
      eventsV2Rsvp_universal_d_DateHistogramResults as DateHistogramResults,
      eventsV2Rsvp_universal_d_NestedResults as NestedResults,
      eventsV2Rsvp_universal_d_AggregationResults as AggregationResults,
      eventsV2Rsvp_universal_d_AggregationResultsResultOneOf as AggregationResultsResultOneOf,
      eventsV2Rsvp_universal_d_SearchRsvpsWithOffsetRequest as SearchRsvpsWithOffsetRequest,
      eventsV2Rsvp_universal_d_Search as Search,
      eventsV2Rsvp_universal_d_SearchPagingMethodOneOf as SearchPagingMethodOneOf,
      Paging$2 as Paging,
      eventsV2Rsvp_universal_d_SearchRsvpsWithOffsetResponse as SearchRsvpsWithOffsetResponse,
      PagingMetadataV2$2 as PagingMetadataV2,
      eventsV2Rsvp_universal_d_QueryRsvpsRequest as QueryRsvpsRequest,
      eventsV2Rsvp_universal_d_CursorQuery as CursorQuery,
      eventsV2Rsvp_universal_d_CursorQueryPagingMethodOneOf as CursorQueryPagingMethodOneOf,
      eventsV2Rsvp_universal_d_QueryRsvpsResponse as QueryRsvpsResponse,
      eventsV2Rsvp_universal_d_CountRsvpsRequest as CountRsvpsRequest,
      eventsV2Rsvp_universal_d_CountRsvpsResponse as CountRsvpsResponse,
      eventsV2Rsvp_universal_d_GetRsvpRequest as GetRsvpRequest,
      eventsV2Rsvp_universal_d_GetRsvpResponse as GetRsvpResponse,
      eventsV2Rsvp_universal_d_CreateRsvpRequest as CreateRsvpRequest,
      eventsV2Rsvp_universal_d_ModificationOptions as ModificationOptions,
      eventsV2Rsvp_universal_d_CreateRsvpResponse as CreateRsvpResponse,
      CalendarLinks$2 as CalendarLinks,
      eventsV2Rsvp_universal_d_GuestLimitExceededData as GuestLimitExceededData,
      eventsV2Rsvp_universal_d_UpdateRsvpRequest as UpdateRsvpRequest,
      eventsV2Rsvp_universal_d_UpdateRsvpResponse as UpdateRsvpResponse,
      eventsV2Rsvp_universal_d_DeleteRsvpRequest as DeleteRsvpRequest,
      eventsV2Rsvp_universal_d_DeleteRsvpResponse as DeleteRsvpResponse,
      eventsV2Rsvp_universal_d_BulkUpdateRsvpRequest as BulkUpdateRsvpRequest,
      eventsV2Rsvp_universal_d_MaskedRsvp as MaskedRsvp,
      eventsV2Rsvp_universal_d_BulkUpdateRsvpResponse as BulkUpdateRsvpResponse,
      eventsV2Rsvp_universal_d_ItemMetadata as ItemMetadata,
      eventsV2Rsvp_universal_d_ApplicationError as ApplicationError,
      eventsV2Rsvp_universal_d_BulkRsvpResult as BulkRsvpResult,
      eventsV2Rsvp_universal_d_BulkActionMetadata as BulkActionMetadata,
      eventsV2Rsvp_universal_d_BulkDeleteRsvpsByFilterRequest as BulkDeleteRsvpsByFilterRequest,
      eventsV2Rsvp_universal_d_BulkDeleteRsvpsByFilterResponse as BulkDeleteRsvpsByFilterResponse,
      eventsV2Rsvp_universal_d_CheckInRsvpGuestsRequest as CheckInRsvpGuestsRequest,
      eventsV2Rsvp_universal_d_CheckInRsvpGuestsResponse as CheckInRsvpGuestsResponse,
      eventsV2Rsvp_universal_d_CancelRsvpGuestsCheckInRequest as CancelRsvpGuestsCheckInRequest,
      eventsV2Rsvp_universal_d_CancelRsvpGuestsCheckInResponse as CancelRsvpGuestsCheckInResponse,
      eventsV2Rsvp_universal_d_ListRsvpSummaryRequest as ListRsvpSummaryRequest,
      eventsV2Rsvp_universal_d_ListRsvpSummaryResponse as ListRsvpSummaryResponse,
      eventsV2Rsvp_universal_d_V2RsvpSummary as V2RsvpSummary,
      eventsV2Rsvp_universal_d_CompareRsvpSummaryRequest as CompareRsvpSummaryRequest,
      eventsV2Rsvp_universal_d_CompareRsvpSummaryResponse as CompareRsvpSummaryResponse,
      EventCreated$2 as EventCreated,
      Location$2 as Location,
      MapCoordinates$2 as MapCoordinates,
      LocationType$2 as LocationType,
      Address$2 as Address,
      AddressStreetOneOf$2 as AddressStreetOneOf,
      StreetAddress$2 as StreetAddress,
      AddressLocation$2 as AddressLocation,
      Subdivision$2 as Subdivision,
      ScheduleConfig$2 as ScheduleConfig,
      Recurrences$2 as Recurrences,
      Occurrence$2 as Occurrence,
      Status$2 as Status,
      EventStatus$2 as EventStatus,
      Event$2 as Event,
      Scheduling$2 as Scheduling,
      Registration$2 as Registration,
      EventType$2 as EventType,
      RegistrationStatus$2 as RegistrationStatus,
      RsvpCollection$2 as RsvpCollection,
      RsvpCollectionConfig$2 as RsvpCollectionConfig,
      RsvpStatusOptions$2 as RsvpStatusOptions,
      Ticketing$2 as Ticketing,
      TicketingConfig$2 as TicketingConfig,
      TaxConfig$2 as TaxConfig,
      TaxType$2 as TaxType,
      Money$2 as Money,
      ExternalEvent$2 as ExternalEvent,
      VisitorType$2 as VisitorType,
      SiteUrl$2 as SiteUrl,
      Form$2 as Form,
      InputControl$2 as InputControl,
      InputControlType$2 as InputControlType,
      Input$2 as Input,
      ValueType$2 as ValueType,
      OptionSelection$2 as OptionSelection,
      OptionSelectionSelectedOptionOneOf$2 as OptionSelectionSelectedOptionOneOf,
      Label$2 as Label,
      FormMessages$2 as FormMessages,
      RsvpFormMessages$2 as RsvpFormMessages,
      PositiveResponseConfirmation$2 as PositiveResponseConfirmation,
      NegativeResponseConfirmation$2 as NegativeResponseConfirmation,
      Positive$2 as Positive,
      Negative$2 as Negative,
      CheckoutFormMessages$2 as CheckoutFormMessages,
      ResponseConfirmation$2 as ResponseConfirmation,
      RegistrationClosedMessages$2 as RegistrationClosedMessages,
      TicketsUnavailableMessages$2 as TicketsUnavailableMessages,
      Dashboard$2 as Dashboard,
      RsvpSummary$2 as RsvpSummary,
      TicketingSummary$2 as TicketingSummary,
      GuestListConfig$2 as GuestListConfig,
      Feed$2 as Feed,
      OnlineConferencing$2 as OnlineConferencing,
      OnlineConferencingConfig$2 as OnlineConferencingConfig,
      ConferenceType$2 as ConferenceType,
      OnlineConferencingSession$2 as OnlineConferencingSession,
      SeoSettings$2 as SeoSettings,
      SeoSchema$2 as SeoSchema,
      Keyword$2 as Keyword,
      Tag$2 as Tag,
      Settings$2 as Settings,
      Agenda$2 as Agenda,
      Category$2 as Category,
      CategoryCounts$2 as CategoryCounts,
      State$2 as State,
      EventDisplaySettings$2 as EventDisplaySettings,
      LabellingSettings$2 as LabellingSettings,
      Empty$2 as Empty,
      EventDeleted$2 as EventDeleted,
      DomainEvent$2 as DomainEvent,
      DomainEventBodyOneOf$2 as DomainEventBodyOneOf,
      EntityCreatedEvent$2 as EntityCreatedEvent,
      RestoreInfo$2 as RestoreInfo,
      EntityUpdatedEvent$2 as EntityUpdatedEvent,
      EntityDeletedEvent$2 as EntityDeletedEvent,
      ActionEvent$2 as ActionEvent,
      eventsV2Rsvp_universal_d_BulkUpdateRsvpContactIdRequest as BulkUpdateRsvpContactIdRequest,
      eventsV2Rsvp_universal_d_BulkUpdateRsvpContactIdResponse as BulkUpdateRsvpContactIdResponse,
      MessageEnvelope$2 as MessageEnvelope,
      IdentificationData$2 as IdentificationData,
      IdentificationDataIdOneOf$2 as IdentificationDataIdOneOf,
      WebhookIdentityType$2 as WebhookIdentityType,
      eventsV2Rsvp_universal_d_searchRsvps as searchRsvps,
      eventsV2Rsvp_universal_d_SearchRsvpsOptions as SearchRsvpsOptions,
      eventsV2Rsvp_universal_d_queryRsvps as queryRsvps,
      eventsV2Rsvp_universal_d_QueryRsvpsOptions as QueryRsvpsOptions,
      eventsV2Rsvp_universal_d_RsvpsQueryResult as RsvpsQueryResult,
      eventsV2Rsvp_universal_d_RsvpsQueryBuilder as RsvpsQueryBuilder,
      eventsV2Rsvp_universal_d_countRsvps as countRsvps,
      eventsV2Rsvp_universal_d_CountRsvpsOptions as CountRsvpsOptions,
      eventsV2Rsvp_universal_d_getRsvp as getRsvp,
      eventsV2Rsvp_universal_d_GetRsvpOptions as GetRsvpOptions,
      eventsV2Rsvp_universal_d_createRsvp as createRsvp,
      eventsV2Rsvp_universal_d_CreateRsvpOptions as CreateRsvpOptions,
      eventsV2Rsvp_universal_d_updateRsvp as updateRsvp,
      eventsV2Rsvp_universal_d_UpdateRsvp as UpdateRsvp,
      eventsV2Rsvp_universal_d_UpdateRsvpOptions as UpdateRsvpOptions,
      eventsV2Rsvp_universal_d_deleteRsvp as deleteRsvp,
      eventsV2Rsvp_universal_d_bulkUpdateRsvp as bulkUpdateRsvp,
      eventsV2Rsvp_universal_d_BulkUpdateRsvpOptions as BulkUpdateRsvpOptions,
      eventsV2Rsvp_universal_d_bulkDeleteRsvpsByFilter as bulkDeleteRsvpsByFilter,
      eventsV2Rsvp_universal_d_BulkDeleteRsvpsByFilterOptions as BulkDeleteRsvpsByFilterOptions,
      eventsV2Rsvp_universal_d_checkInRsvpGuests as checkInRsvpGuests,
      eventsV2Rsvp_universal_d_CheckInRsvpGuestsOptions as CheckInRsvpGuestsOptions,
      eventsV2Rsvp_universal_d_cancelRsvpGuestsCheckIn as cancelRsvpGuestsCheckIn,
      eventsV2Rsvp_universal_d_CancelRsvpGuestsCheckInOptions as CancelRsvpGuestsCheckInOptions,
      eventsV2Rsvp_universal_d_listRsvpSummary as listRsvpSummary,
      eventsV2Rsvp_universal_d_ListRsvpSummaryOptions as ListRsvpSummaryOptions,
    };
  }
  
  interface V3Event {
      /**
       * Event ID.
       * @readonly
       */
      _id?: string;
      /** Event location. */
      location?: Location$1;
      /** Event date and time settings. */
      dateAndTimeSettings?: DateAndTimeSettings$1;
      /** Event title. */
      title?: string | null;
      /** Short description that appears under the event title. */
      shortDescription?: string | null;
      /**
       * Detailed description of an event. You can enter the description using rich text format (add various types of markups, such as underlines, italics, bolding, color codes, bullet lists, and links by using HTML formatting tags).
       * @deprecated Detailed description of an event.
       *
       * This field is deprecated. To create a description, see the flow in [introduction](https://dev.wix.com/docs/rest/business-solutions/events/events-v3/introduction).
       * @replacedBy wix.events.v1.rich_content
       * @targetRemovalDate 2025-06-01
       */
      detailedDescription?: string | null;
      /**
       * Main event image. <br>
       * **Note:** This field is returned only when the `DETAILS` fieldset is included in the request.
       */
      mainImage?: string;
      /**
       * Unique identifier of the event page. The naming is the same as the event title written in kebab case. For example, if your event title is "Leather Crafting 101", then the slug is "leather-crafting-101".
       * @readonly
       */
      slug?: string;
      /**
       * Date and time when the event was created.
       * @readonly
       */
      _createdDate?: Date | null;
      /**
       * Date and time when the event was updated.
       * @readonly
       */
      _updatedDate?: Date | null;
      /**
       * Event status:
       *
       *   - `UPCOMING`: Event is published and scheduled to start.
       *   - `STARTED`: Event has started.
       *   - `ENDED`: Event has ended.
       *   - `CANCELED`: Event is canceled.
       *   - `DRAFT`: Event is not published.
       * @readonly
       */
      status?: Status$1;
      /**
       * RSVP or ticketing registration details. <br>
       * **Note:** This field is returned only when the `REGISTRATION` fieldset is included in the request.
       */
      registration?: Registration$1;
      /**
       * URLs that allow you to add an event to the Google calendar, or to download an [ICS calendar](https://icscalendar.com/) file. <br>
       * **Note:** This field is returned only when the `DETAILS` fieldset is included in the request.
       * @readonly
       */
      calendarUrls?: CalendarUrls;
      /**
       * Event page URL components. <br>
       * **Note:** This field is returned only when the `URLS` fieldset is included in the request.
       */
      eventPageUrl?: string;
      /**
       * Event registration form. <br>
       * **Note:** This field is returned only when the `FORM` fieldset is included in the request.
       */
      form?: Form$1;
      /**
       * Summary of RSVP or ticket sales. <br>
       * **Note:** This field is returned only when the `DASHBOARD` fieldset is included in the request and you have the "WIX_EVENTS.READ_EVENT_DASHBOARD" permissions.
       */
      summaries?: Summaries;
      /**
       * Instance ID of the site where the event is hosted.
       * @readonly
       */
      instanceId?: string;
      /** Guest list configuration. */
      guestListSettings?: GuestListSettings;
      /**
       * ID of the user who created the event.
       * @readonly
       */
      userId?: string;
      /**
       * Event discussion feed. For internal use.
       * @internal
       */
      feed?: Feed$1;
      /**
       * Online conferencing details. <br>
       * **Note:** This field is returned only when the `ONLINE_CONFERENCING_SESSION` fieldset is included in the request and you have the "WIX_EVENTS.READ_ONLINE_CONFERENCING" permissions.
       */
      onlineConferencing?: OnlineConferencing$1;
      /**
       * SEO settings. <br>
       * **Note:** This field is returned only when the `SEO_SETTINGS` fieldset is included in the request.
       */
      seoSettings?: SeoSettings$1;
      /**
       * Assigned contacts label key.
       * @readonly
       */
      contactLabel?: string | null;
      /**
       * Event schedule details. <br>
       * **Note:** This field is returned only when the `AGENDA` fieldset is included in the request.
       */
      agendaSettings?: AgendaSettings;
      /**
       * Event categories.
       * @internal
       */
      categories?: EventCategories;
      /** Visual settings for event. */
      eventDisplaySettings?: V3EventDisplaySettings;
      /**
       * True if ticket can be customised
       * @internal
       */
      customizableTickets?: boolean | null;
      /**
       * Labelling related data.
       * @internal
       */
      labellingSettings?: V3LabellingSettings;
  }
  interface Location$1 {
      /** Location name. This value is displayed instead of the address when the location is defined as TBD by setting the `locationTbd` property to `true`. */
      name?: string | null;
      /**
       * Location type:
       *
       *   - `VENUE`: The event is on-site at a specific physical location.
       *   - `ONLINE`: The event is online, such as a virtual video conference.
       */
      type?: LocationType$1;
      /** Exact location address. */
      address?: CommonAddress$1;
      /** Whether the event location is TBD. */
      locationTbd?: boolean | null;
  }
  enum LocationType$1 {
      /** Unknown location type. */
      UNKNOWN_LOCATION = "UNKNOWN_LOCATION",
      /** Event is on-site at a specific physical location. */
      VENUE = "VENUE",
      /** Event is online, such as a virtual video conference. */
      ONLINE = "ONLINE"
  }
  /** Physical address */
  interface CommonAddress$1 extends CommonAddressStreetOneOf$1 {
      /** Street address. */
      streetAddress?: CommonStreetAddress$1;
      /** Primary address information (street and building number). */
      addressLine1?: string | null;
      /** 2-letter country code in [ISO-3166 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2#Officially_assigned_code_elements) format. */
      country?: string | null;
      /** Code for a subdivision (such as state, prefecture, or province) in [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). */
      subdivision?: string | null;
      /** City name. */
      city?: string | null;
      /** Zip or postal code. */
      postalCode?: string | null;
      /** Secondary address information (suite or apartment number and room number). */
      addressLine2?: string | null;
      /**
       * A string containing the full address of this location.
       * @internal
       */
      formatted?: string | null;
      /**
       * Coordinates of the physical address.
       * @internal
       */
      location?: CommonAddressLocation$1;
      /**
       * Country full name.
       * @internal
       */
      countryFullname?: string | null;
      /**
       * Subdivision full name.
       * @internal
       */
      subdivisionFullname?: string | null;
      /**
       * Multi-level subdivisions from top to bottom.
       * @internal
       */
      subdivisions?: CommonSubdivision$1[];
  }
  /** @oneof */
  interface CommonAddressStreetOneOf$1 {
      /** Street address. */
      streetAddress?: CommonStreetAddress$1;
      /** Primary address information (street and building number). */
      addressLine?: string | null;
  }
  interface CommonStreetAddress$1 {
      /** Street number. */
      number?: string;
      /** Street name. */
      name?: string;
      /**
       * Apartment number.
       * @internal
       */
      apt?: string;
      /**
       * Optional address line 1
       * @internal
       */
      formattedAddressLine?: string | null;
  }
  interface CommonAddressLocation$1 {
      /** Address latitude coordinates. */
      latitude?: number | null;
      /** Address longitude coordinates. */
      longitude?: number | null;
  }
  interface CommonSubdivision$1 {
      /** Short subdivision code. */
      code?: string;
      /** Subdivision full name. */
      name?: string;
      /**
       * Subdivision level
       * @internal
       */
      type?: SubdivisionSubdivisionType$1;
      /**
       * Free text description of subdivision type.
       * @internal
       */
      typeInfo?: string | null;
  }
  enum SubdivisionSubdivisionType$1 {
      UNKNOWN_SUBDIVISION_TYPE = "UNKNOWN_SUBDIVISION_TYPE",
      /** State */
      ADMINISTRATIVE_AREA_LEVEL_1 = "ADMINISTRATIVE_AREA_LEVEL_1",
      /** County */
      ADMINISTRATIVE_AREA_LEVEL_2 = "ADMINISTRATIVE_AREA_LEVEL_2",
      /** City/town */
      ADMINISTRATIVE_AREA_LEVEL_3 = "ADMINISTRATIVE_AREA_LEVEL_3",
      /** Neighborhood/quarter */
      ADMINISTRATIVE_AREA_LEVEL_4 = "ADMINISTRATIVE_AREA_LEVEL_4",
      /** Street/block */
      ADMINISTRATIVE_AREA_LEVEL_5 = "ADMINISTRATIVE_AREA_LEVEL_5",
      /** ADMINISTRATIVE_AREA_LEVEL_0. Indicates the national political entity, and is typically the highest order type returned by the Geocoder. */
      COUNTRY = "COUNTRY"
  }
  interface DateAndTimeSettings$1 {
      /** Whether the event date and time are TBD. */
      dateAndTimeTbd?: boolean | null;
      /** Message that is displayed when time and date is TBD. */
      dateAndTimeTbdMessage?: string | null;
      /** Event start date. */
      startDate?: Date | null;
      /** Event end date. */
      endDate?: Date | null;
      /** Event time zone ID in the [TZ database](https://www.iana.org/time-zones) format. */
      timeZoneId?: string | null;
      /** Whether the end date is hidden in the formatted date and time. */
      hideEndDate?: boolean | null;
      /** Whether the time zone is displayed in the formatted schedule. */
      showTimeZone?: boolean | null;
      /**
       * Repeating event status. Possible values:
       *
       *   - `ONE_TIME`: The event happens only once and can last multiple days.
       *   - `RECURRING`: A series of events that repeat.
       *   - `RECURRING_UPCOMING`: Next event in a schedule of recurring events.
       *   - `RECURRING_RECENTLY_ENDED`: Latest event that ended in a schedule of recurring events.
       *   - `RECURRING_RECENTLY_CANCELED`: Latest canceled event tin a schedule of recurring events.
       * @readonly
       */
      recurrenceStatus?: RecurrenceStatusStatus$1;
      /** Event repetitions. */
      recurringEvents?: Recurrences$1;
      /** Formatted date and time settings. */
      formatted?: Formatted$1;
  }
  enum RecurrenceStatusStatus$1 {
      /** Unknown recurrance status. */
      UNKNOWN_STATUS = "UNKNOWN_STATUS",
      /** Event happens only once and can last multiple days. */
      ONE_TIME = "ONE_TIME",
      /** A series of events that repeat. */
      RECURRING = "RECURRING",
      /** Next event in a schedule of recurring events. */
      RECURRING_UPCOMING = "RECURRING_UPCOMING",
      /** Latest event that ended in a schedule of recurring events. */
      RECURRING_RECENTLY_ENDED = "RECURRING_RECENTLY_ENDED",
      /** Latest canceled event in a schedule of recurring events */
      RECURRING_RECENTLY_CANCELED = "RECURRING_RECENTLY_CANCELED"
  }
  interface Recurrences$1 {
      /** Individual event dates info. */
      individualEventDates?: Occurrence$1[];
      /**
       * Recurring event category ID.
       * @readonly
       */
      categoryId?: string | null;
  }
  interface Occurrence$1 {
      /** Event start date. */
      startDate?: Date | null;
      /** Event end date. */
      endDate?: Date | null;
      /** Event time zone ID in the [TZ database](https://www.iana.org/time-zones) format. */
      timeZoneId?: string | null;
      /** Whether the time zone is displayed in a formatted schedule. */
      showTimeZone?: boolean;
  }
  interface Formatted$1 {
      /**
       * Formatted date and time representation.
       *
       * Example of formatting when an event lasts multiple days and is in the UTC time zone: `September 1, 2015 at 10:20 AM – September 5, 2015 at 12:14 PM`.
       * Example of formatting when an event lasts 1 day and is in the GMT+2 time zone: `February 1, 2018, 12:10 – 2:50 PM GMT+2`.
       * @readonly
       */
      dateAndTime?: string | null;
      /**
       * Formatted start date of the event. Empty for TBD schedules.
       * @readonly
       */
      startDate?: string | null;
      /**
       * Formatted start time of the event. Empty for TBD schedules.
       * @readonly
       */
      startTime?: string | null;
      /**
       * Formatted end date of the event. Empty for TBD schedules or when the end date is hidden.
       * @readonly
       */
      endDate?: string | null;
      /**
       * Formatted end time of the event. Empty for TBD schedules or when the end date is hidden.
       * @readonly
       */
      endTime?: string | null;
  }
  /**
   * A coarse-grained representation of time duration divided into whole constituting components of days, hours, and minutes.
   * For example, 25.5 hours duration is represented as `{ days: 1, hours: 1, minutes: 30 }`.
   */
  interface TimeDuration {
      /** Number of days. */
      days?: number;
      /** Number of hours. */
      hours?: number;
      /** Number of minutes. */
      minutes?: number;
  }
  enum Status$1 {
      /** Unknown event status. */
      UNKNOWN_EVENT_STATUS = "UNKNOWN_EVENT_STATUS",
      /** Event is published and scheduled to start. */
      UPCOMING = "UPCOMING",
      /** Event has started. */
      STARTED = "STARTED",
      /** Event has ended. */
      ENDED = "ENDED",
      /** Event is canceled. */
      CANCELED = "CANCELED",
      /** Event is not public. */
      DRAFT = "DRAFT"
  }
  interface Registration$1 {
      /**
       * Current registration type:
       *
       *   - `RSVP`: Guests register by RSVPing to the event.
       *   - `TICKETING`: Guests register by buying tickets.
       *   - `EXTERNAL`: Guests register externally using some other site or platform.
       *   - `NONE`: No registration is required, all guests can attend. This registration type is for only displaying the event details on a site.
       *
       * The property value might change to `EXTERNAL` or `NONE` after initial event creation, depending on any additional configuration applied to the event.
       * @readonly
       */
      type?: RegistrationTypeType;
      /**
       * Registration status. Possible values:
       *
       *   - `CLOSED_AUTOMATICALLY`: Registration is closed after tickets are sold out.
       *   - `CLOSED_MANUALLY`: Registration is closed when the `registration.registrationDisabled` property is set to `true`.
       *   - `OPEN_RSVP`: Guests can start RSVPing to the event.
       *   - `OPEN_RSVP_WAITLIST_ONLY`: Guest list has reached the maximum, new guests are added to a waitlist.
       *   - `OPEN_TICKETS`: Guests can buy tickets to the event.
       *   - `OPEN_EXTERNAL`: Guests register on a different page or web address.
       *   - `SCHEDULED_RSVP`: Registration via RSVP is scheduled for the future.
       * @readonly
       */
      status?: RegistrationStatusStatus;
      /** RSVP registration details. */
      rsvp?: RsvpRegistration;
      /** Ticket registration details. */
      tickets?: TicketsRegistration;
      /** External registration details. */
      external?: ExternalRegistration;
      /**
       * Types of guests allowed to register. Possible values:
       *
       *   - `VISITOR_OR_MEMBER`: All site visitors can RSVP to the event.
       *   - `MEMBER`: Only people who have signed up as members of your site are able to RSVP to the event.
       */
      allowedGuestTypes?: GuestTypeType;
      /**
       * Initial event type which is set when creating an event. Possible values:
       *
       *   - `RSVP`: Guests register by RSVPing to the event.
       *   - `TICKETING`: Guests register by buying tickets.
       *
       *   This property value never changes.
       */
      initialType?: InitialRegistrationTypeType;
      /** Whether the registration is paused. */
      registrationPaused?: boolean;
      /** Whether the registration is disabled. */
      registrationDisabled?: boolean;
  }
  enum RegistrationTypeType {
      /** Unknown registration type. */
      UNKNOWN_REGISTRATION_TYPE = "UNKNOWN_REGISTRATION_TYPE",
      /** Guests register by RSVPing to the event. */
      RSVP = "RSVP",
      /** Guests register by buying tickets. */
      TICKETING = "TICKETING",
      /** Guests register externally using some other site or platform. */
      EXTERNAL = "EXTERNAL",
      /** No registration is required, all guests can attend. This registration type is for only displaying the event details on a site. The property value can be changed from RSVP/TICKETING to EXTERNAL or NONE after the event is created, depending on any additional configurations applied to the event. */
      NONE = "NONE"
  }
  enum RegistrationStatusStatus {
      /** Registration status is not applicable */
      UNKNOWN_REGISTRATION_STATUS = "UNKNOWN_REGISTRATION_STATUS",
      /** Registration is closed after tickets are sold out. */
      CLOSED_AUTOMATICALLY = "CLOSED_AUTOMATICALLY",
      /** Registration is closed when the `registration.registrationDisabled` property is set to `true`. */
      CLOSED_MANUALLY = "CLOSED_MANUALLY",
      /** Guests can start RSVPing to the event. */
      OPEN_RSVP = "OPEN_RSVP",
      /** Guest list has reached the maximum, new guests are added to a waitlist. */
      OPEN_RSVP_WAITLIST_ONLY = "OPEN_RSVP_WAITLIST_ONLY",
      /** Guests can buy tickets to the event. */
      OPEN_TICKETS = "OPEN_TICKETS",
      /** Guests register on a different page or web address. */
      OPEN_EXTERNAL = "OPEN_EXTERNAL",
      /** Registration via RSVP is scheduled for the future. */
      SCHEDULED_RSVP = "SCHEDULED_RSVP"
  }
  interface RsvpRegistration {
      /** Available answers for registration to an event. */
      responseType?: ResponseType;
      /** How many guests can RSVP to an event. */
      limit?: number | null;
      /** Whether a waitlist is opened when the total guest limit is reached. If `true`, guests can RSVP to an event and are automatically put in the waitlist with the `IN_WAITLIST` status. */
      waitlistEnabled?: boolean;
      /** Registration start date. */
      startDate?: Date | null;
      /** Registration end date. */
      endDate?: Date | null;
  }
  enum ResponseType {
      /** Unknown response type. */
      UNKNOWN_RESPONSE_TYPE = "UNKNOWN_RESPONSE_TYPE",
      /** Only a **Yes** answer is available to select when RSVP'ing to an event. */
      YES_ONLY = "YES_ONLY",
      /** *Yes** and **No** answers are available to select when RSVP'ing to an event. */
      YES_AND_NO = "YES_AND_NO"
  }
  interface TicketsRegistration {
      /** Whether the registration form must be filled out separately for each ticket. */
      guestsAssignedSeparately?: boolean;
      /**
       * Ticket limit per order.
       * Default: 20 tickets.
       */
      ticketLimitPerOrder?: number;
      /**
       * App ID for external ticket stock management.
       * The default ticket stock value is as defined in the `TicketDefinition` object. If the ticket stock is defined in the stock manager app, the default is ignored.
       * @internal
       */
      stockManagerAppId?: string | null;
      /** Ticket price currency. */
      currency?: string | null;
      /**
       * Lowest ticket price.
       * @readonly
       */
      lowestPrice?: Money$1;
      /**
       * Highest ticket price.
       * @readonly
       */
      highestPrice?: Money$1;
      /**
       * Whether all tickets are sold for the event.
       * @readonly
       */
      soldOut?: boolean | null;
      /** How tax is applied. */
      taxSettings?: TaxSettings;
  }
  /**
   * Money.
   * Default format to use. Sufficiently compliant with majority of standards: w3c, ISO 4217, ISO 20022, ISO 8583:2003.
   */
  interface Money$1 {
      /** Amount of money in decimal form. A period is used as a decimal separator (for example, `3.99`). */
      value?: string;
      /** Currency code in 3-letter [ISO-4217 alphabetic](https://en.wikipedia.org/wiki/ISO_4217#Active_codes) format. */
      currency?: string;
      /**
       * Amount of money in decimal form. A period or comma are used as a decimal separator (for example, `1 000,30`).
       * @readonly
       */
      formattedValue?: string | null;
  }
  interface TaxSettings {
      /**
       * Tax application settings:
       *
       *   - `INCLUDED_IN_PRICE`: Deduct the fee from the ticket price for a seller. For example, if you're selling tickets for $10, a ticket service fee of $0.25 is deducted from the price and you'll get $9.75.
       *   - `ADDED_AT_CHECKOUT`: Show the fee iin addition to the ticket price at checkout and a guest pays the fee. For example, if you sell tickets for $10, a customer sees a ticket service fee of $0.25 and pays $10.25 in total.
       */
      type?: TaxType$1;
      /** Tax name. */
      name?: string | null;
      /** Tax rate (for example,`21.55`). */
      rate?: string | null;
      /** Apply tax to donations. */
      appliedToDonations?: boolean | null;
  }
  /** Tax application settings. */
  enum TaxType$1 {
      /** Unknown tax type. */
      UNKNOWN_TAX_TYPE = "UNKNOWN_TAX_TYPE",
      /** Deduct the fee from the ticket price for a seller. For example, if you're selling tickets for $10, a ticket ticket service fee of $0.25 is deducted from the price and you'll get $9.75. */
      INCLUDED_IN_PRICE = "INCLUDED_IN_PRICE",
      /** Show the fee in addition to the ticket price at checkout and a guest pays the fee. For example, if you sell tickets for $10, a customer sees a ticket ticket service fee of $0.25 and pays $10.25 in total. */
      ADDED_AT_CHECKOUT = "ADDED_AT_CHECKOUT"
  }
  interface ExternalRegistration {
      /** External event registration URL. */
      url?: string | null;
  }
  enum GuestTypeType {
      /** Unknown guest type. */
      UNKNOWN_GUEST_TYPE = "UNKNOWN_GUEST_TYPE",
      /** All site visitors can RSVP to the event. */
      VISITOR_OR_MEMBER = "VISITOR_OR_MEMBER",
      /** Only people who have signed up as members of your site are able to RSVP to the event. */
      MEMBER = "MEMBER"
  }
  enum InitialRegistrationTypeType {
      /** Unknown initial registration type. */
      UNKNOWN_INITIAL_REGISTRATION_TYPE = "UNKNOWN_INITIAL_REGISTRATION_TYPE",
      /** Guests register by RSVPing to the event. */
      RSVP = "RSVP",
      /** Guests register by buying tickets. This property value never changes. */
      TICKETING = "TICKETING"
  }
  interface CalendarUrls {
      /**
       * "Add to Google calendar" URL.
       * @readonly
       */
      google?: string;
      /**
       * "Download ICS calendar file" URL.
       * @readonly
       */
      ics?: string;
  }
  /**
   * The form defines which elements are rendered in the Wix UI during the registration process (RSVP or checkout).
   * It also contains customizable messages and labels.
   *
   *
   * A form is an ordered list of controls (blocks), which accept guest information into a field input.
   *
   * Each control contains one or more nested inputs. For example, `Name` control has two inputs:
   * - First Name
   * - Last Name
   *
   * By default, name and email controls are always required and are pinned to the top of the form.
   */
  interface Form$1 {
      /** Nested fields as an ordered list. */
      controls?: InputControl$1[];
      /** Set of configured form messages. */
      messages?: FormMessages$1;
  }
  /**
   * A block of nested fields.
   * Used to aggregate similar inputs like First Name and Last Name.
   */
  interface InputControl$1 {
      /** Field control type. */
      type?: InputControlType$1;
      /** Whether control is mandatory (such as name & email). When true, only label can be changed. */
      system?: boolean;
      /**
       * Deprecated: Use `id`.
       * @deprecated
       */
      name?: string;
      /** Child inputs. */
      inputs?: Input$1[];
      /**
       * Deprecated: use `inputs.label`.
       * @deprecated
       */
      label?: string;
      /** Field controls are sorted by this value in ascending order. */
      orderIndex?: number;
      /** Unique control ID. */
      _id?: string;
      /**
       * Whether input control is deleted.
       * @readonly
       */
      deleted?: boolean | null;
  }
  enum InputControlType$1 {
      /** Single text value field. */
      INPUT = "INPUT",
      /** Single text value field. */
      TEXTAREA = "TEXTAREA",
      /** Single-choice field of predefined values. */
      DROPDOWN = "DROPDOWN",
      /** Single-choice field of predefined values. */
      RADIO = "RADIO",
      /** Multiple-choice field of predefined values. */
      CHECKBOX = "CHECKBOX",
      /** First and last name fields. */
      NAME = "NAME",
      /** Additional guests and respective guest names fields. */
      GUEST_CONTROL = "GUEST_CONTROL",
      /** Single-line address field. */
      ADDRESS_SHORT = "ADDRESS_SHORT",
      /** Full address field. */
      ADDRESS_FULL = "ADDRESS_FULL",
      /** Year, month and day fields. */
      DATE = "DATE"
  }
  /** An input of one or multiple text values */
  interface Input$1 {
      /** Field name. */
      name?: string;
      /**
       * Deprecated: use `ValueType.TEXT_ARRAY`.
       * @deprecated
       */
      array?: boolean;
      /** Main field label */
      label?: string;
      /** Additional labels for multi-valued fields such as address. */
      additionalLabels?: Record<string, string>;
      /** Predefined choice options for fields, such as dropdown. */
      options?: string[];
      /** Whether field is mandatory. */
      mandatory?: boolean;
      /** Maximum number of accepted characters (relevant for text fields). */
      maxLength?: number;
      /**
       * Type which determines field format.
       * Used to validate submitted response.
       */
      type?: ValueType$1;
      /**
       * A maximum accepted values for array input.
       * Only applicable for inputs of valueType: TEXT_ARRAY.
       */
      maxSize?: number | null;
      /**
       * Preselected option.
       * Currently only applicable for dropdown.
       */
      defaultOptionSelection?: OptionSelection$1;
      /**
       * Additional labels for multi-valued fields such as address.
       * @readonly
       */
      labels?: Label$1[];
  }
  enum ValueType$1 {
      TEXT = "TEXT",
      NUMBER = "NUMBER",
      TEXT_ARRAY = "TEXT_ARRAY",
      DATE_TIME = "DATE_TIME",
      ADDRESS = "ADDRESS"
  }
  /**
   * Describes initially selected option when an input has multiple choices.
   * Defaults to first (0th) option if not configured.
   */
  interface OptionSelection$1 extends OptionSelectionSelectedOptionOneOf$1 {
      /** 0-based index from predefined `input.options` which is selected initially. */
      optionIndex?: number;
      /**
       * Placeholder hint describing expected choices (such as "Please select").
       * Considered an empty choice.
       */
      placeholderText?: string;
  }
  /** @oneof */
  interface OptionSelectionSelectedOptionOneOf$1 {
      /** 0-based index from predefined `input.options` which is selected initially. */
      optionIndex?: number;
      /**
       * Placeholder hint describing expected choices (such as "Please select").
       * Considered an empty choice.
       */
      placeholderText?: string;
  }
  interface Label$1 {
      /** Field name. */
      name?: string;
      /** Field label. */
      label?: string;
  }
  /**
   * Defines form messages shown in UI before, during, and after registration flow.
   * It enables configuration of form titles, response labels, "thank you" messages, and call-to-action texts.
   */
  interface FormMessages$1 {
      /** RSVP form messages. */
      rsvp?: RsvpFormMessages$1;
      /** Checkout form messages. */
      checkout?: CheckoutFormMessages$1;
      /** Messages shown when event registration is closed. */
      registrationClosed?: RegistrationClosedMessages$1;
      /** Messages shown when event tickets are unavailable. */
      ticketsUnavailable?: TicketsUnavailableMessages$1;
  }
  interface RsvpFormMessages$1 {
      /** Label text indicating RSVP `YES` response. */
      rsvpYesOption?: string;
      /** Label text indicating RSVP `NO` response. */
      rsvpNoOption?: string;
      /** Messages shown for RSVP = `YES`. */
      positiveMessages?: Positive$1;
      /** Messages shown for RSVP = `WAITING` (when event is full and waitlist is available). */
      waitlistMessages?: Positive$1;
      /** Messages shown for RSVP = `NO`. */
      negativeMessages?: Negative$1;
      /** "Submit form" call-to-action label text. */
      submitActionLabel?: string;
  }
  /** Confirmation messages shown after registration. */
  interface PositiveResponseConfirmation$1 {
      /** Confirmation message title. */
      title?: string;
      /** Confirmation message text. */
      message?: string;
      /** "Add to calendar" call-to-action label text. */
      addToCalendarActionLabel?: string;
      /** "Share event" call-to-action label text. */
      shareActionLabel?: string;
  }
  /** Confirmation messages shown after registration. */
  interface NegativeResponseConfirmation$1 {
      /** Confirmation message title. */
      title?: string;
      /** "Share event" call-to-action label text. */
      shareActionLabel?: string;
  }
  /** Set of messages shown during registration when RSVP response is positive. */
  interface Positive$1 {
      /** Main form title for positive response. */
      title?: string;
      /** Confirmation messages shown after registration. */
      confirmation?: PositiveResponseConfirmation$1;
  }
  /** A set of messages shown during registration with negative response */
  interface Negative$1 {
      /** Main form title for negative response. */
      title?: string;
      /** Confirmation messages shown after registration. */
      confirmation?: NegativeResponseConfirmation$1;
  }
  interface CheckoutFormMessages$1 {
      /** Main form title for response. */
      title?: string;
      /** Submit form call-to-action label text. */
      submitActionLabel?: string;
      /** Confirmation messages shown after checkout. */
      confirmation?: ResponseConfirmation$1;
  }
  /** Confirmation messages shown after checkout. */
  interface ResponseConfirmation$1 {
      /** Confirmation message title. */
      title?: string;
      /** Confirmation message text. */
      message?: string;
      /** "Download tickets" call-to-action label text. */
      downloadTicketsLabel?: string;
      /** "Add to calendar" call-to-action label text. */
      addToCalendarLabel?: string;
      /** "Share event" call-to-action label text. */
      shareEventLabel?: string;
  }
  interface RegistrationClosedMessages$1 {
      /** Message shown when event registration is closed. */
      message?: string;
      /** "Explore other events" call-to-action label text. */
      exploreEventsActionLabel?: string;
  }
  interface TicketsUnavailableMessages$1 {
      /** Message shown when event tickets are unavailable. */
      message?: string;
      /** "Explore other events" call-to-action label text. */
      exploreEventsActionLabel?: string;
  }
  interface Summaries {
      /** RSVP summary of guests. */
      rsvps?: Rsvps;
      /** Summary of revenue and sold tickets. Archived orders are not included. */
      tickets?: Tickets;
  }
  interface EventsMoney {
      /**
       * *Deprecated:** Use `value` instead.
       * @deprecated
       */
      amount?: string;
      /** ISO 4217 format of the currency e.g., `USD`. */
      currency?: string;
      /** Monetary amount. Decimal string with a period as a decimal separator (e.g., 3.99). Optionally, starts with a single (-), to indicate that the amount is negative. */
      value?: string | null;
  }
  interface Rsvps {
      /**
       * Total number of RSVPs.
       * @readonly
       */
      totalCount?: number;
      /**
       * Number of RSVPs with status `YES`.
       * @readonly
       */
      yesCount?: number;
      /**
       * Number of RSVPs with status `NO`.
       * @readonly
       */
      noCount?: number;
      /**
       * Number of RSVPs in a waitlist.
       * @readonly
       */
      waitlistCount?: number;
  }
  interface Tickets {
      /**
       * Number of sold tickets.
       * @readonly
       */
      ticketsSold?: number;
      /**
       * Total revenue. Taxes and payment provider fees aren't deducted.
       * @readonly
       */
      revenue?: EventsMoney;
      /**
       * Whether the currency is locked and can’t be changed.
       * @readonly
       */
      currencyLocked?: boolean;
      /**
       * Number of orders placed.
       * @readonly
       */
      totalOrders?: number;
      /**
       * Total balance of confirmed transactions.
       * @readonly
       */
      totalSales?: EventsMoney;
  }
  interface GuestListSettings {
      /** Whether the guest list is public for all guests. */
      displayedPublicly?: boolean;
  }
  interface Feed$1 {
      /** Event discussion feed token. */
      token?: string;
  }
  interface OnlineConferencing$1 {
      /** Whether online conferencing is enabled. Not applicable for events, where date and time are TBD. When enabled, links to join the conference are generated and provided to guests. */
      enabled?: boolean;
      /** Conference host ID. */
      providerId?: string | null;
      /**
       * Configured conferencing provider name.
       * @internal
       * @readonly
       */
      providerName?: string;
      /**
       * Conference type. Possible values:
       *
       *   - `MEETING`: Guests can do some actions during the conference, for example talk, turn on camera and show their screen.
       *   - `WEBINAR`: Guests can only watch the conference.
       */
      type?: ConferenceTypeType;
      /** Online conferencing session information. */
      session?: OnlineConferencingSession$1;
  }
  enum ConferenceTypeType {
      /** Default value. This value is unused */
      UNKNOWN_CONFERENCE_TYPE = "UNKNOWN_CONFERENCE_TYPE",
      /** Guests can do some actions during the conference, for example talk, turn on their camera and show their screen. */
      MEETING = "MEETING",
      /** Guests can only watch the conference. */
      WEBINAR = "WEBINAR"
  }
  interface OnlineConferencingSession$1 {
      /**
       * Link for the event host to start the online conference session.
       * @readonly
       */
      hostLink?: string;
      /**
       * Link for guests to join the online conference session.
       * @readonly
       */
      guestLink?: string;
      /**
       * Password required to join the online conferencing session (when relevant).
       * @readonly
       */
      password?: string | null;
      /**
       * Whether the session was created successfully on the event host side.
       * @readonly
       */
      sessionCreated?: boolean | null;
      /**
       * Unique session ID.
       * @readonly
       */
      sessionId?: string | null;
  }
  interface SeoSettings$1 {
      /** URL slug. */
      slug?: string;
      /** Advanced SEO data. */
      advancedSeoData?: SeoSchema$1;
      /**
       * Whether the slug is hidden from the SEO Site Map.
       * @readonly
       */
      hidden?: boolean | null;
  }
  /**
   * The SEO schema object contains data about different types of meta tags. It makes sure that the information about your page is presented properly to search engines.
   * The search engines use this information for ranking purposes, or to display snippets in the search results.
   * This data will override other sources of tags (for example patterns) and will be included in the <head> section of the HTML document, while not being displayed on the page itself.
   */
  interface SeoSchema$1 {
      /** SEO tag information. */
      tags?: Tag$1[];
      /** SEO general settings. */
      settings?: Settings$1;
  }
  interface Keyword$1 {
      /** Keyword value. */
      term?: string;
      /** Whether the keyword is the main focus keyword. */
      isMain?: boolean;
      /** The source that added the keyword terms to the SEO settings. */
      origin?: string | null;
  }
  interface Tag$1 {
      /**
       * SEO tag type.
       *
       *
       * Supported values: `title`, `meta`, `script`, `link`.
       */
      type?: string;
      /**
       * A `{"key": "value"}` pair object where each SEO tag property (`"name"`, `"content"`, `"rel"`, `"href"`) contains a value.
       * For example: `{"name": "description", "content": "the description itself"}`.
       */
      props?: Record<string, any> | null;
      /** SEO tag meta data. For example, `{"height": 300, "width": 240}`. */
      meta?: Record<string, any> | null;
      /** SEO tag inner content. For example, `<title> inner content </title>`. */
      children?: string;
      /** Whether the tag is a custom tag. */
      custom?: boolean;
      /** Whether the tag is disabled. */
      disabled?: boolean;
  }
  interface Settings$1 {
      /**
       * Whether the Auto Redirect feature, which creates `301 redirects` on a slug change, is enabled.
       *
       *
       * Default: `false` (Auto Redirect is enabled.)
       */
      preventAutoRedirect?: boolean;
      /** User-selected keyword terms for a specific page. */
      keywords?: Keyword$1[];
  }
  interface AgendaSettings {
      /** Whether the schedule is enabled for the event. */
      enabled?: boolean;
      /**
       * Schedule page URL.
       * @readonly
       */
      pageUrl?: string;
  }
  interface EventCategories {
      /** Event categories. */
      categories?: EventCategory[];
  }
  interface EventCategory {
      /**
       * Category ID.
       * @readonly
       */
      _id?: string;
      /** Category name. */
      name?: string;
      /**
       * Category creation timestamp.
       * @readonly
       */
      _createdDate?: Date | null;
      /**
       * Category is hidden.
       * @readonly
       */
      hidden?: boolean;
      /**
       * Category type.
       * @readonly
       */
      type?: Type$1;
  }
  enum Type$1 {
      /** Created manually by the user. */
      MANUAL = "MANUAL",
      /** Created automatically when publishing recurring events. */
      RECURRING_EVENT = "RECURRING_EVENT",
      /** Created automatically and used to store component events. */
      COMPONENT = "COMPONENT"
  }
  interface V3EventDisplaySettings {
      /** Whether event details button is hidden. Only available for events with no registration. */
      hideEventDetailsButton?: boolean | null;
      /** Disables event details page visibility. If event has an external registration configured visitors will be redirected from this page. */
      hideEventDetailsPage?: boolean | null;
  }
  interface V3LabellingSettings {
      /**
       * @internal
       * @readonly
       */
      assignedContactsLegacyLabelId?: string | null;
      /**
       * @internal
       * @readonly
       */
      assignedContactsLabelDeleted?: boolean | null;
  }
  interface EventEventStarted {
      /** Event schedule configuration. */
      timestamp?: Date | null;
      /** Event ID. */
      eventId?: string;
  }
  interface EventEventEnded {
      /** Event end timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Event ID. */
      eventId?: string;
  }
  interface EventEventReminder {
      /** Reminder timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Event ID. */
      eventId?: string;
      /** Event location. */
      location?: Location$1;
      /** Event schedule configuration. */
      dateAndTimeSettings?: DateAndTimeSettings$1;
      /** Event title. */
      title?: string;
      /** ID of the user who created the event. */
      userId?: string | null;
      /** Time until the start of event (currently, reminder letter is triggered 1 day before the start of event). */
      startsIn?: TimeDuration;
  }
  interface EventEventPublished {
      /** Event publishing timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Event ID. */
      eventId?: string;
      /** Event status. */
      status?: Status$1;
      /**
       * Event ID. Indicates the original event from which the current event was derived from.
       * Can be used to track the original event and add missing information.
       */
      derivedFromEventId?: string | null;
      /** Event title. */
      title?: string | null;
      /** Short description that appears under the event title. */
      shortDescription?: string | null;
      /** Event location. */
      location?: Location$1;
      /** Event date  and time settings. */
      dateAndTimeSettings?: DateAndTimeSettings$1;
      /** Event page URL components. */
      eventPageUrl?: string;
      /** RSVP or ticketing registration details. */
      registration?: Registration$1;
  }
  interface EventCloned {
      /** Event creation timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Event ID. */
      eventId?: string;
      /** Event location. */
      location?: Location$1;
      /** Event date and time settings. */
      dateAndTimeSettings?: DateAndTimeSettings$1;
      /** Event title. */
      title?: string;
      /** ID of the user who created the event. */
      userId?: string | null;
      /** Event status. */
      status?: Status$1;
      /** Instance ID. Indicates the original app instance from which current event was derived from. */
      derivedFromInstanceId?: string | null;
      /** Event ID. Indicates the original event from which current event was derived from. */
      derivedFromEventId?: string | null;
      /**
       * Map of copied ticket definitions from the original event. <br>
       * Key represents ticket definition ID in the original event. <br>
       * Value represents ticket definition ID in the newly event.
       */
      ticketDefinitions?: Record<string, string>;
  }
  interface EventEventCanceled {
      /** Event cancelation timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Event ID. */
      eventId?: string;
      /** Event title. */
      title?: string;
      /** ID of the user who created the event. */
      userId?: string | null;
  }
  interface CreateEventRequest {
      /** Event data. */
      event: V3Event;
      /** Whether to create the event as a draft. */
      draft?: boolean;
      /** Predefined sets of fields to return. */
      fields?: RequestedFields[];
  }
  enum RequestedFields {
      /** Unknown requested field. */
      UNKNOWN_REQUESTED_FIELD = "UNKNOWN_REQUESTED_FIELD",
      /** Returns `shortDescription`, `mainImage` and `calendarUrls`. */
      DETAILS = "DETAILS",
      /** Returns `detailedDescription`. */
      TEXTS = "TEXTS",
      /** Returns `registration`. */
      REGISTRATION = "REGISTRATION",
      /** Returns `eventPageUrl`. */
      URLS = "URLS",
      /** Returns `form`. */
      FORM = "FORM",
      /** Returns `summaries`. */
      DASHBOARD = "DASHBOARD",
      /** Returns `feed`. */
      FEED = "FEED",
      /** Returns `onlineConferencing.session`. */
      ONLINE_CONFERENCING_SESSION = "ONLINE_CONFERENCING_SESSION",
      /** Returns `seoSettings`. */
      SEO_SETTINGS = "SEO_SETTINGS",
      /** Returns `agendaSettings`. */
      AGENDA = "AGENDA",
      /** Returns `categories`. */
      CATEGORIES = "CATEGORIES",
      CUSTOMIZABLE_TICKETS = "CUSTOMIZABLE_TICKETS"
  }
  interface CreateEventResponse {
      /** Created event. */
      event?: V3Event;
  }
  interface CloneEventRequest {
      /** Event ID. */
      eventId: string;
      /** Field values to be changed when cloning the event. */
      event?: V3Event;
      /**
       * Fields that are included in this parameter are updated, while all other fields stay the same. If paths are not defined, all field values from the `event` object are updated.
       * @internal
       */
      fieldmask?: string[];
      /** Whether to clone the event as a draft. */
      draft?: boolean;
      /** Predefined sets of fields to return. If both `fields` and `fieldsets` are sent in the request, the union of both lists is returned. */
      fields?: RequestedFields[];
  }
  interface CloneEventResponse {
      /** Cloned event. */
      event?: V3Event;
  }
  interface UpdateEventRequest {
      /** Field values to be changed. */
      event?: V3Event;
      /**
       * Fields that are included in this parameter are updated, while all other fields stay the same. If paths are not defined, all field values from the `event` object are updated.
       * @internal
       */
      fieldmask?: string[];
      /** Predefined sets of fields to return. If both `fields` and `fieldsets` are sent in the request, the union of both lists is returned. */
      fields?: RequestedFields[];
  }
  interface UpdateEventResponse {
      /** Updated event. */
      event?: V3Event;
  }
  interface PublishDraftEventRequest {
      /** Event ID. */
      eventId: string;
      /** Predefined sets of fields to return. If both `fields` and `fieldsets` are sent in the request, the union of both lists is returned. */
      fields?: RequestedFields[];
  }
  interface PublishDraftEventResponse {
      /** Published event. */
      event?: V3Event;
  }
  interface CancelEventRequest {
      /** Event ID. */
      eventId: string;
      /** Predefined sets of fields to return. If both `fields` and `fieldsets` are sent in the request, the union of both lists is returned. */
      fields?: RequestedFields[];
  }
  interface CancelEventResponse {
      /** Canceled event. */
      event?: V3Event;
  }
  interface BulkCancelEventsByFilterRequest {
      /** Filter. */
      filter?: QueryV2$1;
  }
  interface QueryV2$1 extends QueryV2PagingMethodOneOf$1 {
      /** Paging options. Can't be used together with `cursorPaging`. */
      paging?: Paging$1;
      /**
       * Filter object in the following format:
       * `"filter" : {
       * "fieldName1": "value1",
       * "fieldName2":{"$operator":"value2"}
       * }`
       */
      filter?: Record<string, any> | null;
      /**
       * Sort object in the following format:
       * `[{"fieldName":"sortField1","order":"ASC"},{"fieldName":"sortField2","order":"DESC"}]`
       */
      sort?: Sorting$1[];
  }
  /** @oneof */
  interface QueryV2PagingMethodOneOf$1 {
      /** Paging options. Can't be used together with `cursorPaging`. */
      paging?: Paging$1;
  }
  interface Sorting$1 {
      /** Name of the field to sort by. */
      fieldName?: string;
      /**
       * Sort order.
       * Use `ASC` for ascending order or `DESC` for descending order.
       *
       * Default: `ASC`.
       */
      order?: SortOrder$1;
  }
  enum SortOrder$1 {
      ASC = "ASC",
      DESC = "DESC"
  }
  interface Paging$1 {
      /** Number of items to return. See [Paging](https://dev.wix.com/api/rest/getting-started/sorting-and-paging#getting-started_sorting-and-paging_paging) for more information. */
      limit?: number | null;
      /** Number of items to skip in the current sort order. */
      offset?: number | null;
  }
  interface BulkCancelEventsByFilterResponse {
  }
  interface DeleteEventRequest {
      /** Event ID. */
      eventId: string;
  }
  interface DeleteEventResponse {
      /** Deleted event ID. */
      eventId?: string;
  }
  interface BulkDeleteEventsByFilterRequest {
      /** Query options. See [API Query Language](https://dev.wix.com/api/rest/getting-started/api-query-language) for more details. */
      filter?: QueryV2$1;
  }
  interface BulkDeleteEventsByFilterResponse {
  }
  interface QueryEventsRequest {
      /** Query options. See [API Query Language](https://dev.wix.com/api/rest/getting-started/api-query-language) for more details. */
      query?: QueryV2$1;
      /** Predefined sets of fields to return. */
      fields?: RequestedFields[];
      /**
       * Whether draft events should be returned in the response. <br>
       * **Note:** This parameter requires the `WIX_EVENTS.READ_DRAFT_EVENTS` permission.
       */
      includeDrafts?: boolean;
  }
  interface QueryEventsResponse {
      /** Metadata for the paginated results. */
      pagingMetadata?: PagingMetadataV2$1;
      /** List of events. */
      events?: V3Event[];
  }
  interface PagingMetadataV2$1 {
      /** Number of items to return. See [Paging](https://dev.wix.com/api/rest/getting-started/sorting-and-paging#getting-started_sorting-and-paging_paging) for more information. */
      count?: number | null;
      /** Requested offset. */
      offset?: number | null;
      /** Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set. */
      total?: number | null;
      /** Flag that indicates the server failed to calculate the `total` field. */
      tooManyToCount?: boolean | null;
      /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
      cursors?: Cursors$1;
      /**
       * Whether there are more results after the current page.
       * If `true`, another page of results can be retrieved.
       * If `false`, the current page is the final page.
       * @internal
       */
      hasNext?: boolean | null;
  }
  interface Cursors$1 {
      /** Cursor pointing to the next page in the list of results. */
      next?: string | null;
      /** Cursor pointing to the previous page in the list of results. */
      prev?: string | null;
  }
  interface ExportEventsRequest {
      /** Query options. See [API Query Language](https://dev.wix.com/api/rest/getting-started/api-query-language) for more details. */
      query?: CommonQueryV2;
  }
  interface CommonQueryV2 extends CommonQueryV2PagingMethodOneOf {
      /** Paging options to limit and skip the number of items. */
      paging?: CommonPaging;
      /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
      cursorPaging?: CursorPaging$1;
      /**
       * Filter object.
       *
       * Learn more about the [filter section](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#the-filter-section).
       */
      filter?: Record<string, any> | null;
      /**
       * Sort object.
       *
       * Learn more about the [sort section](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#the-sort-section).
       */
      sort?: CommonSorting[];
      /** Array of projected fields. A list of specific field names to return. If `fieldsets` are also specified, the union of `fieldsets` and `fields` is returned. */
      fields?: string[];
      /** Array of named, predefined sets of projected fields. A array of predefined named sets of fields to be returned. Specifying multiple `fieldsets` will return the union of fields from all sets. If `fields` are also specified, the union of `fieldsets` and `fields` is returned. */
      fieldsets?: string[];
  }
  /** @oneof */
  interface CommonQueryV2PagingMethodOneOf {
      /** Paging options to limit and skip the number of items. */
      paging?: CommonPaging;
      /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
      cursorPaging?: CursorPaging$1;
  }
  interface CommonSorting {
      /** Name of the field to sort by. */
      fieldName?: string;
      /** Sort order. */
      order?: CommonSortOrder;
      /**
       * When `field_name` is a property of repeated field that is marked as `MATCH_ITEMS` and sort should be done by
       * a specific element from a collection, filter can/should be provided to ensure correct sort value is picked.
       *
       * If multiple filters are provided, they are combined with AND operator.
       *
       * Example:
       * Given we have document like {"id": "1", "nestedField": [{"price": 10, "region": "EU"}, {"price": 20, "region": "US"}]}
       * and `nestedField` is marked as `MATCH_ITEMS`, to ensure that sorting is done by correct region, filter should be
       * { fieldName: "nestedField.price", "select_items_by": [{"nestedField.region": "US"}] }
       * @internal
       */
      selectItemsBy?: Record<string, any>[] | null;
  }
  enum CommonSortOrder {
      ASC = "ASC",
      DESC = "DESC"
  }
  interface CommonPaging {
      /** Number of items to load. */
      limit?: number | null;
      /** Number of items to skip in the current sort order. */
      offset?: number | null;
  }
  interface CursorPaging$1 {
      /** Maximum number of items to return in the results. */
      limit?: number | null;
      /**
       * Pointer to the next or previous page in the list of results.
       *
       * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
       * Not relevant for the first request.
       */
      cursor?: string | null;
  }
  interface ExportEventsResponse {
      /** Metadata for the paginated results. */
      pagingMetadata?: CommonPagingMetadataV2;
      /** List of events. */
      events?: V3Event[];
  }
  interface CommonPagingMetadataV2 {
      /** Number of items returned in the response. */
      count?: number | null;
      /** Offset that was requested. */
      offset?: number | null;
      /** Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set. */
      total?: number | null;
      /** Flag that indicates the server failed to calculate the `total` field. */
      tooManyToCount?: boolean | null;
      /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
      cursors?: CommonCursors;
      /**
       * Indicates if there are more results after the current page.
       * If `true`, another page of results can be retrieved.
       * If `false`, this is the last page.
       * @internal
       */
      hasNext?: boolean | null;
  }
  interface CommonCursors {
      /** Cursor string pointing to the next page in the list of results. */
      next?: string | null;
      /** Cursor pointing to the previous page in the list of results. */
      prev?: string | null;
  }
  interface CountEventsByStatusRequest {
      /** Filter object in the following format: <br/> `"filter" : { "fieldName1": "value1" }`. */
      filter?: Record<string, any> | null;
      /** Parameters to count events by. */
      facet?: string[];
      /**
       * Whether draft events should be returned in the response. <br>
       * **Note:** This parameter requires the `WIX_EVENTS.READ_DRAFT_EVENTS` permission.
       */
      includeDrafts?: boolean;
  }
  interface CountEventsByStatusResponse {
      /** Metadata for the paginated results. */
      pagingMetadata?: PagingMetadataV2$1;
      /** Filter facets. */
      facets?: Record<string, FacetCounts$1>;
  }
  interface FacetCounts$1 {
      /** Facet counts aggregated per value */
      counts?: Record<string, number>;
  }
  interface ListUserEventsRequest {
      /** Paging options to limit and skip the number of items. */
      paging?: Paging$1;
      /**
       * Sort order, defaults to `"created:asc"`.
       * See [supported fields](https://dev.wix.com/api/rest/wix-events/wix-events/filter-and-sort#wix-events_wix-events_filter-and-sort_list-query-events).
       */
      sort?: Sorting$1[];
      /** Event status. */
      status?: Status$1[];
      /** Allows to filter events by user relation to the event among all wix sites. */
      userFilter?: UserFilter;
      /**
       * Filter facets to include in the response.
       * See [supported facets](https://dev.wix.com/api/rest/wix-events/wix-events/filter-and-sort#wix-events_wix-events_filter-and-sort_list-query-events).
       */
      facet?: string[];
      /**
       * Predefined sets of fields to return. If both `fields` and `fieldsets` are sent in the request, the union of both lists is returned.
       * @internal
       */
      fields?: RequestedFields[];
  }
  interface UserFilter {
      /** User who is related to event */
      userId?: string;
      /** Relation of user to event. */
      relation?: Relation[];
  }
  enum Relation {
      /** User is attending the event. The user RSVP'd with status of `YES` or has ordered tickets. */
      ATTENDING = "ATTENDING"
  }
  interface ListUserEventsResponse {
      /** Metadata for the paginated results. */
      pagingMetadata?: PagingMetadataV2$1;
      /** List of events. */
      events?: V3Event[];
      /** Filter facets. */
      facets?: Record<string, FacetCounts$1>;
  }
  interface ListEventsByCategoryRequest {
      /** Category ID. */
      categoryId: string;
      /** Paging options to limit and skip the number of items. */
      paging?: Paging$1;
      /** Predefined sets of fields to return. If both `fields` and `fieldsets` are sent in the request, the union of both lists is returned. */
      fields?: RequestedFields[];
  }
  interface ListEventsByCategoryResponse {
      /** Metadata for the paginated results. */
      pagingMetadata?: PagingMetadataV2$1;
      /** List of events. */
      events?: V3Event[];
  }
  interface GetEventRequest {
      /** Event ID. */
      eventId: string | null;
      fields?: RequestedFields[];
      /**
       * indicates whether full_address should be resolved
       * @internal
       */
      resolveFullAddress?: boolean;
  }
  interface GetEventResponse {
      /** Event. */
      event?: V3Event;
  }
  interface GetEventBySlugRequest {
      /** URL slug. */
      slug: string | null;
      fields?: RequestedFields[];
      /**
       * indicates whether full_address should be resolved
       * @internal
       */
      resolveFullAddress?: boolean;
  }
  interface GetEventBySlugResponse {
      /** Event. */
      event?: V3Event;
  }
  interface FindEventRequest extends FindEventRequestFindByOneOf {
      /** Event ID. */
      eventId?: string | null;
      /** URL slug. */
      slug?: string | null;
      /** Predefined sets of fields to return. */
      fields?: RequestedFields[];
  }
  /** @oneof */
  interface FindEventRequestFindByOneOf {
      /** Event ID. */
      eventId?: string | null;
      /** URL slug. */
      slug?: string | null;
  }
  interface FindEventResponse {
      /** Event. */
      event?: V3Event;
  }
  interface EventCreated$1 {
      /** Event created timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Event ID. */
      eventId?: string;
      /** Event location. */
      location?: EventsLocation;
      /** Event schedule configuration. */
      scheduleConfig?: ScheduleConfig$1;
      /** Event title. */
      title?: string;
      /** Event creator user ID. */
      userId?: string | null;
      /** Event status. */
      status?: EventStatus$1;
      /** Instance ID. Indicates the original app instance which current event was derived from. */
      derivedFromInstanceId?: string | null;
      /** Event ID. Indicates the original event which current event was derived from. */
      derivedFromEventId?: string | null;
      /** Event that was created. */
      event?: Event$1;
  }
  interface EventsLocation {
      /** Location name. */
      name?: string | null;
      /** Location map coordinates. */
      coordinates?: MapCoordinates$1;
      /** Single line address representation. */
      address?: string | null;
      /** Location type. */
      type?: LocationLocationType$1;
      /**
       * Full address derived from formatted single line `address`.
       * When `full_address` is used to create or update the event, deprecated `address` and `coordinates` are ignored.
       * If provided `full_address` has empty `formatted_address` or `coordinates`, it will be auto-completed using Atlas service.
       *
       * Migration notes:
       * - `full_address.formatted_address` is equivalent to `address`.
       * - `full_address.geocode` is equivalent to `coordinates`.
       */
      fullAddress?: Address$1;
      /**
       * Defines event location as TBD (To Be Determined).
       * When event location is not yet defined, `name` is displayed instead of location address.
       * `coordinates`, `address`, `type` and `full_address` are not required when location is TBD.
       */
      tbd?: boolean | null;
  }
  interface MapCoordinates$1 {
      /** Latitude. */
      lat?: number;
      /** Longitude. */
      lng?: number;
  }
  enum LocationLocationType$1 {
      VENUE = "VENUE",
      ONLINE = "ONLINE"
  }
  /** Physical address */
  interface Address$1 extends AddressStreetOneOf$1 {
      /** a break down of the street to number and street name */
      streetAddress?: StreetAddress$1;
      /** Main address line (usually street and number) as free text */
      addressLine1?: string | null;
      /** country code */
      country?: string | null;
      /** subdivision (usually state or region) code according to ISO 3166-2 */
      subdivision?: string | null;
      /** city name */
      city?: string | null;
      /** zip/postal code */
      postalCode?: string | null;
      /** Free text providing more detailed address info. Usually contains Apt, Suite, Floor */
      addressLine2?: string | null;
      /** A string containing the human-readable address of this location */
      formatted?: string | null;
      /** coordinates of the physical address */
      location?: AddressLocation$1;
      /** country full-name */
      countryFullname?: string | null;
      /** multi-level subdivisions from top to bottom */
      subdivisions?: Subdivision$1[];
  }
  /** @oneof */
  interface AddressStreetOneOf$1 {
      /** a break down of the street to number and street name */
      streetAddress?: StreetAddress$1;
      /** Main address line (usually street and number) as free text */
      addressLine?: string | null;
  }
  interface StreetAddress$1 {
      /** street number */
      number?: string;
      /** street name */
      name?: string;
      /**
       * apartment number
       * @internal
       */
      apt?: string;
  }
  interface AddressLocation$1 {
      /** address latitude coordinates */
      latitude?: number | null;
      /** address longitude coordinates */
      longitude?: number | null;
  }
  interface Subdivision$1 {
      /** subdivision short code */
      code?: string;
      /** subdivision full-name */
      name?: string;
      /**
       * subdivision level
       * @internal
       */
      type?: SubdivisionType$1;
      /**
       * free text description of subdivision type
       * @internal
       */
      typeInfo?: string | null;
  }
  enum SubdivisionType$1 {
      UNKNOWN_SUBDIVISION_TYPE = "UNKNOWN_SUBDIVISION_TYPE",
      /** State */
      ADMINISTRATIVE_AREA_LEVEL_1 = "ADMINISTRATIVE_AREA_LEVEL_1",
      /** County */
      ADMINISTRATIVE_AREA_LEVEL_2 = "ADMINISTRATIVE_AREA_LEVEL_2",
      /** City/town */
      ADMINISTRATIVE_AREA_LEVEL_3 = "ADMINISTRATIVE_AREA_LEVEL_3",
      /** Neighborhood/quarter */
      ADMINISTRATIVE_AREA_LEVEL_4 = "ADMINISTRATIVE_AREA_LEVEL_4",
      /** Street/block */
      ADMINISTRATIVE_AREA_LEVEL_5 = "ADMINISTRATIVE_AREA_LEVEL_5",
      /** ADMINISTRATIVE_AREA_LEVEL_0. Indicates the national political entity, and is typically the highest order type returned by the Geocoder. */
      COUNTRY = "COUNTRY"
  }
  interface ScheduleConfig$1 {
      /**
       * Defines event as TBD (To Be Determined) schedule.
       * When event time is not yet defined, TBD message is displayed instead of event start and end times.
       * `startDate`, `endDate` and `timeZoneId` are not required when schedule is TBD.
       */
      scheduleTbd?: boolean;
      /** TBD message. */
      scheduleTbdMessage?: string | null;
      /** Event start timestamp. */
      startDate?: Date | null;
      /** Event end timestamp. */
      endDate?: Date | null;
      /** Event time zone ID in TZ database format, e.g., `EST`, `America/Los_Angeles`. */
      timeZoneId?: string | null;
      /** Whether end date is hidden in the formatted schedule. */
      endDateHidden?: boolean;
      /** Whether time zone is displayed in formatted schedule. */
      showTimeZone?: boolean;
      /** Event recurrences. */
      recurrences?: EventsRecurrences;
  }
  interface EventsRecurrences {
      /** Event occurrences. */
      occurrences?: EventsOccurrence[];
      /**
       * Recurring event category ID.
       * @readonly
       */
      categoryId?: string | null;
      /**
       * Recurrence status.
       * @readonly
       */
      status?: EventsRecurrenceStatusStatus;
  }
  interface EventsOccurrence {
      /** Event start timestamp. */
      startDate?: Date | null;
      /** Event end timestamp. */
      endDate?: Date | null;
      /** Event time zone ID in TZ database format, e.g., `EST`, `America/Los_Angeles`. */
      timeZoneId?: string | null;
      /** Whether time zone is displayed in formatted schedule. */
      showTimeZone?: boolean;
  }
  enum EventsRecurrenceStatusStatus {
      /** Event occurs only once. */
      ONE_TIME = "ONE_TIME",
      /** Event is recurring. */
      RECURRING = "RECURRING",
      /** Marks the next upcoming occurrence of the recurring event. */
      RECURRING_NEXT = "RECURRING_NEXT",
      /** Marks the most recent ended occurrence of the recurring event. */
      RECURRING_LAST_ENDED = "RECURRING_LAST_ENDED",
      /** Marks the most recent canceled occurrence of the recurring event. */
      RECURRING_LAST_CANCELED = "RECURRING_LAST_CANCELED"
  }
  enum EventStatus$1 {
      /** Event is public and scheduled to start */
      SCHEDULED = "SCHEDULED",
      /** Event has started */
      STARTED = "STARTED",
      /** Event has ended */
      ENDED = "ENDED",
      /** Event was canceled */
      CANCELED = "CANCELED",
      /** Event is not public and needs to be published */
      DRAFT = "DRAFT"
  }
  interface Event$1 {
      /**
       * Event ID.
       * @readonly
       */
      _id?: string;
      /** Event location. */
      location?: EventsLocation;
      /** Event scheduling. */
      scheduling?: Scheduling$1;
      /** Event title. */
      title?: string;
      /** Event description. */
      description?: string;
      /** Rich-text content displayed in Wix UI - "About Event" section (HTML). */
      about?: string;
      /** Main event image. */
      mainImage?: string;
      /** Event slug URL (generated from event title). */
      slug?: string;
      /** ISO 639-1 language code of the event (used in content translations). */
      language?: string;
      /** Event creation timestamp. */
      created?: Date | null;
      /** Event modified timestamp. */
      modified?: Date | null;
      /** Event status. */
      status?: EventStatus$1;
      /** RSVP or ticketing registration details. */
      registration?: EventsRegistration;
      /** "Add to calendar" URLs. */
      calendarLinks?: CalendarLinks$1;
      /** Event page URL components. */
      eventPageUrl?: SiteUrl$1;
      /** Event registration form. */
      form?: Form$1;
      /** Event dashboard summary of RSVP / ticket sales. */
      dashboard?: Dashboard$1;
      /** Instance ID of the site where event is hosted. */
      instanceId?: string;
      /** Guest list configuration. */
      guestListConfig?: GuestListConfig$1;
      /** Event creator user ID. */
      userId?: string;
      /** Event discussion feed. For internal use. */
      feed?: EventsFeed;
      /** Online conferencing details. */
      onlineConferencing?: EventsOnlineConferencing;
      /** SEO settings. */
      seoSettings?: EventsSeoSettings;
      /** Assigned contacts label key. */
      assignedContactsLabel?: string | null;
      /** Agenda details. */
      agenda?: Agenda$1;
      /** Categories this event is assigned to. */
      categories?: Category$1[];
      /** Visual settings for event. */
      eventDisplaySettings?: EventDisplaySettings$1;
      /**
       * @internal
       * @readonly
       */
      customizableTickets?: boolean | null;
      /**
       * Labelling related data.
       * @internal
       */
      labellingSettings?: LabellingSettings$1;
  }
  interface Scheduling$1 {
      /** Schedule configuration. */
      config?: ScheduleConfig$1;
      /** Formatted schedule representation. */
      formatted?: string;
      /** Formatted start date of the event (empty for TBD schedules). */
      startDateFormatted?: string;
      /** Formatted start time of the event (empty for TBD schedules). */
      startTimeFormatted?: string;
      /** Formatted end date of the event (empty for TBD schedules or when end date is hidden). */
      endDateFormatted?: string;
      /** Formatted end time of the event (empty for TBD schedules or when end date is hidden). */
      endTimeFormatted?: string;
  }
  interface EventsRegistration {
      /** Event type. */
      type?: EventType$1;
      /** Event registration status. */
      status?: RegistrationStatus$1;
      /** RSVP collection details. */
      rsvpCollection?: RsvpCollection$1;
      /** Ticketing details. */
      ticketing?: Ticketing$1;
      /** External registration details. */
      external?: ExternalEvent$1;
      /** Types of users allowed to register. */
      restrictedTo?: VisitorType$1;
      /** Initial event type which was set when creating an event. */
      initialType?: EventType$1;
  }
  enum EventType$1 {
      /** Type not available for this request fieldset */
      NA_EVENT_TYPE = "NA_EVENT_TYPE",
      /** Registration via RSVP */
      RSVP = "RSVP",
      /** Registration via ticket purchase */
      TICKETS = "TICKETS",
      /** External registration */
      EXTERNAL = "EXTERNAL",
      /** Registration not available */
      NO_REGISTRATION = "NO_REGISTRATION"
  }
  enum RegistrationStatus$1 {
      /** Registration status is not applicable */
      NA_REGISTRATION_STATUS = "NA_REGISTRATION_STATUS",
      /** Registration to event is closed */
      CLOSED = "CLOSED",
      /** Registration to event is closed manually */
      CLOSED_MANUALLY = "CLOSED_MANUALLY",
      /** Registration is open via RSVP */
      OPEN_RSVP = "OPEN_RSVP",
      /** Registration to event waitlist is open via RSVP */
      OPEN_RSVP_WAITLIST = "OPEN_RSVP_WAITLIST",
      /** Registration is open via ticket purchase */
      OPEN_TICKETS = "OPEN_TICKETS",
      /** Registration is open via external URL */
      OPEN_EXTERNAL = "OPEN_EXTERNAL",
      /** Registration will be open via RSVP */
      SCHEDULED_RSVP = "SCHEDULED_RSVP"
  }
  interface RsvpCollection$1 {
      /** RSVP collection configuration. */
      config?: RsvpCollectionConfig$1;
  }
  interface RsvpCollectionConfig$1 {
      /** Defines the supported RSVP statuses. */
      rsvpStatusOptions?: RsvpStatusOptions$1;
      /**
       * Total guest limit available to register to the event.
       * Additional guests per RSVP are counted towards total guests.
       */
      limit?: number | null;
      /** Whether a waitlist is opened when total guest limit is reached, allowing guests to create RSVP with WAITING RSVP status. */
      waitlist?: boolean;
      /** Registration start timestamp. */
      startDate?: Date | null;
      /** Registration end timestamp. */
      endDate?: Date | null;
  }
  enum RsvpStatusOptions$1 {
      /** Only YES RSVP status is available for RSVP registration */
      YES_ONLY = "YES_ONLY",
      /** YES and NO RSVP status options are available for the registration */
      YES_AND_NO = "YES_AND_NO"
  }
  interface Ticketing$1 {
      /**
       * Deprecated.
       * @deprecated
       */
      lowestPrice?: string | null;
      /**
       * Deprecated.
       * @deprecated
       */
      highestPrice?: string | null;
      /** Currency used in event transactions. */
      currency?: string | null;
      /** Ticketing configuration. */
      config?: TicketingConfig$1;
      /**
       * Price of lowest priced ticket.
       * @readonly
       */
      lowestTicketPrice?: EventsMoney;
      /**
       * Price of highest priced ticket.
       * @readonly
       */
      highestTicketPrice?: EventsMoney;
      /**
       * Formatted price of lowest priced ticket.
       * @readonly
       */
      lowestTicketPriceFormatted?: string | null;
      /**
       * Formatted price of highest priced ticket.
       * @readonly
       */
      highestTicketPriceFormatted?: string | null;
      /**
       * Whether all tickets are sold for this event.
       * @readonly
       */
      soldOut?: boolean | null;
  }
  interface TicketingConfig$1 {
      /** Whether the form must be filled out separately for each ticket. */
      guestAssignedTickets?: boolean;
      /** Tax configuration. */
      taxConfig?: TaxConfig$1;
      /** Limit of tickets that can be purchased per order, default 20. */
      ticketLimitPerOrder?: number;
      /**
       * App Id for external ticket stock management.
       * By default tickets stock is defined in TicketDefinition object.
       * If defined then limitation from TicketDefinition is ignored.
       * @internal
       */
      stockManagerAppId?: string | null;
      /** Duration for which the tickets being bought are reserved. */
      reservationDurationInMinutes?: number | null;
  }
  interface TaxConfig$1 {
      /** Tax application settings. */
      type?: EventsTaxType;
      /** Tax name. */
      name?: string | null;
      /** Tax rate (e.g.,`21.55`). */
      rate?: string | null;
      /** Applies taxes for donations, default true. */
      appliesToDonations?: boolean | null;
  }
  enum EventsTaxType {
      /** Tax is included in the ticket price. */
      INCLUDED = "INCLUDED",
      /** Tax is added to the order at the checkout. */
      ADDED = "ADDED",
      /** Tax is added to the final total at the checkout. */
      ADDED_AT_CHECKOUT = "ADDED_AT_CHECKOUT"
  }
  interface ExternalEvent$1 {
      /** External event registration URL. */
      registration?: string;
  }
  enum VisitorType$1 {
      /** Site visitor (including member) */
      VISITOR = "VISITOR",
      /** Site member */
      MEMBER = "MEMBER",
      /** Site visitor or member */
      VISITOR_OR_MEMBER = "VISITOR_OR_MEMBER"
  }
  interface CalendarLinks$1 {
      /** "Add to Google calendar" URL. */
      google?: string;
      /** "Download ICS calendar file" URL. */
      ics?: string;
  }
  /** Site URL components */
  interface SiteUrl$1 {
      /**
       * Base URL. For premium sites, this will be the domain.
       * For free sites, this would be site URL (e.g `mysite.wixsite.com/mysite`)
       */
      base?: string;
      /** The path to that page - e.g `/my-events/weekly-meetup-2` */
      path?: string;
  }
  interface Dashboard$1 {
      /** Guest RSVP summary. */
      rsvpSummary?: RsvpSummary$1;
      /**
       * Summary of revenue and tickets sold.
       * (Archived orders are not included).
       */
      ticketingSummary?: TicketingSummary$1;
  }
  interface RsvpSummary$1 {
      /** Total number of RSVPs. */
      total?: number;
      /** Number of RSVPs with status `YES`. */
      yes?: number;
      /** Number of RSVPs with status `NO`. */
      no?: number;
      /** Number of RSVPs in waitlist. */
      waitlist?: number;
  }
  interface TicketingSummary$1 {
      /** Number of tickets sold. */
      tickets?: number;
      /**
       * Total revenue, excluding fees.
       * (taxes and payment provider fees are not deducted.)
       */
      revenue?: EventsMoney;
      /** Whether currency is locked and cannot be changed (generally occurs after the first order in the specified currency has been created). */
      currencyLocked?: boolean;
      /** Number of orders placed. */
      orders?: number;
      /** Total balance of confirmed transactions. */
      totalSales?: EventsMoney;
  }
  interface GuestListConfig$1 {
      /** Whether members can see other members attending the event (defaults to true). */
      publicGuestList?: boolean;
  }
  interface EventsFeed {
      /** Event discussion feed token. */
      token?: string;
  }
  interface EventsOnlineConferencing {
      config?: OnlineConferencingConfig$1;
      session?: EventsOnlineConferencingSession;
      /**
       * Configured conferencing provider name.
       * @internal
       * @readonly
       */
      providerName?: string;
  }
  interface OnlineConferencingConfig$1 {
      /**
       * Whether online conferencing is enabled (not supported for TBD schedules).
       * When enabled, links to join conferencing are generated and provided to guests.
       */
      enabled?: boolean;
      /** Conferencing provider ID. */
      providerId?: string | null;
      /** Conference type */
      conferenceType?: ConferenceType$1;
  }
  enum ConferenceType$1 {
      /** Everyone in the meeting can publish and subscribe video and audio. */
      MEETING = "MEETING",
      /** Guests can only subscribe to video and audio. */
      WEBINAR = "WEBINAR"
  }
  interface EventsOnlineConferencingSession {
      /**
       * Link for event host to start the online conference session.
       * @readonly
       */
      hostLink?: string;
      /**
       * Link for guests to join the online conference session.
       * @readonly
       */
      guestLink?: string;
      /**
       * The password required to join online conferencing session (when relevant).
       * @readonly
       */
      password?: string | null;
      /**
       * Indicates that session was created successfully on providers side.
       * @readonly
       */
      sessionCreated?: boolean | null;
      /**
       * Unique session id
       * @readonly
       */
      sessionId?: string | null;
  }
  interface EventsSeoSettings {
      /** URL slug */
      slug?: string;
      /** Advanced SEO data */
      advancedSeoData?: SeoSchema$1;
      /**
       * Hidden from SEO Site Map
       * @readonly
       */
      hidden?: boolean | null;
  }
  interface Agenda$1 {
      /** Whether the schedule is enabled for the event. */
      enabled?: boolean;
      /**
       * Agenda page URL.
       * @readonly
       */
      pageUrl?: SiteUrl$1;
  }
  interface Category$1 {
      /**
       * Category ID.
       * @readonly
       */
      _id?: string;
      /** Category name. */
      name?: string;
      /**
       * Date and time when category was created.
       * @readonly
       */
      _createdDate?: Date | null;
      /**
       * Assigned events count. Deleted events are excluded.
       * @internal
       * @readonly
       * @deprecated
       */
      assignedEventsCount?: number | null;
      /**
       * The total number of draft and published events assigned to the category.
       * @readonly
       */
      counts?: CategoryCounts$1;
      /**
       * Category state. Possible values:
       *
       * `MANUAL`: Category is created manually by the user.
       * `AUTO`: Category is created automatically.
       * `RECURRING_EVENT`: Category is created automatically when publishing recurring events.
       * `HIDDEN`: Category can't be seen.
       *
       * Default: `MANUAL`.
       *
       * **Note:** The WIX_EVENTS.MANAGE_AUTO_CATEGORIES permission scope is required to use states other than `MANUAL`.
       */
      states?: State$1[];
      /**
       * Optionally client defined external ID.
       * @internal
       */
      externalId?: string | null;
  }
  interface CategoryCounts$1 {
      /** Total number of draft events assigned to the category. */
      assignedEventsCount?: number | null;
      /** Total number of published events assigned to the category. Deleted events are excluded. */
      assignedDraftEventsCount?: number | null;
  }
  enum State$1 {
      /** Created manually by the user. */
      MANUAL = "MANUAL",
      /** Created automatically. */
      AUTO = "AUTO",
      /** Created when publishing recurring events. */
      RECURRING_EVENT = "RECURRING_EVENT",
      /** Category is hidden. */
      HIDDEN = "HIDDEN",
      /** Category is used to store component events. */
      COMPONENT = "COMPONENT"
  }
  interface EventDisplaySettings$1 {
      /** Whether event details button is hidden. Only available for events with no registration. */
      hideEventDetailsButton?: boolean | null;
      /** Disables event details page visibility. If event has an external registration configured visitors will be redirected from this page. */
      hideEventDetailsPage?: boolean | null;
  }
  interface LabellingSettings$1 {
      /**
       * @internal
       * @readonly
       */
      assignedContactsLegacyLabelId?: string | null;
      /**
       * @internal
       * @readonly
       */
      assignedContactsLabelDeleted?: boolean | null;
  }
  interface Empty$1 {
  }
  interface EventUpdated$1 {
      /** Event update timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Event ID. */
      eventId?: string;
      /** Event location. */
      location?: EventsLocation;
      /** Event schedule configuration. */
      scheduleConfig?: ScheduleConfig$1;
      /** Event title. */
      title?: string;
      /**
       * Whether schedule configuration was updated.
       * @deprecated
       */
      scheduleConfigUpdated?: boolean;
      /**
       * The set of properties which were updated. For example 'title' or 'location'
       * @internal
       */
      fields?: string[];
      /**
       * Whether event has opened new spots with this update.
       * @internal
       */
      newSpotsOpened?: boolean | null;
      /** Updated event */
      event?: Event$1;
  }
  interface EventDeleted$1 {
      /** Event deleted timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Event ID. */
      eventId?: string;
      /** Event title. */
      title?: string;
      /** Event creator user ID. */
      userId?: string | null;
      /**
       * Event categories.
       * @internal
       */
      categories?: string[];
  }
  interface EventCopied {
      /** Event created timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Event ID. */
      eventId?: string;
      /** Event location. */
      location?: EventsLocation;
      /** Event schedule configuration. */
      scheduleConfig?: ScheduleConfig$1;
      /** Event title. */
      title?: string;
      /** Event creator user ID. */
      userId?: string | null;
      /** Event status. */
      status?: EventStatus$1;
      /** Instance ID. Indicates the original app instance which current event was derived from. */
      derivedFromInstanceId?: string | null;
      /** Event ID. Indicates the original event which current event was derived from. */
      derivedFromEventId?: string | null;
      /**
       * Map of copied ticket definitions from original event.
       * Key represents ticket def id in the original event.
       * Value represents ticket def id in the newly created event.
       */
      ticketDefinitions?: Record<string, string>;
  }
  interface EventPublished {
      /** Event publish timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Event ID. */
      eventId?: string;
      /** Event status. */
      status?: EventStatus$1;
      /**
       * Event ID. Indicates the original event which current event was derived from.
       * Can be used to track the original event and add missing information.
       */
      derivedFromEventId?: string | null;
      /** Event title. */
      title?: string | null;
      /** Event description. */
      description?: string | null;
      /** Event location. */
      location?: EventsLocation;
      /** Event scheduling. */
      scheduling?: Scheduling$1;
      /** Event page URL components. */
      eventPageUrl?: SiteUrl$1;
      /** RSVP or ticketing registration details. */
      registration?: EventsRegistration;
  }
  interface EventCanceled$1 {
      /** Event canceled timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Event ID. */
      eventId?: string;
      /** Event title */
      title?: string;
      /** Event creator user ID. */
      userId?: string | null;
  }
  interface EventStarted {
      /** Event start timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Event ID. */
      eventId?: string;
  }
  interface EventEnded$1 {
      /** Event end timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Event ID. */
      eventId?: string;
  }
  interface EventReminder {
      /** Reminder timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Event ID. */
      eventId?: string;
      /** Event location. */
      location?: EventsLocation;
      /** Event schedule configuration. */
      scheduleConfig?: ScheduleConfig$1;
      /** Event title. */
      title?: string;
      /** Event creator user ID. */
      userId?: string | null;
      /** Time until the event starts (currently, reminder is triggered 1 day before event starts). */
      startsIn?: TimeDuration;
  }
  interface DomainEvent$1 extends DomainEventBodyOneOf$1 {
      createdEvent?: EntityCreatedEvent$1;
      updatedEvent?: EntityUpdatedEvent$1;
      deletedEvent?: EntityDeletedEvent$1;
      actionEvent?: ActionEvent$1;
      /**
       * Unique event ID.
       * Allows clients to ignore duplicate webhooks.
       */
      _id?: string;
      /**
       * Assumes actions are also always typed to an entity_type
       * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
       */
      entityFqdn?: string;
      /**
       * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
       * This is although the created/updated/deleted notion is duplication of the oneof types
       * Example: created/updated/deleted/started/completed/email_opened
       */
      slug?: string;
      /** ID of the entity associated with the event. */
      entityId?: string;
      /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
      eventTime?: Date | null;
      /**
       * Whether the event was triggered as a result of a privacy regulation application
       * (for example, GDPR).
       */
      triggeredByAnonymizeRequest?: boolean | null;
      /** If present, indicates the action that triggered the event. */
      originatedFrom?: string | null;
      /**
       * A sequence number defining the order of updates to the underlying entity.
       * For example, given that some entity was updated at 16:00 and than again at 16:01,
       * it is guaranteed that the sequence number of the second update is strictly higher than the first.
       * As the consumer, you can use this value to ensure that you handle messages in the correct order.
       * To do so, you will need to persist this number on your end, and compare the sequence number from the
       * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
       */
      entityEventSequence?: string | null;
  }
  /** @oneof */
  interface DomainEventBodyOneOf$1 {
      createdEvent?: EntityCreatedEvent$1;
      updatedEvent?: EntityUpdatedEvent$1;
      deletedEvent?: EntityDeletedEvent$1;
      actionEvent?: ActionEvent$1;
  }
  interface EntityCreatedEvent$1 {
      entityAsJson?: string;
      /**
       * Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity
       * @internal
       */
      triggeredByUndelete?: boolean | null;
      /** Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity */
      restoreInfo?: RestoreInfo$1;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface RestoreInfo$1 {
      deletedDate?: Date | null;
  }
  interface EntityUpdatedEvent$1 {
      /**
       * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
       * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
       * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
       */
      currentEntityAsJson?: string;
      /**
       * This field is currently part of the of the EntityUpdatedEvent msg, but scala/node libraries which implements the domain events standard
       * wont populate it / have any reference to it in the API.
       * The main reason for it is that fetching the old entity from the DB will have a performance hit on an update operation so unless truly needed,
       * the developer should send only the new (current) entity.
       * An additional reason is not wanting to send this additional entity over the wire (kafka) since in some cases it can be really big
       * Developers that must reflect the old entity will have to implement their own domain event sender mechanism which will follow the DomainEvent proto message.
       * @internal
       * @deprecated
       */
      previousEntityAsJson?: string | null;
      /**
       * WIP - This property will hold both names and previous values of the updated fields of the entity.
       * For more details please see [adr](https://docs.google.com/document/d/1PdqsOM20Ph2HAkmx8zvUnzzk3Sekp3BR9h34wSvsRnI/edit#heading=h.phlw87mh2imx) or [issue](https://github.com/wix-private/nile-tracker/issues/363)
       * @internal
       */
      modifiedFields?: Record<string, any>;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface EntityDeletedEvent$1 {
      /**
       * Indicates if the entity is sent to trash-bin. only available when trash-bin is enabled
       * @internal
       */
      movedToTrash?: boolean | null;
      /** Entity that was deleted */
      deletedEntityAsJson?: string | null;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface ActionEvent$1 {
      bodyAsJson?: string;
  }
  interface MessageEnvelope$1 {
      /** App instance ID. */
      instanceId?: string | null;
      /** Event type. */
      eventType?: string;
      /** The identification type and identity data. */
      identity?: IdentificationData$1;
      /** Stringify payload. */
      data?: string;
  }
  interface IdentificationData$1 extends IdentificationDataIdOneOf$1 {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
      /** @readonly */
      identityType?: WebhookIdentityType$1;
  }
  /** @oneof */
  interface IdentificationDataIdOneOf$1 {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
  }
  enum WebhookIdentityType$1 {
      UNKNOWN = "UNKNOWN",
      ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
      MEMBER = "MEMBER",
      WIX_USER = "WIX_USER",
      APP = "APP"
  }
  /**
   * Creates an event.
   *
   *
   * The event includes a default registration form in the selected language, which consists of input fields for first name, last name, and email. See [Registration Form](https://www.wix.com/velo/reference/wix-events-v2/forms/introduction) for more information.
   *
   * You can create the event as a draft by setting the draft value to true. Otherwise, the event is published right away.
   *
   * The event is automatically set up to send daily summary reports of new guests to your business email.
   * @param event - Event data.
   * @public
   * @requiredField event
   * @requiredField event.dateAndTimeSettings
   * @requiredField event.location
   * @requiredField event.registration.initialType
   * @requiredField event.title
   * @param options - Optional fields.
   * @permissionId WIX_EVENTS.MANAGE_EVENTS
   * @adminMethod
   * @returns Created event.
   */
  function createEvent(event: V3Event, options?: CreateEventOptions): Promise<V3Event>;
  interface CreateEventOptions {
      /** Whether to create the event as a draft. */
      draft?: boolean;
      /** Predefined sets of fields to return. */
      fields?: RequestedFields[];
  }
  /**
   * Clones an event, including the registration form, notifications, multilingual translations and ticket configuration from the original event.
   *
   *
   * The new event's date is automatically set to 14 days from the original event date.
   * If an event with the same title already exists, the new event's title gets a sequence number. For example, if you clone an event named "Leather Crafting 101", the new event's title is "Leather Crafting 101 (1)".  You can change the required entity field values while cloning an event.
   * @param eventId - Event ID.
   * @public
   * @requiredField eventId
   * @param options - Optional fields.
   * @permissionId WIX_EVENTS.MANAGE_EVENTS
   * @adminMethod
   */
  function cloneEvent(eventId: string, options?: CloneEventOptions): Promise<CloneEventResponse>;
  interface CloneEventOptions {
      /** Field values to be changed when cloning the event. */
      event?: V3Event;
      /**
       * Fields that are included in this parameter are updated, while all other fields stay the same. If paths are not defined, all field values from the `event` object are updated.
       * @internal
       */
      fieldmask?: string[];
      /** Whether to clone the event as a draft. */
      draft?: boolean;
      /** Predefined sets of fields to return. If both `fields` and `fieldsets` are sent in the request, the union of both lists is returned. */
      fields?: RequestedFields[];
  }
  /**
   * Updates an event.
   * @param _id - Event ID.
   * @public
   * @requiredField _id
   * @param options - Optional fields.
   * @permissionId WIX_EVENTS.MANAGE_EVENTS
   * @adminMethod
   * @returns Updated event.
   */
  function updateEvent(_id: string, options?: UpdateEventOptions): Promise<V3Event>;
  interface UpdateEventOptions {
      /** Event to update. */
      event: {
          /**
           * Event ID.
           * @readonly
           */
          _id?: string;
          /** Event location. */
          location?: Location$1;
          /** Event date and time settings. */
          dateAndTimeSettings?: DateAndTimeSettings$1;
          /** Event title. */
          title?: string | null;
          /** Short description that appears under the event title. */
          shortDescription?: string | null;
          /**
           * Detailed description of an event. You can enter the description using rich text format (add various types of markups, such as underlines, italics, bolding, color codes, bullet lists, and links by using HTML formatting tags).
           * @deprecated Detailed description of an event.
           *
           * This field is deprecated. To create a description, see the flow in [introduction](https://dev.wix.com/docs/rest/business-solutions/events/events-v3/introduction).
           * @replacedBy wix.events.v1.rich_content
           * @targetRemovalDate 2025-06-01
           */
          detailedDescription?: string | null;
          /**
           * Main event image. <br>
           * **Note:** This field is returned only when the `DETAILS` fieldset is included in the request.
           */
          mainImage?: string;
          /**
           * Unique identifier of the event page. The naming is the same as the event title written in kebab case. For example, if your event title is "Leather Crafting 101", then the slug is "leather-crafting-101".
           * @readonly
           */
          slug?: string;
          /**
           * Date and time when the event was created.
           * @readonly
           */
          _createdDate?: Date | null;
          /**
           * Date and time when the event was updated.
           * @readonly
           */
          _updatedDate?: Date | null;
          /**
           * Event status. Possible values:
           *
           *   - `UPCOMING`: The event is published and scheduled to start.
           *   - `STARTED`: The event has started.
           *   - `ENDED`: The event has ended.
           *   - `CANCELED`: The event is canceled.
           *   - `DRAFT`: The event is not published.
           * @readonly
           */
          status?: Status$1;
          /**
           * RSVP or ticketing registration details. <br>
           * **Note:** This field is returned only when the `REGISTRATION` fieldset is included in the request.
           */
          registration?: Registration$1;
          /**
           * URLs that allow you to add an event to the Google calendar, or to download an [ICS calendar](https://icscalendar.com/) file. <br>
           * **Note:** This field is returned only when the `DETAILS` fieldset is included in the request.
           * @readonly
           */
          calendarUrls?: CalendarUrls;
          /**
           * Event page URL components. <br>
           * **Note:** This field is returned only when the `URLS` fieldset is included in the request.
           */
          eventPageUrl?: string;
          /**
           * Event registration form. <br>
           * **Note:** This field is returned only when the `FORM` fieldset is included in the request.
           */
          form?: Form$1;
          /**
           * Summary of RSVP or ticket sales. <br>
           * **Note:** This field is returned only when the `DASHBOARD` fieldset is included in the request and you have the "WIX_EVENTS.READ_EVENT_DASHBOARD" permissions.
           */
          summaries?: Summaries;
          /**
           * Instance ID of the site where the event is hosted.
           * @readonly
           */
          instanceId?: string;
          /** Guest list configuration. */
          guestListSettings?: GuestListSettings;
          /**
           * ID of the user who created the event.
           * @readonly
           */
          userId?: string;
          /**
           * Event discussion feed. For internal use.
           * @internal
           */
          feed?: Feed$1;
          /**
           * Online conferencing details. <br>
           * **Note:** This field is returned only when the `ONLINE_CONFERENCING_SESSION` fieldset is included in the request and you have the "WIX_EVENTS.READ_ONLINE_CONFERENCING" permissions.
           */
          onlineConferencing?: OnlineConferencing$1;
          /**
           * SEO settings. <br>
           * **Note:** This field is returned only when the `SEO_SETTINGS` fieldset is included in the request.
           */
          seoSettings?: SeoSettings$1;
          /**
           * Assigned contacts label key.
           * @readonly
           */
          contactLabel?: string | null;
          /**
           * Event schedule details. <br>
           * **Note:** This field is returned only when the `AGENDA` fieldset is included in the request.
           */
          agendaSettings?: AgendaSettings;
          /**
           * Event categories.
           * @internal
           */
          categories?: EventCategories;
          /** Visual settings for event. */
          eventDisplaySettings?: V3EventDisplaySettings;
          /**
           * True if ticket can be customised
           * @internal
           */
          customizableTickets?: boolean | null;
          /**
           * Labelling related data.
           * @internal
           */
          labellingSettings?: V3LabellingSettings;
      };
      /**
       * Fields that are included in this parameter are updated, while all other fields stay the same. If paths are not defined, all field values from the `event` object are updated.
       * @internal
       */
      fieldmask?: string[];
      /** Predefined sets of fields to return. If both `fields` and `fieldsets` are sent in the request, the union of both lists is returned. */
      fields?: RequestedFields[];
  }
  /**
   * Publishes a draft event to your live site. Once published, the event's status changes from `DRAFT` to `UPCOMING.`
   *
   *
   * It's impossible to revert the `DRAFT` status after publishing. The only option is to clone the event, and then delete the original one.
   * @param eventId - Event ID.
   * @public
   * @requiredField eventId
   * @param options - Optional fields.
   * @permissionId WIX_EVENTS.MANAGE_EVENTS
   * @adminMethod
   */
  function publishDraftEvent(eventId: string, options?: PublishDraftEventOptions): Promise<PublishDraftEventResponse>;
  interface PublishDraftEventOptions {
      /** Predefined sets of fields to return. If both `fields` and `fieldsets` are sent in the request, the union of both lists is returned. */
      fields?: RequestedFields[];
  }
  /**
   * Cancels an event.
   *
   *
   * After cancellation, registration for an event is closed. To reuse the event, [clone](https://www.wix.com/velo/reference/wix-events-v2/wixeventsv2/cloneevent) and [publish](https://www.wix.com/velo/reference/wix-events-v2/wixeventsv2/publishdraftevent) it again.
   * If event cancellation notifications are enabled, canceling an event automatically triggers the sending of cancellation emails and/or push notifications to registered guests.
   * @param eventId - Event ID.
   * @public
   * @requiredField eventId
   * @param options - Optional fields.
   * @permissionId WIX_EVENTS.MANAGE_EVENTS
   * @adminMethod
   */
  function cancelEvent(eventId: string, options?: CancelEventOptions): Promise<CancelEventResponse>;
  interface CancelEventOptions {
      /** Predefined sets of fields to return. If both `fields` and `fieldsets` are sent in the request, the union of both lists is returned. */
      fields?: RequestedFields[];
  }
  /**
   * Cancels multiple events that meet the given criteria.
   *
   *
   * After cancellation, registration for an event is closed. To reuse the event, [clone](https://www.wix.com/velo/reference/wix-events-v2/wixeventsv2/cloneevent) and [publish](https://www.wix.com/velo/reference/wix-events-v2/wixeventsv2/publishdraftevent) it again.
   * If event cancellation notifications are enabled, canceling an event automatically triggers the sending of cancellation emails and/or push notifications to registered guests.
   * @public
   * @requiredField options.filter.filter
   * @param options - Optional fields.
   * @permissionId WIX_EVENTS.MANAGE_EVENTS
   * @adminMethod
   */
  function bulkCancelEventsByFilter(options?: BulkCancelEventsByFilterOptions): Promise<void>;
  interface BulkCancelEventsByFilterOptions {
      /** Filter. */
      filter?: QueryV2$1;
  }
  /**
   * Permanently deletes an event. <br> <br>
   * You can retrieve the deleted event through a GDPR access request.
   * @param eventId - Event ID.
   * @public
   * @requiredField eventId
   * @permissionId WIX_EVENTS.MANAGE_EVENTS
   * @adminMethod
   */
  function deleteEvent(eventId: string): Promise<DeleteEventResponse>;
  /**
   * Permanently deletes multiple events that meet the given criteria.
   *
   *
   * You can retrieve the deleted events through a GDPR access request.
   * @public
   * @requiredField options.filter.filter
   * @param options - Optional fields.
   * @permissionId WIX_EVENTS.MANAGE_EVENTS
   * @adminMethod
   */
  function bulkDeleteEventsByFilter(options?: BulkDeleteEventsByFilterOptions): Promise<void>;
  interface BulkDeleteEventsByFilterOptions {
      /** Query options. See [API Query Language](https://dev.wix.com/api/rest/getting-started/api-query-language) for more details. */
      filter?: QueryV2$1;
  }
  /**
   * Creates a query to retrieve a list of events.
   *
   *
   * The `queryEvents()` function builds a query to retrieve a list of events and returns a [`EventsQueryBuilder`](https://www.wix.com/velo/reference/wix-events-v2/wixeventsv2/eventsquerybuilder) object.
   *
   * The returned object contains the query definition, which is typically used to run the query using the [`find()`](https://www.wix.com/velo/reference/wix-events-v2/wixeventsv2/eventsquerybuilder/find) function.
   *
   * You can refine the query by chaining `EventsQueryBuilder` functions onto the query. `EventsQueryBuilder` functions enable you to sort, filter, and control the results `queryEvents()` returns.
   *
   * `queryEvents()` runs with these `EventsQueryBuilder` defaults, which you can override:
   *
   * - [`skip(0)`](https://www.wix.com/velo/reference/wix-events-v2/wixeventsv2/eventsquerybuilder/skip)
   * - [`limit(50)`](https://www.wix.com/velo/reference/wix-events-v2/wixeventsv2/eventsquerybuilder/limit)
   * - [`descending("_createdDate")`](https://www.wix.com/velo/reference/wix-events-v2/wixeventsv2/eventsquerybuilder/descending)
   *
   * The functions that are chained to `queryEvents()` are applied in the order they're called. For example, if you apply `ascending('title')` and then `descending('status')`, the results are sorted first by the `title`, and then, if there are multiple results with the same `title`, the items are sorted by `status`.
   * @public
   * @param options - Optional fields.
   * @permissionId WIX_EVENTS.READ_EVENTS
   */
  function queryEvents(options?: QueryEventsOptions): EventsQueryBuilder;
  interface QueryEventsOptions {
      /** Predefined sets of fields to return. */
      fields?: RequestedFields[] | undefined;
      /**
       * Whether draft events should be returned in the response. <br>
       * **Note:** This parameter requires the `WIX_EVENTS.READ_DRAFT_EVENTS` permission.
       */
      includeDrafts?: boolean | undefined;
  }
  interface QueryOffsetResult {
      currentPage: number | undefined;
      totalPages: number | undefined;
      totalCount: number | undefined;
      hasNext: () => boolean;
      hasPrev: () => boolean;
      length: number;
      pageSize: number;
  }
  interface EventsQueryResult extends QueryOffsetResult {
      items: V3Event[];
      query: EventsQueryBuilder;
      next: () => Promise<EventsQueryResult>;
      prev: () => Promise<EventsQueryResult>;
  }
  interface EventsQueryBuilder {
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       */
      eq: (propertyName: '_id' | 'dateAndTimeSettings.startDate' | 'dateAndTimeSettings.endDate' | 'title' | 'slug' | '_createdDate' | '_updatedDate' | 'status' | 'registration.initialType' | 'userId', value: any) => EventsQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       */
      ne: (propertyName: '_id' | 'dateAndTimeSettings.startDate' | 'dateAndTimeSettings.endDate' | 'title' | 'slug' | '_createdDate' | '_updatedDate' | 'status' | 'userId', value: any) => EventsQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       */
      ge: (propertyName: 'dateAndTimeSettings.startDate' | 'dateAndTimeSettings.endDate' | '_createdDate' | '_updatedDate', value: any) => EventsQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       */
      gt: (propertyName: 'dateAndTimeSettings.startDate' | 'dateAndTimeSettings.endDate' | '_createdDate' | '_updatedDate', value: any) => EventsQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       */
      le: (propertyName: 'dateAndTimeSettings.startDate' | 'dateAndTimeSettings.endDate' | '_createdDate' | '_updatedDate', value: any) => EventsQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       */
      lt: (propertyName: 'dateAndTimeSettings.startDate' | 'dateAndTimeSettings.endDate' | '_createdDate' | '_updatedDate', value: any) => EventsQueryBuilder;
      in: (propertyName: '_id' | 'dateAndTimeSettings.startDate' | 'dateAndTimeSettings.endDate' | 'title' | 'slug' | '_createdDate' | '_updatedDate' | 'status' | 'userId', value: any) => EventsQueryBuilder;
      /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments. */
      ascending: (...propertyNames: Array<'_id' | 'dateAndTimeSettings.startDate' | 'dateAndTimeSettings.endDate' | 'title' | 'slug' | '_createdDate' | '_updatedDate'>) => EventsQueryBuilder;
      /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments. */
      descending: (...propertyNames: Array<'_id' | 'dateAndTimeSettings.startDate' | 'dateAndTimeSettings.endDate' | 'title' | 'slug' | '_createdDate' | '_updatedDate'>) => EventsQueryBuilder;
      /** @param limit - Number of items to return, which is also the `pageSize` of the results object. */
      limit: (limit: number) => EventsQueryBuilder;
      /** @param skip - Number of items to skip in the query results before returning the results. */
      skip: (skip: number) => EventsQueryBuilder;
      find: () => Promise<EventsQueryResult>;
  }
  /**
   * Counts events by status.
   * @public
   * @param options - Optional fields.
   * @permissionId WIX_EVENTS.READ_EVENTS
   */
  function countEventsByStatus(options?: CountEventsByStatusOptions): Promise<CountEventsByStatusResponse>;
  interface CountEventsByStatusOptions {
      /** Filter object in the following format: <br/> `"filter" : { "fieldName1": "value1" }`. */
      filter?: Record<string, any> | null;
      /** Parameters to count events by. */
      facet?: string[];
      /**
       * Whether draft events should be returned in the response. <br>
       * **Note:** This parameter requires the `WIX_EVENTS.READ_DRAFT_EVENTS` permission.
       */
      includeDrafts?: boolean;
  }
  /**
   * Retrieves a list of up to 100 events that belong to the same event category.
   * @param categoryId - Category ID.
   * @internal
   * @requiredField categoryId
   * @param options - Optional fields.
   * @permissionId WIX_EVENTS.READ_EVENTS
   */
  function listEventsByCategory(categoryId: string, options?: ListEventsByCategoryOptions): Promise<ListEventsByCategoryResponse>;
  interface ListEventsByCategoryOptions {
      /** Paging options to limit and skip the number of items. */
      paging?: Paging$1;
      /** Predefined sets of fields to return. If both `fields` and `fieldsets` are sent in the request, the union of both lists is returned. */
      fields?: RequestedFields[];
  }
  /**
   * Retrieves an event by ID.
   *
   * To retrieve an event description, call [Get Rich Content](https://dev.wix.com/docs/rest/business-solutions/events/rich-content/get-rich-content).
   * @param eventId - Event ID.
   * @public
   * @requiredField eventId
   * @param options - Optional fields.
   * @permissionId WIX_EVENTS.READ_EVENTS
   * @returns Event.
   */
  function getEvent(eventId: string | null, options?: GetEventOptions): Promise<V3Event>;
  interface GetEventOptions {
      fields?: RequestedFields[];
      /**
       * indicates whether full_address should be resolved
       * @internal
       */
      resolveFullAddress?: boolean;
  }
  /**
   * Retrieves an event by the `slug` URL.
   *
   *
   * The slug is the end of an event URL that refers to a specific event. For example, if an events' URL is `https://example.com/events/event/{my-event-slug}`, the slug is `my-event-slug`.
   * @param slug - URL slug.
   * @public
   * @requiredField slug
   * @param options - Optional fields.
   * @permissionId WIX_EVENTS.READ_EVENTS
   */
  function getEventBySlug(slug: string | null, options?: GetEventBySlugOptions): Promise<GetEventBySlugResponse>;
  interface GetEventBySlugOptions {
      fields?: RequestedFields[];
      /**
       * indicates whether full_address should be resolved
       * @internal
       */
      resolveFullAddress?: boolean;
  }
  /**
   * Finds an event by ID or URL slug.
   *
   *
   * Unlike the [`getEvent`](https://www.wix.com/velo/reference/wix-events-v2/wixeventsv2/getevent) function, which returns a "not found" error, `findEvent()` returns an empty response when an event is not found.
   * @internal
   * @param options - Optional fields.
   * @permissionId WIX_EVENTS.READ_EVENTS
   */
  function findEvent(options?: FindEventOptions): Promise<FindEventResponse>;
  interface FindEventOptions extends FindEventRequestFindByOneOf {
      /** Event ID. */
      eventId?: string | null;
      /** URL slug. */
      slug?: string | null;
      /** Predefined sets of fields to return. */
      fields?: RequestedFields[];
  }
  
  type eventsV3Event_universal_d_V3Event = V3Event;
  type eventsV3Event_universal_d_TimeDuration = TimeDuration;
  type eventsV3Event_universal_d_RegistrationTypeType = RegistrationTypeType;
  const eventsV3Event_universal_d_RegistrationTypeType: typeof RegistrationTypeType;
  type eventsV3Event_universal_d_RegistrationStatusStatus = RegistrationStatusStatus;
  const eventsV3Event_universal_d_RegistrationStatusStatus: typeof RegistrationStatusStatus;
  type eventsV3Event_universal_d_RsvpRegistration = RsvpRegistration;
  type eventsV3Event_universal_d_ResponseType = ResponseType;
  const eventsV3Event_universal_d_ResponseType: typeof ResponseType;
  type eventsV3Event_universal_d_TicketsRegistration = TicketsRegistration;
  type eventsV3Event_universal_d_TaxSettings = TaxSettings;
  type eventsV3Event_universal_d_ExternalRegistration = ExternalRegistration;
  type eventsV3Event_universal_d_GuestTypeType = GuestTypeType;
  const eventsV3Event_universal_d_GuestTypeType: typeof GuestTypeType;
  type eventsV3Event_universal_d_InitialRegistrationTypeType = InitialRegistrationTypeType;
  const eventsV3Event_universal_d_InitialRegistrationTypeType: typeof InitialRegistrationTypeType;
  type eventsV3Event_universal_d_CalendarUrls = CalendarUrls;
  type eventsV3Event_universal_d_Summaries = Summaries;
  type eventsV3Event_universal_d_EventsMoney = EventsMoney;
  type eventsV3Event_universal_d_Rsvps = Rsvps;
  type eventsV3Event_universal_d_Tickets = Tickets;
  type eventsV3Event_universal_d_GuestListSettings = GuestListSettings;
  type eventsV3Event_universal_d_ConferenceTypeType = ConferenceTypeType;
  const eventsV3Event_universal_d_ConferenceTypeType: typeof ConferenceTypeType;
  type eventsV3Event_universal_d_AgendaSettings = AgendaSettings;
  type eventsV3Event_universal_d_EventCategories = EventCategories;
  type eventsV3Event_universal_d_EventCategory = EventCategory;
  type eventsV3Event_universal_d_V3EventDisplaySettings = V3EventDisplaySettings;
  type eventsV3Event_universal_d_V3LabellingSettings = V3LabellingSettings;
  type eventsV3Event_universal_d_EventEventStarted = EventEventStarted;
  type eventsV3Event_universal_d_EventEventEnded = EventEventEnded;
  type eventsV3Event_universal_d_EventEventReminder = EventEventReminder;
  type eventsV3Event_universal_d_EventEventPublished = EventEventPublished;
  type eventsV3Event_universal_d_EventCloned = EventCloned;
  type eventsV3Event_universal_d_EventEventCanceled = EventEventCanceled;
  type eventsV3Event_universal_d_CreateEventRequest = CreateEventRequest;
  type eventsV3Event_universal_d_RequestedFields = RequestedFields;
  const eventsV3Event_universal_d_RequestedFields: typeof RequestedFields;
  type eventsV3Event_universal_d_CreateEventResponse = CreateEventResponse;
  type eventsV3Event_universal_d_CloneEventRequest = CloneEventRequest;
  type eventsV3Event_universal_d_CloneEventResponse = CloneEventResponse;
  type eventsV3Event_universal_d_UpdateEventRequest = UpdateEventRequest;
  type eventsV3Event_universal_d_UpdateEventResponse = UpdateEventResponse;
  type eventsV3Event_universal_d_PublishDraftEventRequest = PublishDraftEventRequest;
  type eventsV3Event_universal_d_PublishDraftEventResponse = PublishDraftEventResponse;
  type eventsV3Event_universal_d_CancelEventRequest = CancelEventRequest;
  type eventsV3Event_universal_d_CancelEventResponse = CancelEventResponse;
  type eventsV3Event_universal_d_BulkCancelEventsByFilterRequest = BulkCancelEventsByFilterRequest;
  type eventsV3Event_universal_d_BulkCancelEventsByFilterResponse = BulkCancelEventsByFilterResponse;
  type eventsV3Event_universal_d_DeleteEventRequest = DeleteEventRequest;
  type eventsV3Event_universal_d_DeleteEventResponse = DeleteEventResponse;
  type eventsV3Event_universal_d_BulkDeleteEventsByFilterRequest = BulkDeleteEventsByFilterRequest;
  type eventsV3Event_universal_d_BulkDeleteEventsByFilterResponse = BulkDeleteEventsByFilterResponse;
  type eventsV3Event_universal_d_QueryEventsRequest = QueryEventsRequest;
  type eventsV3Event_universal_d_QueryEventsResponse = QueryEventsResponse;
  type eventsV3Event_universal_d_ExportEventsRequest = ExportEventsRequest;
  type eventsV3Event_universal_d_CommonQueryV2 = CommonQueryV2;
  type eventsV3Event_universal_d_CommonQueryV2PagingMethodOneOf = CommonQueryV2PagingMethodOneOf;
  type eventsV3Event_universal_d_CommonSorting = CommonSorting;
  type eventsV3Event_universal_d_CommonSortOrder = CommonSortOrder;
  const eventsV3Event_universal_d_CommonSortOrder: typeof CommonSortOrder;
  type eventsV3Event_universal_d_CommonPaging = CommonPaging;
  type eventsV3Event_universal_d_ExportEventsResponse = ExportEventsResponse;
  type eventsV3Event_universal_d_CommonPagingMetadataV2 = CommonPagingMetadataV2;
  type eventsV3Event_universal_d_CommonCursors = CommonCursors;
  type eventsV3Event_universal_d_CountEventsByStatusRequest = CountEventsByStatusRequest;
  type eventsV3Event_universal_d_CountEventsByStatusResponse = CountEventsByStatusResponse;
  type eventsV3Event_universal_d_ListUserEventsRequest = ListUserEventsRequest;
  type eventsV3Event_universal_d_UserFilter = UserFilter;
  type eventsV3Event_universal_d_Relation = Relation;
  const eventsV3Event_universal_d_Relation: typeof Relation;
  type eventsV3Event_universal_d_ListUserEventsResponse = ListUserEventsResponse;
  type eventsV3Event_universal_d_ListEventsByCategoryRequest = ListEventsByCategoryRequest;
  type eventsV3Event_universal_d_ListEventsByCategoryResponse = ListEventsByCategoryResponse;
  type eventsV3Event_universal_d_GetEventRequest = GetEventRequest;
  type eventsV3Event_universal_d_GetEventResponse = GetEventResponse;
  type eventsV3Event_universal_d_GetEventBySlugRequest = GetEventBySlugRequest;
  type eventsV3Event_universal_d_GetEventBySlugResponse = GetEventBySlugResponse;
  type eventsV3Event_universal_d_FindEventRequest = FindEventRequest;
  type eventsV3Event_universal_d_FindEventRequestFindByOneOf = FindEventRequestFindByOneOf;
  type eventsV3Event_universal_d_FindEventResponse = FindEventResponse;
  type eventsV3Event_universal_d_EventsLocation = EventsLocation;
  type eventsV3Event_universal_d_EventsRecurrences = EventsRecurrences;
  type eventsV3Event_universal_d_EventsOccurrence = EventsOccurrence;
  type eventsV3Event_universal_d_EventsRecurrenceStatusStatus = EventsRecurrenceStatusStatus;
  const eventsV3Event_universal_d_EventsRecurrenceStatusStatus: typeof EventsRecurrenceStatusStatus;
  type eventsV3Event_universal_d_EventsRegistration = EventsRegistration;
  type eventsV3Event_universal_d_EventsTaxType = EventsTaxType;
  const eventsV3Event_universal_d_EventsTaxType: typeof EventsTaxType;
  type eventsV3Event_universal_d_EventsFeed = EventsFeed;
  type eventsV3Event_universal_d_EventsOnlineConferencing = EventsOnlineConferencing;
  type eventsV3Event_universal_d_EventsOnlineConferencingSession = EventsOnlineConferencingSession;
  type eventsV3Event_universal_d_EventsSeoSettings = EventsSeoSettings;
  type eventsV3Event_universal_d_EventCopied = EventCopied;
  type eventsV3Event_universal_d_EventPublished = EventPublished;
  type eventsV3Event_universal_d_EventStarted = EventStarted;
  type eventsV3Event_universal_d_EventReminder = EventReminder;
  const eventsV3Event_universal_d_createEvent: typeof createEvent;
  type eventsV3Event_universal_d_CreateEventOptions = CreateEventOptions;
  const eventsV3Event_universal_d_cloneEvent: typeof cloneEvent;
  type eventsV3Event_universal_d_CloneEventOptions = CloneEventOptions;
  const eventsV3Event_universal_d_updateEvent: typeof updateEvent;
  type eventsV3Event_universal_d_UpdateEventOptions = UpdateEventOptions;
  const eventsV3Event_universal_d_publishDraftEvent: typeof publishDraftEvent;
  type eventsV3Event_universal_d_PublishDraftEventOptions = PublishDraftEventOptions;
  const eventsV3Event_universal_d_cancelEvent: typeof cancelEvent;
  type eventsV3Event_universal_d_CancelEventOptions = CancelEventOptions;
  const eventsV3Event_universal_d_bulkCancelEventsByFilter: typeof bulkCancelEventsByFilter;
  type eventsV3Event_universal_d_BulkCancelEventsByFilterOptions = BulkCancelEventsByFilterOptions;
  const eventsV3Event_universal_d_deleteEvent: typeof deleteEvent;
  const eventsV3Event_universal_d_bulkDeleteEventsByFilter: typeof bulkDeleteEventsByFilter;
  type eventsV3Event_universal_d_BulkDeleteEventsByFilterOptions = BulkDeleteEventsByFilterOptions;
  const eventsV3Event_universal_d_queryEvents: typeof queryEvents;
  type eventsV3Event_universal_d_QueryEventsOptions = QueryEventsOptions;
  type eventsV3Event_universal_d_EventsQueryResult = EventsQueryResult;
  type eventsV3Event_universal_d_EventsQueryBuilder = EventsQueryBuilder;
  const eventsV3Event_universal_d_countEventsByStatus: typeof countEventsByStatus;
  type eventsV3Event_universal_d_CountEventsByStatusOptions = CountEventsByStatusOptions;
  const eventsV3Event_universal_d_listEventsByCategory: typeof listEventsByCategory;
  type eventsV3Event_universal_d_ListEventsByCategoryOptions = ListEventsByCategoryOptions;
  const eventsV3Event_universal_d_getEvent: typeof getEvent;
  type eventsV3Event_universal_d_GetEventOptions = GetEventOptions;
  const eventsV3Event_universal_d_getEventBySlug: typeof getEventBySlug;
  type eventsV3Event_universal_d_GetEventBySlugOptions = GetEventBySlugOptions;
  const eventsV3Event_universal_d_findEvent: typeof findEvent;
  type eventsV3Event_universal_d_FindEventOptions = FindEventOptions;
  namespace eventsV3Event_universal_d {
    export {
      eventsV3Event_universal_d_V3Event as V3Event,
      Location$1 as Location,
      LocationType$1 as LocationType,
      CommonAddress$1 as CommonAddress,
      CommonAddressStreetOneOf$1 as CommonAddressStreetOneOf,
      CommonStreetAddress$1 as CommonStreetAddress,
      CommonAddressLocation$1 as CommonAddressLocation,
      CommonSubdivision$1 as CommonSubdivision,
      SubdivisionSubdivisionType$1 as SubdivisionSubdivisionType,
      DateAndTimeSettings$1 as DateAndTimeSettings,
      RecurrenceStatusStatus$1 as RecurrenceStatusStatus,
      Recurrences$1 as Recurrences,
      Occurrence$1 as Occurrence,
      Formatted$1 as Formatted,
      eventsV3Event_universal_d_TimeDuration as TimeDuration,
      Status$1 as Status,
      Registration$1 as Registration,
      eventsV3Event_universal_d_RegistrationTypeType as RegistrationTypeType,
      eventsV3Event_universal_d_RegistrationStatusStatus as RegistrationStatusStatus,
      eventsV3Event_universal_d_RsvpRegistration as RsvpRegistration,
      eventsV3Event_universal_d_ResponseType as ResponseType,
      eventsV3Event_universal_d_TicketsRegistration as TicketsRegistration,
      Money$1 as Money,
      eventsV3Event_universal_d_TaxSettings as TaxSettings,
      TaxType$1 as TaxType,
      eventsV3Event_universal_d_ExternalRegistration as ExternalRegistration,
      eventsV3Event_universal_d_GuestTypeType as GuestTypeType,
      eventsV3Event_universal_d_InitialRegistrationTypeType as InitialRegistrationTypeType,
      eventsV3Event_universal_d_CalendarUrls as CalendarUrls,
      Form$1 as Form,
      InputControl$1 as InputControl,
      InputControlType$1 as InputControlType,
      Input$1 as Input,
      ValueType$1 as ValueType,
      OptionSelection$1 as OptionSelection,
      OptionSelectionSelectedOptionOneOf$1 as OptionSelectionSelectedOptionOneOf,
      Label$1 as Label,
      FormMessages$1 as FormMessages,
      RsvpFormMessages$1 as RsvpFormMessages,
      PositiveResponseConfirmation$1 as PositiveResponseConfirmation,
      NegativeResponseConfirmation$1 as NegativeResponseConfirmation,
      Positive$1 as Positive,
      Negative$1 as Negative,
      CheckoutFormMessages$1 as CheckoutFormMessages,
      ResponseConfirmation$1 as ResponseConfirmation,
      RegistrationClosedMessages$1 as RegistrationClosedMessages,
      TicketsUnavailableMessages$1 as TicketsUnavailableMessages,
      eventsV3Event_universal_d_Summaries as Summaries,
      eventsV3Event_universal_d_EventsMoney as EventsMoney,
      eventsV3Event_universal_d_Rsvps as Rsvps,
      eventsV3Event_universal_d_Tickets as Tickets,
      eventsV3Event_universal_d_GuestListSettings as GuestListSettings,
      Feed$1 as Feed,
      OnlineConferencing$1 as OnlineConferencing,
      eventsV3Event_universal_d_ConferenceTypeType as ConferenceTypeType,
      OnlineConferencingSession$1 as OnlineConferencingSession,
      SeoSettings$1 as SeoSettings,
      SeoSchema$1 as SeoSchema,
      Keyword$1 as Keyword,
      Tag$1 as Tag,
      Settings$1 as Settings,
      eventsV3Event_universal_d_AgendaSettings as AgendaSettings,
      eventsV3Event_universal_d_EventCategories as EventCategories,
      eventsV3Event_universal_d_EventCategory as EventCategory,
      Type$1 as Type,
      eventsV3Event_universal_d_V3EventDisplaySettings as V3EventDisplaySettings,
      eventsV3Event_universal_d_V3LabellingSettings as V3LabellingSettings,
      eventsV3Event_universal_d_EventEventStarted as EventEventStarted,
      eventsV3Event_universal_d_EventEventEnded as EventEventEnded,
      eventsV3Event_universal_d_EventEventReminder as EventEventReminder,
      eventsV3Event_universal_d_EventEventPublished as EventEventPublished,
      eventsV3Event_universal_d_EventCloned as EventCloned,
      eventsV3Event_universal_d_EventEventCanceled as EventEventCanceled,
      eventsV3Event_universal_d_CreateEventRequest as CreateEventRequest,
      eventsV3Event_universal_d_RequestedFields as RequestedFields,
      eventsV3Event_universal_d_CreateEventResponse as CreateEventResponse,
      eventsV3Event_universal_d_CloneEventRequest as CloneEventRequest,
      eventsV3Event_universal_d_CloneEventResponse as CloneEventResponse,
      eventsV3Event_universal_d_UpdateEventRequest as UpdateEventRequest,
      eventsV3Event_universal_d_UpdateEventResponse as UpdateEventResponse,
      eventsV3Event_universal_d_PublishDraftEventRequest as PublishDraftEventRequest,
      eventsV3Event_universal_d_PublishDraftEventResponse as PublishDraftEventResponse,
      eventsV3Event_universal_d_CancelEventRequest as CancelEventRequest,
      eventsV3Event_universal_d_CancelEventResponse as CancelEventResponse,
      eventsV3Event_universal_d_BulkCancelEventsByFilterRequest as BulkCancelEventsByFilterRequest,
      QueryV2$1 as QueryV2,
      QueryV2PagingMethodOneOf$1 as QueryV2PagingMethodOneOf,
      Sorting$1 as Sorting,
      SortOrder$1 as SortOrder,
      Paging$1 as Paging,
      eventsV3Event_universal_d_BulkCancelEventsByFilterResponse as BulkCancelEventsByFilterResponse,
      eventsV3Event_universal_d_DeleteEventRequest as DeleteEventRequest,
      eventsV3Event_universal_d_DeleteEventResponse as DeleteEventResponse,
      eventsV3Event_universal_d_BulkDeleteEventsByFilterRequest as BulkDeleteEventsByFilterRequest,
      eventsV3Event_universal_d_BulkDeleteEventsByFilterResponse as BulkDeleteEventsByFilterResponse,
      eventsV3Event_universal_d_QueryEventsRequest as QueryEventsRequest,
      eventsV3Event_universal_d_QueryEventsResponse as QueryEventsResponse,
      PagingMetadataV2$1 as PagingMetadataV2,
      Cursors$1 as Cursors,
      eventsV3Event_universal_d_ExportEventsRequest as ExportEventsRequest,
      eventsV3Event_universal_d_CommonQueryV2 as CommonQueryV2,
      eventsV3Event_universal_d_CommonQueryV2PagingMethodOneOf as CommonQueryV2PagingMethodOneOf,
      eventsV3Event_universal_d_CommonSorting as CommonSorting,
      eventsV3Event_universal_d_CommonSortOrder as CommonSortOrder,
      eventsV3Event_universal_d_CommonPaging as CommonPaging,
      CursorPaging$1 as CursorPaging,
      eventsV3Event_universal_d_ExportEventsResponse as ExportEventsResponse,
      eventsV3Event_universal_d_CommonPagingMetadataV2 as CommonPagingMetadataV2,
      eventsV3Event_universal_d_CommonCursors as CommonCursors,
      eventsV3Event_universal_d_CountEventsByStatusRequest as CountEventsByStatusRequest,
      eventsV3Event_universal_d_CountEventsByStatusResponse as CountEventsByStatusResponse,
      FacetCounts$1 as FacetCounts,
      eventsV3Event_universal_d_ListUserEventsRequest as ListUserEventsRequest,
      eventsV3Event_universal_d_UserFilter as UserFilter,
      eventsV3Event_universal_d_Relation as Relation,
      eventsV3Event_universal_d_ListUserEventsResponse as ListUserEventsResponse,
      eventsV3Event_universal_d_ListEventsByCategoryRequest as ListEventsByCategoryRequest,
      eventsV3Event_universal_d_ListEventsByCategoryResponse as ListEventsByCategoryResponse,
      eventsV3Event_universal_d_GetEventRequest as GetEventRequest,
      eventsV3Event_universal_d_GetEventResponse as GetEventResponse,
      eventsV3Event_universal_d_GetEventBySlugRequest as GetEventBySlugRequest,
      eventsV3Event_universal_d_GetEventBySlugResponse as GetEventBySlugResponse,
      eventsV3Event_universal_d_FindEventRequest as FindEventRequest,
      eventsV3Event_universal_d_FindEventRequestFindByOneOf as FindEventRequestFindByOneOf,
      eventsV3Event_universal_d_FindEventResponse as FindEventResponse,
      EventCreated$1 as EventCreated,
      eventsV3Event_universal_d_EventsLocation as EventsLocation,
      MapCoordinates$1 as MapCoordinates,
      LocationLocationType$1 as LocationLocationType,
      Address$1 as Address,
      AddressStreetOneOf$1 as AddressStreetOneOf,
      StreetAddress$1 as StreetAddress,
      AddressLocation$1 as AddressLocation,
      Subdivision$1 as Subdivision,
      SubdivisionType$1 as SubdivisionType,
      ScheduleConfig$1 as ScheduleConfig,
      eventsV3Event_universal_d_EventsRecurrences as EventsRecurrences,
      eventsV3Event_universal_d_EventsOccurrence as EventsOccurrence,
      eventsV3Event_universal_d_EventsRecurrenceStatusStatus as EventsRecurrenceStatusStatus,
      EventStatus$1 as EventStatus,
      Event$1 as Event,
      Scheduling$1 as Scheduling,
      eventsV3Event_universal_d_EventsRegistration as EventsRegistration,
      EventType$1 as EventType,
      RegistrationStatus$1 as RegistrationStatus,
      RsvpCollection$1 as RsvpCollection,
      RsvpCollectionConfig$1 as RsvpCollectionConfig,
      RsvpStatusOptions$1 as RsvpStatusOptions,
      Ticketing$1 as Ticketing,
      TicketingConfig$1 as TicketingConfig,
      TaxConfig$1 as TaxConfig,
      eventsV3Event_universal_d_EventsTaxType as EventsTaxType,
      ExternalEvent$1 as ExternalEvent,
      VisitorType$1 as VisitorType,
      CalendarLinks$1 as CalendarLinks,
      SiteUrl$1 as SiteUrl,
      Dashboard$1 as Dashboard,
      RsvpSummary$1 as RsvpSummary,
      TicketingSummary$1 as TicketingSummary,
      GuestListConfig$1 as GuestListConfig,
      eventsV3Event_universal_d_EventsFeed as EventsFeed,
      eventsV3Event_universal_d_EventsOnlineConferencing as EventsOnlineConferencing,
      OnlineConferencingConfig$1 as OnlineConferencingConfig,
      ConferenceType$1 as ConferenceType,
      eventsV3Event_universal_d_EventsOnlineConferencingSession as EventsOnlineConferencingSession,
      eventsV3Event_universal_d_EventsSeoSettings as EventsSeoSettings,
      Agenda$1 as Agenda,
      Category$1 as Category,
      CategoryCounts$1 as CategoryCounts,
      State$1 as State,
      EventDisplaySettings$1 as EventDisplaySettings,
      LabellingSettings$1 as LabellingSettings,
      Empty$1 as Empty,
      EventUpdated$1 as EventUpdated,
      EventDeleted$1 as EventDeleted,
      eventsV3Event_universal_d_EventCopied as EventCopied,
      eventsV3Event_universal_d_EventPublished as EventPublished,
      EventCanceled$1 as EventCanceled,
      eventsV3Event_universal_d_EventStarted as EventStarted,
      EventEnded$1 as EventEnded,
      eventsV3Event_universal_d_EventReminder as EventReminder,
      DomainEvent$1 as DomainEvent,
      DomainEventBodyOneOf$1 as DomainEventBodyOneOf,
      EntityCreatedEvent$1 as EntityCreatedEvent,
      RestoreInfo$1 as RestoreInfo,
      EntityUpdatedEvent$1 as EntityUpdatedEvent,
      EntityDeletedEvent$1 as EntityDeletedEvent,
      ActionEvent$1 as ActionEvent,
      MessageEnvelope$1 as MessageEnvelope,
      IdentificationData$1 as IdentificationData,
      IdentificationDataIdOneOf$1 as IdentificationDataIdOneOf,
      WebhookIdentityType$1 as WebhookIdentityType,
      eventsV3Event_universal_d_createEvent as createEvent,
      eventsV3Event_universal_d_CreateEventOptions as CreateEventOptions,
      eventsV3Event_universal_d_cloneEvent as cloneEvent,
      eventsV3Event_universal_d_CloneEventOptions as CloneEventOptions,
      eventsV3Event_universal_d_updateEvent as updateEvent,
      eventsV3Event_universal_d_UpdateEventOptions as UpdateEventOptions,
      eventsV3Event_universal_d_publishDraftEvent as publishDraftEvent,
      eventsV3Event_universal_d_PublishDraftEventOptions as PublishDraftEventOptions,
      eventsV3Event_universal_d_cancelEvent as cancelEvent,
      eventsV3Event_universal_d_CancelEventOptions as CancelEventOptions,
      eventsV3Event_universal_d_bulkCancelEventsByFilter as bulkCancelEventsByFilter,
      eventsV3Event_universal_d_BulkCancelEventsByFilterOptions as BulkCancelEventsByFilterOptions,
      eventsV3Event_universal_d_deleteEvent as deleteEvent,
      eventsV3Event_universal_d_bulkDeleteEventsByFilter as bulkDeleteEventsByFilter,
      eventsV3Event_universal_d_BulkDeleteEventsByFilterOptions as BulkDeleteEventsByFilterOptions,
      eventsV3Event_universal_d_queryEvents as queryEvents,
      eventsV3Event_universal_d_QueryEventsOptions as QueryEventsOptions,
      eventsV3Event_universal_d_EventsQueryResult as EventsQueryResult,
      eventsV3Event_universal_d_EventsQueryBuilder as EventsQueryBuilder,
      eventsV3Event_universal_d_countEventsByStatus as countEventsByStatus,
      eventsV3Event_universal_d_CountEventsByStatusOptions as CountEventsByStatusOptions,
      eventsV3Event_universal_d_listEventsByCategory as listEventsByCategory,
      eventsV3Event_universal_d_ListEventsByCategoryOptions as ListEventsByCategoryOptions,
      eventsV3Event_universal_d_getEvent as getEvent,
      eventsV3Event_universal_d_GetEventOptions as GetEventOptions,
      eventsV3Event_universal_d_getEventBySlug as getEventBySlug,
      eventsV3Event_universal_d_GetEventBySlugOptions as GetEventBySlugOptions,
      eventsV3Event_universal_d_findEvent as findEvent,
      eventsV3Event_universal_d_FindEventOptions as FindEventOptions,
    };
  }
  
  interface TicketDefinition {
      /**
       * Ticket definition ID.
       * @readonly
       */
      _id?: string | null;
      /** Event ID to which the ticket definition belongs. */
      eventId?: string | null;
      /**
       * Revision number, which increments by 1 each time the ticket definition is updated. To prevent conflicting changes, the existing revision must be used when updating a ticket definition.
       * @readonly
       */
      revision?: string | null;
      /**
       * Date and time when the ticket definition was created.
       * @readonly
       */
      _createdDate?: Date | null;
      /**
       * Date and time when the ticket definition was updated.
       * @readonly
       */
      _updatedDate?: Date | null;
      /** Ticket definition name. */
      name?: string | null;
      /** Ticket definition description. */
      description?: string | null;
      /** Ticket definition policy. */
      policyText?: string | null;
      /** Whether this ticket definition is hidden to site visitors and can't be purchased. */
      hidden?: boolean;
      /**
       * Whether the ticket has a limited maximum quantity.
       * @readonly
       */
      limited?: boolean;
      /** The maximum number of tickets that can be sold for the event when first defining the event. If a seating map is defined after you created a ticket definition, this property is ignored and `actualLimit` is used instead. */
      initialLimit?: number | null;
      /**
       * The maximum number of tickets that can be sold for the event after adding a seating map to the event. If no seating map is defined, this property is the same as `initialLimit`.
       * @readonly
       */
      actualLimit?: number | null;
      /** Ticket pricing method. */
      pricingMethod?: PricingMethod;
      /** Whether fee is included in the ticket price or customer pays it additionally at checkout. */
      feeType?: Type;
      /** Ticket sale period. */
      salePeriod?: SalePeriod;
      /**
       * Ticket sale status.
       * @readonly
       */
      saleStatus?: SaleStatusEnumStatus;
      /**
       * Ticket sales information. <br>
       * **Note:** This field is only returned when `SALES_DETAILS` fieldset is included in the request.
       */
      salesDetails?: SalesDetails;
      /**
       * For proxy.
       * @internal
       * @readonly
       */
      sortIndex?: number;
      /**
       * Number of tickets that can be purchased per checkout. <br>
       * **Note:** If the `actuaLimit` or `salesDetails.unsoldCount` field value is smaller than `limitPerCheckout`, then it overrides this field.
       * @readonly
       */
      limitPerCheckout?: number | null;
      /**
       * Event created timestamp in `yyyy-mm-ddThh:mm:sssZ` format.
       * @internal
       * @readonly
       */
      eventCreatedDate?: Date | null;
      /** Data extensions. */
      extendedFields?: ExtendedFields;
      /**
       * Associated event information. <br>
       * **Note:** This field is only returned when `EVENT_DETAILS` fieldset is included in the request.
       */
      eventDetails?: EventDetails;
  }
  interface SalePeriod {
      /** Ticket sale start timestamp. */
      startDate?: Date | null;
      /** Ticket sale end timestamp. */
      endDate?: Date | null;
      /** Whether to display the ticket if it's not available to buy. */
      displayNotOnSale?: boolean;
  }
  interface PricingMethod extends PricingMethodPriceOneOf {
      /** Same ticket price for everyone. */
      fixedPrice?: CommonMoney;
      /** Guests choose how much they'd like to pay for the ticket. You can set the minimum price, or make the ticket free(enter `0` in the request). The price can be updated to a higher amount by a guest during the checkout. */
      guestPrice?: CommonMoney;
      /** Sets of various ticket prices. For example, you can charge different prices for children and adults. */
      pricingOptions?: PricingOptions;
      /**
       * Ticket price type.
       * @readonly
       */
      pricingType?: PricingTypeEnumType;
      /**
       * Whether the ticket is free. To create a free ticket, enter `0` in the `pricingMethod.fixedPrice.value` field.
       * @readonly
       */
      free?: boolean;
  }
  /** @oneof */
  interface PricingMethodPriceOneOf {
      /** Same ticket price for everyone. */
      fixedPrice?: CommonMoney;
      /** Guests choose how much they'd like to pay for the ticket. You can set the minimum price, or make the ticket free(enter `0` in the request). The price can be updated to a higher amount by a guest during the checkout. */
      guestPrice?: CommonMoney;
      /** Sets of various ticket prices. For example, you can charge different prices for children and adults. */
      pricingOptions?: PricingOptions;
  }
  /**
   * Money.
   * Default format to use. Sufficiently compliant with majority of standards: w3c, ISO 4217, ISO 20022, ISO 8583:2003.
   */
  interface CommonMoney {
      /** Monetary amount. Decimal string with a period as a decimal separator (e.g., 3.99). Optionally, a single (-), to indicate that the amount is negative. */
      value?: string;
      /** Currency code. Must be a valid [ISO 4217](https://www.iso.org/iso-4217-currency-codes.html) currency code (e.g., USD). */
      currency?: string;
  }
  interface PricingOptions {
      /** Ticket price option details. */
      optionDetails?: OptionDetails[];
  }
  interface OptionDetails {
      /** Ticket price option ID. */
      optionId?: string | null;
      /** Ticket price option name, such as "Child Ticket". */
      name?: string | null;
      /** Ticket price. */
      price?: CommonMoney;
  }
  enum PricingTypeEnumType {
      /** Undefined pricing type. */
      UNKNOWN_PRICING_TYPE = "UNKNOWN_PRICING_TYPE",
      /** All money goes to a seller. Applies to all ticket pricing methods except for `guestPrice`. */
      STANDARD = "STANDARD",
      /** All collected money is a donation. This pricing type is automatically assigned when you select the `guestPrice` pricing method. */
      DONATION = "DONATION"
  }
  enum Type {
      /** Unknown fee type. */
      UNKNOWN_FEE_TYPE = "UNKNOWN_FEE_TYPE",
      /** The fee is deducted from the ticket price for a seller. For example, if you're selling tickets for $10, then a ticket service fee of $0.25 will be deducted from the price and you'll get $9.75. */
      FEE_INCLUDED = "FEE_INCLUDED",
      /** The fee is shown in addition to the ticket price at checkout and a guest pays the fee. For example, if you sell tickets for $10, a customer will see a ticket service fee of $0.25 and will pay $10.25 in total. */
      FEE_ADDED_AT_CHECKOUT = "FEE_ADDED_AT_CHECKOUT",
      /** Ticket service fee is not collected. Available only for free tickets and legacy users. */
      NO_FEE = "NO_FEE"
  }
  enum SaleStatusEnumStatus {
      /** Undefined sale status. */
      UNKNOWN_SALE_STATUS = "UNKNOWN_SALE_STATUS",
      /** Tickets are not on sale yet. */
      SALE_SCHEDULED = "SALE_SCHEDULED",
      /** Tickets are on sale. */
      SALE_STARTED = "SALE_STARTED",
      /** Tickets are not on sale. */
      SALE_ENDED = "SALE_ENDED"
  }
  interface SalesDetails {
      /**
       * Number of tickets that have not been purchased yet. The field is `null` if the ticket quantity is unlimited.
       * @readonly
       */
      unsoldCount?: number | null;
      /**
       * Number of purchased tickets.
       * @readonly
       */
      soldCount?: number | null;
      /**
       * Number of reserved tickets.
       * @readonly
       */
      reservedCount?: number | null;
      /**
       * Whether the tickets are sold out.
       * @readonly
       */
      soldOut?: boolean | null;
  }
  interface ExtendedFields {
      /**
       * Extended field data. Each key corresponds to the namespace of the app that created the extended fields.
       * The value of each key is structured according to the schema defined when the extended fields were configured.
       *
       * You can only access fields for which you have the appropriate permissions.
       *
       * Learn more about [extended fields](https://dev.wix.com/docs/rest/articles/getting-started/extended-fields).
       */
      namespaces?: Record<string, Record<string, any>>;
  }
  interface EventDetails {
      /**
       * Event title.
       * @readonly
       */
      title?: string | null;
      /**
       * Event short description.
       * @readonly
       */
      shortDescription?: string | null;
      /**
       * Event location.
       * @readonly
       */
      location?: V3Location;
      /**
       * Event date  and time settings.
       * @readonly
       */
      dateAndTimeSettings?: DateAndTimeSettings;
      /**
       * Event page URL components.
       * @readonly
       */
      eventPageUrl?: string;
      /**
       * Event status.
       * @readonly
       */
      status?: EventStatusStatus;
  }
  interface V3Location {
      /** Location name. This value is displayed instead of the address when the location is defined as TBD by setting the `locationTbd` property to `true`. */
      name?: string | null;
      /** Location type. */
      type?: LocationLocationType;
      /** Exact location address. */
      address?: CommonAddress;
      /** Whether the event location is TBD. */
      locationTbd?: boolean | null;
  }
  enum LocationLocationType {
      /** Unknown location type. */
      UNKNOWN_LOCATION = "UNKNOWN_LOCATION",
      /** Event is on-site at a specific physical location. */
      VENUE = "VENUE",
      /** Event is online, such as a virtual video conference. */
      ONLINE = "ONLINE"
  }
  /** Physical address */
  interface CommonAddress extends CommonAddressStreetOneOf {
      /** Street address. */
      streetAddress?: CommonStreetAddress;
      /** Primary address information (street and building number). */
      addressLine1?: string | null;
      /** 2-letter country code in [ISO-3166 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2#Officially_assigned_code_elements) format. */
      country?: string | null;
      /** Code for a subdivision (such as state, prefecture, or province) in [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). */
      subdivision?: string | null;
      /** City name. */
      city?: string | null;
      /** Zip or postal code. */
      postalCode?: string | null;
      /** Secondary address information (suite or apartment number and room number). */
      addressLine2?: string | null;
      /**
       * A string containing the full address of this location.
       * @internal
       */
      formatted?: string | null;
      /**
       * Coordinates of the physical address.
       * @internal
       */
      location?: CommonAddressLocation;
      /**
       * Country full name.
       * @internal
       */
      countryFullname?: string | null;
      /**
       * Subdivision full name.
       * @internal
       */
      subdivisionFullname?: string | null;
      /**
       * Multi-level subdivisions from top to bottom.
       * @internal
       */
      subdivisions?: CommonSubdivision[];
  }
  /** @oneof */
  interface CommonAddressStreetOneOf {
      /** Street address. */
      streetAddress?: CommonStreetAddress;
      /** Primary address information (street and building number). */
      addressLine?: string | null;
  }
  interface CommonStreetAddress {
      /** Street number. */
      number?: string;
      /** Street name. */
      name?: string;
      /**
       * Apartment number.
       * @internal
       */
      apt?: string;
      /**
       * Optional address line 1
       * @internal
       */
      formattedAddressLine?: string | null;
  }
  interface CommonAddressLocation {
      /** Address latitude coordinates. */
      latitude?: number | null;
      /** Address longitude coordinates. */
      longitude?: number | null;
  }
  interface CommonSubdivision {
      /** Short subdivision code. */
      code?: string;
      /** Subdivision full name. */
      name?: string;
      /**
       * Subdivision level
       * @internal
       */
      type?: SubdivisionSubdivisionType;
      /**
       * Free text description of subdivision type.
       * @internal
       */
      typeInfo?: string | null;
  }
  enum SubdivisionSubdivisionType {
      UNKNOWN_SUBDIVISION_TYPE = "UNKNOWN_SUBDIVISION_TYPE",
      /** State */
      ADMINISTRATIVE_AREA_LEVEL_1 = "ADMINISTRATIVE_AREA_LEVEL_1",
      /** County */
      ADMINISTRATIVE_AREA_LEVEL_2 = "ADMINISTRATIVE_AREA_LEVEL_2",
      /** City/town */
      ADMINISTRATIVE_AREA_LEVEL_3 = "ADMINISTRATIVE_AREA_LEVEL_3",
      /** Neighborhood/quarter */
      ADMINISTRATIVE_AREA_LEVEL_4 = "ADMINISTRATIVE_AREA_LEVEL_4",
      /** Street/block */
      ADMINISTRATIVE_AREA_LEVEL_5 = "ADMINISTRATIVE_AREA_LEVEL_5",
      /** ADMINISTRATIVE_AREA_LEVEL_0. Indicates the national political entity, and is typically the highest order type returned by the Geocoder. */
      COUNTRY = "COUNTRY"
  }
  interface DateAndTimeSettings {
      /** Whether the event date and time are TBD. */
      dateAndTimeTbd?: boolean | null;
      /** Message that is displayed when time and date is TBD. */
      dateAndTimeTbdMessage?: string | null;
      /** Event start date. */
      startDate?: Date | null;
      /** Event end date. */
      endDate?: Date | null;
      /** Event time zone ID in the [TZ database](https://www.iana.org/time-zones) format. */
      timeZoneId?: string | null;
      /** Whether the end date is hidden in the formatted date and time. */
      hideEndDate?: boolean | null;
      /** Whether the time zone is displayed in the formatted schedule. */
      showTimeZone?: boolean | null;
      /**
       * Repeating event status.
       * @readonly
       */
      recurrenceStatus?: RecurrenceStatusStatus;
      /** Event repetitions. */
      recurringEvents?: V3Recurrences;
      /** Formatted date and time settings. */
      formatted?: Formatted;
  }
  enum RecurrenceStatusStatus {
      /** Unknown recurrance status. */
      UNKNOWN_STATUS = "UNKNOWN_STATUS",
      /** Event happens only once and can last multiple days. */
      ONE_TIME = "ONE_TIME",
      /** A series of events that repeat. */
      RECURRING = "RECURRING",
      /** Next event in a schedule of recurring events. */
      RECURRING_UPCOMING = "RECURRING_UPCOMING",
      /** Latest event that ended in a schedule of recurring events. */
      RECURRING_RECENTLY_ENDED = "RECURRING_RECENTLY_ENDED",
      /** Latest canceled event in a schedule of recurring events */
      RECURRING_RECENTLY_CANCELED = "RECURRING_RECENTLY_CANCELED"
  }
  interface V3Recurrences {
      /** Individual event dates. */
      individualEventDates?: V3Occurrence[];
      /**
       * Recurring event category ID.
       * @readonly
       */
      categoryId?: string | null;
  }
  interface V3Occurrence {
      /** Event start date. */
      startDate?: Date | null;
      /** Event end date. */
      endDate?: Date | null;
      /** Event time zone ID in the [TZ database](https://www.iana.org/time-zones) format. */
      timeZoneId?: string | null;
      /** Whether the time zone is displayed in a formatted schedule. */
      showTimeZone?: boolean;
  }
  interface Formatted {
      /**
       * Formatted date and time representation. <br>
       * Example of formatting when an event lasts multiple days and is in the UTC time zone: `September 1, 2015 at 10:20 AM – September 5, 2015 at 12:14 PM`. <br>
       * Example of formatting when an event lasts 1 day and is in the GMT+2 time zone: `February 1, 2018, 12:10 – 2:50 PM GMT+2`.
       * @readonly
       */
      dateAndTime?: string | null;
      /**
       * Formatted start date of the event. Empty for TBD schedules.
       * @readonly
       */
      startDate?: string | null;
      /**
       * Formatted start time of the event. Empty for TBD schedules.
       * @readonly
       */
      startTime?: string | null;
      /**
       * Formatted end date of the event. Empty for TBD schedules or when the end date is hidden.
       * @readonly
       */
      endDate?: string | null;
      /**
       * Formatted end time of the event. Empty for TBD schedules or when the end date is hidden.
       * @readonly
       */
      endTime?: string | null;
  }
  enum EventStatusStatus {
      /** Unknown event status. */
      UNKNOWN_EVENT_STATUS = "UNKNOWN_EVENT_STATUS",
      /** Event is published and scheduled to start. */
      UPCOMING = "UPCOMING",
      /** Event has started. */
      STARTED = "STARTED",
      /** Event has ended. */
      ENDED = "ENDED",
      /** Event is canceled. */
      CANCELED = "CANCELED",
      /** Event is not public. */
      DRAFT = "DRAFT"
  }
  interface SalePeriodUpdated {
      /** Ticket definition sale period after update. */
      afterUpdate?: SalePeriod;
  }
  interface TicketDefinitionSaleStarted {
      /** Ticket definition. */
      ticketDefinition?: TicketDefinition;
  }
  interface TicketDefinitionSaleEnded {
      /** Ticket definition. */
      ticketDefinition?: TicketDefinition;
  }
  interface DomainEvent extends DomainEventBodyOneOf {
      createdEvent?: EntityCreatedEvent;
      updatedEvent?: EntityUpdatedEvent;
      deletedEvent?: EntityDeletedEvent;
      actionEvent?: ActionEvent;
      /**
       * Unique event ID.
       * Allows clients to ignore duplicate webhooks.
       */
      _id?: string;
      /**
       * Assumes actions are also always typed to an entity_type
       * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
       */
      entityFqdn?: string;
      /**
       * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
       * This is although the created/updated/deleted notion is duplication of the oneof types
       * Example: created/updated/deleted/started/completed/email_opened
       */
      slug?: string;
      /** ID of the entity associated with the event. */
      entityId?: string;
      /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
      eventTime?: Date | null;
      /**
       * Whether the event was triggered as a result of a privacy regulation application
       * (for example, GDPR).
       */
      triggeredByAnonymizeRequest?: boolean | null;
      /** If present, indicates the action that triggered the event. */
      originatedFrom?: string | null;
      /**
       * A sequence number defining the order of updates to the underlying entity.
       * For example, given that some entity was updated at 16:00 and than again at 16:01,
       * it is guaranteed that the sequence number of the second update is strictly higher than the first.
       * As the consumer, you can use this value to ensure that you handle messages in the correct order.
       * To do so, you will need to persist this number on your end, and compare the sequence number from the
       * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
       */
      entityEventSequence?: string | null;
  }
  /** @oneof */
  interface DomainEventBodyOneOf {
      createdEvent?: EntityCreatedEvent;
      updatedEvent?: EntityUpdatedEvent;
      deletedEvent?: EntityDeletedEvent;
      actionEvent?: ActionEvent;
  }
  interface EntityCreatedEvent {
      entityAsJson?: string;
      /**
       * Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity
       * @internal
       */
      triggeredByUndelete?: boolean | null;
      /** Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity */
      restoreInfo?: RestoreInfo;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface RestoreInfo {
      deletedDate?: Date | null;
  }
  interface EntityUpdatedEvent {
      /**
       * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
       * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
       * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
       */
      currentEntityAsJson?: string;
      /**
       * This field is currently part of the of the EntityUpdatedEvent msg, but scala/node libraries which implements the domain events standard
       * wont populate it / have any reference to it in the API.
       * The main reason for it is that fetching the old entity from the DB will have a performance hit on an update operation so unless truly needed,
       * the developer should send only the new (current) entity.
       * An additional reason is not wanting to send this additional entity over the wire (kafka) since in some cases it can be really big
       * Developers that must reflect the old entity will have to implement their own domain event sender mechanism which will follow the DomainEvent proto message.
       * @internal
       * @deprecated
       */
      previousEntityAsJson?: string | null;
      /**
       * WIP - This property will hold both names and previous values of the updated fields of the entity.
       * For more details please see [adr](https://docs.google.com/document/d/1PdqsOM20Ph2HAkmx8zvUnzzk3Sekp3BR9h34wSvsRnI/edit#heading=h.phlw87mh2imx) or [issue](https://github.com/wix-private/nile-tracker/issues/363)
       * @internal
       */
      modifiedFields?: Record<string, any>;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface EntityDeletedEvent {
      /**
       * Indicates if the entity is sent to trash-bin. only available when trash-bin is enabled
       * @internal
       */
      movedToTrash?: boolean | null;
      /** Entity that was deleted */
      deletedEntityAsJson?: string | null;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface ActionEvent {
      bodyAsJson?: string;
  }
  interface MessageEnvelope {
      /** App instance ID. */
      instanceId?: string | null;
      /** Event type. */
      eventType?: string;
      /** The identification type and identity data. */
      identity?: IdentificationData;
      /** Stringify payload. */
      data?: string;
  }
  interface IdentificationData extends IdentificationDataIdOneOf {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
      /** @readonly */
      identityType?: WebhookIdentityType;
  }
  /** @oneof */
  interface IdentificationDataIdOneOf {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
  }
  enum WebhookIdentityType {
      UNKNOWN = "UNKNOWN",
      ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
      MEMBER = "MEMBER",
      WIX_USER = "WIX_USER",
      APP = "APP"
  }
  interface InvalidateCache extends InvalidateCacheGetByOneOf {
      /** Invalidate by msId. NOT recommended, as this will invalidate the entire site cache! */
      metaSiteId?: string;
      /** Invalidate by Site ID. NOT recommended, as this will invalidate the entire site cache! */
      siteId?: string;
      /** Invalidate by App */
      app?: App;
      /** Invalidate by page id */
      page?: Page;
      /** Invalidate by URI path */
      uri?: URI;
      /** Invalidate by file (for media files such as PDFs) */
      file?: File;
      /** tell us why you're invalidating the cache. You don't need to add your app name */
      reason?: string | null;
      /** Is local DS */
      localDc?: boolean;
      hardPurge?: boolean;
  }
  /** @oneof */
  interface InvalidateCacheGetByOneOf {
      /** Invalidate by msId. NOT recommended, as this will invalidate the entire site cache! */
      metaSiteId?: string;
      /** Invalidate by Site ID. NOT recommended, as this will invalidate the entire site cache! */
      siteId?: string;
      /** Invalidate by App */
      app?: App;
      /** Invalidate by page id */
      page?: Page;
      /** Invalidate by URI path */
      uri?: URI;
      /** Invalidate by file (for media files such as PDFs) */
      file?: File;
  }
  interface App {
      /** The AppDefId */
      appDefId?: string;
      /** The instance Id */
      instanceId?: string;
  }
  interface Page {
      /** the msid the page is on */
      metaSiteId?: string;
      /** Invalidate by Page ID */
      pageId?: string;
  }
  interface URI {
      /** the msid the URI is on */
      metaSiteId?: string;
      /** URI path to invalidate (e.g. page/my/path) - without leading/trailing slashes */
      uriPath?: string;
  }
  interface File {
      /** the msid the file is related to */
      metaSiteId?: string;
      /** Invalidate by filename (for media files such as PDFs) */
      fileName?: string;
  }
  interface GetTicketDefinitionSummaryRequest {
      /** Ticket definition id. */
      ticketDefinitionId?: string | null;
  }
  interface GetTicketDefinitionSummaryResponse {
      /** Summary. */
      summary?: TicketDefinitionSummary;
  }
  interface TicketDefinitionSummary {
      /**
       * Ticket definition ID.
       * @readonly
       */
      definitionId?: string | null;
      /**
       * Event ID to which the ticket definition summary belongs.
       * @readonly
       */
      eventId?: string | null;
      /**
       * Date and time of the ticket definition summary latest update in `yyyy-mm-ddThh:mm:sssZ` format.
       * @readonly
       */
      _updatedDate?: Date | null;
      /**
       * Reserved count.
       * @readonly
       */
      reservedCount?: number;
      /**
       * Sold count.
       * @readonly
       */
      soldCount?: number;
      /**
       * Paid exists.
       * @readonly
       */
      paidExists?: boolean;
  }
  interface ListEventTicketingSummaryRequest {
      /** Event ID. */
      eventId?: string[];
      /**
       * Consistent read.
       * @internal
       */
      consistentRead?: boolean | null;
  }
  interface ListEventTicketingSummaryResponse {
      /** Ticketing summaries. */
      summaries?: EventTicketingSummary[];
  }
  interface EventTicketingSummary {
      /**
       * Event ID to which the ticketing summary belongs.
       * @readonly
       */
      eventId?: string | null;
      /**
       * Date and time of the ticketing summary latest update in `yyyy-mm-ddThh:mm:sssZ` format.
       * @readonly
       */
      _updatedDate?: Date | null;
      /**
       * Whether all tickets are sold for this event.
       * @readonly
       */
      soldOut?: boolean | null;
      /**
       * Price of lowest priced ticket.
       * @readonly
       */
      lowestTicketPrice?: CommonMoney;
      /**
       * Price of highest priced ticket.
       * @readonly
       */
      highestTicketPrice?: CommonMoney;
      /**
       * Currency used in event transactions.
       * @readonly
       */
      currency?: string | null;
      /**
       * Formatted price of lowest priced ticket.
       * @readonly
       */
      lowestTicketPriceFormatted?: string | null;
      /**
       * Formatted price of highest priced ticket.
       * @readonly
       */
      highestTicketPriceFormatted?: string | null;
  }
  interface Empty {
  }
  interface ReservationCreated {
      /** Reservation created timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Event ID. */
      eventId?: string;
      /**
       * Reservation ID.
       * Can be used to retrieve a reservation invoice.
       */
      reservationId?: string;
      /** Reservation expiration timestamp. */
      expires?: Date | null;
      /** Reservation status. */
      status?: ReservationStatus;
      /** Reservation ticket quantities. */
      quantities?: TicketQuantity[];
      /** Reservation update timestamp. */
      _updatedDate?: Date | null;
      /** Reservation counts. */
      counts?: ReservationCount[];
  }
  enum ReservationStatus {
      /** The Reservation is pending confirmation and will expire after the expiration due time. */
      RESERVATION_PENDING = "RESERVATION_PENDING",
      /** The reservation is confirmed and will not expire. */
      RESERVATION_CONFIRMED = "RESERVATION_CONFIRMED",
      /** The reservation is canceled because of non payment. */
      RESERVATION_CANCELED = "RESERVATION_CANCELED",
      /** The reservation is canceled manually by the buyer. */
      RESERVATION_CANCELED_MANUALLY = "RESERVATION_CANCELED_MANUALLY",
      /** The reservation is expired. */
      RESERVATION_EXPIRED = "RESERVATION_EXPIRED"
  }
  interface TicketQuantity {
      /** Ticket definition ID. */
      ticketDefinitionId?: string | null;
      /** Quantity. */
      quantity?: number | null;
      /** Quantity update timestamp. */
      _updatedDate?: Date | null;
  }
  interface ReservationCount {
      /** Reservation Count snapshot timestamp. */
      timestamp?: Date | null;
      /** Ticket Definition ID. */
      ticketDefinitionId?: string;
      /** Confirmed reservation count. */
      confirmedCount?: number;
      /** Pending reservation count. */
      pendingCount?: number;
      /** True if paid ticket reservation exist. */
      paidExists?: boolean;
  }
  interface ReservationUpdated {
      /** Reservation updated timestamp. */
      timestamp?: Date | null;
      /** Event ID. */
      eventId?: string;
      /**
       * Reservation ID.
       * Can be used to retrieve a reservation invoice.
       */
      reservationId?: string;
      /** Reservation status. */
      status?: ReservationStatus;
      /** Reservation expiration timestamp. */
      expires?: Date | null;
      /** Reservation ticket quantities. */
      quantities?: TicketQuantity[];
      /** Reservation update timestamp. */
      _updatedDate?: Date | null;
      /** Reservation counts. */
      counts?: ReservationCount[];
  }
  interface EventDeleted {
      /** Event deleted timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Event ID. */
      eventId?: string;
      /** Event title. */
      title?: string;
      /** Event creator user ID. */
      userId?: string | null;
      /**
       * Event categories.
       * @internal
       */
      categories?: string[];
  }
  interface CreateTicketDefinitionRequest {
      /** Ticket definition info. */
      ticketDefinition: TicketDefinition;
      /** Predefined sets of fields to return. */
      fields?: Field[];
  }
  enum Field {
      /** Unknown requested field. */
      UNKNOWN_REQUESTED_FIELD = "UNKNOWN_REQUESTED_FIELD",
      /** Returns `salesDetails` in the response. */
      SALES_DETAILS = "SALES_DETAILS",
      /** Returns `eventDetails` in the response. */
      EVENT_DETAILS = "EVENT_DETAILS"
  }
  interface CreateTicketDefinitionResponse {
      /** Created ticket definition. */
      ticketDefinition?: TicketDefinition;
  }
  interface UpdateTicketDefinitionRequest {
      /** Ticket definition to update. */
      ticketDefinition: TicketDefinition;
      /**
       * List of exact fields to update. For example, if you define only `name`, all other fields are ignored.
       * @internal
       */
      mask?: string[];
      /** Predefined sets of fields to return. */
      fields?: Field[];
  }
  interface UpdateTicketDefinitionResponse {
      /** The updated ticket definition. */
      ticketDefinition?: TicketDefinition;
  }
  interface GetTicketDefinitionRequest {
      /** Ticket definition ID. */
      ticketDefinitionId: string;
      /** Predefined sets of fields to return. */
      fields?: Field[];
  }
  interface GetTicketDefinitionResponse {
      /** The requested ticket definition. */
      ticketDefinition?: TicketDefinition;
  }
  interface DeleteTicketDefinitionRequest {
      /** ID of the ticket definition to delete. */
      ticketDefinitionId: string;
  }
  interface DeleteTicketDefinitionResponse {
  }
  interface ReorderTicketDefinitionsRequest extends ReorderTicketDefinitionsRequestReferenceDefinitionOneOf {
      /** Move the given `definitionId` before the referenced ticket definition. */
      beforeDefinitionId?: string;
      /** Move the given `definitionId` after the referenced ticket definition. */
      afterDefinitionId?: string;
      /** Event ID. */
      eventId: string;
      /** Ticket definition ID. */
      ticketDefinitionId: string;
  }
  /** @oneof */
  interface ReorderTicketDefinitionsRequestReferenceDefinitionOneOf {
      /** Move the given `definitionId` before the referenced ticket definition. */
      beforeDefinitionId?: string;
      /** Move the given `definitionId` after the referenced ticket definition. */
      afterDefinitionId?: string;
  }
  interface ReorderTicketDefinitionsResponse {
  }
  interface UpdateTicketDefinitionSortIndexRequest {
      /** Ticket definition ID */
      ticketDefinitionId?: string;
      /** The revision of the ticket definition */
      revision?: string;
      /** the sort index of a ticket definition to set */
      sortIndex?: number;
      /** Requested fields. */
      fields?: Field[];
  }
  interface UpdateTicketDefinitionSortIndexResponse {
      /** the updated ticket definition */
      ticketDefinition?: TicketDefinition;
  }
  interface QueryTicketDefinitionsRequest {
      /** Query options. See [API Query Language](https://dev.wix.com/api/rest/getting-started/api-query-language) for more details. */
      query: QueryV2;
      /** Predefined sets of fields to return. */
      fields?: Field[];
      /**
       * Consistent read.
       * @internal
       */
      consistentRead?: boolean | null;
  }
  interface QueryV2 extends QueryV2PagingMethodOneOf {
      /** Paging options to limit and skip the number of items. */
      paging?: Paging;
      /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort` parameters. */
      cursorPaging?: CursorPaging;
      /** Filter object in the following format: <br/> `"filter" : { "fieldName1": "value1", "fieldName2":{"$operator":"value2"} }`. <br/> <br/> **Example:** <br/> `"filter" : { "id": "2224a9d1-79e6-4549-a5c5-bf7ce5aac1a5", "revision": {"$ne":"1"} }` */
      filter?: Record<string, any> | null;
      /** Sort object in the following format: <br/> `[{"fieldName":"sortField1"},{"fieldName":"sortField2","direction":"DESC"}]` <br/> <br/> **Example:** <br/> `[{"fieldName":"createdDate","direction":"DESC"}]` <br/> <br/> See [supported fields](https://dev.wix.com/api/rest/wix-events/policy-v2/filter-and-sort) for more information. */
      sort?: Sorting[];
  }
  /** @oneof */
  interface QueryV2PagingMethodOneOf {
      /** Paging options to limit and skip the number of items. */
      paging?: Paging;
      /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort` parameters. */
      cursorPaging?: CursorPaging;
  }
  interface Sorting {
      /** Name of the field to sort by. */
      fieldName?: string;
      /** Defaults to `ASC` */
      order?: SortOrder;
  }
  enum SortOrder {
      ASC = "ASC",
      DESC = "DESC"
  }
  interface Paging {
      /** Number of items to load per page. */
      limit?: number | null;
      /** Number of items to skip in the current sort order. */
      offset?: number | null;
  }
  interface CursorPaging {
      /** Number of items to load per page. */
      limit?: number | null;
      /**
       * Pointer to the next or previous page in the list of results.
       * You can get the relevant cursor token
       * from the `pagingMetadata` object in the previous call's response.
       * Not relevant for the first request.
       */
      cursor?: string | null;
  }
  interface QueryTicketDefinitionsResponse {
      /** List of ticket definitions. */
      ticketDefinitions?: TicketDefinition[];
      /** Metadata for the paginated results. */
      metadata?: PagingMetadataV2;
  }
  interface PagingMetadataV2 {
      /** Number of items returned in the response. */
      count?: number | null;
      /** Offset that was requested. */
      offset?: number | null;
      /** Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set. */
      total?: number | null;
      /** Flag that indicates the server failed to calculate the `total` field. */
      tooManyToCount?: boolean | null;
      /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
      cursors?: Cursors;
  }
  interface Cursors {
      /** Cursor pointing to next page in the list of results. */
      next?: string | null;
      /** Cursor pointing to previous page in the list of results. */
      prev?: string | null;
  }
  interface QueryAvailableTicketDefinitionsRequest {
      /** Query options. See [API Query Language](https://dev.wix.com/api/rest/getting-started/api-query-language) for more details. */
      query: QueryV2;
      /** Predefined sets of fields to return. */
      fields?: Field[];
  }
  interface QueryAvailableTicketDefinitionsResponse {
      /** List of ticket definitions. */
      ticketDefinitions?: TicketDefinition[];
      /** Metadata for the paginated results. */
      metadata?: PagingMetadataV2;
  }
  interface CountTicketDefinitionsRequest {
      /** Filter object in the following format: <br/> `"filter" : { "fieldName1": "value1" }`. */
      filter?: Record<string, any> | null;
      /**
       * Parameters to count ticket definitions by.
       *
       * - Max: 20 facets.
       */
      facet?: string[];
  }
  interface CountTicketDefinitionsResponse {
      /** Metadata for the paginated results. */
      metadata?: PagingMetadataV2;
      /** Filter facets. */
      facets?: Record<string, FacetCounts>;
  }
  interface FacetCounts {
      /** Facet counts aggregated per value */
      counts?: Record<string, number>;
  }
  interface CountAvailableTicketDefinitionsRequest {
      /** Filter object in the following format: <br/> `"filter" : { "fieldName1": "value1" }`. */
      filter?: Record<string, any> | null;
  }
  interface CountAvailableTicketDefinitionsResponse {
      /** Metadata for the paginated results. */
      metadata?: PagingMetadataV2;
      /**
       * Filter facets.
       * @internal
       */
      facets?: Record<string, FacetCounts>;
  }
  interface BulkDeleteTicketDefinitionsByFilterRequest {
      /** Filter object in the following format: <br/> `"filter" : { "fieldName1": "value1" }`. <br/> <br/> **Example:** <br/> `"filter" : { "eventId": "3d3d5c04-ece0-45a8-85f0-11a58edaa192" }` */
      filter: Record<string, any> | null;
  }
  interface BulkDeleteTicketDefinitionsByFilterResponse {
  }
  interface ChangeCurrencyRequest {
      /** Event ID. */
      eventId: string;
      /** Ticket price currency in 3-letter [ISO-4217 alphabetic](https://en.wikipedia.org/wiki/ISO_4217#Active_codes) format. */
      currency: string;
  }
  interface ChangeCurrencyResponse {
  }
  interface BulkCopyTicketDefinitionsByEventIdRequest {
      /** Origin instance ID. */
      originInstanceId?: string | null;
      /** Origin Event ID. */
      originEventId?: string;
      /** Target Event ID. */
      targetEventId?: string;
  }
  interface BulkCopyTicketDefinitionsByEventIdResponse {
      /** Copied ticket definitions. */
      definitions?: CopiedTicketDefinition[];
  }
  interface CopiedTicketDefinition {
      /** Origin Ticket definition ID. */
      originTicketDefinitionId?: string;
      /** Ticket definition ID. */
      ticketDefinitionId?: string;
  }
  interface EventCanceled {
      /** Event canceled timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Event ID. */
      eventId?: string;
      /** Event title */
      title?: string;
      /** Event creator user ID. */
      userId?: string | null;
  }
  interface EventEnded {
      /** Event end timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Event ID. */
      eventId?: string;
  }
  interface EventCreated {
      /** Event created timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Event ID. */
      eventId?: string;
      /** Event location. */
      location?: Location;
      /** Event schedule configuration. */
      scheduleConfig?: ScheduleConfig;
      /** Event title. */
      title?: string;
      /** Event creator user ID. */
      userId?: string | null;
      /** Event status. */
      status?: EventStatus;
      /** Instance ID. Indicates the original app instance which current event was derived from. */
      derivedFromInstanceId?: string | null;
      /** Event ID. Indicates the original event which current event was derived from. */
      derivedFromEventId?: string | null;
      /** Event that was created. */
      event?: Event;
  }
  interface Location {
      /** Location name. */
      name?: string | null;
      /** Location map coordinates. */
      coordinates?: MapCoordinates;
      /** Single line address representation. */
      address?: string | null;
      /** Location type. */
      type?: LocationType;
      /**
       * Full address derived from formatted single line `address`.
       * When `full_address` is used to create or update the event, deprecated `address` and `coordinates` are ignored.
       * If provided `full_address` has empty `formatted_address` or `coordinates`, it will be auto-completed using Atlas service.
       *
       * Migration notes:
       * - `full_address.formatted_address` is equivalent to `address`.
       * - `full_address.geocode` is equivalent to `coordinates`.
       */
      fullAddress?: Address;
      /**
       * Defines event location as TBD (To Be Determined).
       * When event location is not yet defined, `name` is displayed instead of location address.
       * `coordinates`, `address`, `type` and `full_address` are not required when location is TBD.
       */
      tbd?: boolean | null;
  }
  interface MapCoordinates {
      /** Latitude. */
      lat?: number;
      /** Longitude. */
      lng?: number;
  }
  enum LocationType {
      VENUE = "VENUE",
      ONLINE = "ONLINE"
  }
  /** Physical address */
  interface Address extends AddressStreetOneOf {
      /** a break down of the street to number and street name */
      streetAddress?: StreetAddress;
      /** Main address line (usually street and number) as free text */
      addressLine1?: string | null;
      /** country code */
      country?: string | null;
      /** subdivision (usually state or region) code according to ISO 3166-2 */
      subdivision?: string | null;
      /** city name */
      city?: string | null;
      /** zip/postal code */
      postalCode?: string | null;
      /** Free text providing more detailed address info. Usually contains Apt, Suite, Floor */
      addressLine2?: string | null;
      /** A string containing the human-readable address of this location */
      formatted?: string | null;
      /** coordinates of the physical address */
      location?: AddressLocation;
      /** country full-name */
      countryFullname?: string | null;
      /** multi-level subdivisions from top to bottom */
      subdivisions?: Subdivision[];
  }
  /** @oneof */
  interface AddressStreetOneOf {
      /** a break down of the street to number and street name */
      streetAddress?: StreetAddress;
      /** Main address line (usually street and number) as free text */
      addressLine?: string | null;
  }
  interface StreetAddress {
      /** street number */
      number?: string;
      /** street name */
      name?: string;
      /**
       * apartment number
       * @internal
       */
      apt?: string;
  }
  interface AddressLocation {
      /** address latitude coordinates */
      latitude?: number | null;
      /** address longitude coordinates */
      longitude?: number | null;
  }
  interface Subdivision {
      /** subdivision short code */
      code?: string;
      /** subdivision full-name */
      name?: string;
      /**
       * subdivision level
       * @internal
       */
      type?: SubdivisionType;
      /**
       * free text description of subdivision type
       * @internal
       */
      typeInfo?: string | null;
  }
  enum SubdivisionType {
      UNKNOWN_SUBDIVISION_TYPE = "UNKNOWN_SUBDIVISION_TYPE",
      /** State */
      ADMINISTRATIVE_AREA_LEVEL_1 = "ADMINISTRATIVE_AREA_LEVEL_1",
      /** County */
      ADMINISTRATIVE_AREA_LEVEL_2 = "ADMINISTRATIVE_AREA_LEVEL_2",
      /** City/town */
      ADMINISTRATIVE_AREA_LEVEL_3 = "ADMINISTRATIVE_AREA_LEVEL_3",
      /** Neighborhood/quarter */
      ADMINISTRATIVE_AREA_LEVEL_4 = "ADMINISTRATIVE_AREA_LEVEL_4",
      /** Street/block */
      ADMINISTRATIVE_AREA_LEVEL_5 = "ADMINISTRATIVE_AREA_LEVEL_5",
      /** ADMINISTRATIVE_AREA_LEVEL_0. Indicates the national political entity, and is typically the highest order type returned by the Geocoder. */
      COUNTRY = "COUNTRY"
  }
  interface ScheduleConfig {
      /**
       * Defines event as TBD (To Be Determined) schedule.
       * When event time is not yet defined, TBD message is displayed instead of event start and end times.
       * `startDate`, `endDate` and `timeZoneId` are not required when schedule is TBD.
       */
      scheduleTbd?: boolean;
      /** TBD message. */
      scheduleTbdMessage?: string | null;
      /** Event start timestamp. */
      startDate?: Date | null;
      /** Event end timestamp. */
      endDate?: Date | null;
      /** Event time zone ID in TZ database format, e.g., `EST`, `America/Los_Angeles`. */
      timeZoneId?: string | null;
      /** Whether end date is hidden in the formatted schedule. */
      endDateHidden?: boolean;
      /** Whether time zone is displayed in formatted schedule. */
      showTimeZone?: boolean;
      /** Event recurrences. */
      recurrences?: Recurrences;
  }
  interface Recurrences {
      /** Event occurrences. */
      occurrences?: Occurrence[];
      /**
       * Recurring event category ID.
       * @readonly
       */
      categoryId?: string | null;
      /**
       * Recurrence status.
       * @readonly
       */
      status?: Status;
  }
  interface Occurrence {
      /** Event start timestamp. */
      startDate?: Date | null;
      /** Event end timestamp. */
      endDate?: Date | null;
      /** Event time zone ID in TZ database format, e.g., `EST`, `America/Los_Angeles`. */
      timeZoneId?: string | null;
      /** Whether time zone is displayed in formatted schedule. */
      showTimeZone?: boolean;
  }
  enum Status {
      /** Event occurs only once. */
      ONE_TIME = "ONE_TIME",
      /** Event is recurring. */
      RECURRING = "RECURRING",
      /** Marks the next upcoming occurrence of the recurring event. */
      RECURRING_NEXT = "RECURRING_NEXT",
      /** Marks the most recent ended occurrence of the recurring event. */
      RECURRING_LAST_ENDED = "RECURRING_LAST_ENDED",
      /** Marks the most recent canceled occurrence of the recurring event. */
      RECURRING_LAST_CANCELED = "RECURRING_LAST_CANCELED"
  }
  enum EventStatus {
      /** Event is public and scheduled to start */
      SCHEDULED = "SCHEDULED",
      /** Event has started */
      STARTED = "STARTED",
      /** Event has ended */
      ENDED = "ENDED",
      /** Event was canceled */
      CANCELED = "CANCELED",
      /** Event is not public and needs to be published */
      DRAFT = "DRAFT"
  }
  interface Event {
      /**
       * Event ID.
       * @readonly
       */
      _id?: string;
      /** Event location. */
      location?: Location;
      /** Event scheduling. */
      scheduling?: Scheduling;
      /** Event title. */
      title?: string;
      /** Event description. */
      description?: string;
      /** Rich-text content displayed in Wix UI - "About Event" section (HTML). */
      about?: string;
      /** Main event image. */
      mainImage?: string;
      /** Event slug URL (generated from event title). */
      slug?: string;
      /** ISO 639-1 language code of the event (used in content translations). */
      language?: string;
      /** Event creation timestamp. */
      created?: Date | null;
      /** Event modified timestamp. */
      modified?: Date | null;
      /** Event status. */
      status?: EventStatus;
      /** RSVP or ticketing registration details. */
      registration?: Registration;
      /** "Add to calendar" URLs. */
      calendarLinks?: CalendarLinks;
      /** Event page URL components. */
      eventPageUrl?: SiteUrl;
      /** Event registration form. */
      form?: Form;
      /** Event dashboard summary of RSVP / ticket sales. */
      dashboard?: Dashboard;
      /** Instance ID of the site where event is hosted. */
      instanceId?: string;
      /** Guest list configuration. */
      guestListConfig?: GuestListConfig;
      /** Event creator user ID. */
      userId?: string;
      /** Event discussion feed. For internal use. */
      feed?: Feed;
      /** Online conferencing details. */
      onlineConferencing?: OnlineConferencing;
      /** SEO settings. */
      seoSettings?: SeoSettings;
      /** Assigned contacts label key. */
      assignedContactsLabel?: string | null;
      /** Agenda details. */
      agenda?: Agenda;
      /** Categories this event is assigned to. */
      categories?: Category[];
      /** Visual settings for event. */
      eventDisplaySettings?: EventDisplaySettings;
      /**
       * @internal
       * @readonly
       */
      customizableTickets?: boolean | null;
      /**
       * Labelling related data.
       * @internal
       */
      labellingSettings?: LabellingSettings;
  }
  interface Scheduling {
      /** Schedule configuration. */
      config?: ScheduleConfig;
      /** Formatted schedule representation. */
      formatted?: string;
      /** Formatted start date of the event (empty for TBD schedules). */
      startDateFormatted?: string;
      /** Formatted start time of the event (empty for TBD schedules). */
      startTimeFormatted?: string;
      /** Formatted end date of the event (empty for TBD schedules or when end date is hidden). */
      endDateFormatted?: string;
      /** Formatted end time of the event (empty for TBD schedules or when end date is hidden). */
      endTimeFormatted?: string;
  }
  interface Registration {
      /** Event type. */
      type?: EventType;
      /** Event registration status. */
      status?: RegistrationStatus;
      /** RSVP collection details. */
      rsvpCollection?: RsvpCollection;
      /** Ticketing details. */
      ticketing?: Ticketing;
      /** External registration details. */
      external?: ExternalEvent;
      /** Types of users allowed to register. */
      restrictedTo?: VisitorType;
      /** Initial event type which was set when creating an event. */
      initialType?: EventType;
  }
  enum EventType {
      /** Type not available for this request fieldset */
      NA_EVENT_TYPE = "NA_EVENT_TYPE",
      /** Registration via RSVP */
      RSVP = "RSVP",
      /** Registration via ticket purchase */
      TICKETS = "TICKETS",
      /** External registration */
      EXTERNAL = "EXTERNAL",
      /** Registration not available */
      NO_REGISTRATION = "NO_REGISTRATION"
  }
  enum RegistrationStatus {
      /** Registration status is not applicable */
      NA_REGISTRATION_STATUS = "NA_REGISTRATION_STATUS",
      /** Registration to event is closed */
      CLOSED = "CLOSED",
      /** Registration to event is closed manually */
      CLOSED_MANUALLY = "CLOSED_MANUALLY",
      /** Registration is open via RSVP */
      OPEN_RSVP = "OPEN_RSVP",
      /** Registration to event waitlist is open via RSVP */
      OPEN_RSVP_WAITLIST = "OPEN_RSVP_WAITLIST",
      /** Registration is open via ticket purchase */
      OPEN_TICKETS = "OPEN_TICKETS",
      /** Registration is open via external URL */
      OPEN_EXTERNAL = "OPEN_EXTERNAL",
      /** Registration will be open via RSVP */
      SCHEDULED_RSVP = "SCHEDULED_RSVP"
  }
  interface RsvpCollection {
      /** RSVP collection configuration. */
      config?: RsvpCollectionConfig;
  }
  interface RsvpCollectionConfig {
      /** Defines the supported RSVP statuses. */
      rsvpStatusOptions?: RsvpStatusOptions;
      /**
       * Total guest limit available to register to the event.
       * Additional guests per RSVP are counted towards total guests.
       */
      limit?: number | null;
      /** Whether a waitlist is opened when total guest limit is reached, allowing guests to create RSVP with WAITING RSVP status. */
      waitlist?: boolean;
      /** Registration start timestamp. */
      startDate?: Date | null;
      /** Registration end timestamp. */
      endDate?: Date | null;
  }
  enum RsvpStatusOptions {
      /** Only YES RSVP status is available for RSVP registration */
      YES_ONLY = "YES_ONLY",
      /** YES and NO RSVP status options are available for the registration */
      YES_AND_NO = "YES_AND_NO"
  }
  interface Ticketing {
      /**
       * Deprecated.
       * @deprecated
       */
      lowestPrice?: string | null;
      /**
       * Deprecated.
       * @deprecated
       */
      highestPrice?: string | null;
      /** Currency used in event transactions. */
      currency?: string | null;
      /** Ticketing configuration. */
      config?: TicketingConfig;
      /**
       * Price of lowest priced ticket.
       * @readonly
       */
      lowestTicketPrice?: Money;
      /**
       * Price of highest priced ticket.
       * @readonly
       */
      highestTicketPrice?: Money;
      /**
       * Formatted price of lowest priced ticket.
       * @readonly
       */
      lowestTicketPriceFormatted?: string | null;
      /**
       * Formatted price of highest priced ticket.
       * @readonly
       */
      highestTicketPriceFormatted?: string | null;
      /**
       * Whether all tickets are sold for this event.
       * @readonly
       */
      soldOut?: boolean | null;
  }
  interface TicketingConfig {
      /** Whether the form must be filled out separately for each ticket. */
      guestAssignedTickets?: boolean;
      /** Tax configuration. */
      taxConfig?: TaxConfig;
      /** Limit of tickets that can be purchased per order, default 20. */
      ticketLimitPerOrder?: number;
      /**
       * App Id for external ticket stock management.
       * By default tickets stock is defined in TicketDefinition object.
       * If defined then limitation from TicketDefinition is ignored.
       * @internal
       */
      stockManagerAppId?: string | null;
      /** Duration for which the tickets being bought are reserved. */
      reservationDurationInMinutes?: number | null;
  }
  interface TaxConfig {
      /** Tax application settings. */
      type?: TaxType;
      /** Tax name. */
      name?: string | null;
      /** Tax rate (e.g.,`21.55`). */
      rate?: string | null;
      /** Applies taxes for donations, default true. */
      appliesToDonations?: boolean | null;
  }
  enum TaxType {
      /** Tax is included in the ticket price. */
      INCLUDED = "INCLUDED",
      /** Tax is added to the order at the checkout. */
      ADDED = "ADDED",
      /** Tax is added to the final total at the checkout. */
      ADDED_AT_CHECKOUT = "ADDED_AT_CHECKOUT"
  }
  interface Money {
      /**
       * *Deprecated:** Use `value` instead.
       * @deprecated
       */
      amount?: string;
      /** ISO 4217 format of the currency e.g., `USD`. */
      currency?: string;
      /** Monetary amount. Decimal string with a period as a decimal separator (e.g., 3.99). Optionally, starts with a single (-), to indicate that the amount is negative. */
      value?: string | null;
  }
  interface ExternalEvent {
      /** External event registration URL. */
      registration?: string;
  }
  enum VisitorType {
      /** Site visitor (including member) */
      VISITOR = "VISITOR",
      /** Site member */
      MEMBER = "MEMBER",
      /** Site visitor or member */
      VISITOR_OR_MEMBER = "VISITOR_OR_MEMBER"
  }
  interface CalendarLinks {
      /** "Add to Google calendar" URL. */
      google?: string;
      /** "Download ICS calendar file" URL. */
      ics?: string;
  }
  /** Site URL components */
  interface SiteUrl {
      /**
       * Base URL. For premium sites, this will be the domain.
       * For free sites, this would be site URL (e.g `mysite.wixsite.com/mysite`)
       */
      base?: string;
      /** The path to that page - e.g `/my-events/weekly-meetup-2` */
      path?: string;
  }
  /**
   * The form defines which elements are rendered in the Wix UI during the registration process (RSVP or checkout).
   * It also contains customizable messages and labels.
   *
   *
   * A form is an ordered list of controls (blocks), which accept guest information into a field input.
   *
   * Each control contains one or more nested inputs. For example, `Name` control has two inputs:
   * - First Name
   * - Last Name
   *
   * By default, name and email controls are always required and are pinned to the top of the form.
   */
  interface Form {
      /** Nested fields as an ordered list. */
      controls?: InputControl[];
      /** Set of configured form messages. */
      messages?: FormMessages;
  }
  /**
   * A block of nested fields.
   * Used to aggregate similar inputs like First Name and Last Name.
   */
  interface InputControl {
      /** Field control type. */
      type?: InputControlType;
      /** Whether control is mandatory (such as name & email). When true, only label can be changed. */
      system?: boolean;
      /**
       * Deprecated: Use `id`.
       * @deprecated
       */
      name?: string;
      /** Child inputs. */
      inputs?: Input[];
      /**
       * Deprecated: use `inputs.label`.
       * @deprecated
       */
      label?: string;
      /** Field controls are sorted by this value in ascending order. */
      orderIndex?: number;
      /** Unique control ID. */
      _id?: string;
      /**
       * Whether input control is deleted.
       * @readonly
       */
      deleted?: boolean | null;
  }
  enum InputControlType {
      /** Single text value field. */
      INPUT = "INPUT",
      /** Single text value field. */
      TEXTAREA = "TEXTAREA",
      /** Single-choice field of predefined values. */
      DROPDOWN = "DROPDOWN",
      /** Single-choice field of predefined values. */
      RADIO = "RADIO",
      /** Multiple-choice field of predefined values. */
      CHECKBOX = "CHECKBOX",
      /** First and last name fields. */
      NAME = "NAME",
      /** Additional guests and respective guest names fields. */
      GUEST_CONTROL = "GUEST_CONTROL",
      /** Single-line address field. */
      ADDRESS_SHORT = "ADDRESS_SHORT",
      /** Full address field. */
      ADDRESS_FULL = "ADDRESS_FULL",
      /** Year, month and day fields. */
      DATE = "DATE"
  }
  /** An input of one or multiple text values */
  interface Input {
      /** Field name. */
      name?: string;
      /**
       * Deprecated: use `ValueType.TEXT_ARRAY`.
       * @deprecated
       */
      array?: boolean;
      /** Main field label */
      label?: string;
      /** Additional labels for multi-valued fields such as address. */
      additionalLabels?: Record<string, string>;
      /** Predefined choice options for fields, such as dropdown. */
      options?: string[];
      /** Whether field is mandatory. */
      mandatory?: boolean;
      /** Maximum number of accepted characters (relevant for text fields). */
      maxLength?: number;
      /**
       * Type which determines field format.
       * Used to validate submitted response.
       */
      type?: ValueType;
      /**
       * A maximum accepted values for array input.
       * Only applicable for inputs of valueType: TEXT_ARRAY.
       */
      maxSize?: number | null;
      /**
       * Preselected option.
       * Currently only applicable for dropdown.
       */
      defaultOptionSelection?: OptionSelection;
      /**
       * Additional labels for multi-valued fields such as address.
       * @readonly
       */
      labels?: Label[];
  }
  enum ValueType {
      TEXT = "TEXT",
      NUMBER = "NUMBER",
      TEXT_ARRAY = "TEXT_ARRAY",
      DATE_TIME = "DATE_TIME",
      ADDRESS = "ADDRESS"
  }
  /**
   * Describes initially selected option when an input has multiple choices.
   * Defaults to first (0th) option if not configured.
   */
  interface OptionSelection extends OptionSelectionSelectedOptionOneOf {
      /** 0-based index from predefined `input.options` which is selected initially. */
      optionIndex?: number;
      /**
       * Placeholder hint describing expected choices (such as "Please select").
       * Considered an empty choice.
       */
      placeholderText?: string;
  }
  /** @oneof */
  interface OptionSelectionSelectedOptionOneOf {
      /** 0-based index from predefined `input.options` which is selected initially. */
      optionIndex?: number;
      /**
       * Placeholder hint describing expected choices (such as "Please select").
       * Considered an empty choice.
       */
      placeholderText?: string;
  }
  interface Label {
      /** Field name. */
      name?: string;
      /** Field label. */
      label?: string;
  }
  /**
   * Defines form messages shown in UI before, during, and after registration flow.
   * It enables configuration of form titles, response labels, "thank you" messages, and call-to-action texts.
   */
  interface FormMessages {
      /** RSVP form messages. */
      rsvp?: RsvpFormMessages;
      /** Checkout form messages. */
      checkout?: CheckoutFormMessages;
      /** Messages shown when event registration is closed. */
      registrationClosed?: RegistrationClosedMessages;
      /** Messages shown when event tickets are unavailable. */
      ticketsUnavailable?: TicketsUnavailableMessages;
  }
  interface RsvpFormMessages {
      /** Label text indicating RSVP `YES` response. */
      rsvpYesOption?: string;
      /** Label text indicating RSVP `NO` response. */
      rsvpNoOption?: string;
      /** Messages shown for RSVP = `YES`. */
      positiveMessages?: Positive;
      /** Messages shown for RSVP = `WAITING` (when event is full and waitlist is available). */
      waitlistMessages?: Positive;
      /** Messages shown for RSVP = `NO`. */
      negativeMessages?: Negative;
      /** "Submit form" call-to-action label text. */
      submitActionLabel?: string;
  }
  /** Confirmation messages shown after registration. */
  interface PositiveResponseConfirmation {
      /** Confirmation message title. */
      title?: string;
      /** Confirmation message text. */
      message?: string;
      /** "Add to calendar" call-to-action label text. */
      addToCalendarActionLabel?: string;
      /** "Share event" call-to-action label text. */
      shareActionLabel?: string;
  }
  /** Confirmation messages shown after registration. */
  interface NegativeResponseConfirmation {
      /** Confirmation message title. */
      title?: string;
      /** "Share event" call-to-action label text. */
      shareActionLabel?: string;
  }
  /** Set of messages shown during registration when RSVP response is positive. */
  interface Positive {
      /** Main form title for positive response. */
      title?: string;
      /** Confirmation messages shown after registration. */
      confirmation?: PositiveResponseConfirmation;
  }
  /** A set of messages shown during registration with negative response */
  interface Negative {
      /** Main form title for negative response. */
      title?: string;
      /** Confirmation messages shown after registration. */
      confirmation?: NegativeResponseConfirmation;
  }
  interface CheckoutFormMessages {
      /** Main form title for response. */
      title?: string;
      /** Submit form call-to-action label text. */
      submitActionLabel?: string;
      /** Confirmation messages shown after checkout. */
      confirmation?: ResponseConfirmation;
  }
  /** Confirmation messages shown after checkout. */
  interface ResponseConfirmation {
      /** Confirmation message title. */
      title?: string;
      /** Confirmation message text. */
      message?: string;
      /** "Download tickets" call-to-action label text. */
      downloadTicketsLabel?: string;
      /** "Add to calendar" call-to-action label text. */
      addToCalendarLabel?: string;
      /** "Share event" call-to-action label text. */
      shareEventLabel?: string;
  }
  interface RegistrationClosedMessages {
      /** Message shown when event registration is closed. */
      message?: string;
      /** "Explore other events" call-to-action label text. */
      exploreEventsActionLabel?: string;
  }
  interface TicketsUnavailableMessages {
      /** Message shown when event tickets are unavailable. */
      message?: string;
      /** "Explore other events" call-to-action label text. */
      exploreEventsActionLabel?: string;
  }
  interface Dashboard {
      /** Guest RSVP summary. */
      rsvpSummary?: RsvpSummary;
      /**
       * Summary of revenue and tickets sold.
       * (Archived orders are not included).
       */
      ticketingSummary?: TicketingSummary;
  }
  interface RsvpSummary {
      /** Total number of RSVPs. */
      total?: number;
      /** Number of RSVPs with status `YES`. */
      yes?: number;
      /** Number of RSVPs with status `NO`. */
      no?: number;
      /** Number of RSVPs in waitlist. */
      waitlist?: number;
  }
  interface TicketingSummary {
      /** Number of tickets sold. */
      tickets?: number;
      /**
       * Total revenue, excluding fees.
       * (taxes and payment provider fees are not deducted.)
       */
      revenue?: Money;
      /** Whether currency is locked and cannot be changed (generally occurs after the first order in the specified currency has been created). */
      currencyLocked?: boolean;
      /** Number of orders placed. */
      orders?: number;
      /** Total balance of confirmed transactions. */
      totalSales?: Money;
  }
  interface GuestListConfig {
      /** Whether members can see other members attending the event (defaults to true). */
      publicGuestList?: boolean;
  }
  interface Feed {
      /** Event discussion feed token. */
      token?: string;
  }
  interface OnlineConferencing {
      config?: OnlineConferencingConfig;
      session?: OnlineConferencingSession;
      /**
       * Configured conferencing provider name.
       * @internal
       * @readonly
       */
      providerName?: string;
  }
  interface OnlineConferencingConfig {
      /**
       * Whether online conferencing is enabled (not supported for TBD schedules).
       * When enabled, links to join conferencing are generated and provided to guests.
       */
      enabled?: boolean;
      /** Conferencing provider ID. */
      providerId?: string | null;
      /** Conference type */
      conferenceType?: ConferenceType;
  }
  enum ConferenceType {
      /** Everyone in the meeting can publish and subscribe video and audio. */
      MEETING = "MEETING",
      /** Guests can only subscribe to video and audio. */
      WEBINAR = "WEBINAR"
  }
  interface OnlineConferencingSession {
      /**
       * Link for event host to start the online conference session.
       * @readonly
       */
      hostLink?: string;
      /**
       * Link for guests to join the online conference session.
       * @readonly
       */
      guestLink?: string;
      /**
       * The password required to join online conferencing session (when relevant).
       * @readonly
       */
      password?: string | null;
      /**
       * Indicates that session was created successfully on providers side.
       * @readonly
       */
      sessionCreated?: boolean | null;
      /**
       * Unique session id
       * @readonly
       */
      sessionId?: string | null;
  }
  interface SeoSettings {
      /** URL slug */
      slug?: string;
      /** Advanced SEO data */
      advancedSeoData?: SeoSchema;
      /**
       * Hidden from SEO Site Map
       * @readonly
       */
      hidden?: boolean | null;
  }
  /**
   * The SEO schema object contains data about different types of meta tags. It makes sure that the information about your page is presented properly to search engines.
   * The search engines use this information for ranking purposes, or to display snippets in the search results.
   * This data will override other sources of tags (for example patterns) and will be included in the <head> section of the HTML document, while not being displayed on the page itself.
   */
  interface SeoSchema {
      /** SEO tag information. */
      tags?: Tag[];
      /** SEO general settings. */
      settings?: Settings;
  }
  interface Keyword {
      /** Keyword value. */
      term?: string;
      /** Whether the keyword is the main focus keyword. */
      isMain?: boolean;
      /** The source that added the keyword terms to the SEO settings. */
      origin?: string | null;
  }
  interface Tag {
      /**
       * SEO tag type.
       *
       *
       * Supported values: `title`, `meta`, `script`, `link`.
       */
      type?: string;
      /**
       * A `{"key": "value"}` pair object where each SEO tag property (`"name"`, `"content"`, `"rel"`, `"href"`) contains a value.
       * For example: `{"name": "description", "content": "the description itself"}`.
       */
      props?: Record<string, any> | null;
      /** SEO tag meta data. For example, `{"height": 300, "width": 240}`. */
      meta?: Record<string, any> | null;
      /** SEO tag inner content. For example, `<title> inner content </title>`. */
      children?: string;
      /** Whether the tag is a custom tag. */
      custom?: boolean;
      /** Whether the tag is disabled. */
      disabled?: boolean;
  }
  interface Settings {
      /**
       * Whether the Auto Redirect feature, which creates `301 redirects` on a slug change, is enabled.
       *
       *
       * Default: `false` (Auto Redirect is enabled.)
       */
      preventAutoRedirect?: boolean;
      /** User-selected keyword terms for a specific page. */
      keywords?: Keyword[];
  }
  interface Agenda {
      /** Whether the schedule is enabled for the event. */
      enabled?: boolean;
      /**
       * Agenda page URL.
       * @readonly
       */
      pageUrl?: SiteUrl;
  }
  interface Category {
      /**
       * Category ID.
       * @readonly
       */
      _id?: string;
      /** Category name. */
      name?: string;
      /**
       * Date and time when category was created.
       * @readonly
       */
      _createdDate?: Date | null;
      /**
       * Assigned events count. Deleted events are excluded.
       * @internal
       * @readonly
       * @deprecated
       */
      assignedEventsCount?: number | null;
      /**
       * The total number of draft and published events assigned to the category.
       * @readonly
       */
      counts?: CategoryCounts;
      /**
       * Category state. Possible values:
       *
       * `MANUAL`: Category is created manually by the user.
       * `AUTO`: Category is created automatically.
       * `RECURRING_EVENT`: Category is created automatically when publishing recurring events.
       * `HIDDEN`: Category can't be seen.
       *
       * Default: `MANUAL`.
       *
       * **Note:** The WIX_EVENTS.MANAGE_AUTO_CATEGORIES permission scope is required to use states other than `MANUAL`.
       */
      states?: CategoryStateState[];
      /**
       * Optionally client defined external ID.
       * @internal
       */
      externalId?: string | null;
  }
  interface CategoryCounts {
      /** Total number of draft events assigned to the category. */
      assignedEventsCount?: number | null;
      /** Total number of published events assigned to the category. Deleted events are excluded. */
      assignedDraftEventsCount?: number | null;
  }
  enum CategoryStateState {
      /** Created manually by the user. */
      MANUAL = "MANUAL",
      /** Created automatically. */
      AUTO = "AUTO",
      /** Created when publishing recurring events. */
      RECURRING_EVENT = "RECURRING_EVENT",
      /** Category is hidden. */
      HIDDEN = "HIDDEN",
      /** Category is used to store component events. */
      COMPONENT = "COMPONENT"
  }
  interface EventDisplaySettings {
      /** Whether event details button is hidden. Only available for events with no registration. */
      hideEventDetailsButton?: boolean | null;
      /** Disables event details page visibility. If event has an external registration configured visitors will be redirected from this page. */
      hideEventDetailsPage?: boolean | null;
  }
  interface LabellingSettings {
      /**
       * @internal
       * @readonly
       */
      assignedContactsLegacyLabelId?: string | null;
      /**
       * @internal
       * @readonly
       */
      assignedContactsLabelDeleted?: boolean | null;
  }
  interface EventUpdated {
      /** Event update timestamp in ISO UTC format. */
      timestamp?: Date | null;
      /** Event ID. */
      eventId?: string;
      /** Event location. */
      location?: Location;
      /** Event schedule configuration. */
      scheduleConfig?: ScheduleConfig;
      /** Event title. */
      title?: string;
      /**
       * Whether schedule configuration was updated.
       * @deprecated
       */
      scheduleConfigUpdated?: boolean;
      /**
       * The set of properties which were updated. For example 'title' or 'location'
       * @internal
       */
      fields?: string[];
      /**
       * Whether event has opened new spots with this update.
       * @internal
       */
      newSpotsOpened?: boolean | null;
      /** Updated event */
      event?: Event;
  }
  interface SeatingPlanCategoriesSummaryUpdated {
      /** Seating plan id */
      seatingPlanId?: string;
      /** External seating plan id */
      externalSeatingPlanId?: string | null;
      /** Ticket counts by category */
      categories?: CategoryDetails[];
      /**
       * Summary revision.
       * @readonly
       */
      revision?: string | null;
  }
  interface CategoryDetails {
      /**
       * Seating plan id
       * @readonly
       */
      seatingPlanId?: string | null;
      /**
       * External seating plan id
       * @readonly
       */
      externalSeatingPlanId?: string | null;
      /**
       * External category id
       * @readonly
       */
      externalCategoryId?: string | null;
      /**
       * Total capacity in the category
       * @readonly
       */
      totalCapacity?: number | null;
      /**
       * Already reserved capacity
       * @readonly
       */
      reserved?: number | null;
  }
  interface MetaSiteSpecialEvent extends MetaSiteSpecialEventPayloadOneOf {
      /** Emitted on a meta site creation. */
      siteCreated?: SiteCreated;
      /** Emitted on a meta site transfer completion. */
      siteTransferred?: SiteTransferred;
      /** Emitted on a meta site deletion. */
      siteDeleted?: SiteDeleted;
      /** Emitted on a meta site restoration. */
      siteUndeleted?: SiteUndeleted;
      /** Emitted on the first* publish of the meta site (* switching from unpublished to published state). */
      sitePublished?: SitePublished;
      /** Emitted on a meta site unpublish. */
      siteUnpublished?: SiteUnpublished;
      /** Emitted when meta site is marked as template. */
      siteMarkedAsTemplate?: SiteMarkedAsTemplate;
      /** Emitted when meta site is marked as a WixSite. */
      siteMarkedAsWixSite?: SiteMarkedAsWixSite;
      /** Emitted when an application is provisioned (installed). */
      serviceProvisioned?: ServiceProvisioned;
      /** Emitted when an application is removed (uninstalled). */
      serviceRemoved?: ServiceRemoved;
      /** Emitted when meta site name (URL slug) is changed. */
      siteRenamedPayload?: SiteRenamed;
      /** Emitted when meta site was permanently deleted. */
      hardDeleted?: SiteHardDeleted;
      /** Emitted on a namespace change. */
      namespaceChanged?: NamespaceChanged;
      /** Emitted when Studio is attached. */
      studioAssigned?: StudioAssigned;
      /** Emitted when Studio is detached. */
      studioUnassigned?: StudioUnassigned;
      /** A meta site id. */
      metaSiteId?: string;
      /** A meta site version. Monotonically increasing. */
      version?: string;
      /** A timestamp of the event. */
      timestamp?: string;
      /**
       * TODO(meta-site): Change validation once validations are disabled for consumers
       * More context: https://wix.slack.com/archives/C0UHEBPFT/p1720957844413149 and https://wix.slack.com/archives/CFWKX325T/p1728892152855659
       */
      assets?: Asset[];
  }
  /** @oneof */
  interface MetaSiteSpecialEventPayloadOneOf {
      /** Emitted on a meta site creation. */
      siteCreated?: SiteCreated;
      /** Emitted on a meta site transfer completion. */
      siteTransferred?: SiteTransferred;
      /** Emitted on a meta site deletion. */
      siteDeleted?: SiteDeleted;
      /** Emitted on a meta site restoration. */
      siteUndeleted?: SiteUndeleted;
      /** Emitted on the first* publish of the meta site (* switching from unpublished to published state). */
      sitePublished?: SitePublished;
      /** Emitted on a meta site unpublish. */
      siteUnpublished?: SiteUnpublished;
      /** Emitted when meta site is marked as template. */
      siteMarkedAsTemplate?: SiteMarkedAsTemplate;
      /** Emitted when meta site is marked as a WixSite. */
      siteMarkedAsWixSite?: SiteMarkedAsWixSite;
      /** Emitted when an application is provisioned (installed). */
      serviceProvisioned?: ServiceProvisioned;
      /** Emitted when an application is removed (uninstalled). */
      serviceRemoved?: ServiceRemoved;
      /** Emitted when meta site name (URL slug) is changed. */
      siteRenamedPayload?: SiteRenamed;
      /** Emitted when meta site was permanently deleted. */
      hardDeleted?: SiteHardDeleted;
      /** Emitted on a namespace change. */
      namespaceChanged?: NamespaceChanged;
      /** Emitted when Studio is attached. */
      studioAssigned?: StudioAssigned;
      /** Emitted when Studio is detached. */
      studioUnassigned?: StudioUnassigned;
  }
  interface Asset {
      /** An application definition id (app_id in dev-center). For legacy reasons may be UUID or a string (from Java Enum). */
      appDefId?: string;
      /** An instance id. For legacy reasons may be UUID or a string. */
      instanceId?: string;
      /** An application state. */
      state?: State;
  }
  enum State {
      UNKNOWN = "UNKNOWN",
      ENABLED = "ENABLED",
      DISABLED = "DISABLED",
      PENDING = "PENDING",
      DEMO = "DEMO"
  }
  interface SiteCreated {
      /** A template identifier (empty if not created from a template). */
      originTemplateId?: string;
      /** An account id of the owner. */
      ownerId?: string;
      /** A context in which meta site was created. */
      context?: SiteCreatedContext;
      /**
       * A meta site id from which this site was created.
       *
       * In case of a creation from a template it's a template id.
       * In case of a site duplication ("Save As" in dashboard or duplicate in UM) it's an id of a source site.
       */
      originMetaSiteId?: string | null;
      /** A meta site name (URL slug). */
      siteName?: string;
      /** A namespace. */
      namespace?: Namespace;
  }
  enum SiteCreatedContext {
      /** A valid option, we don't expose all reasons why site might be created. */
      OTHER = "OTHER",
      /** A meta site was created from template. */
      FROM_TEMPLATE = "FROM_TEMPLATE",
      /** A meta site was created by copying of the transfferred meta site. */
      DUPLICATE_BY_SITE_TRANSFER = "DUPLICATE_BY_SITE_TRANSFER",
      /** A copy of existing meta site. */
      DUPLICATE = "DUPLICATE",
      /** A meta site was created as a transfferred site (copy of the original), old flow, should die soon. */
      OLD_SITE_TRANSFER = "OLD_SITE_TRANSFER",
      /** deprecated A meta site was created for Flash editor. */
      FLASH = "FLASH"
  }
  enum Namespace {
      UNKNOWN_NAMESPACE = "UNKNOWN_NAMESPACE",
      /** Default namespace for UGC sites. MetaSites with this namespace will be shown in a user's site list by default. */
      WIX = "WIX",
      /** ShoutOut stand alone product. These are siteless (no actual Wix site, no HtmlWeb). MetaSites with this namespace will *not* be shown in a user's site list by default. */
      SHOUT_OUT = "SHOUT_OUT",
      /** MetaSites created by the Albums product, they appear as part of the Albums app. MetaSites with this namespace will *not* be shown in a user's site list by default. */
      ALBUMS = "ALBUMS",
      /** Part of the WixStores migration flow, a user tries to migrate and gets this site to view and if the user likes it then stores removes this namespace and deletes the old site with the old stores. MetaSites with this namespace will *not* be shown in a user's site list by default. */
      WIX_STORES_TEST_DRIVE = "WIX_STORES_TEST_DRIVE",
      /** Hotels standalone (siteless). MetaSites with this namespace will *not* be shown in a user's site list by default. */
      HOTELS = "HOTELS",
      /** Clubs siteless MetaSites, a club without a wix website. MetaSites with this namespace will *not* be shown in a user's site list by default. */
      CLUBS = "CLUBS",
      /** A partially created ADI website. MetaSites with this namespace will *not* be shown in a user's site list by default. */
      ONBOARDING_DRAFT = "ONBOARDING_DRAFT",
      /** AppBuilder for AppStudio / shmite (c). MetaSites with this namespace will *not* be shown in a user's site list by default. */
      DEV_SITE = "DEV_SITE",
      /** LogoMaker websites offered to the user after logo purchase. MetaSites with this namespace will *not* be shown in a user's site list by default. */
      LOGOS = "LOGOS",
      /** VideoMaker websites offered to the user after video purchase. MetaSites with this namespace will *not* be shown in a user's site list by default. */
      VIDEO_MAKER = "VIDEO_MAKER",
      /** MetaSites with this namespace will *not* be shown in a user's site list by default. */
      PARTNER_DASHBOARD = "PARTNER_DASHBOARD",
      /** MetaSites with this namespace will *not* be shown in a user's site list by default. */
      DEV_CENTER_COMPANY = "DEV_CENTER_COMPANY",
      /**
       * A draft created by HTML editor on open. Upon "first save" it will be moved to be of WIX domain.
       *
       * Meta site with this namespace will *not* be shown in a user's site list by default.
       */
      HTML_DRAFT = "HTML_DRAFT",
      /**
       * the user-journey for Fitness users who want to start from managing their business instead of designing their website.
       * Will be accessible from Site List and will not have a website app.
       * Once the user attaches a site, the site will become a regular wixsite.
       */
      SITELESS_BUSINESS = "SITELESS_BUSINESS",
      /** Belongs to "strategic products" company. Supports new product in the creator's economy space. */
      CREATOR_ECONOMY = "CREATOR_ECONOMY",
      /** It is to be used in the Business First efforts. */
      DASHBOARD_FIRST = "DASHBOARD_FIRST",
      /** Bookings business flow with no site. */
      ANYWHERE = "ANYWHERE",
      /** Namespace for Headless Backoffice with no editor */
      HEADLESS = "HEADLESS",
      /**
       * Namespace for master site that will exist in parent account that will be referenced by subaccounts
       * The site will be used for account level CSM feature for enterprise
       */
      ACCOUNT_MASTER_CMS = "ACCOUNT_MASTER_CMS",
      /** Rise.ai Siteless account management for Gift Cards and Store Credit. */
      RISE = "RISE",
      /**
       * As part of the branded app new funnel, users now can create a meta site that will be branded app first.
       * There's a blank site behind the scene but it's blank).
       * The Mobile company will be the owner of this namespace.
       */
      BRANDED_FIRST = "BRANDED_FIRST",
      /** Nownia.com Siteless account management for Ai Scheduling Assistant. */
      NOWNIA = "NOWNIA",
      /**
       * UGC Templates are templates that are created by users for personal use and to sale to other users.
       * The Partners company owns this namespace.
       */
      UGC_TEMPLATE = "UGC_TEMPLATE",
      /** Codux Headless Sites */
      CODUX = "CODUX",
      /** Bobb - AI Design Creator. */
      MEDIA_DESIGN_CREATOR = "MEDIA_DESIGN_CREATOR"
  }
  /** Site transferred to another user. */
  interface SiteTransferred {
      /** A previous owner id (user that transfers meta site). */
      oldOwnerId?: string;
      /** A new owner id (user that accepts meta site). */
      newOwnerId?: string;
  }
  /** Soft deletion of the meta site. Could be restored. */
  interface SiteDeleted {
      /** A deletion context. */
      deleteContext?: DeleteContext;
  }
  interface DeleteContext {
      /** When the meta site was deleted. */
      dateDeleted?: Date | null;
      /** A status. */
      deleteStatus?: DeleteStatus;
      /** A reason (flow). */
      deleteOrigin?: string;
      /** A service that deleted it. */
      initiatorId?: string | null;
  }
  enum DeleteStatus {
      UNKNOWN = "UNKNOWN",
      TRASH = "TRASH",
      DELETED = "DELETED",
      PENDING_PURGE = "PENDING_PURGE"
  }
  /** Restoration of the meta site. */
  interface SiteUndeleted {
  }
  /** First publish of a meta site. Or subsequent publish after unpublish. */
  interface SitePublished {
  }
  interface SiteUnpublished {
      /** A list of URLs previously associated with the meta site. */
      urls?: string[];
  }
  interface SiteMarkedAsTemplate {
  }
  interface SiteMarkedAsWixSite {
  }
  /**
   * Represents a service provisioned a site.
   *
   * Note on `origin_instance_id`:
   * There is no guarantee that you will be able to find a meta site using `origin_instance_id`.
   * This is because of the following scenario:
   *
   * Imagine you have a template where a third-party application (TPA) includes some stub data,
   * such as a product catalog. When you create a site from this template, you inherit this
   * default product catalog. However, if the template's product catalog is modified,
   * your site will retain the catalog as it was at the time of site creation. This ensures that
   * your site remains consistent with what you initially received and does not include any
   * changes made to the original template afterward.
   * To ensure this, the TPA on the template gets a new instance_id.
   */
  interface ServiceProvisioned {
      /** Either UUID or EmbeddedServiceType. */
      appDefId?: string;
      /** Not only UUID. Something here could be something weird. */
      instanceId?: string;
      /** An instance id from which this instance is originated. */
      originInstanceId?: string;
      /** A version. */
      version?: string | null;
      /** The origin meta site id */
      originMetaSiteId?: string | null;
  }
  interface ServiceRemoved {
      /** Either UUID or EmbeddedServiceType. */
      appDefId?: string;
      /** Not only UUID. Something here could be something weird. */
      instanceId?: string;
      /** A version. */
      version?: string | null;
  }
  /** Rename of the site. Meaning, free public url has been changed as well. */
  interface SiteRenamed {
      /** A new meta site name (URL slug). */
      newSiteName?: string;
      /** A previous meta site name (URL slug). */
      oldSiteName?: string;
  }
  /**
   * Hard deletion of the meta site.
   *
   * Could not be restored. Therefore it's desirable to cleanup data.
   */
  interface SiteHardDeleted {
      /** A deletion context. */
      deleteContext?: DeleteContext;
  }
  interface NamespaceChanged {
      /** A previous namespace. */
      oldNamespace?: Namespace;
      /** A new namespace. */
      newNamespace?: Namespace;
  }
  /** Assigned Studio editor */
  interface StudioAssigned {
  }
  /** Unassigned Studio editor */
  interface StudioUnassigned {
  }
  interface GetTicketDefinitionFromTrashBinRequest {
      /** Ticket definition ID. */
      ticketDefinitionId?: string;
      /** Requested fields. Not implemented. */
      fields?: Field[];
  }
  interface GetTicketDefinitionFromTrashBinResponse {
      /** The requested ticket definition. */
      ticketDefinition?: TicketDefinition;
  }
  interface ScheduleLegacyTimeCapsuleTaskRequest {
      /** Definition ID. */
      ticketDefinitionId?: string;
  }
  /**
   * > **Note:** This function replaces the deprecated `createTicketDefinition()` function. The deprecated function will continue to work until November 8, 2024, but it will not receive updates. To keep any existing code compatible with future changes, see the [migration instructions](https://www.wix.com/velo/reference/wix-events-v2/ticketdefinitions/createticketdefinition).
   *
   *
   * Creates a ticket definition.
   *
   *
   * It is allowed to create up to 100 definitions per event.
   * @param ticketDefinition - Ticket definition info.
   * @public
   * @requiredField ticketDefinition
   * @requiredField ticketDefinition.eventId
   * @requiredField ticketDefinition.feeType
   * @requiredField ticketDefinition.name
   * @requiredField ticketDefinition.pricingMethod
   * @param options - Optional fields.
   * @permissionId WIX_EVENTS.MANAGE_TICKET_DEFINITIONS
   * @adminMethod
   * @returns Created ticket definition.
   */
  function createTicketDefinition(ticketDefinition: TicketDefinition, options?: CreateTicketDefinitionOptions): Promise<TicketDefinition>;
  interface CreateTicketDefinitionOptions {
      /** Predefined sets of fields to return. */
      fields?: Field[];
  }
  /**
   * > **Note:** This function replaces the deprecated `updateTicketDefinition()` function. The deprecated function will continue to work until November 8, 2024, but it will not receive updates. To keep any existing code compatible with future changes, see the [migration instructions](https://www.wix.com/velo/reference/wix-events-v2/ticketdefinitions/updateticketdefinition).
   *
   * Updates a ticket definition.
   *
   *
   * Each time the ticket definition is updated, `revision` increments by 1. The existing `revision` must be included when updating the ticket definition. This ensures you're working with the latest ticket definition and prevents unintended overwrites.
   * @param _id - Ticket definition ID.
   * @public
   * @requiredField _id
   * @requiredField ticketDefinition
   * @requiredField ticketDefinition.revision
   * @param options - Optional fields.
   * @param ticketDefinition - Ticket definition to update.
   * @permissionId WIX_EVENTS.MANAGE_TICKET_DEFINITIONS
   * @adminMethod
   * @returns The updated ticket definition.
   */
  function updateTicketDefinition(_id: string | null, ticketDefinition: UpdateTicketDefinition, options?: UpdateTicketDefinitionOptions): Promise<TicketDefinition>;
  interface UpdateTicketDefinition {
      /**
       * Ticket definition ID.
       * @readonly
       */
      _id?: string | null;
      /** Event ID to which the ticket definition belongs. */
      eventId?: string | null;
      /**
       * Revision number, which increments by 1 each time the ticket definition is updated. To prevent conflicting changes, the existing revision must be used when updating a ticket definition.
       * @readonly
       */
      revision?: string | null;
      /**
       * Date and time when the ticket definition was created.
       * @readonly
       */
      _createdDate?: Date | null;
      /**
       * Date and time when the ticket definition was updated.
       * @readonly
       */
      _updatedDate?: Date | null;
      /** Ticket definition name. */
      name?: string | null;
      /** Ticket definition description. */
      description?: string | null;
      /** Ticket definition policy. */
      policyText?: string | null;
      /** Whether this ticket definition is hidden to site visitors and can't be purchased. */
      hidden?: boolean;
      /**
       * Whether the ticket has a limited maximum quantity.
       * @readonly
       */
      limited?: boolean;
      /** The maximum number of tickets that can be sold for the event when first defining the event. If a seating map is defined after you created a ticket definition, this property is ignored and `actualLimit` is used instead. */
      initialLimit?: number | null;
      /**
       * The maximum number of tickets that can be sold for the event after adding a seating map to the event. If no seating map is defined, this property is the same as `initialLimit`.
       * @readonly
       */
      actualLimit?: number | null;
      /** Ticket pricing method. */
      pricingMethod?: PricingMethod;
      /** Whether fee is included in the ticket price or customer pays it additionally at checkout. */
      feeType?: Type;
      /** Ticket sale period. */
      salePeriod?: SalePeriod;
      /**
       * Ticket sale status.
       * @readonly
       */
      saleStatus?: SaleStatusEnumStatus;
      /**
       * Ticket sales information. <br>
       * **Note:** This field is only returned when `SALES_DETAILS` fieldset is included in the request.
       */
      salesDetails?: SalesDetails;
      /**
       * For proxy.
       * @internal
       * @readonly
       */
      sortIndex?: number;
      /**
       * Number of tickets that can be purchased per checkout. <br>
       * **Note:** If the `actuaLimit` or `salesDetails.unsoldCount` field value is smaller than `limitPerCheckout`, then it overrides this field.
       * @readonly
       */
      limitPerCheckout?: number | null;
      /**
       * Event created timestamp in `yyyy-mm-ddThh:mm:sssZ` format.
       * @internal
       * @readonly
       */
      eventCreatedDate?: Date | null;
      /** Data extensions. */
      extendedFields?: ExtendedFields;
      /**
       * Associated event information. <br>
       * **Note:** This field is only returned when `EVENT_DETAILS` fieldset is included in the request.
       */
      eventDetails?: EventDetails;
  }
  interface UpdateTicketDefinitionOptions {
      /**
       * List of exact fields to update. For example, if you define only `name`, all other fields are ignored.
       * @internal
       */
      mask?: string[];
      /** Predefined sets of fields to return. */
      fields?: Field[];
  }
  /**
   * > **Note:** This function replaces the deprecated `getTicketDefinition()` function. The deprecated function will continue to work until November 8, 2024, but it will not receive updates. To keep any existing code compatible with future changes, see the [migration instructions](https://www.wix.com/velo/reference/wix-events-v2/ticketdefinitions/getticketdefinition).
   *
   * Retrieves a ticket definition by ID.
   * @param ticketDefinitionId - Ticket definition ID.
   * @public
   * @requiredField ticketDefinitionId
   * @param options - Optional fields.
   * @permissionId WIX_EVENTS.READ_TICKET_DEFINITIONS
   * @adminMethod
   * @returns The requested ticket definition.
   */
  function getTicketDefinition(ticketDefinitionId: string, options?: GetTicketDefinitionOptions): Promise<TicketDefinition>;
  interface GetTicketDefinitionOptions {
      /** Predefined sets of fields to return. */
      fields?: Field[];
  }
  /**
   * > **Note:** This function replaces the deprecated `deleteTicketDefinition()` function. The deprecated function will continue to work until November 8, 2024, but it will not receive updates. To keep any existing code compatible with future changes, see the [migration instructions](https://www.wix.com/velo/reference/wix-events-v2/ticketdefinitions/deleteticketdefinition).
   *
   * Permanently deletes a ticket definition.
   * @param ticketDefinitionId - ID of the ticket definition to delete.
   * @public
   * @requiredField ticketDefinitionId
   * @permissionId WIX_EVENTS.MANAGE_TICKET_DEFINITIONS
   * @adminMethod
   */
  function deleteTicketDefinition(ticketDefinitionId: string): Promise<void>;
  /**
   * Changes ticket definitions order in an event dashboard and the list of available tickets in the ticket picker.
   * > **Note:** It is possible to use both `beforeTicketDefinitionId` and `afterTicketDefinitionId` at the same time but only the last one defined will be executed.
   * @param eventId - Event ID.
   * @public
   * @requiredField eventId
   * @requiredField options.ticketDefinitionId
   * @param options - Optional fields.
   * @permissionId WIX_EVENTS.MANAGE_TICKET_DEFINITIONS
   * @adminMethod
   */
  function reorderTicketDefinitions(eventId: string, options?: ReorderTicketDefinitionsOptions): Promise<void>;
  interface ReorderTicketDefinitionsOptions extends ReorderTicketDefinitionsRequestReferenceDefinitionOneOf {
      /** Ticket definition ID. */
      ticketDefinitionId: string;
      /** Move the given `definitionId` before the referenced ticket definition. */
      beforeDefinitionId?: string;
      /** Move the given `definitionId` after the referenced ticket definition. */
      afterDefinitionId?: string;
  }
  /**
   * > **Note:** This function replaces the deprecated `listTicketDefinition()` and `queryTicketDefinitions` functions. The deprecated functions will continue to work until November 8, 2024, but it will not receive updates. To keep any existing code compatible with future changes, see the [migration instructions](https://www.wix.com/velo/reference/wix-events-v2/ticketdefinitions/queryticketdefinitions).
   *
   * Retrieves a list of ticket definitions, given the provided paging, filtering, and sorting.
   * Query Ticket Definitions runs with these defaults, which you can override:
   * - `createdDate` is sorted in `ASC` order
   * - `paging.limit` is `100`
   * - `paging.offset` is `0`
   * @public
   * @param options - Optional fields.
   * @permissionId WIX_EVENTS.READ_TICKET_DEFINITIONS
   * @adminMethod
   */
  function queryTicketDefinitions(options?: QueryTicketDefinitionsOptions): TicketDefinitionsQueryBuilder;
  interface QueryTicketDefinitionsOptions {
      /** Predefined sets of fields to return. */
      fields?: Field[] | undefined;
      /**
       * Consistent read.
       * @internal
       */
      consistentRead?: boolean | null | undefined;
  }
  interface QueryCursorResult {
      cursors: Cursors;
      hasNext: () => boolean;
      hasPrev: () => boolean;
      length: number;
      pageSize: number;
  }
  interface TicketDefinitionsQueryResult extends QueryCursorResult {
      items: TicketDefinition[];
      query: TicketDefinitionsQueryBuilder;
      next: () => Promise<TicketDefinitionsQueryResult>;
      prev: () => Promise<TicketDefinitionsQueryResult>;
  }
  interface TicketDefinitionsQueryBuilder {
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       */
      eq: (propertyName: '_id' | 'eventId' | 'revision' | '_createdDate' | '_updatedDate' | 'name' | 'description' | 'hidden' | 'initialLimit' | 'pricingMethod.fixedPrice.value' | 'pricingMethod.fixedPrice.currency' | 'pricingMethod.pricingType' | 'pricingMethod.free' | 'feeType' | 'saleStatus', value: any) => TicketDefinitionsQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       */
      ne: (propertyName: '_id' | 'eventId' | 'revision' | '_createdDate' | '_updatedDate' | 'name' | 'description' | 'hidden' | 'initialLimit' | 'pricingMethod.fixedPrice.value' | 'pricingMethod.fixedPrice.currency' | 'pricingMethod.pricingType' | 'pricingMethod.free' | 'feeType' | 'saleStatus', value: any) => TicketDefinitionsQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       */
      ge: (propertyName: 'revision' | '_createdDate' | '_updatedDate' | 'initialLimit', value: any) => TicketDefinitionsQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       */
      gt: (propertyName: 'revision' | '_createdDate' | '_updatedDate' | 'initialLimit', value: any) => TicketDefinitionsQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       */
      le: (propertyName: 'revision' | '_createdDate' | '_updatedDate' | 'initialLimit', value: any) => TicketDefinitionsQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       */
      lt: (propertyName: 'revision' | '_createdDate' | '_updatedDate' | 'initialLimit', value: any) => TicketDefinitionsQueryBuilder;
      in: (propertyName: '_id' | 'eventId' | 'revision' | '_createdDate' | '_updatedDate' | 'name' | 'description' | 'hidden' | 'initialLimit' | 'pricingMethod.fixedPrice.value' | 'pricingMethod.fixedPrice.currency' | 'pricingMethod.pricingType' | 'pricingMethod.free' | 'feeType' | 'saleStatus', value: any) => TicketDefinitionsQueryBuilder;
      exists: (propertyName: '_id' | 'eventId' | 'revision' | '_createdDate' | '_updatedDate' | 'name' | 'description' | 'hidden' | 'initialLimit' | 'pricingMethod.fixedPrice.value' | 'pricingMethod.fixedPrice.currency' | 'pricingMethod.pricingType' | 'pricingMethod.free' | 'feeType' | 'saleStatus', value: boolean) => TicketDefinitionsQueryBuilder;
      /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments. */
      ascending: (...propertyNames: Array<'_id' | 'eventId' | 'revision' | '_createdDate' | '_updatedDate' | 'name' | 'description' | 'hidden' | 'initialLimit' | 'pricingMethod.fixedPrice.value' | 'pricingMethod.fixedPrice.currency' | 'pricingMethod.pricingType' | 'pricingMethod.free' | 'feeType' | 'saleStatus'>) => TicketDefinitionsQueryBuilder;
      /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments. */
      descending: (...propertyNames: Array<'_id' | 'eventId' | 'revision' | '_createdDate' | '_updatedDate' | 'name' | 'description' | 'hidden' | 'initialLimit' | 'pricingMethod.fixedPrice.value' | 'pricingMethod.fixedPrice.currency' | 'pricingMethod.pricingType' | 'pricingMethod.free' | 'feeType' | 'saleStatus'>) => TicketDefinitionsQueryBuilder;
      /** @param limit - Number of items to return, which is also the `pageSize` of the results object. */
      limit: (limit: number) => TicketDefinitionsQueryBuilder;
      /** @param cursor - A pointer to specific record */
      skipTo: (cursor: string) => TicketDefinitionsQueryBuilder;
      find: () => Promise<TicketDefinitionsQueryResult>;
  }
  /**
   * Retrieves a list of available ticket definitions, given the provided paging, filtering, and sorting.
   *
   * This endpoint retrieves ticket definitions that aren't in the `hidden` state. The available ticket definitions can be retrieved by site visitors.
   *
   * > **Note:** You need the `WIX_EVENTS.READ_TICKET_DEFINITIONS` permission to get the `salesDetails` field values.
   *
   * Query Available Ticket Definitions runs with these defaults, which you can override:
   * - `createdDate` is sorted in `ASC` order
   * - `paging.limit` is `100`
   * - `paging.offset` is `0`
   *
   * For field support for filters and sorting, see [Ticket Definitions: Supported Filters and Sorting](https://dev.wix.com/docs/rest/business-solutions/events/ticket-definition-v3/filter-and-sort).
   * To learn about working with _Query_ endpoints, see [API Query Language](https://dev.wix.com/api/rest/getting-started/api-query-language).
   * @param query - Query options. See [API Query Language](https://dev.wix.com/api/rest/getting-started/api-query-language) for more details.
   * @public
   * @requiredField query
   * @param options - Optional fields.
   * @permissionId WIX_EVENTS.READ_AVAILABLE_TICKET_DEFINITIONS
   */
  function queryAvailableTicketDefinitions(query: QueryV2, options?: QueryAvailableTicketDefinitionsOptions): Promise<QueryAvailableTicketDefinitionsResponse>;
  interface QueryAvailableTicketDefinitionsOptions {
      /** Predefined sets of fields to return. */
      fields?: Field[];
  }
  /**
   * Counts ticket definitions by the `saleStatus` field, including those with the `hidden` status.
   * @public
   * @param options - Optional fields.
   * @permissionId WIX_EVENTS.READ_TICKET_DEFINITIONS
   * @adminMethod
   */
  function countTicketDefinitions(options?: CountTicketDefinitionsOptions): Promise<CountTicketDefinitionsResponse>;
  interface CountTicketDefinitionsOptions {
      /** Filter object in the following format: <br/> `"filter" : { "fieldName1": "value1" }`. */
      filter?: Record<string, any> | null;
      /**
       * Parameters to count ticket definitions by.
       *
       * - Max: 20 facets.
       */
      facet?: string[];
  }
  /**
   * Counts ticket definitions by the `saleStatus`, excluding those with the `hidden` status.
   * @public
   * @param options - Optional fields.
   * @permissionId WIX_EVENTS.READ_AVAILABLE_TICKET_DEFINITIONS
   */
  function countAvailableTicketDefinitions(options?: CountAvailableTicketDefinitionsOptions): Promise<CountAvailableTicketDefinitionsResponse>;
  interface CountAvailableTicketDefinitionsOptions {
      /** Filter object in the following format: <br/> `"filter" : { "fieldName1": "value1" }`. */
      filter?: Record<string, any> | null;
  }
  /**
   * Deletes multiple ticket definitions.
   *
   * All ticket definitions that meet the specified `filter` criteria are deleted.
   * @param filter - Filter object in the following format: <br/> `"filter" : { "fieldName1": "value1" }`. <br/> <br/> **Example:** <br/> `"filter" : { "eventId": "3d3d5c04-ece0-45a8-85f0-11a58edaa192" }`
   * @public
   * @requiredField filter
   * @permissionId WIX_EVENTS.MANAGE_TICKET_DEFINITIONS
   * @adminMethod
   */
  function bulkDeleteTicketDefinitionsByFilter(filter: Record<string, any> | null): Promise<void>;
  /**
   * > **Note:** This function replaces the deprecated `changeCurrency()` function. The deprecated function will continue to work until November 8, 2024, but it will not receive updates. To keep any existing code compatible with future changes, see the [migration instructions](https://www.wix.com/velo/reference/wix-events-v2/ticketdefinitions/changecurrency).
   *
   * Changes ticket price currency per event.
   * @param eventId - Event ID.
   * @public
   * @requiredField eventId
   * @requiredField options
   * @requiredField options.currency
   * @param options - Optional fields.
   * @permissionId WIX_EVENTS.MANAGE_TICKET_DEFINITIONS
   * @adminMethod
   */
  function changeCurrency(eventId: string, options: ChangeCurrencyOptions): Promise<void>;
  interface ChangeCurrencyOptions {
      /** Ticket price currency in 3-letter [ISO-4217 alphabetic](https://en.wikipedia.org/wiki/ISO_4217#Active_codes) format. */
      currency: string;
  }
  
  type eventsV3TicketDefinition_universal_d_TicketDefinition = TicketDefinition;
  type eventsV3TicketDefinition_universal_d_SalePeriod = SalePeriod;
  type eventsV3TicketDefinition_universal_d_PricingMethod = PricingMethod;
  type eventsV3TicketDefinition_universal_d_PricingMethodPriceOneOf = PricingMethodPriceOneOf;
  type eventsV3TicketDefinition_universal_d_CommonMoney = CommonMoney;
  type eventsV3TicketDefinition_universal_d_PricingOptions = PricingOptions;
  type eventsV3TicketDefinition_universal_d_OptionDetails = OptionDetails;
  type eventsV3TicketDefinition_universal_d_PricingTypeEnumType = PricingTypeEnumType;
  const eventsV3TicketDefinition_universal_d_PricingTypeEnumType: typeof PricingTypeEnumType;
  type eventsV3TicketDefinition_universal_d_Type = Type;
  const eventsV3TicketDefinition_universal_d_Type: typeof Type;
  type eventsV3TicketDefinition_universal_d_SaleStatusEnumStatus = SaleStatusEnumStatus;
  const eventsV3TicketDefinition_universal_d_SaleStatusEnumStatus: typeof SaleStatusEnumStatus;
  type eventsV3TicketDefinition_universal_d_SalesDetails = SalesDetails;
  type eventsV3TicketDefinition_universal_d_ExtendedFields = ExtendedFields;
  type eventsV3TicketDefinition_universal_d_EventDetails = EventDetails;
  type eventsV3TicketDefinition_universal_d_V3Location = V3Location;
  type eventsV3TicketDefinition_universal_d_LocationLocationType = LocationLocationType;
  const eventsV3TicketDefinition_universal_d_LocationLocationType: typeof LocationLocationType;
  type eventsV3TicketDefinition_universal_d_CommonAddress = CommonAddress;
  type eventsV3TicketDefinition_universal_d_CommonAddressStreetOneOf = CommonAddressStreetOneOf;
  type eventsV3TicketDefinition_universal_d_CommonStreetAddress = CommonStreetAddress;
  type eventsV3TicketDefinition_universal_d_CommonAddressLocation = CommonAddressLocation;
  type eventsV3TicketDefinition_universal_d_CommonSubdivision = CommonSubdivision;
  type eventsV3TicketDefinition_universal_d_SubdivisionSubdivisionType = SubdivisionSubdivisionType;
  const eventsV3TicketDefinition_universal_d_SubdivisionSubdivisionType: typeof SubdivisionSubdivisionType;
  type eventsV3TicketDefinition_universal_d_DateAndTimeSettings = DateAndTimeSettings;
  type eventsV3TicketDefinition_universal_d_RecurrenceStatusStatus = RecurrenceStatusStatus;
  const eventsV3TicketDefinition_universal_d_RecurrenceStatusStatus: typeof RecurrenceStatusStatus;
  type eventsV3TicketDefinition_universal_d_V3Recurrences = V3Recurrences;
  type eventsV3TicketDefinition_universal_d_V3Occurrence = V3Occurrence;
  type eventsV3TicketDefinition_universal_d_Formatted = Formatted;
  type eventsV3TicketDefinition_universal_d_EventStatusStatus = EventStatusStatus;
  const eventsV3TicketDefinition_universal_d_EventStatusStatus: typeof EventStatusStatus;
  type eventsV3TicketDefinition_universal_d_SalePeriodUpdated = SalePeriodUpdated;
  type eventsV3TicketDefinition_universal_d_TicketDefinitionSaleStarted = TicketDefinitionSaleStarted;
  type eventsV3TicketDefinition_universal_d_TicketDefinitionSaleEnded = TicketDefinitionSaleEnded;
  type eventsV3TicketDefinition_universal_d_DomainEvent = DomainEvent;
  type eventsV3TicketDefinition_universal_d_DomainEventBodyOneOf = DomainEventBodyOneOf;
  type eventsV3TicketDefinition_universal_d_EntityCreatedEvent = EntityCreatedEvent;
  type eventsV3TicketDefinition_universal_d_RestoreInfo = RestoreInfo;
  type eventsV3TicketDefinition_universal_d_EntityUpdatedEvent = EntityUpdatedEvent;
  type eventsV3TicketDefinition_universal_d_EntityDeletedEvent = EntityDeletedEvent;
  type eventsV3TicketDefinition_universal_d_ActionEvent = ActionEvent;
  type eventsV3TicketDefinition_universal_d_MessageEnvelope = MessageEnvelope;
  type eventsV3TicketDefinition_universal_d_IdentificationData = IdentificationData;
  type eventsV3TicketDefinition_universal_d_IdentificationDataIdOneOf = IdentificationDataIdOneOf;
  type eventsV3TicketDefinition_universal_d_WebhookIdentityType = WebhookIdentityType;
  const eventsV3TicketDefinition_universal_d_WebhookIdentityType: typeof WebhookIdentityType;
  type eventsV3TicketDefinition_universal_d_InvalidateCache = InvalidateCache;
  type eventsV3TicketDefinition_universal_d_InvalidateCacheGetByOneOf = InvalidateCacheGetByOneOf;
  type eventsV3TicketDefinition_universal_d_App = App;
  type eventsV3TicketDefinition_universal_d_Page = Page;
  type eventsV3TicketDefinition_universal_d_URI = URI;
  type eventsV3TicketDefinition_universal_d_File = File;
  type eventsV3TicketDefinition_universal_d_GetTicketDefinitionSummaryRequest = GetTicketDefinitionSummaryRequest;
  type eventsV3TicketDefinition_universal_d_GetTicketDefinitionSummaryResponse = GetTicketDefinitionSummaryResponse;
  type eventsV3TicketDefinition_universal_d_TicketDefinitionSummary = TicketDefinitionSummary;
  type eventsV3TicketDefinition_universal_d_ListEventTicketingSummaryRequest = ListEventTicketingSummaryRequest;
  type eventsV3TicketDefinition_universal_d_ListEventTicketingSummaryResponse = ListEventTicketingSummaryResponse;
  type eventsV3TicketDefinition_universal_d_EventTicketingSummary = EventTicketingSummary;
  type eventsV3TicketDefinition_universal_d_Empty = Empty;
  type eventsV3TicketDefinition_universal_d_ReservationCreated = ReservationCreated;
  type eventsV3TicketDefinition_universal_d_ReservationStatus = ReservationStatus;
  const eventsV3TicketDefinition_universal_d_ReservationStatus: typeof ReservationStatus;
  type eventsV3TicketDefinition_universal_d_TicketQuantity = TicketQuantity;
  type eventsV3TicketDefinition_universal_d_ReservationCount = ReservationCount;
  type eventsV3TicketDefinition_universal_d_ReservationUpdated = ReservationUpdated;
  type eventsV3TicketDefinition_universal_d_EventDeleted = EventDeleted;
  type eventsV3TicketDefinition_universal_d_CreateTicketDefinitionRequest = CreateTicketDefinitionRequest;
  type eventsV3TicketDefinition_universal_d_Field = Field;
  const eventsV3TicketDefinition_universal_d_Field: typeof Field;
  type eventsV3TicketDefinition_universal_d_CreateTicketDefinitionResponse = CreateTicketDefinitionResponse;
  type eventsV3TicketDefinition_universal_d_UpdateTicketDefinitionRequest = UpdateTicketDefinitionRequest;
  type eventsV3TicketDefinition_universal_d_UpdateTicketDefinitionResponse = UpdateTicketDefinitionResponse;
  type eventsV3TicketDefinition_universal_d_GetTicketDefinitionRequest = GetTicketDefinitionRequest;
  type eventsV3TicketDefinition_universal_d_GetTicketDefinitionResponse = GetTicketDefinitionResponse;
  type eventsV3TicketDefinition_universal_d_DeleteTicketDefinitionRequest = DeleteTicketDefinitionRequest;
  type eventsV3TicketDefinition_universal_d_DeleteTicketDefinitionResponse = DeleteTicketDefinitionResponse;
  type eventsV3TicketDefinition_universal_d_ReorderTicketDefinitionsRequest = ReorderTicketDefinitionsRequest;
  type eventsV3TicketDefinition_universal_d_ReorderTicketDefinitionsRequestReferenceDefinitionOneOf = ReorderTicketDefinitionsRequestReferenceDefinitionOneOf;
  type eventsV3TicketDefinition_universal_d_ReorderTicketDefinitionsResponse = ReorderTicketDefinitionsResponse;
  type eventsV3TicketDefinition_universal_d_UpdateTicketDefinitionSortIndexRequest = UpdateTicketDefinitionSortIndexRequest;
  type eventsV3TicketDefinition_universal_d_UpdateTicketDefinitionSortIndexResponse = UpdateTicketDefinitionSortIndexResponse;
  type eventsV3TicketDefinition_universal_d_QueryTicketDefinitionsRequest = QueryTicketDefinitionsRequest;
  type eventsV3TicketDefinition_universal_d_QueryV2 = QueryV2;
  type eventsV3TicketDefinition_universal_d_QueryV2PagingMethodOneOf = QueryV2PagingMethodOneOf;
  type eventsV3TicketDefinition_universal_d_Sorting = Sorting;
  type eventsV3TicketDefinition_universal_d_SortOrder = SortOrder;
  const eventsV3TicketDefinition_universal_d_SortOrder: typeof SortOrder;
  type eventsV3TicketDefinition_universal_d_Paging = Paging;
  type eventsV3TicketDefinition_universal_d_CursorPaging = CursorPaging;
  type eventsV3TicketDefinition_universal_d_QueryTicketDefinitionsResponse = QueryTicketDefinitionsResponse;
  type eventsV3TicketDefinition_universal_d_PagingMetadataV2 = PagingMetadataV2;
  type eventsV3TicketDefinition_universal_d_Cursors = Cursors;
  type eventsV3TicketDefinition_universal_d_QueryAvailableTicketDefinitionsRequest = QueryAvailableTicketDefinitionsRequest;
  type eventsV3TicketDefinition_universal_d_QueryAvailableTicketDefinitionsResponse = QueryAvailableTicketDefinitionsResponse;
  type eventsV3TicketDefinition_universal_d_CountTicketDefinitionsRequest = CountTicketDefinitionsRequest;
  type eventsV3TicketDefinition_universal_d_CountTicketDefinitionsResponse = CountTicketDefinitionsResponse;
  type eventsV3TicketDefinition_universal_d_FacetCounts = FacetCounts;
  type eventsV3TicketDefinition_universal_d_CountAvailableTicketDefinitionsRequest = CountAvailableTicketDefinitionsRequest;
  type eventsV3TicketDefinition_universal_d_CountAvailableTicketDefinitionsResponse = CountAvailableTicketDefinitionsResponse;
  type eventsV3TicketDefinition_universal_d_BulkDeleteTicketDefinitionsByFilterRequest = BulkDeleteTicketDefinitionsByFilterRequest;
  type eventsV3TicketDefinition_universal_d_BulkDeleteTicketDefinitionsByFilterResponse = BulkDeleteTicketDefinitionsByFilterResponse;
  type eventsV3TicketDefinition_universal_d_ChangeCurrencyRequest = ChangeCurrencyRequest;
  type eventsV3TicketDefinition_universal_d_ChangeCurrencyResponse = ChangeCurrencyResponse;
  type eventsV3TicketDefinition_universal_d_BulkCopyTicketDefinitionsByEventIdRequest = BulkCopyTicketDefinitionsByEventIdRequest;
  type eventsV3TicketDefinition_universal_d_BulkCopyTicketDefinitionsByEventIdResponse = BulkCopyTicketDefinitionsByEventIdResponse;
  type eventsV3TicketDefinition_universal_d_CopiedTicketDefinition = CopiedTicketDefinition;
  type eventsV3TicketDefinition_universal_d_EventCanceled = EventCanceled;
  type eventsV3TicketDefinition_universal_d_EventEnded = EventEnded;
  type eventsV3TicketDefinition_universal_d_EventCreated = EventCreated;
  type eventsV3TicketDefinition_universal_d_Location = Location;
  type eventsV3TicketDefinition_universal_d_MapCoordinates = MapCoordinates;
  type eventsV3TicketDefinition_universal_d_LocationType = LocationType;
  const eventsV3TicketDefinition_universal_d_LocationType: typeof LocationType;
  type eventsV3TicketDefinition_universal_d_Address = Address;
  type eventsV3TicketDefinition_universal_d_AddressStreetOneOf = AddressStreetOneOf;
  type eventsV3TicketDefinition_universal_d_StreetAddress = StreetAddress;
  type eventsV3TicketDefinition_universal_d_AddressLocation = AddressLocation;
  type eventsV3TicketDefinition_universal_d_Subdivision = Subdivision;
  type eventsV3TicketDefinition_universal_d_SubdivisionType = SubdivisionType;
  const eventsV3TicketDefinition_universal_d_SubdivisionType: typeof SubdivisionType;
  type eventsV3TicketDefinition_universal_d_ScheduleConfig = ScheduleConfig;
  type eventsV3TicketDefinition_universal_d_Recurrences = Recurrences;
  type eventsV3TicketDefinition_universal_d_Occurrence = Occurrence;
  type eventsV3TicketDefinition_universal_d_Status = Status;
  const eventsV3TicketDefinition_universal_d_Status: typeof Status;
  type eventsV3TicketDefinition_universal_d_EventStatus = EventStatus;
  const eventsV3TicketDefinition_universal_d_EventStatus: typeof EventStatus;
  type eventsV3TicketDefinition_universal_d_Event = Event;
  type eventsV3TicketDefinition_universal_d_Scheduling = Scheduling;
  type eventsV3TicketDefinition_universal_d_Registration = Registration;
  type eventsV3TicketDefinition_universal_d_EventType = EventType;
  const eventsV3TicketDefinition_universal_d_EventType: typeof EventType;
  type eventsV3TicketDefinition_universal_d_RegistrationStatus = RegistrationStatus;
  const eventsV3TicketDefinition_universal_d_RegistrationStatus: typeof RegistrationStatus;
  type eventsV3TicketDefinition_universal_d_RsvpCollection = RsvpCollection;
  type eventsV3TicketDefinition_universal_d_RsvpCollectionConfig = RsvpCollectionConfig;
  type eventsV3TicketDefinition_universal_d_RsvpStatusOptions = RsvpStatusOptions;
  const eventsV3TicketDefinition_universal_d_RsvpStatusOptions: typeof RsvpStatusOptions;
  type eventsV3TicketDefinition_universal_d_Ticketing = Ticketing;
  type eventsV3TicketDefinition_universal_d_TicketingConfig = TicketingConfig;
  type eventsV3TicketDefinition_universal_d_TaxConfig = TaxConfig;
  type eventsV3TicketDefinition_universal_d_TaxType = TaxType;
  const eventsV3TicketDefinition_universal_d_TaxType: typeof TaxType;
  type eventsV3TicketDefinition_universal_d_Money = Money;
  type eventsV3TicketDefinition_universal_d_ExternalEvent = ExternalEvent;
  type eventsV3TicketDefinition_universal_d_VisitorType = VisitorType;
  const eventsV3TicketDefinition_universal_d_VisitorType: typeof VisitorType;
  type eventsV3TicketDefinition_universal_d_CalendarLinks = CalendarLinks;
  type eventsV3TicketDefinition_universal_d_SiteUrl = SiteUrl;
  type eventsV3TicketDefinition_universal_d_Form = Form;
  type eventsV3TicketDefinition_universal_d_InputControl = InputControl;
  type eventsV3TicketDefinition_universal_d_InputControlType = InputControlType;
  const eventsV3TicketDefinition_universal_d_InputControlType: typeof InputControlType;
  type eventsV3TicketDefinition_universal_d_Input = Input;
  type eventsV3TicketDefinition_universal_d_ValueType = ValueType;
  const eventsV3TicketDefinition_universal_d_ValueType: typeof ValueType;
  type eventsV3TicketDefinition_universal_d_OptionSelection = OptionSelection;
  type eventsV3TicketDefinition_universal_d_OptionSelectionSelectedOptionOneOf = OptionSelectionSelectedOptionOneOf;
  type eventsV3TicketDefinition_universal_d_Label = Label;
  type eventsV3TicketDefinition_universal_d_FormMessages = FormMessages;
  type eventsV3TicketDefinition_universal_d_RsvpFormMessages = RsvpFormMessages;
  type eventsV3TicketDefinition_universal_d_PositiveResponseConfirmation = PositiveResponseConfirmation;
  type eventsV3TicketDefinition_universal_d_NegativeResponseConfirmation = NegativeResponseConfirmation;
  type eventsV3TicketDefinition_universal_d_Positive = Positive;
  type eventsV3TicketDefinition_universal_d_Negative = Negative;
  type eventsV3TicketDefinition_universal_d_CheckoutFormMessages = CheckoutFormMessages;
  type eventsV3TicketDefinition_universal_d_ResponseConfirmation = ResponseConfirmation;
  type eventsV3TicketDefinition_universal_d_RegistrationClosedMessages = RegistrationClosedMessages;
  type eventsV3TicketDefinition_universal_d_TicketsUnavailableMessages = TicketsUnavailableMessages;
  type eventsV3TicketDefinition_universal_d_Dashboard = Dashboard;
  type eventsV3TicketDefinition_universal_d_RsvpSummary = RsvpSummary;
  type eventsV3TicketDefinition_universal_d_TicketingSummary = TicketingSummary;
  type eventsV3TicketDefinition_universal_d_GuestListConfig = GuestListConfig;
  type eventsV3TicketDefinition_universal_d_Feed = Feed;
  type eventsV3TicketDefinition_universal_d_OnlineConferencing = OnlineConferencing;
  type eventsV3TicketDefinition_universal_d_OnlineConferencingConfig = OnlineConferencingConfig;
  type eventsV3TicketDefinition_universal_d_ConferenceType = ConferenceType;
  const eventsV3TicketDefinition_universal_d_ConferenceType: typeof ConferenceType;
  type eventsV3TicketDefinition_universal_d_OnlineConferencingSession = OnlineConferencingSession;
  type eventsV3TicketDefinition_universal_d_SeoSettings = SeoSettings;
  type eventsV3TicketDefinition_universal_d_SeoSchema = SeoSchema;
  type eventsV3TicketDefinition_universal_d_Keyword = Keyword;
  type eventsV3TicketDefinition_universal_d_Tag = Tag;
  type eventsV3TicketDefinition_universal_d_Settings = Settings;
  type eventsV3TicketDefinition_universal_d_Agenda = Agenda;
  type eventsV3TicketDefinition_universal_d_Category = Category;
  type eventsV3TicketDefinition_universal_d_CategoryCounts = CategoryCounts;
  type eventsV3TicketDefinition_universal_d_CategoryStateState = CategoryStateState;
  const eventsV3TicketDefinition_universal_d_CategoryStateState: typeof CategoryStateState;
  type eventsV3TicketDefinition_universal_d_EventDisplaySettings = EventDisplaySettings;
  type eventsV3TicketDefinition_universal_d_LabellingSettings = LabellingSettings;
  type eventsV3TicketDefinition_universal_d_EventUpdated = EventUpdated;
  type eventsV3TicketDefinition_universal_d_SeatingPlanCategoriesSummaryUpdated = SeatingPlanCategoriesSummaryUpdated;
  type eventsV3TicketDefinition_universal_d_CategoryDetails = CategoryDetails;
  type eventsV3TicketDefinition_universal_d_MetaSiteSpecialEvent = MetaSiteSpecialEvent;
  type eventsV3TicketDefinition_universal_d_MetaSiteSpecialEventPayloadOneOf = MetaSiteSpecialEventPayloadOneOf;
  type eventsV3TicketDefinition_universal_d_Asset = Asset;
  type eventsV3TicketDefinition_universal_d_State = State;
  const eventsV3TicketDefinition_universal_d_State: typeof State;
  type eventsV3TicketDefinition_universal_d_SiteCreated = SiteCreated;
  type eventsV3TicketDefinition_universal_d_SiteCreatedContext = SiteCreatedContext;
  const eventsV3TicketDefinition_universal_d_SiteCreatedContext: typeof SiteCreatedContext;
  type eventsV3TicketDefinition_universal_d_Namespace = Namespace;
  const eventsV3TicketDefinition_universal_d_Namespace: typeof Namespace;
  type eventsV3TicketDefinition_universal_d_SiteTransferred = SiteTransferred;
  type eventsV3TicketDefinition_universal_d_SiteDeleted = SiteDeleted;
  type eventsV3TicketDefinition_universal_d_DeleteContext = DeleteContext;
  type eventsV3TicketDefinition_universal_d_DeleteStatus = DeleteStatus;
  const eventsV3TicketDefinition_universal_d_DeleteStatus: typeof DeleteStatus;
  type eventsV3TicketDefinition_universal_d_SiteUndeleted = SiteUndeleted;
  type eventsV3TicketDefinition_universal_d_SitePublished = SitePublished;
  type eventsV3TicketDefinition_universal_d_SiteUnpublished = SiteUnpublished;
  type eventsV3TicketDefinition_universal_d_SiteMarkedAsTemplate = SiteMarkedAsTemplate;
  type eventsV3TicketDefinition_universal_d_SiteMarkedAsWixSite = SiteMarkedAsWixSite;
  type eventsV3TicketDefinition_universal_d_ServiceProvisioned = ServiceProvisioned;
  type eventsV3TicketDefinition_universal_d_ServiceRemoved = ServiceRemoved;
  type eventsV3TicketDefinition_universal_d_SiteRenamed = SiteRenamed;
  type eventsV3TicketDefinition_universal_d_SiteHardDeleted = SiteHardDeleted;
  type eventsV3TicketDefinition_universal_d_NamespaceChanged = NamespaceChanged;
  type eventsV3TicketDefinition_universal_d_StudioAssigned = StudioAssigned;
  type eventsV3TicketDefinition_universal_d_StudioUnassigned = StudioUnassigned;
  type eventsV3TicketDefinition_universal_d_GetTicketDefinitionFromTrashBinRequest = GetTicketDefinitionFromTrashBinRequest;
  type eventsV3TicketDefinition_universal_d_GetTicketDefinitionFromTrashBinResponse = GetTicketDefinitionFromTrashBinResponse;
  type eventsV3TicketDefinition_universal_d_ScheduleLegacyTimeCapsuleTaskRequest = ScheduleLegacyTimeCapsuleTaskRequest;
  const eventsV3TicketDefinition_universal_d_createTicketDefinition: typeof createTicketDefinition;
  type eventsV3TicketDefinition_universal_d_CreateTicketDefinitionOptions = CreateTicketDefinitionOptions;
  const eventsV3TicketDefinition_universal_d_updateTicketDefinition: typeof updateTicketDefinition;
  type eventsV3TicketDefinition_universal_d_UpdateTicketDefinition = UpdateTicketDefinition;
  type eventsV3TicketDefinition_universal_d_UpdateTicketDefinitionOptions = UpdateTicketDefinitionOptions;
  const eventsV3TicketDefinition_universal_d_getTicketDefinition: typeof getTicketDefinition;
  type eventsV3TicketDefinition_universal_d_GetTicketDefinitionOptions = GetTicketDefinitionOptions;
  const eventsV3TicketDefinition_universal_d_deleteTicketDefinition: typeof deleteTicketDefinition;
  const eventsV3TicketDefinition_universal_d_reorderTicketDefinitions: typeof reorderTicketDefinitions;
  type eventsV3TicketDefinition_universal_d_ReorderTicketDefinitionsOptions = ReorderTicketDefinitionsOptions;
  const eventsV3TicketDefinition_universal_d_queryTicketDefinitions: typeof queryTicketDefinitions;
  type eventsV3TicketDefinition_universal_d_QueryTicketDefinitionsOptions = QueryTicketDefinitionsOptions;
  type eventsV3TicketDefinition_universal_d_TicketDefinitionsQueryResult = TicketDefinitionsQueryResult;
  type eventsV3TicketDefinition_universal_d_TicketDefinitionsQueryBuilder = TicketDefinitionsQueryBuilder;
  const eventsV3TicketDefinition_universal_d_queryAvailableTicketDefinitions: typeof queryAvailableTicketDefinitions;
  type eventsV3TicketDefinition_universal_d_QueryAvailableTicketDefinitionsOptions = QueryAvailableTicketDefinitionsOptions;
  const eventsV3TicketDefinition_universal_d_countTicketDefinitions: typeof countTicketDefinitions;
  type eventsV3TicketDefinition_universal_d_CountTicketDefinitionsOptions = CountTicketDefinitionsOptions;
  const eventsV3TicketDefinition_universal_d_countAvailableTicketDefinitions: typeof countAvailableTicketDefinitions;
  type eventsV3TicketDefinition_universal_d_CountAvailableTicketDefinitionsOptions = CountAvailableTicketDefinitionsOptions;
  const eventsV3TicketDefinition_universal_d_bulkDeleteTicketDefinitionsByFilter: typeof bulkDeleteTicketDefinitionsByFilter;
  const eventsV3TicketDefinition_universal_d_changeCurrency: typeof changeCurrency;
  type eventsV3TicketDefinition_universal_d_ChangeCurrencyOptions = ChangeCurrencyOptions;
  namespace eventsV3TicketDefinition_universal_d {
    export {
      eventsV3TicketDefinition_universal_d_TicketDefinition as TicketDefinition,
      eventsV3TicketDefinition_universal_d_SalePeriod as SalePeriod,
      eventsV3TicketDefinition_universal_d_PricingMethod as PricingMethod,
      eventsV3TicketDefinition_universal_d_PricingMethodPriceOneOf as PricingMethodPriceOneOf,
      eventsV3TicketDefinition_universal_d_CommonMoney as CommonMoney,
      eventsV3TicketDefinition_universal_d_PricingOptions as PricingOptions,
      eventsV3TicketDefinition_universal_d_OptionDetails as OptionDetails,
      eventsV3TicketDefinition_universal_d_PricingTypeEnumType as PricingTypeEnumType,
      eventsV3TicketDefinition_universal_d_Type as Type,
      eventsV3TicketDefinition_universal_d_SaleStatusEnumStatus as SaleStatusEnumStatus,
      eventsV3TicketDefinition_universal_d_SalesDetails as SalesDetails,
      eventsV3TicketDefinition_universal_d_ExtendedFields as ExtendedFields,
      eventsV3TicketDefinition_universal_d_EventDetails as EventDetails,
      eventsV3TicketDefinition_universal_d_V3Location as V3Location,
      eventsV3TicketDefinition_universal_d_LocationLocationType as LocationLocationType,
      eventsV3TicketDefinition_universal_d_CommonAddress as CommonAddress,
      eventsV3TicketDefinition_universal_d_CommonAddressStreetOneOf as CommonAddressStreetOneOf,
      eventsV3TicketDefinition_universal_d_CommonStreetAddress as CommonStreetAddress,
      eventsV3TicketDefinition_universal_d_CommonAddressLocation as CommonAddressLocation,
      eventsV3TicketDefinition_universal_d_CommonSubdivision as CommonSubdivision,
      eventsV3TicketDefinition_universal_d_SubdivisionSubdivisionType as SubdivisionSubdivisionType,
      eventsV3TicketDefinition_universal_d_DateAndTimeSettings as DateAndTimeSettings,
      eventsV3TicketDefinition_universal_d_RecurrenceStatusStatus as RecurrenceStatusStatus,
      eventsV3TicketDefinition_universal_d_V3Recurrences as V3Recurrences,
      eventsV3TicketDefinition_universal_d_V3Occurrence as V3Occurrence,
      eventsV3TicketDefinition_universal_d_Formatted as Formatted,
      eventsV3TicketDefinition_universal_d_EventStatusStatus as EventStatusStatus,
      eventsV3TicketDefinition_universal_d_SalePeriodUpdated as SalePeriodUpdated,
      eventsV3TicketDefinition_universal_d_TicketDefinitionSaleStarted as TicketDefinitionSaleStarted,
      eventsV3TicketDefinition_universal_d_TicketDefinitionSaleEnded as TicketDefinitionSaleEnded,
      eventsV3TicketDefinition_universal_d_DomainEvent as DomainEvent,
      eventsV3TicketDefinition_universal_d_DomainEventBodyOneOf as DomainEventBodyOneOf,
      eventsV3TicketDefinition_universal_d_EntityCreatedEvent as EntityCreatedEvent,
      eventsV3TicketDefinition_universal_d_RestoreInfo as RestoreInfo,
      eventsV3TicketDefinition_universal_d_EntityUpdatedEvent as EntityUpdatedEvent,
      eventsV3TicketDefinition_universal_d_EntityDeletedEvent as EntityDeletedEvent,
      eventsV3TicketDefinition_universal_d_ActionEvent as ActionEvent,
      eventsV3TicketDefinition_universal_d_MessageEnvelope as MessageEnvelope,
      eventsV3TicketDefinition_universal_d_IdentificationData as IdentificationData,
      eventsV3TicketDefinition_universal_d_IdentificationDataIdOneOf as IdentificationDataIdOneOf,
      eventsV3TicketDefinition_universal_d_WebhookIdentityType as WebhookIdentityType,
      eventsV3TicketDefinition_universal_d_InvalidateCache as InvalidateCache,
      eventsV3TicketDefinition_universal_d_InvalidateCacheGetByOneOf as InvalidateCacheGetByOneOf,
      eventsV3TicketDefinition_universal_d_App as App,
      eventsV3TicketDefinition_universal_d_Page as Page,
      eventsV3TicketDefinition_universal_d_URI as URI,
      eventsV3TicketDefinition_universal_d_File as File,
      eventsV3TicketDefinition_universal_d_GetTicketDefinitionSummaryRequest as GetTicketDefinitionSummaryRequest,
      eventsV3TicketDefinition_universal_d_GetTicketDefinitionSummaryResponse as GetTicketDefinitionSummaryResponse,
      eventsV3TicketDefinition_universal_d_TicketDefinitionSummary as TicketDefinitionSummary,
      eventsV3TicketDefinition_universal_d_ListEventTicketingSummaryRequest as ListEventTicketingSummaryRequest,
      eventsV3TicketDefinition_universal_d_ListEventTicketingSummaryResponse as ListEventTicketingSummaryResponse,
      eventsV3TicketDefinition_universal_d_EventTicketingSummary as EventTicketingSummary,
      eventsV3TicketDefinition_universal_d_Empty as Empty,
      eventsV3TicketDefinition_universal_d_ReservationCreated as ReservationCreated,
      eventsV3TicketDefinition_universal_d_ReservationStatus as ReservationStatus,
      eventsV3TicketDefinition_universal_d_TicketQuantity as TicketQuantity,
      eventsV3TicketDefinition_universal_d_ReservationCount as ReservationCount,
      eventsV3TicketDefinition_universal_d_ReservationUpdated as ReservationUpdated,
      eventsV3TicketDefinition_universal_d_EventDeleted as EventDeleted,
      eventsV3TicketDefinition_universal_d_CreateTicketDefinitionRequest as CreateTicketDefinitionRequest,
      eventsV3TicketDefinition_universal_d_Field as Field,
      eventsV3TicketDefinition_universal_d_CreateTicketDefinitionResponse as CreateTicketDefinitionResponse,
      eventsV3TicketDefinition_universal_d_UpdateTicketDefinitionRequest as UpdateTicketDefinitionRequest,
      eventsV3TicketDefinition_universal_d_UpdateTicketDefinitionResponse as UpdateTicketDefinitionResponse,
      eventsV3TicketDefinition_universal_d_GetTicketDefinitionRequest as GetTicketDefinitionRequest,
      eventsV3TicketDefinition_universal_d_GetTicketDefinitionResponse as GetTicketDefinitionResponse,
      eventsV3TicketDefinition_universal_d_DeleteTicketDefinitionRequest as DeleteTicketDefinitionRequest,
      eventsV3TicketDefinition_universal_d_DeleteTicketDefinitionResponse as DeleteTicketDefinitionResponse,
      eventsV3TicketDefinition_universal_d_ReorderTicketDefinitionsRequest as ReorderTicketDefinitionsRequest,
      eventsV3TicketDefinition_universal_d_ReorderTicketDefinitionsRequestReferenceDefinitionOneOf as ReorderTicketDefinitionsRequestReferenceDefinitionOneOf,
      eventsV3TicketDefinition_universal_d_ReorderTicketDefinitionsResponse as ReorderTicketDefinitionsResponse,
      eventsV3TicketDefinition_universal_d_UpdateTicketDefinitionSortIndexRequest as UpdateTicketDefinitionSortIndexRequest,
      eventsV3TicketDefinition_universal_d_UpdateTicketDefinitionSortIndexResponse as UpdateTicketDefinitionSortIndexResponse,
      eventsV3TicketDefinition_universal_d_QueryTicketDefinitionsRequest as QueryTicketDefinitionsRequest,
      eventsV3TicketDefinition_universal_d_QueryV2 as QueryV2,
      eventsV3TicketDefinition_universal_d_QueryV2PagingMethodOneOf as QueryV2PagingMethodOneOf,
      eventsV3TicketDefinition_universal_d_Sorting as Sorting,
      eventsV3TicketDefinition_universal_d_SortOrder as SortOrder,
      eventsV3TicketDefinition_universal_d_Paging as Paging,
      eventsV3TicketDefinition_universal_d_CursorPaging as CursorPaging,
      eventsV3TicketDefinition_universal_d_QueryTicketDefinitionsResponse as QueryTicketDefinitionsResponse,
      eventsV3TicketDefinition_universal_d_PagingMetadataV2 as PagingMetadataV2,
      eventsV3TicketDefinition_universal_d_Cursors as Cursors,
      eventsV3TicketDefinition_universal_d_QueryAvailableTicketDefinitionsRequest as QueryAvailableTicketDefinitionsRequest,
      eventsV3TicketDefinition_universal_d_QueryAvailableTicketDefinitionsResponse as QueryAvailableTicketDefinitionsResponse,
      eventsV3TicketDefinition_universal_d_CountTicketDefinitionsRequest as CountTicketDefinitionsRequest,
      eventsV3TicketDefinition_universal_d_CountTicketDefinitionsResponse as CountTicketDefinitionsResponse,
      eventsV3TicketDefinition_universal_d_FacetCounts as FacetCounts,
      eventsV3TicketDefinition_universal_d_CountAvailableTicketDefinitionsRequest as CountAvailableTicketDefinitionsRequest,
      eventsV3TicketDefinition_universal_d_CountAvailableTicketDefinitionsResponse as CountAvailableTicketDefinitionsResponse,
      eventsV3TicketDefinition_universal_d_BulkDeleteTicketDefinitionsByFilterRequest as BulkDeleteTicketDefinitionsByFilterRequest,
      eventsV3TicketDefinition_universal_d_BulkDeleteTicketDefinitionsByFilterResponse as BulkDeleteTicketDefinitionsByFilterResponse,
      eventsV3TicketDefinition_universal_d_ChangeCurrencyRequest as ChangeCurrencyRequest,
      eventsV3TicketDefinition_universal_d_ChangeCurrencyResponse as ChangeCurrencyResponse,
      eventsV3TicketDefinition_universal_d_BulkCopyTicketDefinitionsByEventIdRequest as BulkCopyTicketDefinitionsByEventIdRequest,
      eventsV3TicketDefinition_universal_d_BulkCopyTicketDefinitionsByEventIdResponse as BulkCopyTicketDefinitionsByEventIdResponse,
      eventsV3TicketDefinition_universal_d_CopiedTicketDefinition as CopiedTicketDefinition,
      eventsV3TicketDefinition_universal_d_EventCanceled as EventCanceled,
      eventsV3TicketDefinition_universal_d_EventEnded as EventEnded,
      eventsV3TicketDefinition_universal_d_EventCreated as EventCreated,
      eventsV3TicketDefinition_universal_d_Location as Location,
      eventsV3TicketDefinition_universal_d_MapCoordinates as MapCoordinates,
      eventsV3TicketDefinition_universal_d_LocationType as LocationType,
      eventsV3TicketDefinition_universal_d_Address as Address,
      eventsV3TicketDefinition_universal_d_AddressStreetOneOf as AddressStreetOneOf,
      eventsV3TicketDefinition_universal_d_StreetAddress as StreetAddress,
      eventsV3TicketDefinition_universal_d_AddressLocation as AddressLocation,
      eventsV3TicketDefinition_universal_d_Subdivision as Subdivision,
      eventsV3TicketDefinition_universal_d_SubdivisionType as SubdivisionType,
      eventsV3TicketDefinition_universal_d_ScheduleConfig as ScheduleConfig,
      eventsV3TicketDefinition_universal_d_Recurrences as Recurrences,
      eventsV3TicketDefinition_universal_d_Occurrence as Occurrence,
      eventsV3TicketDefinition_universal_d_Status as Status,
      eventsV3TicketDefinition_universal_d_EventStatus as EventStatus,
      eventsV3TicketDefinition_universal_d_Event as Event,
      eventsV3TicketDefinition_universal_d_Scheduling as Scheduling,
      eventsV3TicketDefinition_universal_d_Registration as Registration,
      eventsV3TicketDefinition_universal_d_EventType as EventType,
      eventsV3TicketDefinition_universal_d_RegistrationStatus as RegistrationStatus,
      eventsV3TicketDefinition_universal_d_RsvpCollection as RsvpCollection,
      eventsV3TicketDefinition_universal_d_RsvpCollectionConfig as RsvpCollectionConfig,
      eventsV3TicketDefinition_universal_d_RsvpStatusOptions as RsvpStatusOptions,
      eventsV3TicketDefinition_universal_d_Ticketing as Ticketing,
      eventsV3TicketDefinition_universal_d_TicketingConfig as TicketingConfig,
      eventsV3TicketDefinition_universal_d_TaxConfig as TaxConfig,
      eventsV3TicketDefinition_universal_d_TaxType as TaxType,
      eventsV3TicketDefinition_universal_d_Money as Money,
      eventsV3TicketDefinition_universal_d_ExternalEvent as ExternalEvent,
      eventsV3TicketDefinition_universal_d_VisitorType as VisitorType,
      eventsV3TicketDefinition_universal_d_CalendarLinks as CalendarLinks,
      eventsV3TicketDefinition_universal_d_SiteUrl as SiteUrl,
      eventsV3TicketDefinition_universal_d_Form as Form,
      eventsV3TicketDefinition_universal_d_InputControl as InputControl,
      eventsV3TicketDefinition_universal_d_InputControlType as InputControlType,
      eventsV3TicketDefinition_universal_d_Input as Input,
      eventsV3TicketDefinition_universal_d_ValueType as ValueType,
      eventsV3TicketDefinition_universal_d_OptionSelection as OptionSelection,
      eventsV3TicketDefinition_universal_d_OptionSelectionSelectedOptionOneOf as OptionSelectionSelectedOptionOneOf,
      eventsV3TicketDefinition_universal_d_Label as Label,
      eventsV3TicketDefinition_universal_d_FormMessages as FormMessages,
      eventsV3TicketDefinition_universal_d_RsvpFormMessages as RsvpFormMessages,
      eventsV3TicketDefinition_universal_d_PositiveResponseConfirmation as PositiveResponseConfirmation,
      eventsV3TicketDefinition_universal_d_NegativeResponseConfirmation as NegativeResponseConfirmation,
      eventsV3TicketDefinition_universal_d_Positive as Positive,
      eventsV3TicketDefinition_universal_d_Negative as Negative,
      eventsV3TicketDefinition_universal_d_CheckoutFormMessages as CheckoutFormMessages,
      eventsV3TicketDefinition_universal_d_ResponseConfirmation as ResponseConfirmation,
      eventsV3TicketDefinition_universal_d_RegistrationClosedMessages as RegistrationClosedMessages,
      eventsV3TicketDefinition_universal_d_TicketsUnavailableMessages as TicketsUnavailableMessages,
      eventsV3TicketDefinition_universal_d_Dashboard as Dashboard,
      eventsV3TicketDefinition_universal_d_RsvpSummary as RsvpSummary,
      eventsV3TicketDefinition_universal_d_TicketingSummary as TicketingSummary,
      eventsV3TicketDefinition_universal_d_GuestListConfig as GuestListConfig,
      eventsV3TicketDefinition_universal_d_Feed as Feed,
      eventsV3TicketDefinition_universal_d_OnlineConferencing as OnlineConferencing,
      eventsV3TicketDefinition_universal_d_OnlineConferencingConfig as OnlineConferencingConfig,
      eventsV3TicketDefinition_universal_d_ConferenceType as ConferenceType,
      eventsV3TicketDefinition_universal_d_OnlineConferencingSession as OnlineConferencingSession,
      eventsV3TicketDefinition_universal_d_SeoSettings as SeoSettings,
      eventsV3TicketDefinition_universal_d_SeoSchema as SeoSchema,
      eventsV3TicketDefinition_universal_d_Keyword as Keyword,
      eventsV3TicketDefinition_universal_d_Tag as Tag,
      eventsV3TicketDefinition_universal_d_Settings as Settings,
      eventsV3TicketDefinition_universal_d_Agenda as Agenda,
      eventsV3TicketDefinition_universal_d_Category as Category,
      eventsV3TicketDefinition_universal_d_CategoryCounts as CategoryCounts,
      eventsV3TicketDefinition_universal_d_CategoryStateState as CategoryStateState,
      eventsV3TicketDefinition_universal_d_EventDisplaySettings as EventDisplaySettings,
      eventsV3TicketDefinition_universal_d_LabellingSettings as LabellingSettings,
      eventsV3TicketDefinition_universal_d_EventUpdated as EventUpdated,
      eventsV3TicketDefinition_universal_d_SeatingPlanCategoriesSummaryUpdated as SeatingPlanCategoriesSummaryUpdated,
      eventsV3TicketDefinition_universal_d_CategoryDetails as CategoryDetails,
      eventsV3TicketDefinition_universal_d_MetaSiteSpecialEvent as MetaSiteSpecialEvent,
      eventsV3TicketDefinition_universal_d_MetaSiteSpecialEventPayloadOneOf as MetaSiteSpecialEventPayloadOneOf,
      eventsV3TicketDefinition_universal_d_Asset as Asset,
      eventsV3TicketDefinition_universal_d_State as State,
      eventsV3TicketDefinition_universal_d_SiteCreated as SiteCreated,
      eventsV3TicketDefinition_universal_d_SiteCreatedContext as SiteCreatedContext,
      eventsV3TicketDefinition_universal_d_Namespace as Namespace,
      eventsV3TicketDefinition_universal_d_SiteTransferred as SiteTransferred,
      eventsV3TicketDefinition_universal_d_SiteDeleted as SiteDeleted,
      eventsV3TicketDefinition_universal_d_DeleteContext as DeleteContext,
      eventsV3TicketDefinition_universal_d_DeleteStatus as DeleteStatus,
      eventsV3TicketDefinition_universal_d_SiteUndeleted as SiteUndeleted,
      eventsV3TicketDefinition_universal_d_SitePublished as SitePublished,
      eventsV3TicketDefinition_universal_d_SiteUnpublished as SiteUnpublished,
      eventsV3TicketDefinition_universal_d_SiteMarkedAsTemplate as SiteMarkedAsTemplate,
      eventsV3TicketDefinition_universal_d_SiteMarkedAsWixSite as SiteMarkedAsWixSite,
      eventsV3TicketDefinition_universal_d_ServiceProvisioned as ServiceProvisioned,
      eventsV3TicketDefinition_universal_d_ServiceRemoved as ServiceRemoved,
      eventsV3TicketDefinition_universal_d_SiteRenamed as SiteRenamed,
      eventsV3TicketDefinition_universal_d_SiteHardDeleted as SiteHardDeleted,
      eventsV3TicketDefinition_universal_d_NamespaceChanged as NamespaceChanged,
      eventsV3TicketDefinition_universal_d_StudioAssigned as StudioAssigned,
      eventsV3TicketDefinition_universal_d_StudioUnassigned as StudioUnassigned,
      eventsV3TicketDefinition_universal_d_GetTicketDefinitionFromTrashBinRequest as GetTicketDefinitionFromTrashBinRequest,
      eventsV3TicketDefinition_universal_d_GetTicketDefinitionFromTrashBinResponse as GetTicketDefinitionFromTrashBinResponse,
      eventsV3TicketDefinition_universal_d_ScheduleLegacyTimeCapsuleTaskRequest as ScheduleLegacyTimeCapsuleTaskRequest,
      eventsV3TicketDefinition_universal_d_createTicketDefinition as createTicketDefinition,
      eventsV3TicketDefinition_universal_d_CreateTicketDefinitionOptions as CreateTicketDefinitionOptions,
      eventsV3TicketDefinition_universal_d_updateTicketDefinition as updateTicketDefinition,
      eventsV3TicketDefinition_universal_d_UpdateTicketDefinition as UpdateTicketDefinition,
      eventsV3TicketDefinition_universal_d_UpdateTicketDefinitionOptions as UpdateTicketDefinitionOptions,
      eventsV3TicketDefinition_universal_d_getTicketDefinition as getTicketDefinition,
      eventsV3TicketDefinition_universal_d_GetTicketDefinitionOptions as GetTicketDefinitionOptions,
      eventsV3TicketDefinition_universal_d_deleteTicketDefinition as deleteTicketDefinition,
      eventsV3TicketDefinition_universal_d_reorderTicketDefinitions as reorderTicketDefinitions,
      eventsV3TicketDefinition_universal_d_ReorderTicketDefinitionsOptions as ReorderTicketDefinitionsOptions,
      eventsV3TicketDefinition_universal_d_queryTicketDefinitions as queryTicketDefinitions,
      eventsV3TicketDefinition_universal_d_QueryTicketDefinitionsOptions as QueryTicketDefinitionsOptions,
      eventsV3TicketDefinition_universal_d_TicketDefinitionsQueryResult as TicketDefinitionsQueryResult,
      eventsV3TicketDefinition_universal_d_TicketDefinitionsQueryBuilder as TicketDefinitionsQueryBuilder,
      eventsV3TicketDefinition_universal_d_queryAvailableTicketDefinitions as queryAvailableTicketDefinitions,
      eventsV3TicketDefinition_universal_d_QueryAvailableTicketDefinitionsOptions as QueryAvailableTicketDefinitionsOptions,
      eventsV3TicketDefinition_universal_d_countTicketDefinitions as countTicketDefinitions,
      eventsV3TicketDefinition_universal_d_CountTicketDefinitionsOptions as CountTicketDefinitionsOptions,
      eventsV3TicketDefinition_universal_d_countAvailableTicketDefinitions as countAvailableTicketDefinitions,
      eventsV3TicketDefinition_universal_d_CountAvailableTicketDefinitionsOptions as CountAvailableTicketDefinitionsOptions,
      eventsV3TicketDefinition_universal_d_bulkDeleteTicketDefinitionsByFilter as bulkDeleteTicketDefinitionsByFilter,
      eventsV3TicketDefinition_universal_d_changeCurrency as changeCurrency,
      eventsV3TicketDefinition_universal_d_ChangeCurrencyOptions as ChangeCurrencyOptions,
    };
  }
  
  export { eventsV1Category_universal_d as categories, eventsV1Form_universal_d as forms, eventsGuestsV1Guest_universal_d as guests, eventsNotificationsV2NotificationConfig_universal_d as notifications, eventsV1Order_universal_d as orders, eventsV2Policy_universal_d as policies, eventsV1RichContent_universal_d as ricos, eventsV1Rsvp_universal_d as rsvp, eventsV2Rsvp_universal_d as rsvpV2, eventsScheduleV1ScheduleItemSchedule_universal_d as schedule, eventsScheduleV1ScheduleItemScheduleBookmarks_universal_d as scheduleBookmarks, eventsStaffmembersV1StaffMember_universal_d as staffMembers, eventsV1TicketDefinition_universal_d as ticketDefinitions, eventsV3TicketDefinition_universal_d as ticketDefinitionsV2, eventsV1Ticket_universal_d as tickets, eventsV3Event_universal_d as wixEventsV2 };
}
