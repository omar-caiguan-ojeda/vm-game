declare module "wix-bookings.v2" {
  const __debug: {
      verboseLogging: {
          on: () => boolean;
          off: () => boolean;
      };
  };
  /**
   * The `TimeSlot` object represents the availability information
   * for an `Appointment` service's specific slot, including:
   *
   * 1. Whether the slot is bookable for the given service?
   *
   * 2. In what location the service is available for this slot?
   *
   * 3. Which available resources can provide the service for this slot?
   *
   * 4. Does booking the slot for the service violates any of the service booking policies?
   *
   * 5. What is the total capacity and remaining capacity of the service at the time of the calculation of the `TimeSlot`?
   *
   * > __Note:__
   * > When the `TimeSlot` has a non empty `NestedTimeSlots`, it represents the availability information
   * > for a given list of `Appointment` services within a specific time slot.
   */
  interface TimeSlot$4 {
      /**
       * Service ID.
       *
       * > Not returned from `MultiServiceAvailabilityTimeSlots` API calls.
       * > Instead, each nested time slot has its own serviceId.
       */
      serviceId?: string | null;
      /**
       * Local start date of the time slot in ISO-8601 format.
       * For example, "2024-01-30T13:30:00".
       */
      localStartDate?: string | null;
      /**
       * Local end date of the time slot in ISO-8601 format.
       * For example, "2024-01-30T14:30:00".
       */
      localEndDate?: string | null;
      /**
       * Whether the slot is bookable according to the service's booking policies.
       *
       * If booking this time slot does not violates any of the service's booking policies,
       * the returned value is `true`. Otherwise, returns `false`.
       */
      bookable?: boolean | null;
      /** The geographic location of the slot. */
      location?: Location$b;
      /**
       * Returned only for event.
       * @internal
       */
      eventInfo?: EventInfo$4;
      /** Total number of spots for the slot. */
      totalCapacity?: number | null;
      /**
       * Remaining number of spots for the slot.
       * For example, for an appointment service with total capacity of 1 spot and one booked spot, the remaining capacity will be 0.
       */
      remainingCapacity?: number | null;
      /**
       * Indicators for booking policy violations for the slot.
       *
       * Each nested field is checked on its own. i.e. if `tooEarlyToBook` is defined and `bookOnlineDisabled` is not defined
       * we will return also slots for which `tooEarlyToBook` is same as on the request, regardless of `bookOnlineDisabled`.
       */
      bookingPolicyViolations?: BookingPolicyViolations$5;
      /**
       * List of `AvailableResources` for the time slot.
       * Each `AvailableResources` contains information about available resources of the same type.
       *
       * > Not returned from `MultiServiceAvailabilityTimeSlots` API calls.
       * > Instead, each nested time slot has its own available resources.
       */
      availableResources?: AvailableResources$5[];
      /**
       * > Nested time slots.
       * > Returned only from `MultiServiceAvailabilityTimeSlots` API calls.
       */
      nestedTimeSlots?: NestedTimeSlot$4[];
  }
  interface Location$b {
      /** Business Location ID. Present only if the location is a business location. */
      _id?: string | null;
      /** The location name. */
      name?: string | null;
      /** A string representation for the full address of the location. */
      formattedAddress?: string | null;
      /**
       * The type of location:
       * - `CUSTOM`: The location is specific to this service, and is not derived from the business location.
       * - `BUSINESS`: A business location, either the default business address, or locations defined for the business by the Business Info.
       * - `CUSTOMER`: The location is determined by the customer and is not set up beforehand.
       */
      locationType?: LocationType$b;
  }
  enum LocationType$b {
      UNKNOWN_LOCATION_TYPE = "UNKNOWN_LOCATION_TYPE",
      /** A business location, either the default business address, or locations defined for the business by the Business Info. */
      BUSINESS = "BUSINESS",
      /** The location is unique to this service and isn't defined as one of the business locations. */
      CUSTOM = "CUSTOM",
      /** The location can be determined by the customer and is not set up beforehand. */
      CUSTOMER = "CUSTOMER"
  }
  /** relevant for event based slots, and not for availability based slots */
  interface EventInfo$4 {
      /**
       * TODO: format - might not be a guid?
       * @internal
       */
      eventId?: string | null;
      /** @internal */
      waitingList?: WaitingList$5;
  }
  interface WaitingList$5 {
      /** Total number of spots in this wait list. */
      totalCapacity?: number | null;
      /**
       * Number of remaining spots for this wait list.
       * For example, a Yoga event with 10 waitList spots and 3 registered
       * on the waitList has 10 `total_capacity` and 7 `remaining_capacity`.
       */
      remainingCapacity?: number | null;
  }
  interface BookingPolicyViolations$5 {
      /** Bookings policy violation. Too early to book this slot. */
      tooEarlyToBook?: boolean | null;
      /** Bookings policy violation. Too late to book this slot. */
      tooLateToBook?: boolean | null;
      /** Bookings policy violation. Online booking is disabled for the `TimeSlot` service. */
      bookOnlineDisabled?: boolean | null;
  }
  interface AvailableResources$5 {
      /** Resource type ID. */
      resourceTypeId?: string | null;
      /**
       * Available resources for the time slot.
       *
       * + When returned from `ListAvailabilityTimeSlots`, empty by default.
       * + + If you provided `includeResourceTypeIds` or  `resourceIds` in request,
       * contains __up__ to 10 available resources out of those provided.
       *
       * + When returned from `GetAvailabilityTimeSlots`, contains all available resources by default.
       * + + If you provided `includeResourceTypeIds` or  `resourceIds` in request,
       * contains all of the available resources out of those provided.
       *
       *
       * > + When returned from `ListMultiServiceAvailabilityTimeSlots`, empty by default.
       * > + + If you provided `includeResourceTypeIds` or  `resourceIds` in request,
       * > contains __up__ to 10 available resources out of those provided.
       *
       * > + When returned from `GetMultiServiceAvailabilityTimeSlots`, contains all available resources by default.
       * > + + If you provided `includeResourceTypeIds` or  `resourceIds` in request,
       * > contains all of the available resources out of those provided.
       */
      resources?: Resource$8[];
      /**
       * The required number of resources of this type in order to book the service.
       * For example, a slot for a service that provides a double massage
       * requires two resources of type `Staff Member` and one resource of type `Room`.
       * @internal
       */
      numberOfResourcesRequired?: number | null;
      /**
       * Whether there are more available resources for the slot that are not listed in `resources` due to size limitations.
       * @readonly
       */
      hasMoreAvailableResources?: boolean | null;
  }
  interface Resource$8 {
      /** Resource ID. */
      _id?: string;
      /** Resource name. */
      name?: string | null;
  }
  interface NestedTimeSlot$4 {
      /** Service ID of the nested time slot. */
      serviceId?: string;
      /**
       * Local start date of the nested time slot in ISO-8601 format.
       * For example, "2024-01-30T13:30:00".
       */
      localStartDate?: string;
      /**
       * Local end date of the nested time slot in ISO-8601 format.
       * For example, "2024-01-30T14:30:00".
       */
      localEndDate?: string;
      /**
       * List of `AvailableResources` for the nested time slot.
       * Each `AvailableResources` contains information about available resources of the same type.
       */
      availableResources?: AvailableResources$5[];
  }
  interface CalculateEventBasedAvailabilityRequest$3 {
      serviceIds: string[];
      from: string;
      to: string;
      timeZone: string;
      /**
       * TODO good definition of what bookable means https://github.com/wix-private/scheduler/pull/18267/files?file-filters%5B%5D=.proto&show-viewed-files=true#r1199809006
       * TODO: Locks are not taken into account. // Class is not supported yet. (relevant only for classes with waiting list)
       * Aliza's suggestion to consider locks in bookable
       */
      bookable?: boolean | null;
      /** support filtering by location type, or by locationId. Other fields like `name` are ignored */
      location?: Location$b[];
      resourceIds?: string[];
      /** if not empty, return slots with openSpots >= X */
      openSpots?: number | null;
      /**
       * each nested field is checked on its own. i.e. if `too_early_to_book` is defined and `too_late_to_book` is not defined
       * we will return slots for which `too_early_to_book` is same as on the request, regardless of `too_late_to_book`.
       */
      bookingPolicyViolations?: BookingPolicyViolations$5;
      /**
       * Maximum number of slots to load for each date. For example, if `slots_per_day` is set to `3`,
       * at most 3 available slots are returned for each day in the date range specified in the query's
       * `filter`.
       *
       * When a day has both bookable and non-bookable slots, bookable slots are returned first.
       * Non-bookable slots are returned according to the specified filters, after all
       * bookable slots are already included.
       */
      slotsPerDay?: number | null;
      cursorPaging?: CursorPaging$e;
  }
  interface CursorPaging$e {
      /** Number of items to load. */
      limit?: number | null;
      /**
       * Pointer to the next or previous page in the list of results.
       *
       * You can get the relevant cursor token
       * from the `pagingMetadata` object in the previous call's response.
       * Not relevant for the first request.
       */
      cursor?: string | null;
  }
  interface CalculateEventBasedAvailabilityResponse$3 {
      slots?: TimeSlot$4[];
      cursorPagingMetadata?: CursorPagingMetadata$c;
  }
  interface CursorPagingMetadata$c {
      /** Number of items returned in the response. */
      count?: number | null;
      /** Offset that was requested. */
      cursors?: Cursors$f;
      /**
       * Indicates if there are more results after the current page.
       * If `true`, another page of results can be retrieved.
       * If `false`, this is the last page.
       */
      hasNext?: boolean | null;
  }
  interface Cursors$f {
      /** Cursor pointing to next page in the list of results. */
      next?: string | null;
      /** Cursor pointing to previous page in the list of results. */
      prev?: string | null;
  }
  interface ListEventTimeSlotsRequest$3 {
      /** The services for which the time slots are being returned. */
      serviceIds: string[] | null;
      /**
       * Local start date for which event time slots are returned, in ISO-8601 format.
       * E.g, "2024-01-30T13:30:00".
       * Required, unless `cursorPaging` is provided.
       */
      fromLocalDate: string | null;
      /**
       * Local end date for which event time slots are returned, in ISO-8601 format.
       * E.g, "2024-01-30T13:30:00".
       * Required, unless `cursorPaging` is provided.
       */
      toLocalDate: string | null;
      /**
       * The time zone, in IANA time zone format.
       * Default is the Wix Business time zone.
       */
      timeZone: string | null;
      /** TODO good definition of what bookable means https://github.com/wix-private/scheduler/pull/18267/files?file-filters%5B%5D=.proto&show-viewed-files=true#r1199809006 */
      bookable?: boolean | null;
      /** support filtering by location type, or by locationId. Other fields like `name` are ignored */
      location?: Location$b[];
      /** TODO: maxsize && do we need include_resource_type_id here? also is the behavior is the same as availabilityTimeSlots, we won't return resources by default? */
      resourceIds?: string[] | null;
      /** if not empty, return slots with remainingCapacity >= X */
      remainingCapacity?: number | null;
      /**
       * each nested field is checked on its own. i.e. if `too_early_to_book` is defined and `too_late_to_book` is not defined
       * we will return slots for which `too_early_to_book` is same as on the request, regardless of `too_late_to_book`.
       */
      bookingPolicyViolations?: BookingPolicyViolations$5;
      /**
       * Maximum number of slots to load for each date. For example, if `slots_per_day` is set to `3`,
       * at most 3 available slots are returned for each day in the date range specified in the query's
       * `filter`.
       *
       * When a day has both bookable and non-bookable slots, bookable slots are returned first.
       * Non-bookable slots are returned according to the specified filters, after all
       * bookable slots are already included.
       */
      timeSlotsPerDay?: number | null;
      cursorPaging?: CursorPaging$e;
  }
  interface ListEventTimeSlotsResponse$3 {
      /** TODO: maxsize */
      timeSlots?: TimeSlot$4[];
      /** The time zone, in IANA time zone format. */
      timeZone?: string | null;
      cursorPagingMetadata?: CursorPagingMetadata$c;
  }
  interface ListMultiServiceAvailabilityTimeSlotsRequest$3 {
      /**
       * Services for which the multiService time slots are being returned for.
       * Each service contains its own resources filters within.
       *
       * MinSize: `2`.
       * MaxSize: `8`.
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      services?: Service$5[];
      /**
       * Lower boundary for `localStartDate` to include in response, in ISO-8601 format.
       * For example, "2024-01-30T13:30:00".
       *
       * Each returned `TimeSlot` in response has a `localStartDate`
       * within the provided `fromLocalDate` and `toLocalDate` exclusive.
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      fromLocalDate?: string | null;
      /**
       * Upper boundary for `localStartDate` to include in response, in ISO-8601 format.
       * For example, "2024-01-30T14:30:00".
       *
       * Each returned `TimeSlot` in response has a `localStartDate`
       * within the provided `fromLocalDate` and `toLocalDate` exclusive.
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      toLocalDate?: string | null;
      /**
       * Time zone, in IANA time zone format.
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      timeZone?: string | null;
      /**
       * Location for which the multiService TimeSlots are being returned for.
       *
       * You can specify location or location type for which the TimeSlots will be returned for.
       * If locationType is `BUSINESS`, you __must__ provide a locationId.
       *
       * <blockquote class="warning">
       * <p><strong>warning:</strong><br/>
       * Supports filtering by location type, or by location ID. </br>
       * Other fields like <code class="grey-background">name</code> are ignored.</p>
       * </blockquote>
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      location?: Location$b;
      /**
       * Whether the `TimeSlot` is bookable according to all of the services booking policies.
       *
       * If booking any of the `TimeSlot`.`NestedTimeSlot`s violates any of its services bookings policies,
       * returns as `false`. Otherwise, returns as `true`.
       *
       * > __Note:__
       * > A `TimeSlot` with a `NestedTimeSlot` that doesn't meet its service's bookings policies will be returned with `bookable` = false,
       * > while a `TimeSlot` with no available resources will not be returned at all.
       */
      bookable?: boolean | null;
      /**
       * Indicators for service's booking policy violations for booking the `TimeSlot`.
       *
       * A bookable time slot must not violate any policy,
       * therefor, this filter is only relevant when `bookable` filter is false.
       *
       * Each nested field is checked on all `NestedTimeSlot`s. For example, if only one of the `NestedTimeSlot`'s
       * has a service with `tooEarlyToBook` same as in the request, we return the `TimeSlot` regardless of whether
       * the other `NestedTimeSlots` has the same `tooEarlyToBook` as in request.
       *
       * Each nested field is checked on its own. For example, if `tooEarlyToBook` is defined and `bookOnlineDisabled` is not defined
       * we return slots for which `tooEarlyToBook` is same as on the request, regardless of `bookOnlineDisabled`.
       */
      bookingPolicyViolations?: BookingPolicyViolations$5;
      /**
       * Maximum number of slots to load for each day. For example, if `timeSlotsPerDay` is set to `3`,
       * we return at most 3 available TimeSlots for each day within the date range specified in request.
       *
       * By default,
       * if `bookable` filter was not specified,
       * and a day has both `bookable` and `un-bookable` slots, `bookable` slots are returned first.
       *
       * If the number of `bookable` slots is less than the requested `timeSlotsPerDay`,
       * `un-bookable` slots will be returned according to the specified filters.
       */
      timeSlotsPerDay?: number | null;
      /**
       * CursorPaging.
       *
       * Enables you to fetch TimeSlots in smaller, more manageable chunks
       * by setting a limit on the number of results returned in response.
       * This is useful in order to enhance efficiency of data retrieval and reduce load on both the client and server.
       *
       * If there are more results than the specified limit, the response will contain a `cursorPagingMetaData`
       * with a cursor pointing to next page of results. In order to fetch the next page of results, you should pass the
       * returned cursor to the next call as `cursorPaging`.`cursor`.
       *
       * For the first call, you should only specify the `limit` for the results page.
       * For each following call, you should only pass the previous returned cursor as `cursorPaging`.`cursor`
       * the `cursorPaging`.`limit`. You may pass a different `limit`.
       * No need to specify any additional parameters.
       *
       * <blockquote class="important">
       * <p><strong>Important:</strong><br/>
       * If you only provide a <code class="grey-background">cursorPaging</code>. <code class="grey-background">cursor</code>,
       * the response will contain the default size of results which is `1000`.
       * </p>
       * </blockquote>
       */
      cursorPaging?: CommonCursorPaging$3;
  }
  interface Service$5 {
      /** Service ID. */
      serviceId?: string;
      /** Resources to include in response. */
      resourceIds?: string[];
      /**
       * The resource type ID's to include in returned time slots.
       * This is in addition to the specifically requested resources.
       *
       * <blockquote class="important">
       * Currently supported only for Staff Member resource type.
       * Staff Member type ID: 1cd44cf8-756f-41c3-bd90-3e2ffcaf1155
       * </blockquote>
       */
      includeResourceTypeIds?: string[];
  }
  interface CommonCursorPaging$3 {
      /**
       * Number of results to load.
       *
       * Default: `1000`.
       * Max: `1000`.
       */
      limit?: number | null;
      /**
       * Pointer to the next or previous page in the list of results.
       *
       * You can get the relevant cursor token
       * from the `pagingMetadata` object in the previous call's response.
       * Not relevant for the first request.
       */
      cursor?: string | null;
  }
  interface ListMultiServiceAvailabilityTimeSlotsResponse$3 {
      /** Time slots. */
      timeSlots?: TimeSlot$4[];
      /**
       * Time zone, in IANA time zone format.
       * Shared for all TimeSlots in response.
       */
      timeZone?: string | null;
      /**
       * CursorPagingMetaData.
       * Contains information about the next page of results.
       *
       * By default,
       * if there are more than 1000 results,
       * the response will contain a `cursorPagingMetaData` with a cursor to the next page of results.
       *
       * <blockquote class="important">
       * <p><strong>Important:</strong><br/>
       * <code class="grey-background">count</code> is not supported.</p>
       * </blockquote>
       */
      cursorPagingMetadata?: CommonCursorPagingMetadata$3;
  }
  interface CommonCursorPagingMetadata$3 {
      /** Offset that was requested. */
      cursors?: CommonCursors$3;
      /**
       * Indicates if there are more results after the current page.
       * If `true`, another page of results can be retrieved.
       * If `false`, this is the last page.
       */
      hasNext?: boolean | null;
  }
  interface CommonCursors$3 {
      /** Cursor pointing to next page in the list of results. */
      next?: string | null;
      /** Cursor pointing to previous page in the list of results. */
      prev?: string | null;
  }
  interface GetMultiServiceAvailabilityTimeSlotRequest$3 {
      /**
       * Services for which the multiService TimeSlots are being returned for.
       * Each service contains its own resources filters within.
       *
       * MinSize: 2.
       * MaxSize: 8.
       */
      services: Service$5[];
      /**
       * Local start date of the time slot, in ISO-8601 format.
       * For example, "2024-01-30T13:30:00".
       */
      localStartDate: string;
      /**
       * Local end date of the time slot, in ISO-8601 format.
       * For example, "2024-01-30T14:30:00".
       */
      localEndDate: string;
      /** Time zone, in IANA time zone format. */
      timeZone: string | null;
      /**
       * The location of the time slot.
       *
       * You must provide a specific `locationType`.
       * If locationType is `BUSINESS`, you __must__ also provide a `locationId`.
       *
       * <blockquote class="warning">
       * <p>Supports filtering by location type, or by location ID.
       * Other fields like <code class="grey-background">name</code> are ignored.</p>
       * </blockquote>
       */
      location: Location$b;
  }
  interface GetMultiServiceAvailabilityTimeSlotResponse$3 {
      /** Time slot. */
      timeSlot?: TimeSlot$4;
      /** The time zone, in IANA time zone format. */
      timeZone?: string | null;
  }
  interface ListAvailabilityTimeSlotsRequest$3 {
      /**
       * Service ID for which the time slots are being returned for.
       * Currently supported only for services of type `APPOINTMENT`.
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      serviceId?: string | null;
      /**
       * Lower boundary for `localStartDate` to include in response, in ISO-8601 format.
       * For example, "2024-01-30T13:30:00".
       *
       * Each returned `TimeSlot` in response has a `localStartDate`
       * within the provided `fromLocalDate` and `toLocalDate` exclusive.
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      fromLocalDate?: string | null;
      /**
       * Upper boundary for `localStartDate` to include in response, in ISO-8601 format.
       * For example, "2024-01-30T14:30:00".
       *
       * Each returned `TimeSlot` in response has a `localStartDate`
       * within the provided `fromLocalDate` and `toLocalDate` exclusive.
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      toLocalDate?: string | null;
      /**
       * Time zone, in IANA time zone format.
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      timeZone?: string | null;
      /**
       * Locations to include in response.
       *
       * By default,
       * if no locations are provided,
       * the response contains TimeSlots for all locations where the service is available.
       *
       * You can specify locations or location types for which the time slots will be returned for.
       * If locationType is `BUSINESS`, you __must__ provide a locationId.
       *
       * <blockquote class="warning">
       * <p><strong>warning:</strong><br/>
       * Supports filtering by location type, or by location ID. </br>
       * Other fields like <code class="grey-background">name</code> are ignored.</p>
       * </blockquote>
       */
      locations?: Location$b[];
      /**
       * Resources to include in response.
       *
       * If specified,
       * the returned TimeSlots will contain __up__ to 10 available resources out of the provided list.
       * Otherwise, the returned TimeSlots returns with an empty `AvailableResources`.
       */
      resourceIds?: string[];
      /**
       * Resource type ID's to include in response, this is in addition to the requested `resourceIds`.
       *
       * If specified in request, the returned TimeSlots will contain __up__ to 10 `AvailableResources` with `ResourceTypeId`
       * out of those specified, each contains __up__ to 10 available resources of this type.
       */
      includeResourceTypeIds?: string[];
      /**
       * Whether the `TimeSlot` is bookable according to the service's booking policies.
       *
       * If booking this `TimeSlot` does not violates any of the service's booking policies,
       * returns as `true`. Otherwise, returns as `false`.
       *
       * > __Note:__
       * > A time slot that doesn't meet the service's bookings policies will be returned with `bookable` = false,
       * > while a time slot with no available resources will not be returned at all.
       */
      bookable?: boolean | null;
      /**
       * Indicators for service's booking policy violations for booking the `TimeSlot`.
       *
       * A bookable time slot must not violate any policy,
       * therefor, this filter is only relevant when `bookable` filter is false.
       *
       * Each nested field is checked on its own. i.e. if `tooEarlyToBook` is defined and `bookOnlineDisabled` is not defined
       * we return slots for which `tooEarlyToBook` is same as on the request, regardless of `bookOnlineDisabled`.
       */
      bookingPolicyViolations?: BookingPolicyViolations$5;
      /**
       * Maximum number of slots to load for each day. For example, if `timeSlotsPerDay` is set to `3`,
       * we return at most 3 available TimeSlots for each day within the date range specified in request.
       *
       * By default,
       * if `bookable` filter was not specified,
       * and a day has both `bookable` and `un-bookable` slots, `bookable` slots are returned first.
       *
       * If the number of `bookable` slots is less than the requested `timeSlotsPerDay`,
       * `un-bookable` slots will be returned according to the specified filters.
       */
      timeSlotsPerDay?: number | null;
      /**
       * CursorPaging.
       *
       * Enables you to fetch results in smaller, more manageable chunks
       * by setting a limit on the number of results returned in response.
       * This is useful in order to enhance efficiency of data retrieval and reduce load on both the client and server.
       *
       * If there are more results than the specified limit, the response will contain a `cursorPagingMetaData`
       * with a cursor pointing to next page of results. In order to fetch the next page of results, you should pass the
       * returned cursor to the next call as `cursorPaging`.`cursor`.
       *
       * For the first call, you should only specify the `limit` for the results page.
       * For each following call, you should only pass `cursorPaging`.`cursor` with the returned cursor from previous call, and
       * a `cursorPaging`.`limit`.
       * No need to specify any additional parameters.
       *
       * <blockquote class="important">
       * <p><strong>Important:</strong><br/>
       * If you only provide a <code class="grey-background">cursorPaging</code>. <code class="grey-background">cursor</code>,
       * the response will contain the default size of results which is `1000`.
       * </p>
       * </blockquote>
       */
      cursorPaging?: CommonCursorPaging$3;
      /**
       * Specifies whether to return all available resources in response.
       * @internal
       */
      shouldReturnAllResources?: boolean;
  }
  interface ListAvailabilityTimeSlotsResponse$3 {
      /** Time slots. */
      timeSlots?: TimeSlot$4[];
      /**
       * Time zone, in IANA time zone format.
       * Shared for all TimeSlots in response.
       */
      timeZone?: string | null;
      /**
       * CursorPagingMetaData.
       * Contains information about the next page of results.
       *
       * By default,
       * if there are more than 1000 results,
       * the response will contain a `cursorPagingMetaData` with a cursor to the next page of results.
       *
       * <blockquote class="important">
       * <p><strong>Important:</strong><br/>
       * <code class="grey-background">count</code> is not supported.</p>
       * </blockquote>
       */
      cursorPagingMetadata?: CommonCursorPagingMetadata$3;
  }
  interface GetAvailabilityTimeSlotRequest$4 {
      /**
       * Service ID of the time slot.
       * Currently supported only for services of type `APPOINTMENT`.
       */
      serviceId: string;
      /**
       * Local start date of the time slot, in ISO-8601 format.
       * For example, "2024-01-30T13:30:00".
       */
      localStartDate: string;
      /**
       * Local end date of the time slot, in ISO-8601 format.
       * For example, "2024-01-30T14:30:00".
       */
      localEndDate: string;
      /** Time zone, in IANA time zone format. */
      timeZone: string | null;
      /**
       * The location of the time slot.
       *
       * You must provide a specific `locationType`.
       * If locationType is `BUSINESS`, you __must__ also provide a `locationId`.
       *
       * <blockquote class="warning">
       * <p>Supports filtering by location type, or by location ID.
       * Other fields like <code class="grey-background">name</code> are ignored.</p>
       * </blockquote>
       */
      location: Location$b;
      /**
       * Resources to include in response.
       *
       * If specified,
       * the returned `TimeSlot` contains only the available resources out of provided list.
       * Otherwise, the returned `TimeSlot` returned with all possible `AvailableResources`.
       */
      resourceIds?: string[];
      /**
       * Resource type IDs to include in response, this is in addition to the requested `resourceIds`.
       *
       * If specified in request, the returned `TimeSlot` contains only the `AvailableResources` with `ResourceTypeId`
       * out of those specified, each contains all the available resources of this type.
       */
      includeResourceTypeIds?: string[];
  }
  interface GetAvailabilityTimeSlotResponse$4 {
      /** Time slot. */
      timeSlot?: TimeSlot$4;
      /** Time zone, in IANA time zone format. */
      timeZone?: string | null;
  }
  /** @internal
   * @documentationMaturity preview
   * @requiredField options.from
   * @requiredField options.timeZone
   * @requiredField options.to
   * @requiredField serviceIds
   */
  function calculateEventBasedAvailability$1(serviceIds: string[], options?: CalculateEventBasedAvailabilityOptions$1): Promise<CalculateEventBasedAvailabilityResponse$3>;
  interface CalculateEventBasedAvailabilityOptions$1 {
      from: string;
      to: string;
      timeZone: string;
      /**
       * TODO good definition of what bookable means https://github.com/wix-private/scheduler/pull/18267/files?file-filters%5B%5D=.proto&show-viewed-files=true#r1199809006
       * TODO: Locks are not taken into account. // Class is not supported yet. (relevant only for classes with waiting list)
       * Aliza's suggestion to consider locks in bookable
       */
      bookable?: boolean | null;
      /** support filtering by location type, or by locationId. Other fields like `name` are ignored */
      location?: Location$b[];
      resourceIds?: string[];
      /** if not empty, return slots with openSpots >= X */
      openSpots?: number | null;
      /**
       * each nested field is checked on its own. i.e. if `too_early_to_book` is defined and `too_late_to_book` is not defined
       * we will return slots for which `too_early_to_book` is same as on the request, regardless of `too_late_to_book`.
       */
      bookingPolicyViolations?: BookingPolicyViolations$5;
      /**
       * Maximum number of slots to load for each date. For example, if `slots_per_day` is set to `3`,
       * at most 3 available slots are returned for each day in the date range specified in the query's
       * `filter`.
       *
       * When a day has both bookable and non-bookable slots, bookable slots are returned first.
       * Non-bookable slots are returned according to the specified filters, after all
       * bookable slots are already included.
       */
      slotsPerDay?: number | null;
      cursorPaging?: CursorPaging$e;
  }
  /**
   * TODO explain the sorting tie breaker
   * Return a list of available slots, for Event based services
   * can be called only for services with tag "GROUP"
   * @param serviceIds - The services for which the time slots are being returned.
   * @internal
   * @documentationMaturity preview
   * @requiredField options.fromLocalDate
   * @requiredField options.timeZone
   * @requiredField options.toLocalDate
   * @requiredField serviceIds
   */
  function listEventTimeSlots$1(serviceIds: string[] | null, options?: ListEventTimeSlotsOptions$1): Promise<ListEventTimeSlotsResponse$3>;
  interface ListEventTimeSlotsOptions$1 {
      /**
       * Local start date for which event time slots are returned, in ISO-8601 format.
       * E.g, "2024-01-30T13:30:00".
       * Required, unless `cursorPaging` is provided.
       */
      fromLocalDate: string | null;
      /**
       * Local end date for which event time slots are returned, in ISO-8601 format.
       * E.g, "2024-01-30T13:30:00".
       * Required, unless `cursorPaging` is provided.
       */
      toLocalDate: string | null;
      /**
       * The time zone, in IANA time zone format.
       * Default is the Wix Business time zone.
       */
      timeZone: string | null;
      /** TODO good definition of what bookable means https://github.com/wix-private/scheduler/pull/18267/files?file-filters%5B%5D=.proto&show-viewed-files=true#r1199809006 */
      bookable?: boolean | null;
      /** support filtering by location type, or by locationId. Other fields like `name` are ignored */
      location?: Location$b[];
      /** TODO: maxsize && do we need include_resource_type_id here? also is the behavior is the same as availabilityTimeSlots, we won't return resources by default? */
      resourceIds?: string[] | null;
      /** if not empty, return slots with remainingCapacity >= X */
      remainingCapacity?: number | null;
      /**
       * each nested field is checked on its own. i.e. if `too_early_to_book` is defined and `too_late_to_book` is not defined
       * we will return slots for which `too_early_to_book` is same as on the request, regardless of `too_late_to_book`.
       */
      bookingPolicyViolations?: BookingPolicyViolations$5;
      /**
       * Maximum number of slots to load for each date. For example, if `slots_per_day` is set to `3`,
       * at most 3 available slots are returned for each day in the date range specified in the query's
       * `filter`.
       *
       * When a day has both bookable and non-bookable slots, bookable slots are returned first.
       * Non-bookable slots are returned according to the specified filters, after all
       * bookable slots are already included.
       */
      timeSlotsPerDay?: number | null;
      cursorPaging?: CursorPaging$e;
  }
  /**
   * Retrieves a list of multiService `TimeSlot`s that match the provided filters.
   *
   * <blockquote class="important">
   * <p><strong>Important:</strong><br/>
   * Currently supported only for services of type <code class="grey-background">APPOINTMENT</code>.</p>
   * </blockquote>
   *
   * The request body __must__ include either:
   * + All of the following filters:  `service`.`serviceId`, `fromLocalDate`, `toLocalDate`, `location`, and `timeZone`. You may add additional filters as you wish.
   * + A `cursorPaging` with a valid `cursor` from previous response.
   *
   *
   * Each [TimeSlot](https://bo.wix.com/wix-docs/rest/all-apis/wix-service-availability/availability-time-slots/time-slot-object) in response
   * represents the availability of the given sequence of services in a specific order, location, and within a given range of time.
   *
   * Each `TimeSlot`.`NestedTimeSlot` represents a single service from the given list. The order of the `NestedTimeSlots` is the same as the order
   * of the given services in request.
   * The first `NestedTimeSlot` has `localStartDate` within the given `fromLocalDate` and `toLocalDate` exclusive,
   * and each following `NestedTimeSlot` has a `localStartDate` that equals to the previous `NestedTimeSlot`'s `localEndDate`.
   *
   * By default,
   * the response contains at most 1000 results.
   * If there are more than 1000 results, we return a `cursorPagingMetadata` with
   * a cursor for the next page of results, regardless of whether a `cursorPaging`
   * was provided in request.
   *
   * > __Notes:__
   * >  + All nested time slots share the same location.
   * >  + You can pass up to 8 services in request.
   *
   * ### AvailableResources in response:
   * The `TimeSlot`.`NestedTimeSlot`'s `AvailableResources` contains information about the resources that are available to provide the service
   * within the `NestedTimeSlot` range of time. Each `AvailableResources` contains information about available resources of the same type.
   *
   * <blockquote class="important">
   * <p><strong>Important:</strong><br/>
   * By default,
   * if you don't specify <code class="grey-background">service</code>.<code class="grey-background">includeResourceTypeIds</code>
   * or  <code class="grey-background">service</code>.<code class="grey-background">resourceIds</code> filters in request,
   * we return TimeSlots with <code class="grey-background">NestedTimeSlot</code>s with an empty <code class="grey-background">AvailableResources</code>.
   * <br/><strong>Note:</strong><br/> Not specifying resources filters can be handy in case you want to avoid large response in flows that only
   * interested of whether the time slots are available. [Finding the next available slot within the next 3 months](https://bo.wix.com/wix-docs/rest/all-apis/service-availability/multi-service-availability-time-slots/sample-flows?localViewerId=inbari#all-apis_service-availability_multi-service-availability-time-slots_sample-flows_find-the-first-date-within-the-next-3-months-that-all-selected-services-are-available-for)
   * is an example for such flow.
   * </p>
   * </blockquote>
   *
   *
   * If you wish to get a list of available resources for a `TimeSlot`.`NestedTimeSlot` you should either:
   * + provide `service`.`resourceIds` in request.
   * + provide `service`.`includeResourceTypeIds` in request.
   *
   * __Notes:__
   * + In both cases the returned `TimeSlot`.`NestedTimeSlot` contains  __up__ to 10 `AvailableResources` that match the provided filters. Each `AvailableResources` contains __up__ to 10 available `resources` of the same type that match the provided filters.
   * + If an `AvailableResources` has more available resources which are not listed within it, we return `AvailableResources`.`hasMoreAvailableResources` as true.
   * + If you wish to get the full available resources list for all `NestedTimeSlot` of a specific `TimeSlot`, you should call [GetMultiServiceAvailabilityTimeSlot](https://bo.wix.com/wix-docs/rest/all-apis/wix-service-availability/multi-service-availability-time-slots/get-multi-service-availability-time-slot).
   *
   *
   * ### Availability VS Bookability
   * An `available` time slot is not necessarily `bookable`.
   * The `bookable` field of a `TimeSlot` indicates whether the customer can book all of the of the services within the given time slot,
   * at a specific period of time.
   * Read more about [Availability VS Bookability](https://bo.wix.com/wix-docs/rest/all-apis/wix-service-availability/multi-service-availability-time-slots/introduction#all-apis_wix-service-availability_multi-service-availability-time-slots_introduction_availability-vs-bookability).
   *
   * By default,
   * + The response does not contains `unavailable` TimeSlots.For example, if there are no available resources to provide one of the services from `2024-01-30T14:30:00` to `2024-01-30T15:30:00`, we don't return TimeSlots with `NestedTimeSlot`.`localStartDate` within this range for this service.
   * + The response contains both `bookable` and `un-bookable` TimeSlots.For example, if one of the services has a booking policy which enforces booking the service up to 10 minutes before the session starts, we return TimeSlots with the violating `NestedTimeSlot`.`localStartDate`, with `bookable` as `false`. If you want to list only __bookable__ TimeSlots you should pass `bookable` as `true`.
   * + If booking one of the `NestedTimeSlot`s violates one of the corresponding service's booking policies, the `TimeSlot` returns with `bookable` as false. There is no indication which service's policy was violated.
   *
   * <blockquote class="important">
   * <p><strong>Important:</strong>
   * Because of DST, there are edge cases where certain times either do not exist or exist twice for a local time zone.
   * Read more about <a href="https://bo.wix.com/wix-docs/rest/all-apis/wix-service-availability/multi-service-availability-time-slots/introduction#all-apis_wix-service-availability_multi-service-availability-time-slots_introduction_daylight-saving-time-dst-handling">DST Handling</a></p>
   * </blockquote>
   *
   * ### ListAvailabilityTimeSlots runs with the following defaults:
   * + `localStartDate` is sorted in `ASC` order.
   * + `cursorPaging`.`limit` is `1000`.
   * @public
   * @documentationMaturity preview
   */
  function listMultiServiceAvailabilityTimeSlots$1(options?: ListMultiServiceAvailabilityTimeSlotsOptions$1): Promise<ListMultiServiceAvailabilityTimeSlotsResponse$3>;
  interface ListMultiServiceAvailabilityTimeSlotsOptions$1 {
      /**
       * Services for which the multiService time slots are being returned for.
       * Each service contains its own resources filters within.
       *
       * MinSize: `2`.
       * MaxSize: `8`.
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      services?: Service$5[];
      /**
       * Lower boundary for `localStartDate` to include in response, in ISO-8601 format.
       * For example, "2024-01-30T13:30:00".
       *
       * Each returned `TimeSlot` in response has a `localStartDate`
       * within the provided `fromLocalDate` and `toLocalDate` exclusive.
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      fromLocalDate?: string | null;
      /**
       * Upper boundary for `localStartDate` to include in response, in ISO-8601 format.
       * For example, "2024-01-30T14:30:00".
       *
       * Each returned `TimeSlot` in response has a `localStartDate`
       * within the provided `fromLocalDate` and `toLocalDate` exclusive.
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      toLocalDate?: string | null;
      /**
       * Time zone, in IANA time zone format.
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      timeZone?: string | null;
      /**
       * Location for which the multiService TimeSlots are being returned for.
       *
       * You can specify location or location type for which the TimeSlots will be returned for.
       * If locationType is `BUSINESS`, you __must__ provide a locationId.
       *
       * <blockquote class="warning">
       * <p><strong>warning:</strong><br/>
       * Supports filtering by location type, or by location ID. </br>
       * Other fields like <code class="grey-background">name</code> are ignored.</p>
       * </blockquote>
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      location?: Location$b;
      /**
       * Whether the `TimeSlot` is bookable according to all of the services booking policies.
       *
       * If booking any of the `TimeSlot`.`NestedTimeSlot`s violates any of its services bookings policies,
       * returns as `false`. Otherwise, returns as `true`.
       *
       * > __Note:__
       * > A `TimeSlot` with a `NestedTimeSlot` that doesn't meet its service's bookings policies will be returned with `bookable` = false,
       * > while a `TimeSlot` with no available resources will not be returned at all.
       */
      bookable?: boolean | null;
      /**
       * Indicators for service's booking policy violations for booking the `TimeSlot`.
       *
       * A bookable time slot must not violate any policy,
       * therefor, this filter is only relevant when `bookable` filter is false.
       *
       * Each nested field is checked on all `NestedTimeSlot`s. For example, if only one of the `NestedTimeSlot`'s
       * has a service with `tooEarlyToBook` same as in the request, we return the `TimeSlot` regardless of whether
       * the other `NestedTimeSlots` has the same `tooEarlyToBook` as in request.
       *
       * Each nested field is checked on its own. For example, if `tooEarlyToBook` is defined and `bookOnlineDisabled` is not defined
       * we return slots for which `tooEarlyToBook` is same as on the request, regardless of `bookOnlineDisabled`.
       */
      bookingPolicyViolations?: BookingPolicyViolations$5;
      /**
       * Maximum number of slots to load for each day. For example, if `timeSlotsPerDay` is set to `3`,
       * we return at most 3 available TimeSlots for each day within the date range specified in request.
       *
       * By default,
       * if `bookable` filter was not specified,
       * and a day has both `bookable` and `un-bookable` slots, `bookable` slots are returned first.
       *
       * If the number of `bookable` slots is less than the requested `timeSlotsPerDay`,
       * `un-bookable` slots will be returned according to the specified filters.
       */
      timeSlotsPerDay?: number | null;
      /**
       * CursorPaging.
       *
       * Enables you to fetch TimeSlots in smaller, more manageable chunks
       * by setting a limit on the number of results returned in response.
       * This is useful in order to enhance efficiency of data retrieval and reduce load on both the client and server.
       *
       * If there are more results than the specified limit, the response will contain a `cursorPagingMetaData`
       * with a cursor pointing to next page of results. In order to fetch the next page of results, you should pass the
       * returned cursor to the next call as `cursorPaging`.`cursor`.
       *
       * For the first call, you should only specify the `limit` for the results page.
       * For each following call, you should only pass the previous returned cursor as `cursorPaging`.`cursor`
       * the `cursorPaging`.`limit`. You may pass a different `limit`.
       * No need to specify any additional parameters.
       *
       * <blockquote class="important">
       * <p><strong>Important:</strong><br/>
       * If you only provide a <code class="grey-background">cursorPaging</code>. <code class="grey-background">cursor</code>,
       * the response will contain the default size of results which is `1000`.
       * </p>
       * </blockquote>
       */
      cursorPaging?: CommonCursorPaging$3;
  }
  /**
   * Retrieves an available multiService `TimeSlot` that match the provided filters.
   *
   * Throws `SlotNotFound` if there is no such available time slot.
   *
   * <blockquote class="important">
   * <p><strong>Important:</strong><br/>
   * Currently supported only for services of type <code class="grey-background">APPOINTMENT</code>.</p>
   * </blockquote>
   *
   * By default,
   * if you don't provide a `service`.`includeResourceTypeIds` or `service`.`resourceIds` in request,
   * we return for each `TimeSlot`.`NestedTimeSlot` all `AvailableResources` with all `AvailableResources`.`resources` which are available to provide
   * the corresponding service within the time slot.
   *
   * If you specify `service`.`includeResourceTypeIds` or `service`.`resourceIds` in request,
   * the returned `TimeSlot`.`NestedTimeSlot` for this service will contain only `AvailableResources` with at least one available resource
   * which match the given resources filters,
   * each contains all available resources out of those requested.
   *
   * + Notes:
   * + All nested time slots share the same location.
   * + You can pass up to 8 services.
   *
   * <blockquote class="tip">
   * <p><strong>Tip:</strong><br/>
   * Use this API in order to get the availability of a specific <code class="grey-background">TimeSlot</code> out of those returned from  <code class="grey-background">ListMultiServiceAvailabilityTimeSlots</code> API.</p>
   * </blockquote>
   * @param services - Services for which the multiService TimeSlots are being returned for.
   * Each service contains its own resources filters within.
   *
   * MinSize: 2.
   * MaxSize: 8.
   * @public
   * @documentationMaturity preview
   * @requiredField options
   * @requiredField options.localEndDate
   * @requiredField options.localStartDate
   * @requiredField options.location
   * @requiredField options.location.locationType
   * @requiredField options.timeZone
   * @requiredField services
   * @requiredField services.serviceId
   */
  function getMultiServiceAvailabilityTimeSlot$1(services: Service$5[], options: GetMultiServiceAvailabilityTimeSlotOptions): Promise<GetMultiServiceAvailabilityTimeSlotResponse$3>;
  interface GetMultiServiceAvailabilityTimeSlotOptions {
      /**
       * Local start date of the time slot, in ISO-8601 format.
       * For example, "2024-01-30T13:30:00".
       */
      localStartDate: string;
      /**
       * Local end date of the time slot, in ISO-8601 format.
       * For example, "2024-01-30T14:30:00".
       */
      localEndDate: string;
      /** Time zone, in IANA time zone format. */
      timeZone: string | null;
      /**
       * The location of the time slot.
       *
       * You must provide a specific `locationType`.
       * If locationType is `BUSINESS`, you __must__ also provide a `locationId`.
       *
       * <blockquote class="warning">
       * <p>Supports filtering by location type, or by location ID.
       * Other fields like <code class="grey-background">name</code> are ignored.</p>
       * </blockquote>
       */
      location: Location$b;
  }
  /**
   * Retrieves a list of `TimeSlot`s that match the provided filters.
   *
   * <blockquote class="important">
   * <p><strong>Important:</strong>
   * Currently supported only for services of type <code class="grey-background">APPOINTMENT</code>.</p>
   * </blockquote>
   *
   * The request body __must__ include either:
   * + All of the following filters:  `serviceId`, `fromLocalDate`, `toLocalDate`, and `timeZone`.
   * You may add additional filters as you wish.
   * + A `cursorPaging` with a valid `cursor` from previous response.
   *
   *
   * Each [TimeSlot](https://bo.wix.com/wix-docs/rest/all-apis/wix-service-availability/availability-time-slots/time-slot-object) in response
   * represents the availability of the service in a specific location,
   * and has a `localStartDate` within the range of the provided `fromLocalDate` and `toLocalDate` exclusive.
   * The `localEndDate` of a `TimeSlot` is calculated as the sum of the `TimeSlot`'s `localStartDate` and the duration of the service.
   *
   * By default,
   * the response contains at most 1000 results.
   * If there are more than 1000 results, we return a `cursorPagingMetadata` with
   * a cursor for the next page of results, regardless of whether a `cursorPaging`
   * was provided in request.
   *
   * ### AvailableResources in response
   * The `TimeSlot`'s `AvailableResources` contains information about the resources that are available to provide the service
   * within the time slot. Each `AvailableResources` contains information about available resources of the same type.
   *
   * <blockquote class="important">
   * <p><strong>Important:</strong><br/>
   * By default,
   * if you don't specify <code class="grey-background">includeResourceTypeIds</code>
   * or <code class="grey-background">resourceIds</code> filters in request,
   * we return TimeSlots with an empty <code class="grey-background">AvailableResources</code>.
   * <br/><strong>Note:</strong><br/> Not specifying resources filters can be handy in case you want to avoid large response in flows that only
   * interested of whether the time slots are available. [Finding the next available slot within the next 3 months](https://bo.wix.com/wix-docs/rest/all-apis/service-availability/availability-time-slots/sample-flows?localViewerId=inbari#all-apis_service-availability_availability-time-slots_sample-flows_find-the-first-date-within-the-next-3-months-that-the-selected-service-is-available-for)
   * is an example for such flow.
   * </p>
   * </blockquote>
   *
   * If you wish to get a list of available resources for each `TimeSlot` you should either:
   * + provide `resourceIds` in request.
   * + provide `includeResourceTypeIds` in request.
   *
   * __Notes:__
   * + In both cases the returned TimeSlots contains  __up__ to 10 `AvailableResources` that match the provided filters.
   * Each `AvailableResources` contains __up__ to 10 available `resources` of the same type that match the provided filters.
   * + If an `AvailableResources` has more available resources which are not listed within it,
   * we return `AvailableResources`.`hasMoreAvailableResources` as true.
   * > __Note:__
   * > If you wish to get the full available resources list for a specific `TimeSlot`,
   * > you should call [GetAvailabilityTimeSlot](https://bo.wix.com/wix-docs/rest/all-apis/wix-service-availability/service-availability-time-slots/get-availability-time-slot).
   *
   *
   * ### Availability VS Bookability
   * An `available` time slot is not necessarily `bookable`.
   * The `bookable` field of a `TimeSlot` indicates whether a customer can book the service within the given time slot,
   * at a specific period of time.
   * Read more about [Availability VS Bookability](https://bo.wix.com/wix-docs/rest/all-apis/wix-service-availability/service-availability-time-slots/introduction#all-apis_wix-service-availability_service-availability-time-slots_introduction_availability-vs-bookability).
   *
   * By default,
   * + The response does not contains `unavailable` TimeSlots.
   * For example,
   * if there are no available resources to provide the service from `2024-01-30T14:30:00` to `2024-01-30T15:30:00`,
   * we don't return TimeSlots with `localStartDate` within this range.
   * + The response contains both `bookable` and `un-bookable` TimeSlots.
   * For example,
   * if the service has a booking policy which enforces booking the service up to 10 minutes before the session starts,
   * we return TimeSlots with the violating `localStartDate` with `bookable` as false.
   * If you wish to list only available __bookable__ TimeSlots you should pass `bookable` filter as true.
   *
   * <blockquote class="important">
   * <p><strong>Important:</strong>
   * Because of DST, there are edge cases where certain times either do not exist or exist twice for a local time zone.
   * Read more about <a href="https://bo.wix.com/wix-docs/rest/all-apis/service-availability/availability-time-slots/introduction?localViewerId=inbari#all-apis_service-availability_availability-time-slots_introduction_daylight-saving-time-dst-handling">DST Handling</a></p>
   * </blockquote>
   *
   *
   * ### ListAvailabilityTimeSlots runs with the following defaults
   * + `localStartDate` is sorted in `ASC` order
   * + `cursorPaging`.`limit` is `1000`
   * @public
   * @documentationMaturity preview
   */
  function listAvailabilityTimeSlots$1(options?: ListAvailabilityTimeSlotsOptions$1): Promise<ListAvailabilityTimeSlotsResponse$3>;
  interface ListAvailabilityTimeSlotsOptions$1 {
      /**
       * Service ID for which the time slots are being returned for.
       * Currently supported only for services of type `APPOINTMENT`.
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      serviceId?: string | null;
      /**
       * Lower boundary for `localStartDate` to include in response, in ISO-8601 format.
       * For example, "2024-01-30T13:30:00".
       *
       * Each returned `TimeSlot` in response has a `localStartDate`
       * within the provided `fromLocalDate` and `toLocalDate` exclusive.
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      fromLocalDate?: string | null;
      /**
       * Upper boundary for `localStartDate` to include in response, in ISO-8601 format.
       * For example, "2024-01-30T14:30:00".
       *
       * Each returned `TimeSlot` in response has a `localStartDate`
       * within the provided `fromLocalDate` and `toLocalDate` exclusive.
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      toLocalDate?: string | null;
      /**
       * Time zone, in IANA time zone format.
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      timeZone?: string | null;
      /**
       * Locations to include in response.
       *
       * By default,
       * if no locations are provided,
       * the response contains TimeSlots for all locations where the service is available.
       *
       * You can specify locations or location types for which the time slots will be returned for.
       * If locationType is `BUSINESS`, you __must__ provide a locationId.
       *
       * <blockquote class="warning">
       * <p><strong>warning:</strong><br/>
       * Supports filtering by location type, or by location ID. </br>
       * Other fields like <code class="grey-background">name</code> are ignored.</p>
       * </blockquote>
       */
      locations?: Location$b[];
      /**
       * Resources to include in response.
       *
       * If specified,
       * the returned TimeSlots will contain __up__ to 10 available resources out of the provided list.
       * Otherwise, the returned TimeSlots returns with an empty `AvailableResources`.
       */
      resourceIds?: string[];
      /**
       * Resource type ID's to include in response, this is in addition to the requested `resourceIds`.
       *
       * If specified in request, the returned TimeSlots will contain __up__ to 10 `AvailableResources` with `ResourceTypeId`
       * out of those specified, each contains __up__ to 10 available resources of this type.
       */
      includeResourceTypeIds?: string[];
      /**
       * Whether the `TimeSlot` is bookable according to the service's booking policies.
       *
       * If booking this `TimeSlot` does not violates any of the service's booking policies,
       * returns as `true`. Otherwise, returns as `false`.
       *
       * > __Note:__
       * > A time slot that doesn't meet the service's bookings policies will be returned with `bookable` = false,
       * > while a time slot with no available resources will not be returned at all.
       */
      bookable?: boolean | null;
      /**
       * Indicators for service's booking policy violations for booking the `TimeSlot`.
       *
       * A bookable time slot must not violate any policy,
       * therefor, this filter is only relevant when `bookable` filter is false.
       *
       * Each nested field is checked on its own. i.e. if `tooEarlyToBook` is defined and `bookOnlineDisabled` is not defined
       * we return slots for which `tooEarlyToBook` is same as on the request, regardless of `bookOnlineDisabled`.
       */
      bookingPolicyViolations?: BookingPolicyViolations$5;
      /**
       * Maximum number of slots to load for each day. For example, if `timeSlotsPerDay` is set to `3`,
       * we return at most 3 available TimeSlots for each day within the date range specified in request.
       *
       * By default,
       * if `bookable` filter was not specified,
       * and a day has both `bookable` and `un-bookable` slots, `bookable` slots are returned first.
       *
       * If the number of `bookable` slots is less than the requested `timeSlotsPerDay`,
       * `un-bookable` slots will be returned according to the specified filters.
       */
      timeSlotsPerDay?: number | null;
      /**
       * CursorPaging.
       *
       * Enables you to fetch results in smaller, more manageable chunks
       * by setting a limit on the number of results returned in response.
       * This is useful in order to enhance efficiency of data retrieval and reduce load on both the client and server.
       *
       * If there are more results than the specified limit, the response will contain a `cursorPagingMetaData`
       * with a cursor pointing to next page of results. In order to fetch the next page of results, you should pass the
       * returned cursor to the next call as `cursorPaging`.`cursor`.
       *
       * For the first call, you should only specify the `limit` for the results page.
       * For each following call, you should only pass `cursorPaging`.`cursor` with the returned cursor from previous call, and
       * a `cursorPaging`.`limit`.
       * No need to specify any additional parameters.
       *
       * <blockquote class="important">
       * <p><strong>Important:</strong><br/>
       * If you only provide a <code class="grey-background">cursorPaging</code>. <code class="grey-background">cursor</code>,
       * the response will contain the default size of results which is `1000`.
       * </p>
       * </blockquote>
       */
      cursorPaging?: CommonCursorPaging$3;
      /**
       * Specifies whether to return all available resources in response.
       * @internal
       */
      shouldReturnAllResources?: boolean;
  }
  /**
   * Retrieves an available `TimeSlot` that match the provided filters.
   *
   * Throws `SlotNotFound` if there is no such available time slot.
   *
   * <blockquote class="important">
   * <p><strong>Important:</strong><br/>
   * Currently supported only for services of type <code class="grey-background">APPOINTMENT</code>.</p>
   * </blockquote>
   *
   * By default,
   * if you don't provide `includeResourceTypeIds` or `resourceIds` in request,
   * we return all `AvailableResources` with all `AvailableResources`.`resources` which are available to provide
   * the service within the time slot.
   *
   * If you specify `includeResourceTypeIds` or `resourceIds` in request,
   * the returned `TimeSlot` will contain only `AvailableResources` with at least one available resource
   * which match the given resources filters,
   * each contains all available resources out of those requested.
   *
   *
   * <blockquote class="tip">
   * <p><strong>Tip:</strong><br/>
   * Use this API in order to get the availability of a specific <code class="grey-background">TimeSlot</code> out of those returned from  <code class="grey-background">ListAvailabilityTimeSlots</code> API.</p>
   * </blockquote>
   * @param serviceId - Service ID of the time slot.
   * Currently supported only for services of type `APPOINTMENT`.
   * @public
   * @documentationMaturity preview
   * @requiredField options.localEndDate
   * @requiredField options.localStartDate
   * @requiredField options.location
   * @requiredField options.timeZone
   * @requiredField serviceId
   */
  function getAvailabilityTimeSlot$2(serviceId: string, options?: GetAvailabilityTimeSlotOptions$2): Promise<GetAvailabilityTimeSlotResponse$4>;
  interface GetAvailabilityTimeSlotOptions$2 {
      /**
       * Local start date of the time slot, in ISO-8601 format.
       * For example, "2024-01-30T13:30:00".
       */
      localStartDate: string;
      /**
       * Local end date of the time slot, in ISO-8601 format.
       * For example, "2024-01-30T14:30:00".
       */
      localEndDate: string;
      /** Time zone, in IANA time zone format. */
      timeZone: string | null;
      /**
       * The location of the time slot.
       *
       * You must provide a specific `locationType`.
       * If locationType is `BUSINESS`, you __must__ also provide a `locationId`.
       *
       * <blockquote class="warning">
       * <p>Supports filtering by location type, or by location ID.
       * Other fields like <code class="grey-background">name</code> are ignored.</p>
       * </blockquote>
       */
      location: Location$b;
      /**
       * Resources to include in response.
       *
       * If specified,
       * the returned `TimeSlot` contains only the available resources out of provided list.
       * Otherwise, the returned `TimeSlot` returned with all possible `AvailableResources`.
       */
      resourceIds?: string[];
      /**
       * Resource type IDs to include in response, this is in addition to the requested `resourceIds`.
       *
       * If specified in request, the returned `TimeSlot` contains only the `AvailableResources` with `ResourceTypeId`
       * out of those specified, each contains all the available resources of this type.
       */
      includeResourceTypeIds?: string[];
  }
  
  const bookingsAvailabilityV2TimeSlot_universal_d___debug: typeof __debug;
  type bookingsAvailabilityV2TimeSlot_universal_d_GetMultiServiceAvailabilityTimeSlotOptions = GetMultiServiceAvailabilityTimeSlotOptions;
  namespace bookingsAvailabilityV2TimeSlot_universal_d {
    export {
      bookingsAvailabilityV2TimeSlot_universal_d___debug as __debug,
      TimeSlot$4 as TimeSlot,
      Location$b as Location,
      LocationType$b as LocationType,
      EventInfo$4 as EventInfo,
      WaitingList$5 as WaitingList,
      BookingPolicyViolations$5 as BookingPolicyViolations,
      AvailableResources$5 as AvailableResources,
      Resource$8 as Resource,
      NestedTimeSlot$4 as NestedTimeSlot,
      CalculateEventBasedAvailabilityRequest$3 as CalculateEventBasedAvailabilityRequest,
      CursorPaging$e as CursorPaging,
      CalculateEventBasedAvailabilityResponse$3 as CalculateEventBasedAvailabilityResponse,
      CursorPagingMetadata$c as CursorPagingMetadata,
      Cursors$f as Cursors,
      ListEventTimeSlotsRequest$3 as ListEventTimeSlotsRequest,
      ListEventTimeSlotsResponse$3 as ListEventTimeSlotsResponse,
      ListMultiServiceAvailabilityTimeSlotsRequest$3 as ListMultiServiceAvailabilityTimeSlotsRequest,
      Service$5 as Service,
      CommonCursorPaging$3 as CommonCursorPaging,
      ListMultiServiceAvailabilityTimeSlotsResponse$3 as ListMultiServiceAvailabilityTimeSlotsResponse,
      CommonCursorPagingMetadata$3 as CommonCursorPagingMetadata,
      CommonCursors$3 as CommonCursors,
      GetMultiServiceAvailabilityTimeSlotRequest$3 as GetMultiServiceAvailabilityTimeSlotRequest,
      GetMultiServiceAvailabilityTimeSlotResponse$3 as GetMultiServiceAvailabilityTimeSlotResponse,
      ListAvailabilityTimeSlotsRequest$3 as ListAvailabilityTimeSlotsRequest,
      ListAvailabilityTimeSlotsResponse$3 as ListAvailabilityTimeSlotsResponse,
      GetAvailabilityTimeSlotRequest$4 as GetAvailabilityTimeSlotRequest,
      GetAvailabilityTimeSlotResponse$4 as GetAvailabilityTimeSlotResponse,
      calculateEventBasedAvailability$1 as calculateEventBasedAvailability,
      CalculateEventBasedAvailabilityOptions$1 as CalculateEventBasedAvailabilityOptions,
      listEventTimeSlots$1 as listEventTimeSlots,
      ListEventTimeSlotsOptions$1 as ListEventTimeSlotsOptions,
      listMultiServiceAvailabilityTimeSlots$1 as listMultiServiceAvailabilityTimeSlots,
      ListMultiServiceAvailabilityTimeSlotsOptions$1 as ListMultiServiceAvailabilityTimeSlotsOptions,
      getMultiServiceAvailabilityTimeSlot$1 as getMultiServiceAvailabilityTimeSlot,
      bookingsAvailabilityV2TimeSlot_universal_d_GetMultiServiceAvailabilityTimeSlotOptions as GetMultiServiceAvailabilityTimeSlotOptions,
      listAvailabilityTimeSlots$1 as listAvailabilityTimeSlots,
      ListAvailabilityTimeSlotsOptions$1 as ListAvailabilityTimeSlotsOptions,
      getAvailabilityTimeSlot$2 as getAvailabilityTimeSlot,
      GetAvailabilityTimeSlotOptions$2 as GetAvailabilityTimeSlotOptions,
    };
  }
  
  interface SlotAvailability$1 {
      /**
       * The slot for the corresponding session, when the session is either a single session
       * or a specific session generated from a recurring session.
       */
      slot?: Slot$1;
      /**
       * Whether the slot is bookable. Bookability is determined by checking a
       * session's open slots and booking policies. Locks are not taken into
       * account.
       */
      bookable?: boolean;
      /**
       * Total number of spots for this slot.
       * For example, if a session has a total of 10 spots and 3 spots are booked,
       * `spotsTotal` is 10 and `openSpots` is 7.
       */
      totalSpots?: number | null;
      /** Number of open spots for this slot. */
      openSpots?: number | null;
      /** An object describing the slot's waitlist and its occupancy. */
      waitingList?: WaitingList$4;
      /** Booking policy violations for the slot. */
      bookingPolicyViolations?: BookingPolicyViolations$4;
      /**
       * Indicates whether the slot is locked because a waitlist exists.
       * When a slot frees up, the slot is offered to the next customer on the waitlist. Read-only.
       */
      locked?: boolean | null;
      isFromV2?: boolean;
      /** @internal */
      nestedSlots?: NestedTimeSlot$3[];
  }
  interface Slot$1 {
      /**
       * ID for the slot's corresponding session, when the session is either a single session
       * or a specific session generated from a recurring session.
       */
      sessionId?: string | null;
      /** Service ID. */
      serviceId?: string;
      /** Schedule ID. */
      scheduleId?: string;
      /**
       * The start time of this slot in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339)
       * format.
       *
       * If `timezone` is specified,
       * dates are based on the local date/time. This means that the timezone offset
       * in the `start_date` is ignored.
       */
      startDate?: string | null;
      /**
       * The end time of this slot in
       * [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339) format.
       *
       * If `timezone` is specified,
       * dates are based on the local date/time. This means that the timezone offset
       * in the `end_date` is ignored.
       */
      endDate?: string | null;
      /**
       * The timezone for which slot availability is to be calculated. If specified,
       * dates are based on the local date/time, meaning that the timezone offset
       * in the date's format is ignored.
       */
      timezone?: string | null;
      /**
       * The resource required for this slot. Currently, the only supported resource
       * is the relevant staff member for the slot.
       */
      resource?: SlotResource$1;
      /** Geographic location of the slot. */
      location?: Location$a;
  }
  interface SlotResource$1 {
      /**
       * Resource ID.
       * @readonly
       */
      _id?: string | null;
      /** Resource name. Read only. */
      name?: string | null;
      /**
       * Schedule ID. Read only.
       * @internal
       */
      scheduleId?: string | null;
  }
  interface Location$a {
      /**
       * Business location ID. Available only for locations that are business locations,
       * meaning the `location_type` is `"OWNER_BUSINESS"`.
       */
      _id?: string | null;
      /** Location name. */
      name?: string | null;
      /** The full address of this location. */
      formattedAddress?: string | null;
      /** The full translated address of this location. */
      formattedAddressTranslated?: string | null;
      /**
       * Location type.
       *
       * - `"OWNER_BUSINESS"`: The business address, as set in the sites general settings.
       * - `"OWNER_CUSTOM"`: The address as set when creating the service.
       * - `"CUSTOM"`: The address as set for the individual session.
       */
      locationType?: LocationType$a;
  }
  enum LocationType$a {
      UNDEFINED = "UNDEFINED",
      OWNER_BUSINESS = "OWNER_BUSINESS",
      OWNER_CUSTOM = "OWNER_CUSTOM",
      CUSTOM = "CUSTOM"
  }
  interface WaitingList$4 {
      /**
       * Total number of spots and open spots for this waitlist.
       * For example, a Yoga class with 10 waitlist spots and 3 registered
       * on the waitlist has 10 `total_spots` and 7 `open_spots`.
       */
      totalSpots?: number | null;
      /** Number of open spots for this waitlist. */
      openSpots?: number | null;
  }
  interface BookingPolicyViolations$4 {
      /** Bookings policy violation. Too early to book this slot. */
      tooEarlyToBook?: boolean | null;
      /** Bookings policy violation. Too late to book this slot. */
      tooLateToBook?: boolean | null;
      /** Bookings policy violation. Online booking is disabled for this slot. */
      bookOnlineDisabled?: boolean | null;
  }
  interface NestedTimeSlot$3 {
      serviceId?: string;
      start?: string;
      end?: string;
      resource?: SlotResource$1;
      /** Schedule ID. */
      scheduleId?: string;
  }
  interface QueryAvailabilityRequest {
      /** Query options. */
      query: QueryV2$5;
      /**
       * The timezone for which slot availability is to be calculated. If specified,
       * dates are based on the local date/time, meaning that the timezone offset
       * in the date's format is ignored.
       */
      timezone?: string | null;
      /**
       * Maximum number of slots to load for each date. For example, if `slots_per_day` is set to `3`,
       * at most 3 available slots are returned for each day in the date range specified in the query's
       * `filter`.
       *
       * When a day has both bookable and non-bookable slots, bookable slots are returned first.
       * Non-bookable slots are returned according to the specified filters, after all
       * bookable slots are already included.
       */
      slotsPerDay?: number | null;
      /**
       * specifies whether this request should be proxied to availability
       * @internal
       */
      allowProxyToAvailability?: boolean;
      /**
       * specifies whether slots v2 should be premutated or not, true will mean to not premutate and won't return resource on the slot response.
       * @internal
       */
      anyResource?: boolean;
      /**
       * Selected customer choices.
       * If specified, the selected choices will be used to calculate service configuration.
       * If not specified, the service default configuration will be used.
       * @internal
       */
      customerChoices?: CustomerChoices$3;
  }
  interface QueryV2$5 extends QueryV2PagingMethodOneOf$5 {
      /**
       * Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`.
       * @internal
       */
      cursorPaging?: CursorPaging$d;
      /**
       * Filter object. You must include `serviceId`, `startDate` and `endDate` in the filter. This avoids large results that can impact performance.
       */
      filter?: Record<string, any> | null;
      /** Currently, only sorting by `startDate` is supported.  */
      sort?: Sorting$9[];
      /**
       * List of projected fields to return. All fields are supported.
       * @internal
       */
      fields?: string[];
  }
  /** @oneof */
  interface QueryV2PagingMethodOneOf$5 {
      /**
       * Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`.
       * @internal
       */
      cursorPaging?: CursorPaging$d;
  }
  interface Sorting$9 {
      /** Name of the field to sort by. */
      fieldName?: string;
      /** Sort order. */
      order?: SortOrder$9;
      /**
       * When `field_name` is a property of repeated field that is marked as `MATCH_ITEMS` and sort should be done by
       * a specific element from a collection, filter can/should be provided to ensure correct sort value is picked.
       *
       * If multiple filters are provided, they are combined with AND operator.
       *
       * Example:
       * Given we have document like {"id": "1", "nestedField": [{"price": 10, "region": "EU"}, {"price": 20, "region": "US"}]}
       * and `nestedField` is marked as `MATCH_ITEMS`, to ensure that sorting is done by correct region, filter should be
       * { fieldName: "nestedField.price", "select_items_by": [{"nestedField.region": "US"}] }
       * @internal
       */
      selectItemsBy?: Record<string, any>[] | null;
  }
  enum SortOrder$9 {
      ASC = "ASC",
      DESC = "DESC"
  }
  interface CursorPaging$d {
      /** Maximum number of items to return in the results. */
      limit?: number | null;
      /**
       * Pointer to the next or previous page in the list of results.
       *
       * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
       * Not relevant for the first request.
       */
      cursor?: string | null;
  }
  /**
   * Selected customer choices.
   * These choices are selected by the customer during the booking flow and can be utilized to calculate the corresponding service's configuration properties.
   */
  interface CustomerChoices$3 {
      /**
       * The selected customer duration in minutes.
       * Min: `1 minute`
       * Max: `44639 minutes` (30 days, 23 hours, and 59 minutes)
       */
      durationInMinutes?: number | null;
  }
  interface QueryAvailabilityResponse {
      /** List of slots that potentially can be booked. */
      availabilityEntries?: SlotAvailability$1[];
      /**
       * Details on the paged set of returned results.
       * @internal
       */
      pagingMetadata?: PagingMetadataV2$4;
  }
  interface PagingMetadataV2$4 {
      /** Number of items returned in the response. */
      count?: number | null;
      /** Offset that was requested. */
      offset?: number | null;
      /** Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set. */
      total?: number | null;
      /** Flag that indicates the server failed to calculate the `total` field. */
      tooManyToCount?: boolean | null;
      /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
      cursors?: Cursors$e;
      /**
       * Indicates if there are more results after the current page.
       * If `true`, another page of results can be retrieved.
       * If `false`, this is the last page.
       * @internal
       */
      hasNext?: boolean | null;
  }
  interface Cursors$e {
      /** Cursor string pointing to the next page in the list of results. */
      next?: string | null;
      /** Cursor pointing to the previous page in the list of results. */
      prev?: string | null;
  }
  interface GetSlotAvailabilityRequest$1 {
      /** The slot for which the availability is checked. */
      slot?: Slot$1;
      /**
       * The timezone for which slot availability is to be calculated. If specified,
       * dates are based on the local date/time, meaning that the timezone offset
       * in the date's format is ignored.
       */
      timezone?: string | null;
      /**
       * Return the IDs of bookings that are currently allowed to book
       * the given slot due to being a part of a waitlist in a "suggested" status.
       * @internal
       */
      returnAllowedBookingIds?: boolean;
      /**
       * Check if this booking is allowed to book the given slot due to
       * being a part of a waitlist in a "suggested" status.
       * If passed and the slot is locked for a different booking than this,
       * then `bookable` = `false` is returned.
       * @internal
       */
      bookingId?: string | null;
      /**
       * Check if should call consistentQuery in order to calculate open spots  //todo: this field is temporary in order to align bookings ft conduction with availabilityCalendar ft
       * @internal
       */
      shouldNotCallConsistentQuery?: boolean | null;
  }
  interface GetSlotAvailabilityResponse$1 {
      availability?: SlotAvailability$1;
      bookingPolicySettings?: BookingPolicySettings$2;
      /**
       * Bookings that are currently allowed to book the given slot due to being a part of a waitlist in a "suggested" status.
       * @internal
       */
      allowedBookingIds?: string[];
  }
  interface BookingPolicySettings$2 {
      /**
       * The policy defining the maximum number of participants that can
       * be booked for a slot or a schedule.
       */
      maxParticipantsPerBooking?: number | null;
  }
  interface GetScheduleAvailabilityRequest$1 {
      /** The schedule ID for which availability is being checked. */
      scheduleId: string;
      /**
       * Check if should call consistentQuery in order to calculate open spots        //todo: this field is temporary in order to align bookings ft conduction with availabilityCalendar ft
       * @internal
       */
      shouldNotCallConsistentQuery?: boolean | null;
  }
  interface GetScheduleAvailabilityResponse$1 {
      availability?: ScheduleAvailability$1;
      bookingPolicySettings?: BookingPolicySettings$2;
  }
  interface ScheduleAvailability$1 {
      /**
       * The total number of spots defined for the schedule, including
       * both open and non-available spots.
       */
      totalSpots?: number | null;
      /** The number of open spots defined for the schedule. */
      openSpots?: number | null;
      /** Booking policy violations for the schedule. */
      bookingPolicyViolations?: BookingPolicyViolations$4;
  }
  interface CalculateMultiSlotAvailabilityRequest {
      from?: string;
      to?: string;
      timeZone?: string;
      /** TODO good definition of what bookable means https://github.com/wix-private/scheduler/pull/18267/files?file-filters%5B%5D=.proto&show-viewed-files=true#r1199809006 */
      bookable?: boolean | null;
      /**
       * each nested field is checked on its own. i.e. if `too_early_to_book` is defined and `too_late_to_book` is not defined
       * we will return slots for which `too_early_to_book` is same as on the request, regardless of `too_late_to_book`.
       */
      bookingPolicyViolations?: BookingPolicyViolations$4;
      /**
       * support filtering by location type, or by locationId. Other fields like `name` are ignored
       * must be set, and must have locationType. If locationType is `OWNER_BUSINESS`, must have location_id
       */
      location?: Location$a;
      slots?: RuleBasedConstraints[];
      /**
       * Maximum number of slots to load for each date. For example, if `slots_per_day` is set to `3`,
       * at most 3 available slots are returned for each day in the date range specified in the query's
       * `filter`.
       *
       * When a day has both bookable and non-bookable slots, bookable slots are returned first.
       * Non-bookable slots are returned according to the specified filters, after all
       * bookable slots are already included.
       */
      slotsPerDay?: number | null;
      cursorPaging?: CursorPaging$d;
  }
  interface RuleBasedConstraints {
      serviceId?: string;
      resourcesFilter?: ResourcesFilter;
      /**
       * specifies whether slots v2 should be premutated or not, true will mean to not premutate and won't return resource on the slot response.
       * @internal
       */
      anyResource?: boolean;
  }
  interface ResourcesFilter {
      resourceIds?: string[];
  }
  interface CalculateMultiSlotAvailabilityResponse {
      slots?: SlotAvailability$1[];
      cursorPagingMetadata?: CursorPagingMetadata$b;
  }
  interface CursorPagingMetadata$b {
      /** Number of items returned in current page. */
      count?: number | null;
      /** Cursor strings that point to the next page, previous page, or both. */
      cursors?: Cursors$e;
      /**
       * Whether there are more pages to retrieve following the current page.
       *
       * + `true`: Another page of results can be retrieved.
       * + `false`: This is the last page.
       */
      hasNext?: boolean | null;
      /**
       * Total number of items matching the filter.
       * Available only on the first page of *Search* results, not included in *Query* or *List* results.
       * If the Search results span multiple pages, the value of `total` will exceed the number of items returned on the first page.
       * @internal
       */
      total?: number | null;
  }
  interface GetAvailabilityTimeSlotRequest$3 {
      /**
       * Service ID of the time slot.
       * Currently supported only for services of type `APPOINTMENT`.
       */
      serviceId: string;
      /**
       * Local start date of the time slot, in ISO-8601 format.
       * For example, "2024-01-30T13:30:00".
       */
      localStartDate: string;
      /**
       * Local end date of the time slot, in ISO-8601 format.
       * For example, "2024-01-30T14:30:00".
       */
      localEndDate: string;
      /** Time zone, in IANA time zone format. */
      timeZone: string | null;
      /**
       * The location of the time slot.
       *
       * You must provide a specific `locationType`.
       * If locationType is `BUSINESS`, you __must__ also provide a `locationId`.
       *
       * <blockquote class="warning">
       * <p>Supports filtering by location type, or by location ID.
       * Other fields like <code class="grey-background">name</code> are ignored.</p>
       * </blockquote>
       */
      location?: TimeSlotLocation;
      /**
       * Resources to include in response.
       *
       * If specified,
       * the returned `TimeSlot` contains only the available resources out of provided list.
       * Otherwise, the returned `TimeSlot` returned with all possible `AvailableResources`.
       */
      resourceIds?: string[];
      /**
       * Resource type IDs to include in response, this is in addition to the requested `resourceIds`.
       *
       * If specified in request, the returned `TimeSlot` contains only the `AvailableResources` with `ResourceTypeId`
       * out of those specified, each contains all the available resources of this type.
       */
      includeResourceTypeIds?: string[];
      fromV2?: boolean | null;
  }
  interface TimeSlotLocation {
      /** Business Location ID. Present only if the location is a business location. */
      _id?: string | null;
      /** The location name. */
      name?: string | null;
      /** A string representation for the full address of the location. */
      formattedAddress?: string | null;
      /**
       * The type of location:
       * - `CUSTOM`: The location is specific to this service, and is not derived from the business location.
       * - `BUSINESS`: A business location, either the default business address, or locations defined for the business by the Business Info.
       * - `CUSTOMER`: The location is determined by the customer and is not set up beforehand.
       */
      locationType?: LocationLocationType$2;
  }
  enum LocationLocationType$2 {
      UNKNOWN_LOCATION_TYPE = "UNKNOWN_LOCATION_TYPE",
      /** A business location, either the default business address, or locations defined for the business by the Business Info. */
      BUSINESS = "BUSINESS",
      /** The location is unique to this service and isn't defined as one of the business locations. */
      CUSTOM = "CUSTOM",
      /** The location can be determined by the customer and is not set up beforehand. */
      CUSTOMER = "CUSTOMER"
  }
  interface GetAvailabilityTimeSlotResponse$3 {
      /** Time slot. */
      timeSlot?: TimeSlot$3;
      /** Time zone, in IANA time zone format. */
      timeZone?: string | null;
  }
  /**
   * The `TimeSlot` object represents the availability information
   * for an `Appointment` service's specific slot, including:
   *
   * 1. Whether the slot is bookable for the given service?
   *
   * 2. In what location the service is available for this slot?
   *
   * 3. Which available resources can provide the service for this slot?
   *
   * 4. Does booking the slot for the service violates any of the service booking policies?
   *
   * 5. What is the total capacity and remaining capacity of the service at the time of the calculation of the `TimeSlot`?
   *
   * > __Note:__
   * > When the `TimeSlot` has a non empty `NestedTimeSlots`, it represents the availability information
   * > for a given list of `Appointment` services within a specific time slot.
   */
  interface TimeSlot$3 {
      /**
       * Service ID.
       *
       * > Not returned from `MultiServiceAvailabilityTimeSlots` API calls.
       * > Instead, each nested time slot has its own serviceId.
       */
      serviceId?: string | null;
      /**
       * Local start date of the time slot in ISO-8601 format.
       * For example, "2024-01-30T13:30:00".
       */
      localStartDate?: string | null;
      /**
       * Local end date of the time slot in ISO-8601 format.
       * For example, "2024-01-30T14:30:00".
       */
      localEndDate?: string | null;
      /**
       * Whether the slot is bookable according to the service's booking policies.
       *
       * If booking this time slot does not violates any of the service's booking policies,
       * the returned value is `true`. Otherwise, returns `false`.
       */
      bookable?: boolean | null;
      /** The geographic location of the slot. */
      location?: TimeSlotLocation;
      /**
       * Returned only for event.
       * @internal
       */
      eventInfo?: EventInfo$3;
      /** Total number of spots for the slot. */
      totalCapacity?: number | null;
      /**
       * Remaining number of spots for the slot.
       * For example, for an appointment service with total capacity of 1 spot and one booked spot, the remaining capacity will be 0.
       */
      remainingCapacity?: number | null;
      /**
       * Indicators for booking policy violations for the slot.
       *
       * Each nested field is checked on its own. i.e. if `tooEarlyToBook` is defined and `bookOnlineDisabled` is not defined
       * we will return also slots for which `tooEarlyToBook` is same as on the request, regardless of `bookOnlineDisabled`.
       */
      bookingPolicyViolations?: Service_availabilityBookingPolicyViolations;
      /**
       * List of `AvailableResources` for the time slot.
       * Each `AvailableResources` contains information about available resources of the same type.
       *
       * > Not returned from `MultiServiceAvailabilityTimeSlots` API calls.
       * > Instead, each nested time slot has its own available resources.
       */
      availableResources?: AvailableResources$4[];
      /**
       * > Nested time slots.
       * > Returned only from `MultiServiceAvailabilityTimeSlots` API calls.
       */
      nestedTimeSlots?: Service_availabilityNestedTimeSlot[];
  }
  /** relevant for event based slots, and not for availability based slots */
  interface EventInfo$3 {
      /**
       * TODO: format - might not be a guid?
       * @internal
       */
      eventId?: string | null;
      /** @internal */
      waitingList?: Service_availabilityWaitingList;
  }
  interface Service_availabilityWaitingList {
      /** Total number of spots in this wait list. */
      totalCapacity?: number | null;
      /**
       * Number of remaining spots for this wait list.
       * For example, a Yoga event with 10 waitList spots and 3 registered
       * on the waitList has 10 `total_capacity` and 7 `remaining_capacity`.
       */
      remainingCapacity?: number | null;
  }
  interface Service_availabilityBookingPolicyViolations {
      /** Bookings policy violation. Too early to book this slot. */
      tooEarlyToBook?: boolean | null;
      /** Bookings policy violation. Too late to book this slot. */
      tooLateToBook?: boolean | null;
      /** Bookings policy violation. Online booking is disabled for the `TimeSlot` service. */
      bookOnlineDisabled?: boolean | null;
  }
  interface AvailableResources$4 {
      /** Resource type ID. */
      resourceTypeId?: string | null;
      /**
       * Available resources for the time slot.
       *
       * + When returned from `ListAvailabilityTimeSlots`, empty by default.
       * + + If you provided `includeResourceTypeIds` or  `resourceIds` in request,
       * contains __up__ to 10 available resources out of those provided.
       *
       * + When returned from `GetAvailabilityTimeSlots`, contains all available resources by default.
       * + + If you provided `includeResourceTypeIds` or  `resourceIds` in request,
       * contains all of the available resources out of those provided.
       *
       *
       * > + When returned from `ListMultiServiceAvailabilityTimeSlots`, empty by default.
       * > + + If you provided `includeResourceTypeIds` or  `resourceIds` in request,
       * > contains __up__ to 10 available resources out of those provided.
       *
       * > + When returned from `GetMultiServiceAvailabilityTimeSlots`, contains all available resources by default.
       * > + + If you provided `includeResourceTypeIds` or  `resourceIds` in request,
       * > contains all of the available resources out of those provided.
       */
      resources?: Resource$7[];
      /**
       * The required number of resources of this type in order to book the service.
       * For example, a slot for a service that provides a double massage
       * requires two resources of type `Staff Member` and one resource of type `Room`.
       * @internal
       */
      numberOfResourcesRequired?: number | null;
      /**
       * Whether there are more available resources for the slot that are not listed in `resources` due to size limitations.
       * @readonly
       */
      hasMoreAvailableResources?: boolean | null;
  }
  interface Resource$7 {
      /** Resource ID. */
      _id?: string;
      /** Resource name. */
      name?: string | null;
  }
  interface Service_availabilityNestedTimeSlot {
      /** Service ID of the nested time slot. */
      serviceId?: string;
      /**
       * Local start date of the nested time slot in ISO-8601 format.
       * For example, "2024-01-30T13:30:00".
       */
      localStartDate?: string;
      /**
       * Local end date of the nested time slot in ISO-8601 format.
       * For example, "2024-01-30T14:30:00".
       */
      localEndDate?: string;
      /**
       * List of `AvailableResources` for the nested time slot.
       * Each `AvailableResources` contains information about available resources of the same type.
       */
      availableResources?: AvailableResources$4[];
  }
  /**
   * Retrieves the availability for sessions
   * that match the provided query criteria (paging, filtering, and sorting).
   *
   *
   * The Availability Calendar APIs calculate the availability of sessions for
   * appointments and classes, but not
   * for courses.
   *
   * The entire list of slots is returned in case you want to display both
   * available and non-available slots in the calendar for your customers.
   * Using the `bookable` property, you can limit the display to available
   * slots only.
   *
   * When querying, you must enter a start date and an end date. This avoids very large
   * results that can impact performance.
   *
   * #### Calculating availability
   *
   * The availability is determined
   * by checking:
   * + **The sessions' open slots**. A slot is considered open if the session's
   * capacity is greater than number of participants.
   * + **Booking policies**. Policies that affect whether a slot is considered
   * available include `tooEarlyToBook`, `tooLateToBook`, and `bookOnlineDisabled`.
   *
   * Locked sessions do not impact session availability and `bookable` can
   * be `true` even if `locked` is `true`. For example, if a session has a waitlist and a
   * place frees up, the slot is offered to the customers on the waitlist, one by one. The
   * session remains locked because there is still a waitlist, but for a period of time
   * there is availability, until a customer on the waitlist takes the slot. Locking
   * prevents customers who are not yet on the waitlist from grabbing the slot.
   *
   * #### Handling Daylight Savings Time (DST) for local time zones
   *
   * Because of DST, there are cases where certain times either do not exist
   * or exist twice for a local time zone.
   * For example, the tine `00:05` on September 5th 2021 might not exist in Santiago, Chile,
   * because at `00:00` the clock moved
   * 1 hour forward to `01:00`.
   *
   * In this case, the Availability Calendar APIs take this
   * into account and mediate the time gaps automatically. The non-existent local time is
   * automatically moved forward 1 hour to match local DST. Local times that exist do not change.
   * So if the `queryAvailability()` function is called with a `startDate` of `2021-09-05T00:00:01.000`
   * and an `endDate` of `2021-09-06T00:00:02.000`, `2021-09-05T01:00:01.000` is used in the query
   * instead. The start time shifts one hour forward and the end time remains the same.
   * @param query - Query options.
   * @public
   * @documentationMaturity preview
   * @requiredField query
   * @requiredField query.filter
   * @param options - Additional options for performing the query.
   * @permissionId BOOKINGS.AVAILABILITY_READ
   * @adminMethod
   */
  function queryAvailability(query: QueryV2$5, options?: QueryAvailabilityOptions): Promise<QueryAvailabilityResponse>;
  interface QueryAvailabilityOptions {
      /**
       * The timezone for which slot availability is to be calculated. If specified,
       * dates are based on the local date/time, meaning that the timezone offset
       * in the date's format is ignored.
       */
      timezone?: string | null;
      /**
       * Maximum number of slots to load for each date. For example, if `slots_per_day` is set to `3`,
       * at most 3 available slots are returned for each day in the date range specified in the query's
       * `filter`.
       *
       * When a day has both bookable and non-bookable slots, bookable slots are returned first.
       * Non-bookable slots are returned according to the specified filters, after all
       * bookable slots are already included.
       */
      slotsPerDay?: number | null;
      /**
       * specifies whether this request should be proxied to availability
       * @internal
       */
      allowProxyToAvailability?: boolean;
      /**
       * specifies whether slots v2 should be premutated or not, true will mean to not premutate and won't return resource on the slot response.
       * @internal
       */
      anyResource?: boolean;
      /**
       * Selected customer choices.
       * If specified, the selected choices will be used to calculate service configuration.
       * If not specified, the service default configuration will be used.
       * @internal
       */
      customerChoices?: CustomerChoices$3;
  }
  /**
   * Returns the availability for a given slot.
   *
   * A slot for an appointment does not have a `sessionId. Only a slot for a class has a `sessionId`.
   *
   * Availability for an appointment is calculated as follows:
   * - Checking for available slots in the calendar, and calculating the open spots
   * - Checking for existing bookings with overlapping time, service & resource, where the booked session has transparency set to  `"BUSY"`  When the booking is in the process of being checked out, it may not have a sessionId yet. In this case it is considered as `"BUSY"`.
   * - Checking for booking policy violations in the services-catalog.
   * The following fields are required to get the availability for an appointment:
   * - `startDate`
   * - `endDate`
   * - `serviceId`
   * - `resourceId`
   * - `scheduleId`
   * Availability for classes is calculated as follows:
   * - Checking for total spots by the session's capacity
   * - Checking for open spots by subtracting the current number of participants from the total spots
   * - Checking for booking policy violations in the services-catalog
   * - Checking for a waitlist and its occupancy in the waiting-list
   * - Checking for locked in the locks
   * For a class, the following fields are required:
   * - `sessionId`
   * @internal
   * @documentationMaturity preview
   * @adminMethod
   */
  function getSlotAvailability$1(options?: GetSlotAvailabilityOptions$1): Promise<GetSlotAvailabilityResponse$1>;
  interface GetSlotAvailabilityOptions$1 {
      /** The slot for which the availability is checked. */
      slot?: Slot$1;
      /**
       * The timezone for which slot availability is to be calculated. If specified,
       * dates are based on the local date/time, meaning that the timezone offset
       * in the date's format is ignored.
       */
      timezone?: string | null;
      /**
       * Return the IDs of bookings that are currently allowed to book
       * the given slot due to being a part of a waitlist in a "suggested" status.
       * @internal
       */
      returnAllowedBookingIds?: boolean;
      /**
       * Check if this booking is allowed to book the given slot due to
       * being a part of a waitlist in a "suggested" status.
       * If passed and the slot is locked for a different booking than this,
       * then `bookable` = `false` is returned.
       * @internal
       */
      bookingId?: string | null;
      /**
       * Check if should call consistentQuery in order to calculate open spots  //todo: this field is temporary in order to align bookings ft conduction with availabilityCalendar ft
       * @internal
       */
      shouldNotCallConsistentQuery?: boolean | null;
  }
  /**
   * Returns availability for a given schedule ID
   * The availability for a course is calculated by:
   * - Checking for total spots by the schedule's capacity
   * - Checking for open spots by subtracting the current number of participants from the total spots
   * current number of participants is calculated by summing the number of participants of all bookings booked to the schedule
   * @param scheduleId - The schedule ID for which availability is being checked.
   * @public
   * @documentationMaturity preview
   * @requiredField scheduleId
   * @adminMethod
   * @deprecated
   */
  function getScheduleAvailability$1(scheduleId: string, options?: GetScheduleAvailabilityOptions): Promise<GetScheduleAvailabilityResponse$1>;
  interface GetScheduleAvailabilityOptions {
      /**
       * Check if should call consistentQuery in order to calculate open spots        //todo: this field is temporary in order to align bookings ft conduction with availabilityCalendar ft
       * @internal
       */
      shouldNotCallConsistentQuery?: boolean | null;
  }
  /** @public
   * @documentationMaturity preview
   * @permissionId BOOKINGS.AVAILABILITY_READ_MULTI_SLOT
   */
  function calculateMultiSlotAvailability(options?: CalculateMultiSlotAvailabilityOptions): Promise<CalculateMultiSlotAvailabilityResponse>;
  interface CalculateMultiSlotAvailabilityOptions {
      from?: string;
      to?: string;
      timeZone?: string;
      /** TODO good definition of what bookable means https://github.com/wix-private/scheduler/pull/18267/files?file-filters%5B%5D=.proto&show-viewed-files=true#r1199809006 */
      bookable?: boolean | null;
      /**
       * each nested field is checked on its own. i.e. if `too_early_to_book` is defined and `too_late_to_book` is not defined
       * we will return slots for which `too_early_to_book` is same as on the request, regardless of `too_late_to_book`.
       */
      bookingPolicyViolations?: BookingPolicyViolations$4;
      /**
       * support filtering by location type, or by locationId. Other fields like `name` are ignored
       * must be set, and must have locationType. If locationType is `OWNER_BUSINESS`, must have location_id
       */
      location?: Location$a;
      slots?: RuleBasedConstraints[];
      /**
       * Maximum number of slots to load for each date. For example, if `slots_per_day` is set to `3`,
       * at most 3 available slots are returned for each day in the date range specified in the query's
       * `filter`.
       *
       * When a day has both bookable and non-bookable slots, bookable slots are returned first.
       * Non-bookable slots are returned according to the specified filters, after all
       * bookable slots are already included.
       */
      slotsPerDay?: number | null;
      cursorPaging?: CursorPaging$d;
  }
  /**
   * a decision based proxy between GetSlotAvailability and  service-availability's GetAvailabilityTimeSlot
   * this is a temporary solution based on FromV2 flag, and will be removed once all the clients are migrated to v2
   * the request will be proxied to GetSlotAvailability if from_v2 is false, and to GetAvailabilityTimeSlot if from_v2 is true
   * it supports only appointment services (NOT classes, and NOT courses)
   * in case from_v2 is not provided, the request will be proxied based on `ShouldCallAvailabilityService` FT and ResourceManagement check [exists not staff resource]
   * in case from_v2 is false and ResourceManagement check is true, an FAILED_PRECONDITION error will be thrown
   * @param serviceId - Service ID of the time slot.
   * Currently supported only for services of type `APPOINTMENT`.
   * @internal
   * @documentationMaturity preview
   * @requiredField options.localEndDate
   * @requiredField options.localStartDate
   * @requiredField options.timeZone
   * @requiredField serviceId
   * @permissionId BOOKINGS.AVAILABILITY_READ
   */
  function getAvailabilityTimeSlot$1(serviceId: string, options?: GetAvailabilityTimeSlotOptions$1): Promise<GetAvailabilityTimeSlotResponse$3>;
  interface GetAvailabilityTimeSlotOptions$1 {
      /**
       * Local start date of the time slot, in ISO-8601 format.
       * For example, "2024-01-30T13:30:00".
       */
      localStartDate: string;
      /**
       * Local end date of the time slot, in ISO-8601 format.
       * For example, "2024-01-30T14:30:00".
       */
      localEndDate: string;
      /** Time zone, in IANA time zone format. */
      timeZone: string | null;
      /**
       * The location of the time slot.
       *
       * You must provide a specific `locationType`.
       * If locationType is `BUSINESS`, you __must__ also provide a `locationId`.
       *
       * <blockquote class="warning">
       * <p>Supports filtering by location type, or by location ID.
       * Other fields like <code class="grey-background">name</code> are ignored.</p>
       * </blockquote>
       */
      location?: TimeSlotLocation;
      /**
       * Resources to include in response.
       *
       * If specified,
       * the returned `TimeSlot` contains only the available resources out of provided list.
       * Otherwise, the returned `TimeSlot` returned with all possible `AvailableResources`.
       */
      resourceIds?: string[];
      /**
       * Resource type IDs to include in response, this is in addition to the requested `resourceIds`.
       *
       * If specified in request, the returned `TimeSlot` contains only the `AvailableResources` with `ResourceTypeId`
       * out of those specified, each contains all the available resources of this type.
       */
      includeResourceTypeIds?: string[];
      fromV2?: boolean | null;
  }
  
  type bookingsAvailabilityV1SlotAvailability_universal_d_QueryAvailabilityRequest = QueryAvailabilityRequest;
  type bookingsAvailabilityV1SlotAvailability_universal_d_QueryAvailabilityResponse = QueryAvailabilityResponse;
  type bookingsAvailabilityV1SlotAvailability_universal_d_CalculateMultiSlotAvailabilityRequest = CalculateMultiSlotAvailabilityRequest;
  type bookingsAvailabilityV1SlotAvailability_universal_d_RuleBasedConstraints = RuleBasedConstraints;
  type bookingsAvailabilityV1SlotAvailability_universal_d_ResourcesFilter = ResourcesFilter;
  type bookingsAvailabilityV1SlotAvailability_universal_d_CalculateMultiSlotAvailabilityResponse = CalculateMultiSlotAvailabilityResponse;
  type bookingsAvailabilityV1SlotAvailability_universal_d_TimeSlotLocation = TimeSlotLocation;
  type bookingsAvailabilityV1SlotAvailability_universal_d_Service_availabilityWaitingList = Service_availabilityWaitingList;
  type bookingsAvailabilityV1SlotAvailability_universal_d_Service_availabilityBookingPolicyViolations = Service_availabilityBookingPolicyViolations;
  type bookingsAvailabilityV1SlotAvailability_universal_d_Service_availabilityNestedTimeSlot = Service_availabilityNestedTimeSlot;
  const bookingsAvailabilityV1SlotAvailability_universal_d_queryAvailability: typeof queryAvailability;
  type bookingsAvailabilityV1SlotAvailability_universal_d_QueryAvailabilityOptions = QueryAvailabilityOptions;
  type bookingsAvailabilityV1SlotAvailability_universal_d_GetScheduleAvailabilityOptions = GetScheduleAvailabilityOptions;
  const bookingsAvailabilityV1SlotAvailability_universal_d_calculateMultiSlotAvailability: typeof calculateMultiSlotAvailability;
  type bookingsAvailabilityV1SlotAvailability_universal_d_CalculateMultiSlotAvailabilityOptions = CalculateMultiSlotAvailabilityOptions;
  namespace bookingsAvailabilityV1SlotAvailability_universal_d {
    export {
      SlotAvailability$1 as SlotAvailability,
      Slot$1 as Slot,
      SlotResource$1 as SlotResource,
      Location$a as Location,
      LocationType$a as LocationType,
      WaitingList$4 as WaitingList,
      BookingPolicyViolations$4 as BookingPolicyViolations,
      NestedTimeSlot$3 as NestedTimeSlot,
      bookingsAvailabilityV1SlotAvailability_universal_d_QueryAvailabilityRequest as QueryAvailabilityRequest,
      QueryV2$5 as QueryV2,
      QueryV2PagingMethodOneOf$5 as QueryV2PagingMethodOneOf,
      Sorting$9 as Sorting,
      SortOrder$9 as SortOrder,
      CursorPaging$d as CursorPaging,
      CustomerChoices$3 as CustomerChoices,
      bookingsAvailabilityV1SlotAvailability_universal_d_QueryAvailabilityResponse as QueryAvailabilityResponse,
      PagingMetadataV2$4 as PagingMetadataV2,
      Cursors$e as Cursors,
      GetSlotAvailabilityRequest$1 as GetSlotAvailabilityRequest,
      GetSlotAvailabilityResponse$1 as GetSlotAvailabilityResponse,
      BookingPolicySettings$2 as BookingPolicySettings,
      GetScheduleAvailabilityRequest$1 as GetScheduleAvailabilityRequest,
      GetScheduleAvailabilityResponse$1 as GetScheduleAvailabilityResponse,
      ScheduleAvailability$1 as ScheduleAvailability,
      bookingsAvailabilityV1SlotAvailability_universal_d_CalculateMultiSlotAvailabilityRequest as CalculateMultiSlotAvailabilityRequest,
      bookingsAvailabilityV1SlotAvailability_universal_d_RuleBasedConstraints as RuleBasedConstraints,
      bookingsAvailabilityV1SlotAvailability_universal_d_ResourcesFilter as ResourcesFilter,
      bookingsAvailabilityV1SlotAvailability_universal_d_CalculateMultiSlotAvailabilityResponse as CalculateMultiSlotAvailabilityResponse,
      CursorPagingMetadata$b as CursorPagingMetadata,
      GetAvailabilityTimeSlotRequest$3 as GetAvailabilityTimeSlotRequest,
      bookingsAvailabilityV1SlotAvailability_universal_d_TimeSlotLocation as TimeSlotLocation,
      LocationLocationType$2 as LocationLocationType,
      GetAvailabilityTimeSlotResponse$3 as GetAvailabilityTimeSlotResponse,
      TimeSlot$3 as TimeSlot,
      EventInfo$3 as EventInfo,
      bookingsAvailabilityV1SlotAvailability_universal_d_Service_availabilityWaitingList as Service_availabilityWaitingList,
      bookingsAvailabilityV1SlotAvailability_universal_d_Service_availabilityBookingPolicyViolations as Service_availabilityBookingPolicyViolations,
      AvailableResources$4 as AvailableResources,
      Resource$7 as Resource,
      bookingsAvailabilityV1SlotAvailability_universal_d_Service_availabilityNestedTimeSlot as Service_availabilityNestedTimeSlot,
      bookingsAvailabilityV1SlotAvailability_universal_d_queryAvailability as queryAvailability,
      bookingsAvailabilityV1SlotAvailability_universal_d_QueryAvailabilityOptions as QueryAvailabilityOptions,
      getSlotAvailability$1 as getSlotAvailability,
      GetSlotAvailabilityOptions$1 as GetSlotAvailabilityOptions,
      getScheduleAvailability$1 as getScheduleAvailability,
      bookingsAvailabilityV1SlotAvailability_universal_d_GetScheduleAvailabilityOptions as GetScheduleAvailabilityOptions,
      bookingsAvailabilityV1SlotAvailability_universal_d_calculateMultiSlotAvailability as calculateMultiSlotAvailability,
      bookingsAvailabilityV1SlotAvailability_universal_d_CalculateMultiSlotAvailabilityOptions as CalculateMultiSlotAvailabilityOptions,
      getAvailabilityTimeSlot$1 as getAvailabilityTimeSlot,
      GetAvailabilityTimeSlotOptions$1 as GetAvailabilityTimeSlotOptions,
    };
  }
  
  /**
   * The `TimeSlot` object represents the availability information
   * for an `Appointment` service's specific slot, including:
   *
   * 1. Whether the slot is bookable for the given service?
   *
   * 2. In what location the service is available for this slot?
   *
   * 3. Which available resources can provide the service for this slot?
   *
   * 4. Does booking the slot for the service violates any of the service booking policies?
   *
   * 5. What is the total capacity and remaining capacity of the service at the time of the calculation of the `TimeSlot`?
   *
   * > __Note:__
   * > When the `TimeSlot` has a non empty `NestedTimeSlots`, it represents the availability information
   * > for a given list of `Appointment` services within a specific time slot.
   */
  interface TimeSlot$2 {
      /**
       * Service ID.
       *
       * > Not returned from `MultiServiceAvailabilityTimeSlots` API calls.
       * > Instead, each nested time slot has its own serviceId.
       */
      serviceId?: string | null;
      /**
       * Local start date of the time slot in ISO-8601 format.
       * For example, "2024-01-30T13:30:00".
       */
      localStartDate?: string | null;
      /**
       * Local end date of the time slot in ISO-8601 format.
       * For example, "2024-01-30T14:30:00".
       */
      localEndDate?: string | null;
      /**
       * Whether the slot is bookable according to the service's booking policies.
       *
       * If booking this time slot does not violates any of the service's booking policies,
       * the returned value is `true`. Otherwise, returns `false`.
       */
      bookable?: boolean | null;
      /** The geographic location of the slot. */
      location?: Location$9;
      /**
       * Returned only for event.
       * @internal
       */
      eventInfo?: EventInfo$2;
      /** Total number of spots for the slot. */
      totalCapacity?: number | null;
      /**
       * Remaining number of spots for the slot.
       * For example, for an appointment service with total capacity of 1 spot and one booked spot, the remaining capacity will be 0.
       */
      remainingCapacity?: number | null;
      /**
       * Indicators for booking policy violations for the slot.
       *
       * Each nested field is checked on its own. i.e. if `tooEarlyToBook` is defined and `bookOnlineDisabled` is not defined
       * we will return also slots for which `tooEarlyToBook` is same as on the request, regardless of `bookOnlineDisabled`.
       */
      bookingPolicyViolations?: BookingPolicyViolations$3;
      /**
       * List of `AvailableResources` for the time slot.
       * Each `AvailableResources` contains information about available resources of the same type.
       *
       * > Not returned from `MultiServiceAvailabilityTimeSlots` API calls.
       * > Instead, each nested time slot has its own available resources.
       */
      availableResources?: AvailableResources$3[];
      /**
       * > Nested time slots.
       * > Returned only from `MultiServiceAvailabilityTimeSlots` API calls.
       */
      nestedTimeSlots?: NestedTimeSlot$2[];
  }
  interface Location$9 {
      /** Business Location ID. Present only if the location is a business location. */
      _id?: string | null;
      /** The location name. */
      name?: string | null;
      /** A string representation for the full address of the location. */
      formattedAddress?: string | null;
      /**
       * The type of location:
       * - `CUSTOM`: The location is specific to this service, and is not derived from the business location.
       * - `BUSINESS`: A business location, either the default business address, or locations defined for the business by the Business Info.
       * - `CUSTOMER`: The location is determined by the customer and is not set up beforehand.
       */
      locationType?: LocationType$9;
  }
  enum LocationType$9 {
      UNKNOWN_LOCATION_TYPE = "UNKNOWN_LOCATION_TYPE",
      /** A business location, either the default business address, or locations defined for the business by the Business Info. */
      BUSINESS = "BUSINESS",
      /** The location is unique to this service and isn't defined as one of the business locations. */
      CUSTOM = "CUSTOM",
      /** The location can be determined by the customer and is not set up beforehand. */
      CUSTOMER = "CUSTOMER"
  }
  /** relevant for event based slots, and not for availability based slots */
  interface EventInfo$2 {
      /**
       * TODO: format - might not be a guid?
       * @internal
       */
      eventId?: string | null;
      /** @internal */
      waitingList?: WaitingList$3;
  }
  interface WaitingList$3 {
      /** Total number of spots in this wait list. */
      totalCapacity?: number | null;
      /**
       * Number of remaining spots for this wait list.
       * For example, a Yoga event with 10 waitList spots and 3 registered
       * on the waitList has 10 `total_capacity` and 7 `remaining_capacity`.
       */
      remainingCapacity?: number | null;
  }
  interface BookingPolicyViolations$3 {
      /** Bookings policy violation. Too early to book this slot. */
      tooEarlyToBook?: boolean | null;
      /** Bookings policy violation. Too late to book this slot. */
      tooLateToBook?: boolean | null;
      /** Bookings policy violation. Online booking is disabled for the `TimeSlot` service. */
      bookOnlineDisabled?: boolean | null;
  }
  interface AvailableResources$3 {
      /** Resource type ID. */
      resourceTypeId?: string | null;
      /**
       * Available resources for the time slot.
       *
       * + When returned from `ListAvailabilityTimeSlots`, empty by default.
       * + + If you provided `includeResourceTypeIds` or  `resourceIds` in request,
       * contains __up__ to 10 available resources out of those provided.
       *
       * + When returned from `GetAvailabilityTimeSlots`, contains all available resources by default.
       * + + If you provided `includeResourceTypeIds` or  `resourceIds` in request,
       * contains all of the available resources out of those provided.
       *
       *
       * > + When returned from `ListMultiServiceAvailabilityTimeSlots`, empty by default.
       * > + + If you provided `includeResourceTypeIds` or  `resourceIds` in request,
       * > contains __up__ to 10 available resources out of those provided.
       *
       * > + When returned from `GetMultiServiceAvailabilityTimeSlots`, contains all available resources by default.
       * > + + If you provided `includeResourceTypeIds` or  `resourceIds` in request,
       * > contains all of the available resources out of those provided.
       */
      resources?: Resource$6[];
      /**
       * The required number of resources of this type in order to book the service.
       * For example, a slot for a service that provides a double massage
       * requires two resources of type `Staff Member` and one resource of type `Room`.
       * @internal
       */
      numberOfResourcesRequired?: number | null;
      /**
       * Whether there are more available resources for the slot that are not listed in `resources` due to size limitations.
       * @readonly
       */
      hasMoreAvailableResources?: boolean | null;
  }
  interface Resource$6 {
      /** Resource ID. */
      _id?: string;
      /** Resource name. */
      name?: string | null;
  }
  interface NestedTimeSlot$2 {
      /** Service ID of the nested time slot. */
      serviceId?: string;
      /**
       * Local start date of the nested time slot in ISO-8601 format.
       * For example, "2024-01-30T13:30:00".
       */
      localStartDate?: string;
      /**
       * Local end date of the nested time slot in ISO-8601 format.
       * For example, "2024-01-30T14:30:00".
       */
      localEndDate?: string;
      /**
       * List of `AvailableResources` for the nested time slot.
       * Each `AvailableResources` contains information about available resources of the same type.
       */
      availableResources?: AvailableResources$3[];
  }
  interface CalculateEventBasedAvailabilityRequest$2 {
      serviceIds: string[];
      from: string;
      to: string;
      timeZone: string;
      /**
       * TODO good definition of what bookable means https://github.com/wix-private/scheduler/pull/18267/files?file-filters%5B%5D=.proto&show-viewed-files=true#r1199809006
       * TODO: Locks are not taken into account. // Class is not supported yet. (relevant only for classes with waiting list)
       * Aliza's suggestion to consider locks in bookable
       */
      bookable?: boolean | null;
      /** support filtering by location type, or by locationId. Other fields like `name` are ignored */
      location?: Location$9[];
      resourceIds?: string[];
      /** if not empty, return slots with openSpots >= X */
      openSpots?: number | null;
      /**
       * each nested field is checked on its own. i.e. if `too_early_to_book` is defined and `too_late_to_book` is not defined
       * we will return slots for which `too_early_to_book` is same as on the request, regardless of `too_late_to_book`.
       */
      bookingPolicyViolations?: BookingPolicyViolations$3;
      /**
       * Maximum number of slots to load for each date. For example, if `slots_per_day` is set to `3`,
       * at most 3 available slots are returned for each day in the date range specified in the query's
       * `filter`.
       *
       * When a day has both bookable and non-bookable slots, bookable slots are returned first.
       * Non-bookable slots are returned according to the specified filters, after all
       * bookable slots are already included.
       */
      slotsPerDay?: number | null;
      cursorPaging?: CursorPaging$c;
  }
  interface CursorPaging$c {
      /** Maximum number of items to return in the results. */
      limit?: number | null;
      /**
       * Pointer to the next or previous page in the list of results.
       *
       * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
       * Not relevant for the first request.
       */
      cursor?: string | null;
  }
  interface CalculateEventBasedAvailabilityResponse$2 {
      slots?: TimeSlot$2[];
      cursorPagingMetadata?: CursorPagingMetadata$a;
  }
  interface CursorPagingMetadata$a {
      /** Number of items returned in the response. */
      count?: number | null;
      /** Cursor strings that point to the next page, previous page, or both. */
      cursors?: Cursors$d;
      /**
       * Whether there are more pages to retrieve following the current page.
       *
       * + `true`: Another page of results can be retrieved.
       * + `false`: This is the last page.
       */
      hasNext?: boolean | null;
  }
  interface Cursors$d {
      /** Cursor string pointing to the next page in the list of results. */
      next?: string | null;
      /** Cursor pointing to the previous page in the list of results. */
      prev?: string | null;
  }
  interface ListEventTimeSlotsRequest$2 {
      /** The services for which the time slots are being returned. */
      serviceIds: string[] | null;
      /**
       * Local start date for which event time slots are returned, in ISO-8601 format.
       * E.g, "2024-01-30T13:30:00".
       * Required, unless `cursorPaging` is provided.
       */
      fromLocalDate: string | null;
      /**
       * Local end date for which event time slots are returned, in ISO-8601 format.
       * E.g, "2024-01-30T13:30:00".
       * Required, unless `cursorPaging` is provided.
       */
      toLocalDate: string | null;
      /**
       * The time zone, in IANA time zone format.
       * Default is the Wix Business time zone.
       */
      timeZone: string | null;
      /** TODO good definition of what bookable means https://github.com/wix-private/scheduler/pull/18267/files?file-filters%5B%5D=.proto&show-viewed-files=true#r1199809006 */
      bookable?: boolean | null;
      /** support filtering by location type, or by locationId. Other fields like `name` are ignored */
      location?: Location$9[];
      /** TODO: maxsize && do we need include_resource_type_id here? also is the behavior is the same as availabilityTimeSlots, we won't return resources by default? */
      resourceIds?: string[] | null;
      /** if not empty, return slots with remainingCapacity >= X */
      remainingCapacity?: number | null;
      /**
       * each nested field is checked on its own. i.e. if `too_early_to_book` is defined and `too_late_to_book` is not defined
       * we will return slots for which `too_early_to_book` is same as on the request, regardless of `too_late_to_book`.
       */
      bookingPolicyViolations?: BookingPolicyViolations$3;
      /**
       * Maximum number of slots to load for each date. For example, if `slots_per_day` is set to `3`,
       * at most 3 available slots are returned for each day in the date range specified in the query's
       * `filter`.
       *
       * When a day has both bookable and non-bookable slots, bookable slots are returned first.
       * Non-bookable slots are returned according to the specified filters, after all
       * bookable slots are already included.
       */
      timeSlotsPerDay?: number | null;
      cursorPaging?: CursorPaging$c;
  }
  interface ListEventTimeSlotsResponse$2 {
      /** TODO: maxsize */
      timeSlots?: TimeSlot$2[];
      /** The time zone, in IANA time zone format. */
      timeZone?: string | null;
      cursorPagingMetadata?: CursorPagingMetadata$a;
  }
  interface ListMultiServiceAvailabilityTimeSlotsRequest$2 {
      /**
       * Services for which the multiService time slots are being returned for.
       * Each service contains its own resources filters within.
       *
       * MinSize: `2`.
       * MaxSize: `8`.
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      services?: Service$4[];
      /**
       * Lower boundary for `localStartDate` to include in response, in ISO-8601 format.
       * For example, "2024-01-30T13:30:00".
       *
       * Each returned `TimeSlot` in response has a `localStartDate`
       * within the provided `fromLocalDate` and `toLocalDate` exclusive.
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      fromLocalDate?: string | null;
      /**
       * Upper boundary for `localStartDate` to include in response, in ISO-8601 format.
       * For example, "2024-01-30T14:30:00".
       *
       * Each returned `TimeSlot` in response has a `localStartDate`
       * within the provided `fromLocalDate` and `toLocalDate` exclusive.
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      toLocalDate?: string | null;
      /**
       * Time zone, in IANA time zone format.
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      timeZone?: string | null;
      /**
       * Location for which the multiService TimeSlots are being returned for.
       *
       * You can specify location or location type for which the TimeSlots will be returned for.
       * If locationType is `BUSINESS`, you __must__ provide a locationId.
       *
       * <blockquote class="warning">
       * <p><strong>warning:</strong><br/>
       * Supports filtering by location type, or by location ID. </br>
       * Other fields like <code class="grey-background">name</code> are ignored.</p>
       * </blockquote>
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      location?: Location$9;
      /**
       * Whether the `TimeSlot` is bookable according to all of the services booking policies.
       *
       * If booking any of the `TimeSlot`.`NestedTimeSlot`s violates any of its services bookings policies,
       * returns as `false`. Otherwise, returns as `true`.
       *
       * > __Note:__
       * > A `TimeSlot` with a `NestedTimeSlot` that doesn't meet its service's bookings policies will be returned with `bookable` = false,
       * > while a `TimeSlot` with no available resources will not be returned at all.
       */
      bookable?: boolean | null;
      /**
       * Indicators for service's booking policy violations for booking the `TimeSlot`.
       *
       * A bookable time slot must not violate any policy,
       * therefor, this filter is only relevant when `bookable` filter is false.
       *
       * Each nested field is checked on all `NestedTimeSlot`s. For example, if only one of the `NestedTimeSlot`'s
       * has a service with `tooEarlyToBook` same as in the request, we return the `TimeSlot` regardless of whether
       * the other `NestedTimeSlots` has the same `tooEarlyToBook` as in request.
       *
       * Each nested field is checked on its own. For example, if `tooEarlyToBook` is defined and `bookOnlineDisabled` is not defined
       * we return slots for which `tooEarlyToBook` is same as on the request, regardless of `bookOnlineDisabled`.
       */
      bookingPolicyViolations?: BookingPolicyViolations$3;
      /**
       * Maximum number of slots to load for each day. For example, if `timeSlotsPerDay` is set to `3`,
       * we return at most 3 available TimeSlots for each day within the date range specified in request.
       *
       * By default,
       * if `bookable` filter was not specified,
       * and a day has both `bookable` and `un-bookable` slots, `bookable` slots are returned first.
       *
       * If the number of `bookable` slots is less than the requested `timeSlotsPerDay`,
       * `un-bookable` slots will be returned according to the specified filters.
       */
      timeSlotsPerDay?: number | null;
      /**
       * CursorPaging.
       *
       * Enables you to fetch TimeSlots in smaller, more manageable chunks
       * by setting a limit on the number of results returned in response.
       * This is useful in order to enhance efficiency of data retrieval and reduce load on both the client and server.
       *
       * If there are more results than the specified limit, the response will contain a `cursorPagingMetaData`
       * with a cursor pointing to next page of results. In order to fetch the next page of results, you should pass the
       * returned cursor to the next call as `cursorPaging`.`cursor`.
       *
       * For the first call, you should only specify the `limit` for the results page.
       * For each following call, you should only pass the previous returned cursor as `cursorPaging`.`cursor`
       * the `cursorPaging`.`limit`. You may pass a different `limit`.
       * No need to specify any additional parameters.
       *
       * <blockquote class="important">
       * <p><strong>Important:</strong><br/>
       * If you only provide a <code class="grey-background">cursorPaging</code>. <code class="grey-background">cursor</code>,
       * the response will contain the default size of results which is `1000`.
       * </p>
       * </blockquote>
       */
      cursorPaging?: CommonCursorPaging$2;
  }
  interface Service$4 {
      /** Service ID. */
      serviceId?: string;
      /** Resources to include in response. */
      resourceIds?: string[];
      /**
       * The resource type ID's to include in returned time slots.
       * This is in addition to the specifically requested resources.
       *
       * <blockquote class="important">
       * Currently supported only for Staff Member resource type.
       * Staff Member type ID: 1cd44cf8-756f-41c3-bd90-3e2ffcaf1155
       * </blockquote>
       */
      includeResourceTypeIds?: string[];
  }
  interface CommonCursorPaging$2 {
      /**
       * Number of results to load.
       *
       * Default: `1000`.
       * Max: `1000`.
       */
      limit?: number | null;
      /**
       * Pointer to the next or previous page in the list of results.
       *
       * You can get the relevant cursor token
       * from the `pagingMetadata` object in the previous call's response.
       * Not relevant for the first request.
       */
      cursor?: string | null;
  }
  interface ListMultiServiceAvailabilityTimeSlotsResponse$2 {
      /** Time slots. */
      timeSlots?: TimeSlot$2[];
      /**
       * Time zone, in IANA time zone format.
       * Shared for all TimeSlots in response.
       */
      timeZone?: string | null;
      /**
       * CursorPagingMetaData.
       * Contains information about the next page of results.
       *
       * By default,
       * if there are more than 1000 results,
       * the response will contain a `cursorPagingMetaData` with a cursor to the next page of results.
       *
       * <blockquote class="important">
       * <p><strong>Important:</strong><br/>
       * <code class="grey-background">count</code> is not supported.</p>
       * </blockquote>
       */
      cursorPagingMetadata?: CommonCursorPagingMetadata$2;
  }
  interface CommonCursorPagingMetadata$2 {
      /** Offset that was requested. */
      cursors?: CommonCursors$2;
      /**
       * Indicates if there are more results after the current page.
       * If `true`, another page of results can be retrieved.
       * If `false`, this is the last page.
       */
      hasNext?: boolean | null;
  }
  interface CommonCursors$2 {
      /** Cursor pointing to next page in the list of results. */
      next?: string | null;
      /** Cursor pointing to previous page in the list of results. */
      prev?: string | null;
  }
  interface GetMultiServiceAvailabilityTimeSlotRequest$2 {
      /**
       * Services for which the multiService TimeSlots are being returned for.
       * Each service contains its own resources filters within.
       *
       * MinSize: 2.
       * MaxSize: 8.
       */
      services: Service$4[];
      /**
       * Local start date of the time slot, in ISO-8601 format.
       * For example, "2024-01-30T13:30:00".
       */
      localStartDate: string;
      /**
       * Local end date of the time slot, in ISO-8601 format.
       * For example, "2024-01-30T14:30:00".
       */
      localEndDate: string;
      /** Time zone, in IANA time zone format. */
      timeZone: string | null;
      /**
       * The location of the time slot.
       *
       * You must provide a specific `locationType`.
       * If locationType is `BUSINESS`, you __must__ also provide a `locationId`.
       *
       * <blockquote class="warning">
       * <p>Supports filtering by location type, or by location ID.
       * Other fields like <code class="grey-background">name</code> are ignored.</p>
       * </blockquote>
       */
      location: Location$9;
  }
  interface GetMultiServiceAvailabilityTimeSlotResponse$2 {
      /** Time slot. */
      timeSlot?: TimeSlot$2;
      /** The time zone, in IANA time zone format. */
      timeZone?: string | null;
  }
  interface ListAvailabilityTimeSlotsRequest$2 {
      /**
       * Service ID for which the time slots are being returned for.
       * Currently supported only for services of type `APPOINTMENT`.
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      serviceId?: string | null;
      /**
       * Lower boundary for `localStartDate` to include in response, in ISO-8601 format.
       * For example, "2024-01-30T13:30:00".
       *
       * Each returned `TimeSlot` in response has a `localStartDate`
       * within the provided `fromLocalDate` and `toLocalDate` exclusive.
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      fromLocalDate?: string | null;
      /**
       * Upper boundary for `localStartDate` to include in response, in ISO-8601 format.
       * For example, "2024-01-30T14:30:00".
       *
       * Each returned `TimeSlot` in response has a `localStartDate`
       * within the provided `fromLocalDate` and `toLocalDate` exclusive.
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      toLocalDate?: string | null;
      /**
       * Time zone, in IANA time zone format.
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      timeZone?: string | null;
      /**
       * Locations to include in response.
       *
       * By default,
       * if no locations are provided,
       * the response contains TimeSlots for all locations where the service is available.
       *
       * You can specify locations or location types for which the time slots will be returned for.
       * If locationType is `BUSINESS`, you __must__ provide a locationId.
       *
       * <blockquote class="warning">
       * <p><strong>warning:</strong><br/>
       * Supports filtering by location type, or by location ID. </br>
       * Other fields like <code class="grey-background">name</code> are ignored.</p>
       * </blockquote>
       */
      locations?: Location$9[];
      /**
       * Resources to include in response.
       *
       * If specified,
       * the returned TimeSlots will contain __up__ to 10 available resources out of the provided list.
       * Otherwise, the returned TimeSlots returns with an empty `AvailableResources`.
       * @deprecated
       */
      resourceIds?: string[];
      /**
       * Resource type ID's to include in response, this is in addition to the requested `resourceIds`.
       *
       * If specified in request, the returned TimeSlots will contain __up__ to 10 `AvailableResources` with `ResourceTypeId`
       * out of those specified, each contains __up__ to 10 available resources of this type.
       */
      includeResourceTypeIds?: string[];
      /**
       * Whether the `TimeSlot` is bookable according to the service's booking policies.
       *
       * If booking this `TimeSlot` does not violates any of the service's booking policies,
       * returns as `true`. Otherwise, returns as `false`.
       *
       * > __Note:__
       * > A time slot that doesn't meet the service's bookings policies will be returned with `bookable` = false,
       * > while a time slot with no available resources will not be returned at all.
       */
      bookable?: boolean | null;
      /**
       * Indicators for service's booking policy violations for booking the `TimeSlot`.
       *
       * A bookable time slot must not violate any policy,
       * therefor, this filter is only relevant when `bookable` filter is false.
       *
       * Each nested field is checked on its own. i.e. if `tooEarlyToBook` is defined and `bookOnlineDisabled` is not defined
       * we return slots for which `tooEarlyToBook` is same as on the request, regardless of `bookOnlineDisabled`.
       */
      bookingPolicyViolations?: BookingPolicyViolations$3;
      /**
       * Maximum number of slots to load for each day. For example, if `timeSlotsPerDay` is set to `3`,
       * we return at most 3 available TimeSlots for each day within the date range specified in request.
       *
       * By default,
       * if `bookable` filter was not specified,
       * and a day has both `bookable` and `un-bookable` slots, `bookable` slots are returned first.
       *
       * If the number of `bookable` slots is less than the requested `timeSlotsPerDay`,
       * `un-bookable` slots will be returned according to the specified filters.
       */
      timeSlotsPerDay?: number | null;
      /**
       * CursorPaging.
       *
       * Enables you to fetch results in smaller, more manageable chunks
       * by setting a limit on the number of results returned in response.
       * This is useful in order to enhance efficiency of data retrieval and reduce load on both the client and server.
       *
       * If there are more results than the specified limit, the response will contain a `cursorPagingMetaData`
       * with a cursor pointing to next page of results. In order to fetch the next page of results, you should pass the
       * returned cursor to the next call as `cursorPaging`.`cursor`.
       *
       * For the first call, you should only specify the `limit` for the results page.
       * For each following call, you should only pass `cursorPaging`.`cursor` with the returned cursor from previous call, and
       * a `cursorPaging`.`limit`.
       * No need to specify any additional parameters.
       *
       * <blockquote class="important">
       * <p><strong>Important:</strong><br/>
       * If you only provide a <code class="grey-background">cursorPaging</code>. <code class="grey-background">cursor</code>,
       * the response will contain the default size of results which is `1000`.
       * </p>
       * </blockquote>
       */
      cursorPaging?: CommonCursorPaging$2;
      /**
       * Specifies whether to return all available resources in response.
       * @internal
       */
      shouldReturnAllResources?: boolean;
      /**
       * Selected customer choices.
       * If specified, the selected choices will be used to calculate service configuration.
       * If not specified, the service default configuration will be used.
       * Enforcing this field is the responsibility of the SPI implementer, and not by the Availability API.
       * @internal
       */
      customerChoices?: CustomerChoices$2;
      /**
       * resources filter
       * If specified, only time slots with these resources will be returned.
       */
      resourceTypes?: ResourceType$4[];
  }
  /**
   * Selected customer choices.
   * These choices are selected by the customer during the booking flow and can be utilized to calculate the corresponding service's configuration properties.
   */
  interface CustomerChoices$2 {
      /**
       * The selected customer duration in minutes.
       * Min: `1 minute`
       * Max: `44639 minutes` (30 days, 23 hours, and 59 minutes)
       */
      durationInMinutes?: number | null;
  }
  interface ResourceType$4 {
      /** Resource type ID. */
      resourceTypeId?: string | null;
      /**
       * Resource IDs.
       * The response will contain only slots that have at least one of the specified resources.
       */
      resourceIds?: string[] | null;
  }
  interface ListAvailabilityTimeSlotsResponse$2 {
      /** Time slots. */
      timeSlots?: TimeSlot$2[];
      /**
       * Time zone, in IANA time zone format.
       * Shared for all TimeSlots in response.
       */
      timeZone?: string | null;
      /**
       * CursorPagingMetaData.
       * Contains information about the next page of results.
       *
       * By default,
       * if there are more than 1000 results,
       * the response will contain a `cursorPagingMetaData` with a cursor to the next page of results.
       *
       * <blockquote class="important">
       * <p><strong>Important:</strong><br/>
       * <code class="grey-background">count</code> is not supported.</p>
       * </blockquote>
       */
      cursorPagingMetadata?: CommonCursorPagingMetadata$2;
  }
  interface GetAvailabilityTimeSlotRequest$2 {
      /**
       * Service ID of the time slot.
       * Currently supported only for services of type `APPOINTMENT`.
       */
      serviceId: string;
      /**
       * Local start date of the time slot, in ISO-8601 format.
       * For example, "2024-01-30T13:30:00".
       */
      localStartDate: string;
      /**
       * Local end date of the time slot, in ISO-8601 format.
       * For example, "2024-01-30T14:30:00".
       */
      localEndDate: string;
      /** Time zone, in IANA time zone format. */
      timeZone: string | null;
      /**
       * The location of the time slot.
       *
       * You must provide a specific `locationType`.
       * If locationType is `BUSINESS`, you __must__ also provide a `locationId`.
       *
       * <blockquote class="warning">
       * <p>Supports filtering by location type, or by location ID.
       * Other fields like <code class="grey-background">name</code> are ignored.</p>
       * </blockquote>
       */
      location: Location$9;
      /**
       * Resources to include in response.
       *
       * If specified,
       * the returned `TimeSlot` contains only the available resources out of provided list.
       * Otherwise, the returned `TimeSlot` returned with all possible `AvailableResources`.
       */
      resourceIds?: string[];
      /**
       * Resource type IDs to include in response, this is in addition to the requested `resourceIds`.
       *
       * If specified in request, the returned `TimeSlot` contains only the `AvailableResources` with `ResourceTypeId`
       * out of those specified, each contains all the available resources of this type.
       */
      includeResourceTypeIds?: string[];
  }
  interface GetAvailabilityTimeSlotResponse$2 {
      /** Time slot. */
      timeSlot?: TimeSlot$2;
      /** Time zone, in IANA time zone format. */
      timeZone?: string | null;
  }
  /**
   * Retrieves a list of `TimeSlot`s that match the provided filters.
   *
   * <blockquote class="important">
   * <p><strong>Important:</strong>
   * Currently supported only for services of type <code class="grey-background">APPOINTMENT</code>.</p>
   * </blockquote>
   *
   * The request body __must__ include either:
   * + All of the following filters:  `serviceId`, `fromLocalDate`, `toLocalDate`, and `timeZone`.
   * You may add additional filters as you wish.
   * + A `cursorPaging` with a valid `cursor` from previous response.
   *
   *
   * Each [TimeSlot](https://bo.wix.com/wix-docs/rest/all-apis/wix-service-availability/availability-time-slots/time-slot-object) in response
   * represents the availability of the service in a specific location,
   * and has a `localStartDate` within the range of the provided `fromLocalDate` and `toLocalDate` exclusive.
   * The `localEndDate` of a `TimeSlot` is calculated as the sum of the `TimeSlot`'s `localStartDate` and the duration of the service.
   *
   * By default,
   * the response contains at most 1000 results.
   * If there are more than 1000 results, we return a `cursorPagingMetadata` with
   * a cursor for the next page of results, regardless of whether a `cursorPaging`
   * was provided in request.
   *
   * ### AvailableResources in response
   * The `TimeSlot`'s `AvailableResources` contains information about the resources that are available to provide the service
   * within the time slot. Each `AvailableResources` contains information about available resources of the same type.
   *
   * <blockquote class="important">
   * <p><strong>Important:</strong><br/>
   * By default,
   * if you don't specify <code class="grey-background">includeResourceTypeIds</code>
   * or <code class="grey-background">resourceIds</code> filters in request,
   * we return TimeSlots with an empty <code class="grey-background">AvailableResources</code>.
   * <br/><strong>Note:</strong><br/> Not specifying resources filters can be handy in case you want to avoid large response in flows that only
   * interested of whether the time slots are available. [Finding the next available slot within the next 3 months](https://bo.wix.com/wix-docs/rest/all-apis/service-availability/availability-time-slots/sample-flows?localViewerId=inbari#all-apis_service-availability_availability-time-slots_sample-flows_find-the-first-date-within-the-next-3-months-that-the-selected-service-is-available-for)
   * is an example for such flow.
   * </p>
   * </blockquote>
   *
   * If you wish to get a list of available resources for each `TimeSlot` you should either:
   * + provide `resourceIds` in request.
   * + provide `includeResourceTypeIds` in request.
   *
   * __Notes:__
   * + In both cases the returned TimeSlots contains  __up__ to 10 `AvailableResources` that match the provided filters.
   * Each `AvailableResources` contains __up__ to 10 available `resources` of the same type that match the provided filters.
   * + If an `AvailableResources` has more available resources which are not listed within it,
   * we return `AvailableResources`.`hasMoreAvailableResources` as true.
   * > __Note:__
   * > If you wish to get the full available resources list for a specific `TimeSlot`,
   * > you should call [GetAvailabilityTimeSlot](https://bo.wix.com/wix-docs/rest/all-apis/wix-service-availability/service-availability-time-slots/get-availability-time-slot).
   *
   *
   * ### Availability VS Bookability
   * An `available` time slot is not necessarily `bookable`.
   * The `bookable` field of a `TimeSlot` indicates whether a customer can book the service within the given time slot,
   * at a specific period of time.
   * Read more about [Availability VS Bookability](https://bo.wix.com/wix-docs/rest/all-apis/wix-service-availability/service-availability-time-slots/introduction#all-apis_wix-service-availability_service-availability-time-slots_introduction_availability-vs-bookability).
   *
   * By default,
   * + The response does not contains `unavailable` TimeSlots.
   * For example,
   * if there are no available resources to provide the service from `2024-01-30T14:30:00` to `2024-01-30T15:30:00`,
   * we don't return TimeSlots with `localStartDate` within this range.
   * + The response contains both `bookable` and `un-bookable` TimeSlots.
   * For example,
   * if the service has a booking policy which enforces booking the service up to 10 minutes before the session starts,
   * we return TimeSlots with the violating `localStartDate` with `bookable` as false.
   * If you wish to list only available __bookable__ TimeSlots you should pass `bookable` filter as true.
   *
   * <blockquote class="important">
   * <p><strong>Important:</strong>
   * Because of DST, there are edge cases where certain times either do not exist or exist twice for a local time zone.
   * Read more about <a href="https://bo.wix.com/wix-docs/rest/all-apis/service-availability/availability-time-slots/introduction?localViewerId=inbari#all-apis_service-availability_availability-time-slots_introduction_daylight-saving-time-dst-handling">DST Handling</a></p>
   * </blockquote>
   *
   *
   * ### ListAvailabilityTimeSlots runs with the following defaults
   * + `localStartDate` is sorted in `ASC` order
   * + `cursorPaging`.`limit` is `1000`
   * @public
   * @documentationMaturity preview
   * @permissionId BOOKINGS.AVAILABILITY_READ_TIME_SLOTS
   */
  function listAvailabilityTimeSlots(options?: ListAvailabilityTimeSlotsOptions): Promise<ListAvailabilityTimeSlotsResponse$2>;
  interface ListAvailabilityTimeSlotsOptions {
      /**
       * Service ID for which the time slots are being returned for.
       * Currently supported only for services of type `APPOINTMENT`.
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      serviceId?: string | null;
      /**
       * Lower boundary for `localStartDate` to include in response, in ISO-8601 format.
       * For example, "2024-01-30T13:30:00".
       *
       * Each returned `TimeSlot` in response has a `localStartDate`
       * within the provided `fromLocalDate` and `toLocalDate` exclusive.
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      fromLocalDate?: string | null;
      /**
       * Upper boundary for `localStartDate` to include in response, in ISO-8601 format.
       * For example, "2024-01-30T14:30:00".
       *
       * Each returned `TimeSlot` in response has a `localStartDate`
       * within the provided `fromLocalDate` and `toLocalDate` exclusive.
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      toLocalDate?: string | null;
      /**
       * Time zone, in IANA time zone format.
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      timeZone?: string | null;
      /**
       * Locations to include in response.
       *
       * By default,
       * if no locations are provided,
       * the response contains TimeSlots for all locations where the service is available.
       *
       * You can specify locations or location types for which the time slots will be returned for.
       * If locationType is `BUSINESS`, you __must__ provide a locationId.
       *
       * <blockquote class="warning">
       * <p><strong>warning:</strong><br/>
       * Supports filtering by location type, or by location ID. </br>
       * Other fields like <code class="grey-background">name</code> are ignored.</p>
       * </blockquote>
       */
      locations?: Location$9[];
      /**
       * Resources to include in response.
       *
       * If specified,
       * the returned TimeSlots will contain __up__ to 10 available resources out of the provided list.
       * Otherwise, the returned TimeSlots returns with an empty `AvailableResources`.
       * @deprecated
       */
      resourceIds?: string[];
      /**
       * Resource type ID's to include in response, this is in addition to the requested `resourceIds`.
       *
       * If specified in request, the returned TimeSlots will contain __up__ to 10 `AvailableResources` with `ResourceTypeId`
       * out of those specified, each contains __up__ to 10 available resources of this type.
       */
      includeResourceTypeIds?: string[];
      /**
       * Whether the `TimeSlot` is bookable according to the service's booking policies.
       *
       * If booking this `TimeSlot` does not violates any of the service's booking policies,
       * returns as `true`. Otherwise, returns as `false`.
       *
       * > __Note:__
       * > A time slot that doesn't meet the service's bookings policies will be returned with `bookable` = false,
       * > while a time slot with no available resources will not be returned at all.
       */
      bookable?: boolean | null;
      /**
       * Indicators for service's booking policy violations for booking the `TimeSlot`.
       *
       * A bookable time slot must not violate any policy,
       * therefor, this filter is only relevant when `bookable` filter is false.
       *
       * Each nested field is checked on its own. i.e. if `tooEarlyToBook` is defined and `bookOnlineDisabled` is not defined
       * we return slots for which `tooEarlyToBook` is same as on the request, regardless of `bookOnlineDisabled`.
       */
      bookingPolicyViolations?: BookingPolicyViolations$3;
      /**
       * Maximum number of slots to load for each day. For example, if `timeSlotsPerDay` is set to `3`,
       * we return at most 3 available TimeSlots for each day within the date range specified in request.
       *
       * By default,
       * if `bookable` filter was not specified,
       * and a day has both `bookable` and `un-bookable` slots, `bookable` slots are returned first.
       *
       * If the number of `bookable` slots is less than the requested `timeSlotsPerDay`,
       * `un-bookable` slots will be returned according to the specified filters.
       */
      timeSlotsPerDay?: number | null;
      /**
       * CursorPaging.
       *
       * Enables you to fetch results in smaller, more manageable chunks
       * by setting a limit on the number of results returned in response.
       * This is useful in order to enhance efficiency of data retrieval and reduce load on both the client and server.
       *
       * If there are more results than the specified limit, the response will contain a `cursorPagingMetaData`
       * with a cursor pointing to next page of results. In order to fetch the next page of results, you should pass the
       * returned cursor to the next call as `cursorPaging`.`cursor`.
       *
       * For the first call, you should only specify the `limit` for the results page.
       * For each following call, you should only pass `cursorPaging`.`cursor` with the returned cursor from previous call, and
       * a `cursorPaging`.`limit`.
       * No need to specify any additional parameters.
       *
       * <blockquote class="important">
       * <p><strong>Important:</strong><br/>
       * If you only provide a <code class="grey-background">cursorPaging</code>. <code class="grey-background">cursor</code>,
       * the response will contain the default size of results which is `1000`.
       * </p>
       * </blockquote>
       */
      cursorPaging?: CommonCursorPaging$2;
      /**
       * Specifies whether to return all available resources in response.
       * @internal
       */
      shouldReturnAllResources?: boolean;
      /**
       * Selected customer choices.
       * If specified, the selected choices will be used to calculate service configuration.
       * If not specified, the service default configuration will be used.
       * Enforcing this field is the responsibility of the SPI implementer, and not by the Availability API.
       * @internal
       */
      customerChoices?: CustomerChoices$2;
      /**
       * resources filter
       * If specified, only time slots with these resources will be returned.
       */
      resourceTypes?: ResourceType$4[];
  }
  /**
   * Retrieves an available `TimeSlot` that match the provided filters.
   *
   * Throws `SlotNotFound` if there is no such available time slot.
   *
   * <blockquote class="important">
   * <p><strong>Important:</strong><br/>
   * Currently supported only for services of type <code class="grey-background">APPOINTMENT</code>.</p>
   * </blockquote>
   *
   * By default,
   * if you don't provide `includeResourceTypeIds` or `resourceIds` in request,
   * we return all `AvailableResources` with all `AvailableResources`.`resources` which are available to provide
   * the service within the time slot.
   *
   * If you specify `includeResourceTypeIds` or `resourceIds` in request,
   * the returned `TimeSlot` will contain only `AvailableResources` with at least one available resource
   * which match the given resources filters,
   * each contains all available resources out of those requested.
   *
   *
   * <blockquote class="tip">
   * <p><strong>Tip:</strong><br/>
   * Use this API in order to get the availability of a specific <code class="grey-background">TimeSlot</code> out of those returned from  <code class="grey-background">ListAvailabilityTimeSlots</code> API.</p>
   * </blockquote>
   * @param serviceId - Service ID of the time slot.
   * Currently supported only for services of type `APPOINTMENT`.
   * @param localStartDate - Local start date of the time slot, in ISO-8601 format.
   * For example, "2024-01-30T13:30:00".
   * @param localEndDate - Local end date of the time slot, in ISO-8601 format.
   * For example, "2024-01-30T14:30:00".
   * @param timeZone - Time zone, in IANA time zone format.
   * @param location - The location of the time slot.
   *
   * You must provide a specific `locationType`.
   * If locationType is `BUSINESS`, you __must__ also provide a `locationId`.
   *
   * <blockquote class="warning">
   * <p>Supports filtering by location type, or by location ID.
   * Other fields like <code class="grey-background">name</code> are ignored.</p>
   * </blockquote>
   * @public
   * @documentationMaturity preview
   * @requiredField localEndDate
   * @requiredField localStartDate
   * @requiredField location
   * @requiredField serviceId
   * @requiredField timeZone
   * @permissionId BOOKINGS.AVAILABILITY_READ_TIME_SLOTS
   */
  function getAvailabilityTimeSlot(serviceId: string, localStartDate: string, localEndDate: string, timeZone: string | null, location: Location$9, options?: GetAvailabilityTimeSlotOptions): Promise<GetAvailabilityTimeSlotResponse$2>;
  interface GetAvailabilityTimeSlotOptions {
      /**
       * Resources to include in response.
       *
       * If specified,
       * the returned `TimeSlot` contains only the available resources out of provided list.
       * Otherwise, the returned `TimeSlot` returned with all possible `AvailableResources`.
       */
      resourceIds?: string[];
      /**
       * Resource type IDs to include in response, this is in addition to the requested `resourceIds`.
       *
       * If specified in request, the returned `TimeSlot` contains only the `AvailableResources` with `ResourceTypeId`
       * out of those specified, each contains all the available resources of this type.
       */
      includeResourceTypeIds?: string[];
  }
  
  const bookingsAvailabilityV2TimeSlotAvailabilityTimeSlots_universal_d_listAvailabilityTimeSlots: typeof listAvailabilityTimeSlots;
  type bookingsAvailabilityV2TimeSlotAvailabilityTimeSlots_universal_d_ListAvailabilityTimeSlotsOptions = ListAvailabilityTimeSlotsOptions;
  const bookingsAvailabilityV2TimeSlotAvailabilityTimeSlots_universal_d_getAvailabilityTimeSlot: typeof getAvailabilityTimeSlot;
  type bookingsAvailabilityV2TimeSlotAvailabilityTimeSlots_universal_d_GetAvailabilityTimeSlotOptions = GetAvailabilityTimeSlotOptions;
  namespace bookingsAvailabilityV2TimeSlotAvailabilityTimeSlots_universal_d {
    export {
      TimeSlot$2 as TimeSlot,
      Location$9 as Location,
      LocationType$9 as LocationType,
      EventInfo$2 as EventInfo,
      WaitingList$3 as WaitingList,
      BookingPolicyViolations$3 as BookingPolicyViolations,
      AvailableResources$3 as AvailableResources,
      Resource$6 as Resource,
      NestedTimeSlot$2 as NestedTimeSlot,
      CalculateEventBasedAvailabilityRequest$2 as CalculateEventBasedAvailabilityRequest,
      CursorPaging$c as CursorPaging,
      CalculateEventBasedAvailabilityResponse$2 as CalculateEventBasedAvailabilityResponse,
      CursorPagingMetadata$a as CursorPagingMetadata,
      Cursors$d as Cursors,
      ListEventTimeSlotsRequest$2 as ListEventTimeSlotsRequest,
      ListEventTimeSlotsResponse$2 as ListEventTimeSlotsResponse,
      ListMultiServiceAvailabilityTimeSlotsRequest$2 as ListMultiServiceAvailabilityTimeSlotsRequest,
      Service$4 as Service,
      CommonCursorPaging$2 as CommonCursorPaging,
      ListMultiServiceAvailabilityTimeSlotsResponse$2 as ListMultiServiceAvailabilityTimeSlotsResponse,
      CommonCursorPagingMetadata$2 as CommonCursorPagingMetadata,
      CommonCursors$2 as CommonCursors,
      GetMultiServiceAvailabilityTimeSlotRequest$2 as GetMultiServiceAvailabilityTimeSlotRequest,
      GetMultiServiceAvailabilityTimeSlotResponse$2 as GetMultiServiceAvailabilityTimeSlotResponse,
      ListAvailabilityTimeSlotsRequest$2 as ListAvailabilityTimeSlotsRequest,
      CustomerChoices$2 as CustomerChoices,
      ResourceType$4 as ResourceType,
      ListAvailabilityTimeSlotsResponse$2 as ListAvailabilityTimeSlotsResponse,
      GetAvailabilityTimeSlotRequest$2 as GetAvailabilityTimeSlotRequest,
      GetAvailabilityTimeSlotResponse$2 as GetAvailabilityTimeSlotResponse,
      bookingsAvailabilityV2TimeSlotAvailabilityTimeSlots_universal_d_listAvailabilityTimeSlots as listAvailabilityTimeSlots,
      bookingsAvailabilityV2TimeSlotAvailabilityTimeSlots_universal_d_ListAvailabilityTimeSlotsOptions as ListAvailabilityTimeSlotsOptions,
      bookingsAvailabilityV2TimeSlotAvailabilityTimeSlots_universal_d_getAvailabilityTimeSlot as getAvailabilityTimeSlot,
      bookingsAvailabilityV2TimeSlotAvailabilityTimeSlots_universal_d_GetAvailabilityTimeSlotOptions as GetAvailabilityTimeSlotOptions,
    };
  }
  
  /**
   * The `TimeSlot` object represents the availability information
   * for an `Appointment` service's specific slot, including:
   *
   * 1. Whether the slot is bookable for the given service?
   *
   * 2. In what location the service is available for this slot?
   *
   * 3. Which available resources can provide the service for this slot?
   *
   * 4. Does booking the slot for the service violates any of the service booking policies?
   *
   * 5. What is the total capacity and remaining capacity of the service at the time of the calculation of the `TimeSlot`?
   *
   * > __Note:__
   * > When the `TimeSlot` has a non empty `NestedTimeSlots`, it represents the availability information
   * > for a given list of `Appointment` services within a specific time slot.
   */
  interface TimeSlot$1 {
      /**
       * Service ID.
       *
       * > Not returned from `MultiServiceAvailabilityTimeSlots` API calls.
       * > Instead, each nested time slot has its own serviceId.
       */
      serviceId?: string | null;
      /**
       * Local start date of the time slot in ISO-8601 format.
       * For example, "2024-01-30T13:30:00".
       */
      localStartDate?: string | null;
      /**
       * Local end date of the time slot in ISO-8601 format.
       * For example, "2024-01-30T14:30:00".
       */
      localEndDate?: string | null;
      /**
       * Whether the slot is bookable according to the service's booking policies.
       *
       * If booking this time slot does not violates any of the service's booking policies,
       * the returned value is `true`. Otherwise, returns `false`.
       */
      bookable?: boolean | null;
      /** The geographic location of the slot. */
      location?: Location$8;
      /**
       * Returned only for event.
       * @internal
       */
      eventInfo?: EventInfo$1;
      /** Total number of spots for the slot. */
      totalCapacity?: number | null;
      /**
       * Remaining number of spots for the slot.
       * For example, for an appointment service with total capacity of 1 spot and one booked spot, the remaining capacity will be 0.
       */
      remainingCapacity?: number | null;
      /**
       * Indicators for booking policy violations for the slot.
       *
       * Each nested field is checked on its own. i.e. if `tooEarlyToBook` is defined and `bookOnlineDisabled` is not defined
       * we will return also slots for which `tooEarlyToBook` is same as on the request, regardless of `bookOnlineDisabled`.
       */
      bookingPolicyViolations?: BookingPolicyViolations$2;
      /**
       * List of `AvailableResources` for the time slot.
       * Each `AvailableResources` contains information about available resources of the same type.
       *
       * > Not returned from `MultiServiceAvailabilityTimeSlots` API calls.
       * > Instead, each nested time slot has its own available resources.
       */
      availableResources?: AvailableResources$2[];
      /**
       * > Nested time slots.
       * > Returned only from `MultiServiceAvailabilityTimeSlots` API calls.
       */
      nestedTimeSlots?: NestedTimeSlot$1[];
  }
  interface Location$8 {
      /** Business Location ID. Present only if the location is a business location. */
      _id?: string | null;
      /** The location name. */
      name?: string | null;
      /** A string representation for the full address of the location. */
      formattedAddress?: string | null;
      /**
       * The type of location:
       * - `CUSTOM`: The location is specific to this service, and is not derived from the business location.
       * - `BUSINESS`: A business location, either the default business address, or locations defined for the business by the Business Info.
       * - `CUSTOMER`: The location is determined by the customer and is not set up beforehand.
       */
      locationType?: LocationType$8;
  }
  enum LocationType$8 {
      UNKNOWN_LOCATION_TYPE = "UNKNOWN_LOCATION_TYPE",
      /** A business location, either the default business address, or locations defined for the business by the Business Info. */
      BUSINESS = "BUSINESS",
      /** The location is unique to this service and isn't defined as one of the business locations. */
      CUSTOM = "CUSTOM",
      /** The location can be determined by the customer and is not set up beforehand. */
      CUSTOMER = "CUSTOMER"
  }
  /** relevant for event based slots, and not for availability based slots */
  interface EventInfo$1 {
      /**
       * TODO: format - might not be a guid?
       * @internal
       */
      eventId?: string | null;
      /** @internal */
      waitingList?: WaitingList$2;
  }
  interface WaitingList$2 {
      /** Total number of spots in this wait list. */
      totalCapacity?: number | null;
      /**
       * Number of remaining spots for this wait list.
       * For example, a Yoga event with 10 waitList spots and 3 registered
       * on the waitList has 10 `total_capacity` and 7 `remaining_capacity`.
       */
      remainingCapacity?: number | null;
  }
  interface BookingPolicyViolations$2 {
      /** Bookings policy violation. Too early to book this slot. */
      tooEarlyToBook?: boolean | null;
      /** Bookings policy violation. Too late to book this slot. */
      tooLateToBook?: boolean | null;
      /** Bookings policy violation. Online booking is disabled for the `TimeSlot` service. */
      bookOnlineDisabled?: boolean | null;
  }
  interface AvailableResources$2 {
      /** Resource type ID. */
      resourceTypeId?: string | null;
      /**
       * Available resources for the time slot.
       *
       * + When returned from `ListAvailabilityTimeSlots`, empty by default.
       * + + If you provided `includeResourceTypeIds` or  `resourceIds` in request,
       * contains __up__ to 10 available resources out of those provided.
       *
       * + When returned from `GetAvailabilityTimeSlots`, contains all available resources by default.
       * + + If you provided `includeResourceTypeIds` or  `resourceIds` in request,
       * contains all of the available resources out of those provided.
       *
       *
       * > + When returned from `ListMultiServiceAvailabilityTimeSlots`, empty by default.
       * > + + If you provided `includeResourceTypeIds` or  `resourceIds` in request,
       * > contains __up__ to 10 available resources out of those provided.
       *
       * > + When returned from `GetMultiServiceAvailabilityTimeSlots`, contains all available resources by default.
       * > + + If you provided `includeResourceTypeIds` or  `resourceIds` in request,
       * > contains all of the available resources out of those provided.
       */
      resources?: Resource$5[];
      /**
       * The required number of resources of this type in order to book the service.
       * For example, a slot for a service that provides a double massage
       * requires two resources of type `Staff Member` and one resource of type `Room`.
       * @internal
       */
      numberOfResourcesRequired?: number | null;
      /**
       * Whether there are more available resources for the slot that are not listed in `resources` due to size limitations.
       * @readonly
       */
      hasMoreAvailableResources?: boolean | null;
  }
  interface Resource$5 {
      /** Resource ID. */
      _id?: string;
      /** Resource name. */
      name?: string | null;
  }
  interface NestedTimeSlot$1 {
      /** Service ID of the nested time slot. */
      serviceId?: string;
      /**
       * Local start date of the nested time slot in ISO-8601 format.
       * For example, "2024-01-30T13:30:00".
       */
      localStartDate?: string;
      /**
       * Local end date of the nested time slot in ISO-8601 format.
       * For example, "2024-01-30T14:30:00".
       */
      localEndDate?: string;
      /**
       * List of `AvailableResources` for the nested time slot.
       * Each `AvailableResources` contains information about available resources of the same type.
       */
      availableResources?: AvailableResources$2[];
  }
  interface CalculateEventBasedAvailabilityRequest$1 {
      serviceIds: string[];
      from: string;
      to: string;
      timeZone: string;
      /**
       * TODO good definition of what bookable means https://github.com/wix-private/scheduler/pull/18267/files?file-filters%5B%5D=.proto&show-viewed-files=true#r1199809006
       * TODO: Locks are not taken into account. // Class is not supported yet. (relevant only for classes with waiting list)
       * Aliza's suggestion to consider locks in bookable
       */
      bookable?: boolean | null;
      /** support filtering by location type, or by locationId. Other fields like `name` are ignored */
      location?: Location$8[];
      resourceIds?: string[];
      /** if not empty, return slots with openSpots >= X */
      openSpots?: number | null;
      /**
       * each nested field is checked on its own. i.e. if `too_early_to_book` is defined and `too_late_to_book` is not defined
       * we will return slots for which `too_early_to_book` is same as on the request, regardless of `too_late_to_book`.
       */
      bookingPolicyViolations?: BookingPolicyViolations$2;
      /**
       * Maximum number of slots to load for each date. For example, if `slots_per_day` is set to `3`,
       * at most 3 available slots are returned for each day in the date range specified in the query's
       * `filter`.
       *
       * When a day has both bookable and non-bookable slots, bookable slots are returned first.
       * Non-bookable slots are returned according to the specified filters, after all
       * bookable slots are already included.
       */
      slotsPerDay?: number | null;
      cursorPaging?: CursorPaging$b;
  }
  interface CursorPaging$b {
      /** Maximum number of items to return in the results. */
      limit?: number | null;
      /**
       * Pointer to the next or previous page in the list of results.
       *
       * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
       * Not relevant for the first request.
       */
      cursor?: string | null;
  }
  interface CalculateEventBasedAvailabilityResponse$1 {
      slots?: TimeSlot$1[];
      cursorPagingMetadata?: CursorPagingMetadata$9;
  }
  interface CursorPagingMetadata$9 {
      /** Number of items returned in the response. */
      count?: number | null;
      /** Cursor strings that point to the next page, previous page, or both. */
      cursors?: Cursors$c;
      /**
       * Whether there are more pages to retrieve following the current page.
       *
       * + `true`: Another page of results can be retrieved.
       * + `false`: This is the last page.
       */
      hasNext?: boolean | null;
  }
  interface Cursors$c {
      /** Cursor string pointing to the next page in the list of results. */
      next?: string | null;
      /** Cursor pointing to the previous page in the list of results. */
      prev?: string | null;
  }
  interface ListEventTimeSlotsRequest$1 {
      /** The services for which the time slots are being returned. */
      serviceIds: string[] | null;
      /**
       * Local start date for which event time slots are returned, in ISO-8601 format.
       * E.g, "2024-01-30T13:30:00".
       * Required, unless `cursorPaging` is provided.
       */
      fromLocalDate: string | null;
      /**
       * Local end date for which event time slots are returned, in ISO-8601 format.
       * E.g, "2024-01-30T13:30:00".
       * Required, unless `cursorPaging` is provided.
       */
      toLocalDate: string | null;
      /**
       * The time zone, in IANA time zone format.
       * Default is the Wix Business time zone.
       */
      timeZone: string | null;
      /** TODO good definition of what bookable means https://github.com/wix-private/scheduler/pull/18267/files?file-filters%5B%5D=.proto&show-viewed-files=true#r1199809006 */
      bookable?: boolean | null;
      /** support filtering by location type, or by locationId. Other fields like `name` are ignored */
      location?: Location$8[];
      /** TODO: maxsize && do we need include_resource_type_id here? also is the behavior is the same as availabilityTimeSlots, we won't return resources by default? */
      resourceIds?: string[] | null;
      /** if not empty, return slots with remainingCapacity >= X */
      remainingCapacity?: number | null;
      /**
       * each nested field is checked on its own. i.e. if `too_early_to_book` is defined and `too_late_to_book` is not defined
       * we will return slots for which `too_early_to_book` is same as on the request, regardless of `too_late_to_book`.
       */
      bookingPolicyViolations?: BookingPolicyViolations$2;
      /**
       * Maximum number of slots to load for each date. For example, if `slots_per_day` is set to `3`,
       * at most 3 available slots are returned for each day in the date range specified in the query's
       * `filter`.
       *
       * When a day has both bookable and non-bookable slots, bookable slots are returned first.
       * Non-bookable slots are returned according to the specified filters, after all
       * bookable slots are already included.
       */
      timeSlotsPerDay?: number | null;
      cursorPaging?: CursorPaging$b;
  }
  interface ListEventTimeSlotsResponse$1 {
      /** TODO: maxsize */
      timeSlots?: TimeSlot$1[];
      /** The time zone, in IANA time zone format. */
      timeZone?: string | null;
      cursorPagingMetadata?: CursorPagingMetadata$9;
  }
  interface ListMultiServiceAvailabilityTimeSlotsRequest$1 {
      /**
       * Services for which the multiService time slots are being returned for.
       * Each service contains its own resources filters within.
       *
       * MinSize: `2`.
       * MaxSize: `8`.
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      services?: Service$3[];
      /**
       * Lower boundary for `localStartDate` to include in response, in ISO-8601 format.
       * For example, "2024-01-30T13:30:00".
       *
       * Each returned `TimeSlot` in response has a `localStartDate`
       * within the provided `fromLocalDate` and `toLocalDate` exclusive.
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      fromLocalDate?: string | null;
      /**
       * Upper boundary for `localStartDate` to include in response, in ISO-8601 format.
       * For example, "2024-01-30T14:30:00".
       *
       * Each returned `TimeSlot` in response has a `localStartDate`
       * within the provided `fromLocalDate` and `toLocalDate` exclusive.
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      toLocalDate?: string | null;
      /**
       * Time zone, in IANA time zone format.
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      timeZone?: string | null;
      /**
       * Location for which the multiService TimeSlots are being returned for.
       *
       * You can specify location or location type for which the TimeSlots will be returned for.
       * If locationType is `BUSINESS`, you __must__ provide a locationId.
       *
       * <blockquote class="warning">
       * <p><strong>warning:</strong><br/>
       * Supports filtering by location type, or by location ID. </br>
       * Other fields like <code class="grey-background">name</code> are ignored.</p>
       * </blockquote>
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      location?: Location$8;
      /**
       * Whether the `TimeSlot` is bookable according to all of the services booking policies.
       *
       * If booking any of the `TimeSlot`.`NestedTimeSlot`s violates any of its services bookings policies,
       * returns as `false`. Otherwise, returns as `true`.
       *
       * > __Note:__
       * > A `TimeSlot` with a `NestedTimeSlot` that doesn't meet its service's bookings policies will be returned with `bookable` = false,
       * > while a `TimeSlot` with no available resources will not be returned at all.
       */
      bookable?: boolean | null;
      /**
       * Indicators for service's booking policy violations for booking the `TimeSlot`.
       *
       * A bookable time slot must not violate any policy,
       * therefor, this filter is only relevant when `bookable` filter is false.
       *
       * Each nested field is checked on all `NestedTimeSlot`s. For example, if only one of the `NestedTimeSlot`'s
       * has a service with `tooEarlyToBook` same as in the request, we return the `TimeSlot` regardless of whether
       * the other `NestedTimeSlots` has the same `tooEarlyToBook` as in request.
       *
       * Each nested field is checked on its own. For example, if `tooEarlyToBook` is defined and `bookOnlineDisabled` is not defined
       * we return slots for which `tooEarlyToBook` is same as on the request, regardless of `bookOnlineDisabled`.
       */
      bookingPolicyViolations?: BookingPolicyViolations$2;
      /**
       * Maximum number of slots to load for each day. For example, if `timeSlotsPerDay` is set to `3`,
       * we return at most 3 available TimeSlots for each day within the date range specified in request.
       *
       * By default,
       * if `bookable` filter was not specified,
       * and a day has both `bookable` and `un-bookable` slots, `bookable` slots are returned first.
       *
       * If the number of `bookable` slots is less than the requested `timeSlotsPerDay`,
       * `un-bookable` slots will be returned according to the specified filters.
       */
      timeSlotsPerDay?: number | null;
      /**
       * CursorPaging.
       *
       * Enables you to fetch TimeSlots in smaller, more manageable chunks
       * by setting a limit on the number of results returned in response.
       * This is useful in order to enhance efficiency of data retrieval and reduce load on both the client and server.
       *
       * If there are more results than the specified limit, the response will contain a `cursorPagingMetaData`
       * with a cursor pointing to next page of results. In order to fetch the next page of results, you should pass the
       * returned cursor to the next call as `cursorPaging`.`cursor`.
       *
       * For the first call, you should only specify the `limit` for the results page.
       * For each following call, you should only pass the previous returned cursor as `cursorPaging`.`cursor`
       * the `cursorPaging`.`limit`. You may pass a different `limit`.
       * No need to specify any additional parameters.
       *
       * <blockquote class="important">
       * <p><strong>Important:</strong><br/>
       * If you only provide a <code class="grey-background">cursorPaging</code>. <code class="grey-background">cursor</code>,
       * the response will contain the default size of results which is `1000`.
       * </p>
       * </blockquote>
       */
      cursorPaging?: CommonCursorPaging$1;
  }
  interface Service$3 {
      /** Service ID. */
      serviceId?: string;
      /** Resources to include in response. */
      resourceIds?: string[];
      /**
       * The resource type ID's to include in returned time slots.
       * This is in addition to the specifically requested resources.
       *
       * <blockquote class="important">
       * Currently supported only for Staff Member resource type.
       * Staff Member type ID: 1cd44cf8-756f-41c3-bd90-3e2ffcaf1155
       * </blockquote>
       */
      includeResourceTypeIds?: string[];
  }
  interface CommonCursorPaging$1 {
      /**
       * Number of results to load.
       *
       * Default: `1000`.
       * Max: `1000`.
       */
      limit?: number | null;
      /**
       * Pointer to the next or previous page in the list of results.
       *
       * You can get the relevant cursor token
       * from the `pagingMetadata` object in the previous call's response.
       * Not relevant for the first request.
       */
      cursor?: string | null;
  }
  interface ListMultiServiceAvailabilityTimeSlotsResponse$1 {
      /** Time slots. */
      timeSlots?: TimeSlot$1[];
      /**
       * Time zone, in IANA time zone format.
       * Shared for all TimeSlots in response.
       */
      timeZone?: string | null;
      /**
       * CursorPagingMetaData.
       * Contains information about the next page of results.
       *
       * By default,
       * if there are more than 1000 results,
       * the response will contain a `cursorPagingMetaData` with a cursor to the next page of results.
       *
       * <blockquote class="important">
       * <p><strong>Important:</strong><br/>
       * <code class="grey-background">count</code> is not supported.</p>
       * </blockquote>
       */
      cursorPagingMetadata?: CommonCursorPagingMetadata$1;
  }
  interface CommonCursorPagingMetadata$1 {
      /** Offset that was requested. */
      cursors?: CommonCursors$1;
      /**
       * Indicates if there are more results after the current page.
       * If `true`, another page of results can be retrieved.
       * If `false`, this is the last page.
       */
      hasNext?: boolean | null;
  }
  interface CommonCursors$1 {
      /** Cursor pointing to next page in the list of results. */
      next?: string | null;
      /** Cursor pointing to previous page in the list of results. */
      prev?: string | null;
  }
  interface GetMultiServiceAvailabilityTimeSlotRequest$1 {
      /**
       * Services for which the multiService TimeSlots are being returned for.
       * Each service contains its own resources filters within.
       *
       * MinSize: 2.
       * MaxSize: 8.
       */
      services: Service$3[];
      /**
       * Local start date of the time slot, in ISO-8601 format.
       * For example, "2024-01-30T13:30:00".
       */
      localStartDate: string;
      /**
       * Local end date of the time slot, in ISO-8601 format.
       * For example, "2024-01-30T14:30:00".
       */
      localEndDate: string;
      /** Time zone, in IANA time zone format. */
      timeZone: string | null;
      /**
       * The location of the time slot.
       *
       * You must provide a specific `locationType`.
       * If locationType is `BUSINESS`, you __must__ also provide a `locationId`.
       *
       * <blockquote class="warning">
       * <p>Supports filtering by location type, or by location ID.
       * Other fields like <code class="grey-background">name</code> are ignored.</p>
       * </blockquote>
       */
      location: Location$8;
  }
  interface GetMultiServiceAvailabilityTimeSlotResponse$1 {
      /** Time slot. */
      timeSlot?: TimeSlot$1;
      /** The time zone, in IANA time zone format. */
      timeZone?: string | null;
  }
  interface ListAvailabilityTimeSlotsRequest$1 {
      /**
       * Service ID for which the time slots are being returned for.
       * Currently supported only for services of type `APPOINTMENT`.
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      serviceId?: string | null;
      /**
       * Lower boundary for `localStartDate` to include in response, in ISO-8601 format.
       * For example, "2024-01-30T13:30:00".
       *
       * Each returned `TimeSlot` in response has a `localStartDate`
       * within the provided `fromLocalDate` and `toLocalDate` exclusive.
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      fromLocalDate?: string | null;
      /**
       * Upper boundary for `localStartDate` to include in response, in ISO-8601 format.
       * For example, "2024-01-30T14:30:00".
       *
       * Each returned `TimeSlot` in response has a `localStartDate`
       * within the provided `fromLocalDate` and `toLocalDate` exclusive.
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      toLocalDate?: string | null;
      /**
       * Time zone, in IANA time zone format.
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      timeZone?: string | null;
      /**
       * Locations to include in response.
       *
       * By default,
       * if no locations are provided,
       * the response contains TimeSlots for all locations where the service is available.
       *
       * You can specify locations or location types for which the time slots will be returned for.
       * If locationType is `BUSINESS`, you __must__ provide a locationId.
       *
       * <blockquote class="warning">
       * <p><strong>warning:</strong><br/>
       * Supports filtering by location type, or by location ID. </br>
       * Other fields like <code class="grey-background">name</code> are ignored.</p>
       * </blockquote>
       */
      locations?: Location$8[];
      /**
       * Resources to include in response.
       *
       * If specified,
       * the returned TimeSlots will contain __up__ to 10 available resources out of the provided list.
       * Otherwise, the returned TimeSlots returns with an empty `AvailableResources`.
       * @deprecated
       */
      resourceIds?: string[];
      /**
       * Resource type ID's to include in response, this is in addition to the requested `resourceIds`.
       *
       * If specified in request, the returned TimeSlots will contain __up__ to 10 `AvailableResources` with `ResourceTypeId`
       * out of those specified, each contains __up__ to 10 available resources of this type.
       */
      includeResourceTypeIds?: string[];
      /**
       * Whether the `TimeSlot` is bookable according to the service's booking policies.
       *
       * If booking this `TimeSlot` does not violates any of the service's booking policies,
       * returns as `true`. Otherwise, returns as `false`.
       *
       * > __Note:__
       * > A time slot that doesn't meet the service's bookings policies will be returned with `bookable` = false,
       * > while a time slot with no available resources will not be returned at all.
       */
      bookable?: boolean | null;
      /**
       * Indicators for service's booking policy violations for booking the `TimeSlot`.
       *
       * A bookable time slot must not violate any policy,
       * therefor, this filter is only relevant when `bookable` filter is false.
       *
       * Each nested field is checked on its own. i.e. if `tooEarlyToBook` is defined and `bookOnlineDisabled` is not defined
       * we return slots for which `tooEarlyToBook` is same as on the request, regardless of `bookOnlineDisabled`.
       */
      bookingPolicyViolations?: BookingPolicyViolations$2;
      /**
       * Maximum number of slots to load for each day. For example, if `timeSlotsPerDay` is set to `3`,
       * we return at most 3 available TimeSlots for each day within the date range specified in request.
       *
       * By default,
       * if `bookable` filter was not specified,
       * and a day has both `bookable` and `un-bookable` slots, `bookable` slots are returned first.
       *
       * If the number of `bookable` slots is less than the requested `timeSlotsPerDay`,
       * `un-bookable` slots will be returned according to the specified filters.
       */
      timeSlotsPerDay?: number | null;
      /**
       * CursorPaging.
       *
       * Enables you to fetch results in smaller, more manageable chunks
       * by setting a limit on the number of results returned in response.
       * This is useful in order to enhance efficiency of data retrieval and reduce load on both the client and server.
       *
       * If there are more results than the specified limit, the response will contain a `cursorPagingMetaData`
       * with a cursor pointing to next page of results. In order to fetch the next page of results, you should pass the
       * returned cursor to the next call as `cursorPaging`.`cursor`.
       *
       * For the first call, you should only specify the `limit` for the results page.
       * For each following call, you should only pass `cursorPaging`.`cursor` with the returned cursor from previous call, and
       * a `cursorPaging`.`limit`.
       * No need to specify any additional parameters.
       *
       * <blockquote class="important">
       * <p><strong>Important:</strong><br/>
       * If you only provide a <code class="grey-background">cursorPaging</code>. <code class="grey-background">cursor</code>,
       * the response will contain the default size of results which is `1000`.
       * </p>
       * </blockquote>
       */
      cursorPaging?: CommonCursorPaging$1;
      /**
       * Specifies whether to return all available resources in response.
       * @internal
       */
      shouldReturnAllResources?: boolean;
      /**
       * Selected customer choices.
       * If specified, the selected choices will be used to calculate service configuration.
       * If not specified, the service default configuration will be used.
       * Enforcing this field is the responsibility of the SPI implementer, and not by the Availability API.
       * @internal
       */
      customerChoices?: CustomerChoices$1;
      /**
       * resources filter
       * If specified, only time slots with these resources will be returned.
       */
      resourceTypes?: ResourceType$3[];
  }
  /**
   * Selected customer choices.
   * These choices are selected by the customer during the booking flow and can be utilized to calculate the corresponding service's configuration properties.
   */
  interface CustomerChoices$1 {
      /**
       * The selected customer duration in minutes.
       * Min: `1 minute`
       * Max: `44639 minutes` (30 days, 23 hours, and 59 minutes)
       */
      durationInMinutes?: number | null;
  }
  interface ResourceType$3 {
      /** Resource type ID. */
      resourceTypeId?: string | null;
      /**
       * Resource IDs.
       * The response will contain only slots that have at least one of the specified resources.
       */
      resourceIds?: string[] | null;
  }
  interface ListAvailabilityTimeSlotsResponse$1 {
      /** Time slots. */
      timeSlots?: TimeSlot$1[];
      /**
       * Time zone, in IANA time zone format.
       * Shared for all TimeSlots in response.
       */
      timeZone?: string | null;
      /**
       * CursorPagingMetaData.
       * Contains information about the next page of results.
       *
       * By default,
       * if there are more than 1000 results,
       * the response will contain a `cursorPagingMetaData` with a cursor to the next page of results.
       *
       * <blockquote class="important">
       * <p><strong>Important:</strong><br/>
       * <code class="grey-background">count</code> is not supported.</p>
       * </blockquote>
       */
      cursorPagingMetadata?: CommonCursorPagingMetadata$1;
  }
  interface GetAvailabilityTimeSlotRequest$1 {
      /**
       * Service ID of the time slot.
       * Currently supported only for services of type `APPOINTMENT`.
       */
      serviceId: string;
      /**
       * Local start date of the time slot, in ISO-8601 format.
       * For example, "2024-01-30T13:30:00".
       */
      localStartDate: string;
      /**
       * Local end date of the time slot, in ISO-8601 format.
       * For example, "2024-01-30T14:30:00".
       */
      localEndDate: string;
      /** Time zone, in IANA time zone format. */
      timeZone: string | null;
      /**
       * The location of the time slot.
       *
       * You must provide a specific `locationType`.
       * If locationType is `BUSINESS`, you __must__ also provide a `locationId`.
       *
       * <blockquote class="warning">
       * <p>Supports filtering by location type, or by location ID.
       * Other fields like <code class="grey-background">name</code> are ignored.</p>
       * </blockquote>
       */
      location: Location$8;
      /**
       * Resources to include in response.
       *
       * If specified,
       * the returned `TimeSlot` contains only the available resources out of provided list.
       * Otherwise, the returned `TimeSlot` returned with all possible `AvailableResources`.
       */
      resourceIds?: string[];
      /**
       * Resource type IDs to include in response, this is in addition to the requested `resourceIds`.
       *
       * If specified in request, the returned `TimeSlot` contains only the `AvailableResources` with `ResourceTypeId`
       * out of those specified, each contains all the available resources of this type.
       */
      includeResourceTypeIds?: string[];
  }
  interface GetAvailabilityTimeSlotResponse$1 {
      /** Time slot. */
      timeSlot?: TimeSlot$1;
      /** Time zone, in IANA time zone format. */
      timeZone?: string | null;
  }
  /** @internal
   * @documentationMaturity preview
   * @requiredField options.from
   * @requiredField options.timeZone
   * @requiredField options.to
   * @requiredField serviceIds
   * @permissionId BOOKINGS.AVAILABILITY_READ
   */
  function calculateEventBasedAvailability(serviceIds: string[], options?: CalculateEventBasedAvailabilityOptions): Promise<CalculateEventBasedAvailabilityResponse$1>;
  interface CalculateEventBasedAvailabilityOptions {
      from: string;
      to: string;
      timeZone: string;
      /**
       * TODO good definition of what bookable means https://github.com/wix-private/scheduler/pull/18267/files?file-filters%5B%5D=.proto&show-viewed-files=true#r1199809006
       * TODO: Locks are not taken into account. // Class is not supported yet. (relevant only for classes with waiting list)
       * Aliza's suggestion to consider locks in bookable
       */
      bookable?: boolean | null;
      /** support filtering by location type, or by locationId. Other fields like `name` are ignored */
      location?: Location$8[];
      resourceIds?: string[];
      /** if not empty, return slots with openSpots >= X */
      openSpots?: number | null;
      /**
       * each nested field is checked on its own. i.e. if `too_early_to_book` is defined and `too_late_to_book` is not defined
       * we will return slots for which `too_early_to_book` is same as on the request, regardless of `too_late_to_book`.
       */
      bookingPolicyViolations?: BookingPolicyViolations$2;
      /**
       * Maximum number of slots to load for each date. For example, if `slots_per_day` is set to `3`,
       * at most 3 available slots are returned for each day in the date range specified in the query's
       * `filter`.
       *
       * When a day has both bookable and non-bookable slots, bookable slots are returned first.
       * Non-bookable slots are returned according to the specified filters, after all
       * bookable slots are already included.
       */
      slotsPerDay?: number | null;
      cursorPaging?: CursorPaging$b;
  }
  /**
   * TODO explain the sorting tie breaker
   * Return a list of available slots, for Event based services
   * can be called only for services with tag "GROUP"
   * @param serviceIds - The services for which the time slots are being returned.
   * @internal
   * @documentationMaturity preview
   * @requiredField options.fromLocalDate
   * @requiredField options.timeZone
   * @requiredField options.toLocalDate
   * @requiredField serviceIds
   * @permissionId BOOKINGS.AVAILABILITY_READ
   */
  function listEventTimeSlots(serviceIds: string[] | null, options?: ListEventTimeSlotsOptions): Promise<ListEventTimeSlotsResponse$1>;
  interface ListEventTimeSlotsOptions {
      /**
       * Local start date for which event time slots are returned, in ISO-8601 format.
       * E.g, "2024-01-30T13:30:00".
       * Required, unless `cursorPaging` is provided.
       */
      fromLocalDate: string | null;
      /**
       * Local end date for which event time slots are returned, in ISO-8601 format.
       * E.g, "2024-01-30T13:30:00".
       * Required, unless `cursorPaging` is provided.
       */
      toLocalDate: string | null;
      /**
       * The time zone, in IANA time zone format.
       * Default is the Wix Business time zone.
       */
      timeZone: string | null;
      /** TODO good definition of what bookable means https://github.com/wix-private/scheduler/pull/18267/files?file-filters%5B%5D=.proto&show-viewed-files=true#r1199809006 */
      bookable?: boolean | null;
      /** support filtering by location type, or by locationId. Other fields like `name` are ignored */
      location?: Location$8[];
      /** TODO: maxsize && do we need include_resource_type_id here? also is the behavior is the same as availabilityTimeSlots, we won't return resources by default? */
      resourceIds?: string[] | null;
      /** if not empty, return slots with remainingCapacity >= X */
      remainingCapacity?: number | null;
      /**
       * each nested field is checked on its own. i.e. if `too_early_to_book` is defined and `too_late_to_book` is not defined
       * we will return slots for which `too_early_to_book` is same as on the request, regardless of `too_late_to_book`.
       */
      bookingPolicyViolations?: BookingPolicyViolations$2;
      /**
       * Maximum number of slots to load for each date. For example, if `slots_per_day` is set to `3`,
       * at most 3 available slots are returned for each day in the date range specified in the query's
       * `filter`.
       *
       * When a day has both bookable and non-bookable slots, bookable slots are returned first.
       * Non-bookable slots are returned according to the specified filters, after all
       * bookable slots are already included.
       */
      timeSlotsPerDay?: number | null;
      cursorPaging?: CursorPaging$b;
  }
  
  const bookingsAvailabilityV2TimeSlotEventTimeSlots_universal_d_calculateEventBasedAvailability: typeof calculateEventBasedAvailability;
  type bookingsAvailabilityV2TimeSlotEventTimeSlots_universal_d_CalculateEventBasedAvailabilityOptions = CalculateEventBasedAvailabilityOptions;
  const bookingsAvailabilityV2TimeSlotEventTimeSlots_universal_d_listEventTimeSlots: typeof listEventTimeSlots;
  type bookingsAvailabilityV2TimeSlotEventTimeSlots_universal_d_ListEventTimeSlotsOptions = ListEventTimeSlotsOptions;
  namespace bookingsAvailabilityV2TimeSlotEventTimeSlots_universal_d {
    export {
      TimeSlot$1 as TimeSlot,
      Location$8 as Location,
      LocationType$8 as LocationType,
      EventInfo$1 as EventInfo,
      WaitingList$2 as WaitingList,
      BookingPolicyViolations$2 as BookingPolicyViolations,
      AvailableResources$2 as AvailableResources,
      Resource$5 as Resource,
      NestedTimeSlot$1 as NestedTimeSlot,
      CalculateEventBasedAvailabilityRequest$1 as CalculateEventBasedAvailabilityRequest,
      CursorPaging$b as CursorPaging,
      CalculateEventBasedAvailabilityResponse$1 as CalculateEventBasedAvailabilityResponse,
      CursorPagingMetadata$9 as CursorPagingMetadata,
      Cursors$c as Cursors,
      ListEventTimeSlotsRequest$1 as ListEventTimeSlotsRequest,
      ListEventTimeSlotsResponse$1 as ListEventTimeSlotsResponse,
      ListMultiServiceAvailabilityTimeSlotsRequest$1 as ListMultiServiceAvailabilityTimeSlotsRequest,
      Service$3 as Service,
      CommonCursorPaging$1 as CommonCursorPaging,
      ListMultiServiceAvailabilityTimeSlotsResponse$1 as ListMultiServiceAvailabilityTimeSlotsResponse,
      CommonCursorPagingMetadata$1 as CommonCursorPagingMetadata,
      CommonCursors$1 as CommonCursors,
      GetMultiServiceAvailabilityTimeSlotRequest$1 as GetMultiServiceAvailabilityTimeSlotRequest,
      GetMultiServiceAvailabilityTimeSlotResponse$1 as GetMultiServiceAvailabilityTimeSlotResponse,
      ListAvailabilityTimeSlotsRequest$1 as ListAvailabilityTimeSlotsRequest,
      CustomerChoices$1 as CustomerChoices,
      ResourceType$3 as ResourceType,
      ListAvailabilityTimeSlotsResponse$1 as ListAvailabilityTimeSlotsResponse,
      GetAvailabilityTimeSlotRequest$1 as GetAvailabilityTimeSlotRequest,
      GetAvailabilityTimeSlotResponse$1 as GetAvailabilityTimeSlotResponse,
      bookingsAvailabilityV2TimeSlotEventTimeSlots_universal_d_calculateEventBasedAvailability as calculateEventBasedAvailability,
      bookingsAvailabilityV2TimeSlotEventTimeSlots_universal_d_CalculateEventBasedAvailabilityOptions as CalculateEventBasedAvailabilityOptions,
      bookingsAvailabilityV2TimeSlotEventTimeSlots_universal_d_listEventTimeSlots as listEventTimeSlots,
      bookingsAvailabilityV2TimeSlotEventTimeSlots_universal_d_ListEventTimeSlotsOptions as ListEventTimeSlotsOptions,
    };
  }
  
  /**
   * The `TimeSlot` object represents the availability information
   * for an `Appointment` service's specific slot, including:
   *
   * 1. Whether the slot is bookable for the given service?
   *
   * 2. In what location the service is available for this slot?
   *
   * 3. Which available resources can provide the service for this slot?
   *
   * 4. Does booking the slot for the service violates any of the service booking policies?
   *
   * 5. What is the total capacity and remaining capacity of the service at the time of the calculation of the `TimeSlot`?
   *
   * > __Note:__
   * > When the `TimeSlot` has a non empty `NestedTimeSlots`, it represents the availability information
   * > for a given list of `Appointment` services within a specific time slot.
   */
  interface TimeSlot {
      /**
       * Service ID.
       *
       * > Not returned from `MultiServiceAvailabilityTimeSlots` API calls.
       * > Instead, each nested time slot has its own serviceId.
       */
      serviceId?: string | null;
      /**
       * Local start date of the time slot in ISO-8601 format.
       * For example, "2024-01-30T13:30:00".
       */
      localStartDate?: string | null;
      /**
       * Local end date of the time slot in ISO-8601 format.
       * For example, "2024-01-30T14:30:00".
       */
      localEndDate?: string | null;
      /**
       * Whether the slot is bookable according to the service's booking policies.
       *
       * If booking this time slot does not violates any of the service's booking policies,
       * the returned value is `true`. Otherwise, returns `false`.
       */
      bookable?: boolean | null;
      /** The geographic location of the slot. */
      location?: Location$7;
      /**
       * Returned only for event.
       * @internal
       */
      eventInfo?: EventInfo;
      /** Total number of spots for the slot. */
      totalCapacity?: number | null;
      /**
       * Remaining number of spots for the slot.
       * For example, for an appointment service with total capacity of 1 spot and one booked spot, the remaining capacity will be 0.
       */
      remainingCapacity?: number | null;
      /**
       * Indicators for booking policy violations for the slot.
       *
       * Each nested field is checked on its own. i.e. if `tooEarlyToBook` is defined and `bookOnlineDisabled` is not defined
       * we will return also slots for which `tooEarlyToBook` is same as on the request, regardless of `bookOnlineDisabled`.
       */
      bookingPolicyViolations?: BookingPolicyViolations$1;
      /**
       * List of `AvailableResources` for the time slot.
       * Each `AvailableResources` contains information about available resources of the same type.
       *
       * > Not returned from `MultiServiceAvailabilityTimeSlots` API calls.
       * > Instead, each nested time slot has its own available resources.
       */
      availableResources?: AvailableResources$1[];
      /**
       * > Nested time slots.
       * > Returned only from `MultiServiceAvailabilityTimeSlots` API calls.
       */
      nestedTimeSlots?: NestedTimeSlot[];
  }
  interface Location$7 {
      /** Business Location ID. Present only if the location is a business location. */
      _id?: string | null;
      /** The location name. */
      name?: string | null;
      /** A string representation for the full address of the location. */
      formattedAddress?: string | null;
      /**
       * The type of location:
       * - `CUSTOM`: The location is specific to this service, and is not derived from the business location.
       * - `BUSINESS`: A business location, either the default business address, or locations defined for the business by the Business Info.
       * - `CUSTOMER`: The location is determined by the customer and is not set up beforehand.
       */
      locationType?: LocationType$7;
  }
  enum LocationType$7 {
      UNKNOWN_LOCATION_TYPE = "UNKNOWN_LOCATION_TYPE",
      /** A business location, either the default business address, or locations defined for the business by the Business Info. */
      BUSINESS = "BUSINESS",
      /** The location is unique to this service and isn't defined as one of the business locations. */
      CUSTOM = "CUSTOM",
      /** The location can be determined by the customer and is not set up beforehand. */
      CUSTOMER = "CUSTOMER"
  }
  /** relevant for event based slots, and not for availability based slots */
  interface EventInfo {
      /**
       * TODO: format - might not be a guid?
       * @internal
       */
      eventId?: string | null;
      /** @internal */
      waitingList?: WaitingList$1;
  }
  interface WaitingList$1 {
      /** Total number of spots in this wait list. */
      totalCapacity?: number | null;
      /**
       * Number of remaining spots for this wait list.
       * For example, a Yoga event with 10 waitList spots and 3 registered
       * on the waitList has 10 `total_capacity` and 7 `remaining_capacity`.
       */
      remainingCapacity?: number | null;
  }
  interface BookingPolicyViolations$1 {
      /** Bookings policy violation. Too early to book this slot. */
      tooEarlyToBook?: boolean | null;
      /** Bookings policy violation. Too late to book this slot. */
      tooLateToBook?: boolean | null;
      /** Bookings policy violation. Online booking is disabled for the `TimeSlot` service. */
      bookOnlineDisabled?: boolean | null;
  }
  interface AvailableResources$1 {
      /** Resource type ID. */
      resourceTypeId?: string | null;
      /**
       * Available resources for the time slot.
       *
       * + When returned from `ListAvailabilityTimeSlots`, empty by default.
       * + + If you provided `includeResourceTypeIds` or  `resourceIds` in request,
       * contains __up__ to 10 available resources out of those provided.
       *
       * + When returned from `GetAvailabilityTimeSlots`, contains all available resources by default.
       * + + If you provided `includeResourceTypeIds` or  `resourceIds` in request,
       * contains all of the available resources out of those provided.
       *
       *
       * > + When returned from `ListMultiServiceAvailabilityTimeSlots`, empty by default.
       * > + + If you provided `includeResourceTypeIds` or  `resourceIds` in request,
       * > contains __up__ to 10 available resources out of those provided.
       *
       * > + When returned from `GetMultiServiceAvailabilityTimeSlots`, contains all available resources by default.
       * > + + If you provided `includeResourceTypeIds` or  `resourceIds` in request,
       * > contains all of the available resources out of those provided.
       */
      resources?: Resource$4[];
      /**
       * The required number of resources of this type in order to book the service.
       * For example, a slot for a service that provides a double massage
       * requires two resources of type `Staff Member` and one resource of type `Room`.
       * @internal
       */
      numberOfResourcesRequired?: number | null;
      /**
       * Whether there are more available resources for the slot that are not listed in `resources` due to size limitations.
       * @readonly
       */
      hasMoreAvailableResources?: boolean | null;
  }
  interface Resource$4 {
      /** Resource ID. */
      _id?: string;
      /** Resource name. */
      name?: string | null;
  }
  interface NestedTimeSlot {
      /** Service ID of the nested time slot. */
      serviceId?: string;
      /**
       * Local start date of the nested time slot in ISO-8601 format.
       * For example, "2024-01-30T13:30:00".
       */
      localStartDate?: string;
      /**
       * Local end date of the nested time slot in ISO-8601 format.
       * For example, "2024-01-30T14:30:00".
       */
      localEndDate?: string;
      /**
       * List of `AvailableResources` for the nested time slot.
       * Each `AvailableResources` contains information about available resources of the same type.
       */
      availableResources?: AvailableResources$1[];
  }
  interface CalculateEventBasedAvailabilityRequest {
      serviceIds: string[];
      from: string;
      to: string;
      timeZone: string;
      /**
       * TODO good definition of what bookable means https://github.com/wix-private/scheduler/pull/18267/files?file-filters%5B%5D=.proto&show-viewed-files=true#r1199809006
       * TODO: Locks are not taken into account. // Class is not supported yet. (relevant only for classes with waiting list)
       * Aliza's suggestion to consider locks in bookable
       */
      bookable?: boolean | null;
      /** support filtering by location type, or by locationId. Other fields like `name` are ignored */
      location?: Location$7[];
      resourceIds?: string[];
      /** if not empty, return slots with openSpots >= X */
      openSpots?: number | null;
      /**
       * each nested field is checked on its own. i.e. if `too_early_to_book` is defined and `too_late_to_book` is not defined
       * we will return slots for which `too_early_to_book` is same as on the request, regardless of `too_late_to_book`.
       */
      bookingPolicyViolations?: BookingPolicyViolations$1;
      /**
       * Maximum number of slots to load for each date. For example, if `slots_per_day` is set to `3`,
       * at most 3 available slots are returned for each day in the date range specified in the query's
       * `filter`.
       *
       * When a day has both bookable and non-bookable slots, bookable slots are returned first.
       * Non-bookable slots are returned according to the specified filters, after all
       * bookable slots are already included.
       */
      slotsPerDay?: number | null;
      cursorPaging?: CursorPaging$a;
  }
  interface CursorPaging$a {
      /** Maximum number of items to return in the results. */
      limit?: number | null;
      /**
       * Pointer to the next or previous page in the list of results.
       *
       * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
       * Not relevant for the first request.
       */
      cursor?: string | null;
  }
  interface CalculateEventBasedAvailabilityResponse {
      slots?: TimeSlot[];
      cursorPagingMetadata?: CursorPagingMetadata$8;
  }
  interface CursorPagingMetadata$8 {
      /** Number of items returned in the response. */
      count?: number | null;
      /** Cursor strings that point to the next page, previous page, or both. */
      cursors?: Cursors$b;
      /**
       * Whether there are more pages to retrieve following the current page.
       *
       * + `true`: Another page of results can be retrieved.
       * + `false`: This is the last page.
       */
      hasNext?: boolean | null;
  }
  interface Cursors$b {
      /** Cursor string pointing to the next page in the list of results. */
      next?: string | null;
      /** Cursor pointing to the previous page in the list of results. */
      prev?: string | null;
  }
  interface ListEventTimeSlotsRequest {
      /** The services for which the time slots are being returned. */
      serviceIds: string[] | null;
      /**
       * Local start date for which event time slots are returned, in ISO-8601 format.
       * E.g, "2024-01-30T13:30:00".
       * Required, unless `cursorPaging` is provided.
       */
      fromLocalDate: string | null;
      /**
       * Local end date for which event time slots are returned, in ISO-8601 format.
       * E.g, "2024-01-30T13:30:00".
       * Required, unless `cursorPaging` is provided.
       */
      toLocalDate: string | null;
      /**
       * The time zone, in IANA time zone format.
       * Default is the Wix Business time zone.
       */
      timeZone: string | null;
      /** TODO good definition of what bookable means https://github.com/wix-private/scheduler/pull/18267/files?file-filters%5B%5D=.proto&show-viewed-files=true#r1199809006 */
      bookable?: boolean | null;
      /** support filtering by location type, or by locationId. Other fields like `name` are ignored */
      location?: Location$7[];
      /** TODO: maxsize && do we need include_resource_type_id here? also is the behavior is the same as availabilityTimeSlots, we won't return resources by default? */
      resourceIds?: string[] | null;
      /** if not empty, return slots with remainingCapacity >= X */
      remainingCapacity?: number | null;
      /**
       * each nested field is checked on its own. i.e. if `too_early_to_book` is defined and `too_late_to_book` is not defined
       * we will return slots for which `too_early_to_book` is same as on the request, regardless of `too_late_to_book`.
       */
      bookingPolicyViolations?: BookingPolicyViolations$1;
      /**
       * Maximum number of slots to load for each date. For example, if `slots_per_day` is set to `3`,
       * at most 3 available slots are returned for each day in the date range specified in the query's
       * `filter`.
       *
       * When a day has both bookable and non-bookable slots, bookable slots are returned first.
       * Non-bookable slots are returned according to the specified filters, after all
       * bookable slots are already included.
       */
      timeSlotsPerDay?: number | null;
      cursorPaging?: CursorPaging$a;
  }
  interface ListEventTimeSlotsResponse {
      /** TODO: maxsize */
      timeSlots?: TimeSlot[];
      /** The time zone, in IANA time zone format. */
      timeZone?: string | null;
      cursorPagingMetadata?: CursorPagingMetadata$8;
  }
  interface ListMultiServiceAvailabilityTimeSlotsRequest {
      /**
       * Services for which the multiService time slots are being returned for.
       * Each service contains its own resources filters within.
       *
       * MinSize: `2`.
       * MaxSize: `8`.
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      services?: Service$2[];
      /**
       * Lower boundary for `localStartDate` to include in response, in ISO-8601 format.
       * For example, "2024-01-30T13:30:00".
       *
       * Each returned `TimeSlot` in response has a `localStartDate`
       * within the provided `fromLocalDate` and `toLocalDate` exclusive.
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      fromLocalDate?: string | null;
      /**
       * Upper boundary for `localStartDate` to include in response, in ISO-8601 format.
       * For example, "2024-01-30T14:30:00".
       *
       * Each returned `TimeSlot` in response has a `localStartDate`
       * within the provided `fromLocalDate` and `toLocalDate` exclusive.
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      toLocalDate?: string | null;
      /**
       * Time zone, in IANA time zone format.
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      timeZone?: string | null;
      /**
       * Location for which the multiService TimeSlots are being returned for.
       *
       * You can specify location or location type for which the TimeSlots will be returned for.
       * If locationType is `BUSINESS`, you __must__ provide a locationId.
       *
       * <blockquote class="warning">
       * <p><strong>warning:</strong><br/>
       * Supports filtering by location type, or by location ID. </br>
       * Other fields like <code class="grey-background">name</code> are ignored.</p>
       * </blockquote>
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      location?: Location$7;
      /**
       * Whether the `TimeSlot` is bookable according to all of the services booking policies.
       *
       * If booking any of the `TimeSlot`.`NestedTimeSlot`s violates any of its services bookings policies,
       * returns as `false`. Otherwise, returns as `true`.
       *
       * > __Note:__
       * > A `TimeSlot` with a `NestedTimeSlot` that doesn't meet its service's bookings policies will be returned with `bookable` = false,
       * > while a `TimeSlot` with no available resources will not be returned at all.
       */
      bookable?: boolean | null;
      /**
       * Indicators for service's booking policy violations for booking the `TimeSlot`.
       *
       * A bookable time slot must not violate any policy,
       * therefor, this filter is only relevant when `bookable` filter is false.
       *
       * Each nested field is checked on all `NestedTimeSlot`s. For example, if only one of the `NestedTimeSlot`'s
       * has a service with `tooEarlyToBook` same as in the request, we return the `TimeSlot` regardless of whether
       * the other `NestedTimeSlots` has the same `tooEarlyToBook` as in request.
       *
       * Each nested field is checked on its own. For example, if `tooEarlyToBook` is defined and `bookOnlineDisabled` is not defined
       * we return slots for which `tooEarlyToBook` is same as on the request, regardless of `bookOnlineDisabled`.
       */
      bookingPolicyViolations?: BookingPolicyViolations$1;
      /**
       * Maximum number of slots to load for each day. For example, if `timeSlotsPerDay` is set to `3`,
       * we return at most 3 available TimeSlots for each day within the date range specified in request.
       *
       * By default,
       * if `bookable` filter was not specified,
       * and a day has both `bookable` and `un-bookable` slots, `bookable` slots are returned first.
       *
       * If the number of `bookable` slots is less than the requested `timeSlotsPerDay`,
       * `un-bookable` slots will be returned according to the specified filters.
       */
      timeSlotsPerDay?: number | null;
      /**
       * CursorPaging.
       *
       * Enables you to fetch TimeSlots in smaller, more manageable chunks
       * by setting a limit on the number of results returned in response.
       * This is useful in order to enhance efficiency of data retrieval and reduce load on both the client and server.
       *
       * If there are more results than the specified limit, the response will contain a `cursorPagingMetaData`
       * with a cursor pointing to next page of results. In order to fetch the next page of results, you should pass the
       * returned cursor to the next call as `cursorPaging`.`cursor`.
       *
       * For the first call, you should only specify the `limit` for the results page.
       * For each following call, you should only pass the previous returned cursor as `cursorPaging`.`cursor`
       * the `cursorPaging`.`limit`. You may pass a different `limit`.
       * No need to specify any additional parameters.
       *
       * <blockquote class="important">
       * <p><strong>Important:</strong><br/>
       * If you only provide a <code class="grey-background">cursorPaging</code>. <code class="grey-background">cursor</code>,
       * the response will contain the default size of results which is `1000`.
       * </p>
       * </blockquote>
       */
      cursorPaging?: CommonCursorPaging;
  }
  interface Service$2 {
      /** Service ID. */
      serviceId?: string;
      /** Resources to include in response. */
      resourceIds?: string[];
      /**
       * The resource type ID's to include in returned time slots.
       * This is in addition to the specifically requested resources.
       *
       * <blockquote class="important">
       * Currently supported only for Staff Member resource type.
       * Staff Member type ID: 1cd44cf8-756f-41c3-bd90-3e2ffcaf1155
       * </blockquote>
       */
      includeResourceTypeIds?: string[];
  }
  interface CommonCursorPaging {
      /**
       * Number of results to load.
       *
       * Default: `1000`.
       * Max: `1000`.
       */
      limit?: number | null;
      /**
       * Pointer to the next or previous page in the list of results.
       *
       * You can get the relevant cursor token
       * from the `pagingMetadata` object in the previous call's response.
       * Not relevant for the first request.
       */
      cursor?: string | null;
  }
  interface ListMultiServiceAvailabilityTimeSlotsResponse {
      /** Time slots. */
      timeSlots?: TimeSlot[];
      /**
       * Time zone, in IANA time zone format.
       * Shared for all TimeSlots in response.
       */
      timeZone?: string | null;
      /**
       * CursorPagingMetaData.
       * Contains information about the next page of results.
       *
       * By default,
       * if there are more than 1000 results,
       * the response will contain a `cursorPagingMetaData` with a cursor to the next page of results.
       *
       * <blockquote class="important">
       * <p><strong>Important:</strong><br/>
       * <code class="grey-background">count</code> is not supported.</p>
       * </blockquote>
       */
      cursorPagingMetadata?: CommonCursorPagingMetadata;
  }
  interface CommonCursorPagingMetadata {
      /** Offset that was requested. */
      cursors?: CommonCursors;
      /**
       * Indicates if there are more results after the current page.
       * If `true`, another page of results can be retrieved.
       * If `false`, this is the last page.
       */
      hasNext?: boolean | null;
  }
  interface CommonCursors {
      /** Cursor pointing to next page in the list of results. */
      next?: string | null;
      /** Cursor pointing to previous page in the list of results. */
      prev?: string | null;
  }
  interface GetMultiServiceAvailabilityTimeSlotRequest {
      /**
       * Services for which the multiService TimeSlots are being returned for.
       * Each service contains its own resources filters within.
       *
       * MinSize: 2.
       * MaxSize: 8.
       */
      services: Service$2[];
      /**
       * Local start date of the time slot, in ISO-8601 format.
       * For example, "2024-01-30T13:30:00".
       */
      localStartDate: string;
      /**
       * Local end date of the time slot, in ISO-8601 format.
       * For example, "2024-01-30T14:30:00".
       */
      localEndDate: string;
      /** Time zone, in IANA time zone format. */
      timeZone: string | null;
      /**
       * The location of the time slot.
       *
       * You must provide a specific `locationType`.
       * If locationType is `BUSINESS`, you __must__ also provide a `locationId`.
       *
       * <blockquote class="warning">
       * <p>Supports filtering by location type, or by location ID.
       * Other fields like <code class="grey-background">name</code> are ignored.</p>
       * </blockquote>
       */
      location: Location$7;
  }
  interface GetMultiServiceAvailabilityTimeSlotResponse {
      /** Time slot. */
      timeSlot?: TimeSlot;
      /** The time zone, in IANA time zone format. */
      timeZone?: string | null;
  }
  interface ListAvailabilityTimeSlotsRequest {
      /**
       * Service ID for which the time slots are being returned for.
       * Currently supported only for services of type `APPOINTMENT`.
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      serviceId?: string | null;
      /**
       * Lower boundary for `localStartDate` to include in response, in ISO-8601 format.
       * For example, "2024-01-30T13:30:00".
       *
       * Each returned `TimeSlot` in response has a `localStartDate`
       * within the provided `fromLocalDate` and `toLocalDate` exclusive.
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      fromLocalDate?: string | null;
      /**
       * Upper boundary for `localStartDate` to include in response, in ISO-8601 format.
       * For example, "2024-01-30T14:30:00".
       *
       * Each returned `TimeSlot` in response has a `localStartDate`
       * within the provided `fromLocalDate` and `toLocalDate` exclusive.
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      toLocalDate?: string | null;
      /**
       * Time zone, in IANA time zone format.
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      timeZone?: string | null;
      /**
       * Locations to include in response.
       *
       * By default,
       * if no locations are provided,
       * the response contains TimeSlots for all locations where the service is available.
       *
       * You can specify locations or location types for which the time slots will be returned for.
       * If locationType is `BUSINESS`, you __must__ provide a locationId.
       *
       * <blockquote class="warning">
       * <p><strong>warning:</strong><br/>
       * Supports filtering by location type, or by location ID. </br>
       * Other fields like <code class="grey-background">name</code> are ignored.</p>
       * </blockquote>
       */
      locations?: Location$7[];
      /**
       * Resources to include in response.
       *
       * If specified,
       * the returned TimeSlots will contain __up__ to 10 available resources out of the provided list.
       * Otherwise, the returned TimeSlots returns with an empty `AvailableResources`.
       * @deprecated
       */
      resourceIds?: string[];
      /**
       * Resource type ID's to include in response, this is in addition to the requested `resourceIds`.
       *
       * If specified in request, the returned TimeSlots will contain __up__ to 10 `AvailableResources` with `ResourceTypeId`
       * out of those specified, each contains __up__ to 10 available resources of this type.
       */
      includeResourceTypeIds?: string[];
      /**
       * Whether the `TimeSlot` is bookable according to the service's booking policies.
       *
       * If booking this `TimeSlot` does not violates any of the service's booking policies,
       * returns as `true`. Otherwise, returns as `false`.
       *
       * > __Note:__
       * > A time slot that doesn't meet the service's bookings policies will be returned with `bookable` = false,
       * > while a time slot with no available resources will not be returned at all.
       */
      bookable?: boolean | null;
      /**
       * Indicators for service's booking policy violations for booking the `TimeSlot`.
       *
       * A bookable time slot must not violate any policy,
       * therefor, this filter is only relevant when `bookable` filter is false.
       *
       * Each nested field is checked on its own. i.e. if `tooEarlyToBook` is defined and `bookOnlineDisabled` is not defined
       * we return slots for which `tooEarlyToBook` is same as on the request, regardless of `bookOnlineDisabled`.
       */
      bookingPolicyViolations?: BookingPolicyViolations$1;
      /**
       * Maximum number of slots to load for each day. For example, if `timeSlotsPerDay` is set to `3`,
       * we return at most 3 available TimeSlots for each day within the date range specified in request.
       *
       * By default,
       * if `bookable` filter was not specified,
       * and a day has both `bookable` and `un-bookable` slots, `bookable` slots are returned first.
       *
       * If the number of `bookable` slots is less than the requested `timeSlotsPerDay`,
       * `un-bookable` slots will be returned according to the specified filters.
       */
      timeSlotsPerDay?: number | null;
      /**
       * CursorPaging.
       *
       * Enables you to fetch results in smaller, more manageable chunks
       * by setting a limit on the number of results returned in response.
       * This is useful in order to enhance efficiency of data retrieval and reduce load on both the client and server.
       *
       * If there are more results than the specified limit, the response will contain a `cursorPagingMetaData`
       * with a cursor pointing to next page of results. In order to fetch the next page of results, you should pass the
       * returned cursor to the next call as `cursorPaging`.`cursor`.
       *
       * For the first call, you should only specify the `limit` for the results page.
       * For each following call, you should only pass `cursorPaging`.`cursor` with the returned cursor from previous call, and
       * a `cursorPaging`.`limit`.
       * No need to specify any additional parameters.
       *
       * <blockquote class="important">
       * <p><strong>Important:</strong><br/>
       * If you only provide a <code class="grey-background">cursorPaging</code>. <code class="grey-background">cursor</code>,
       * the response will contain the default size of results which is `1000`.
       * </p>
       * </blockquote>
       */
      cursorPaging?: CommonCursorPaging;
      /**
       * Specifies whether to return all available resources in response.
       * @internal
       */
      shouldReturnAllResources?: boolean;
      /**
       * Selected customer choices.
       * If specified, the selected choices will be used to calculate service configuration.
       * If not specified, the service default configuration will be used.
       * Enforcing this field is the responsibility of the SPI implementer, and not by the Availability API.
       * @internal
       */
      customerChoices?: CustomerChoices;
      /**
       * resources filter
       * If specified, only time slots with these resources will be returned.
       */
      resourceTypes?: ResourceType$2[];
  }
  /**
   * Selected customer choices.
   * These choices are selected by the customer during the booking flow and can be utilized to calculate the corresponding service's configuration properties.
   */
  interface CustomerChoices {
      /**
       * The selected customer duration in minutes.
       * Min: `1 minute`
       * Max: `44639 minutes` (30 days, 23 hours, and 59 minutes)
       */
      durationInMinutes?: number | null;
  }
  interface ResourceType$2 {
      /** Resource type ID. */
      resourceTypeId?: string | null;
      /**
       * Resource IDs.
       * The response will contain only slots that have at least one of the specified resources.
       */
      resourceIds?: string[] | null;
  }
  interface ListAvailabilityTimeSlotsResponse {
      /** Time slots. */
      timeSlots?: TimeSlot[];
      /**
       * Time zone, in IANA time zone format.
       * Shared for all TimeSlots in response.
       */
      timeZone?: string | null;
      /**
       * CursorPagingMetaData.
       * Contains information about the next page of results.
       *
       * By default,
       * if there are more than 1000 results,
       * the response will contain a `cursorPagingMetaData` with a cursor to the next page of results.
       *
       * <blockquote class="important">
       * <p><strong>Important:</strong><br/>
       * <code class="grey-background">count</code> is not supported.</p>
       * </blockquote>
       */
      cursorPagingMetadata?: CommonCursorPagingMetadata;
  }
  interface GetAvailabilityTimeSlotRequest {
      /**
       * Service ID of the time slot.
       * Currently supported only for services of type `APPOINTMENT`.
       */
      serviceId: string;
      /**
       * Local start date of the time slot, in ISO-8601 format.
       * For example, "2024-01-30T13:30:00".
       */
      localStartDate: string;
      /**
       * Local end date of the time slot, in ISO-8601 format.
       * For example, "2024-01-30T14:30:00".
       */
      localEndDate: string;
      /** Time zone, in IANA time zone format. */
      timeZone: string | null;
      /**
       * The location of the time slot.
       *
       * You must provide a specific `locationType`.
       * If locationType is `BUSINESS`, you __must__ also provide a `locationId`.
       *
       * <blockquote class="warning">
       * <p>Supports filtering by location type, or by location ID.
       * Other fields like <code class="grey-background">name</code> are ignored.</p>
       * </blockquote>
       */
      location: Location$7;
      /**
       * Resources to include in response.
       *
       * If specified,
       * the returned `TimeSlot` contains only the available resources out of provided list.
       * Otherwise, the returned `TimeSlot` returned with all possible `AvailableResources`.
       */
      resourceIds?: string[];
      /**
       * Resource type IDs to include in response, this is in addition to the requested `resourceIds`.
       *
       * If specified in request, the returned `TimeSlot` contains only the `AvailableResources` with `ResourceTypeId`
       * out of those specified, each contains all the available resources of this type.
       */
      includeResourceTypeIds?: string[];
  }
  interface GetAvailabilityTimeSlotResponse {
      /** Time slot. */
      timeSlot?: TimeSlot;
      /** Time zone, in IANA time zone format. */
      timeZone?: string | null;
  }
  /**
   * Retrieves a list of multiService `TimeSlot`s that match the provided filters.
   *
   * <blockquote class="important">
   * <p><strong>Important:</strong><br/>
   * Currently supported only for services of type <code class="grey-background">APPOINTMENT</code>.</p>
   * </blockquote>
   *
   * The request body __must__ include either:
   * + All of the following filters:  `service`.`serviceId`, `fromLocalDate`, `toLocalDate`, `location`, and `timeZone`. You may add additional filters as you wish.
   * + A `cursorPaging` with a valid `cursor` from previous response.
   *
   *
   * Each [TimeSlot](https://bo.wix.com/wix-docs/rest/all-apis/wix-service-availability/availability-time-slots/time-slot-object) in response
   * represents the availability of the given sequence of services in a specific order, location, and within a given range of time.
   *
   * Each `TimeSlot`.`NestedTimeSlot` represents a single service from the given list. The order of the `NestedTimeSlots` is the same as the order
   * of the given services in request.
   * The first `NestedTimeSlot` has `localStartDate` within the given `fromLocalDate` and `toLocalDate` exclusive,
   * and each following `NestedTimeSlot` has a `localStartDate` that equals to the previous `NestedTimeSlot`'s `localEndDate`.
   *
   * By default,
   * the response contains at most 1000 results.
   * If there are more than 1000 results, we return a `cursorPagingMetadata` with
   * a cursor for the next page of results, regardless of whether a `cursorPaging`
   * was provided in request.
   *
   * > __Notes:__
   * >  + All nested time slots share the same location.
   * >  + You can pass up to 8 services in request.
   *
   * ### AvailableResources in response:
   * The `TimeSlot`.`NestedTimeSlot`'s `AvailableResources` contains information about the resources that are available to provide the service
   * within the `NestedTimeSlot` range of time. Each `AvailableResources` contains information about available resources of the same type.
   *
   * <blockquote class="important">
   * <p><strong>Important:</strong><br/>
   * By default,
   * if you don't specify <code class="grey-background">service</code>.<code class="grey-background">includeResourceTypeIds</code>
   * or  <code class="grey-background">service</code>.<code class="grey-background">resourceIds</code> filters in request,
   * we return TimeSlots with <code class="grey-background">NestedTimeSlot</code>s with an empty <code class="grey-background">AvailableResources</code>.
   * <br/><strong>Note:</strong><br/> Not specifying resources filters can be handy in case you want to avoid large response in flows that only
   * interested of whether the time slots are available. [Finding the next available slot within the next 3 months](https://bo.wix.com/wix-docs/rest/all-apis/service-availability/multi-service-availability-time-slots/sample-flows?localViewerId=inbari#all-apis_service-availability_multi-service-availability-time-slots_sample-flows_find-the-first-date-within-the-next-3-months-that-all-selected-services-are-available-for)
   * is an example for such flow.
   * </p>
   * </blockquote>
   *
   *
   * If you wish to get a list of available resources for a `TimeSlot`.`NestedTimeSlot` you should either:
   * + provide `service`.`resourceIds` in request.
   * + provide `service`.`includeResourceTypeIds` in request.
   *
   * __Notes:__
   * + In both cases the returned `TimeSlot`.`NestedTimeSlot` contains  __up__ to 10 `AvailableResources` that match the provided filters. Each `AvailableResources` contains __up__ to 10 available `resources` of the same type that match the provided filters.
   * + If an `AvailableResources` has more available resources which are not listed within it, we return `AvailableResources`.`hasMoreAvailableResources` as true.
   * + If you wish to get the full available resources list for all `NestedTimeSlot` of a specific `TimeSlot`, you should call [GetMultiServiceAvailabilityTimeSlot](https://bo.wix.com/wix-docs/rest/all-apis/wix-service-availability/multi-service-availability-time-slots/get-multi-service-availability-time-slot).
   *
   *
   * ### Availability VS Bookability
   * An `available` time slot is not necessarily `bookable`.
   * The `bookable` field of a `TimeSlot` indicates whether the customer can book all of the of the services within the given time slot,
   * at a specific period of time.
   * Read more about [Availability VS Bookability](https://bo.wix.com/wix-docs/rest/all-apis/wix-service-availability/multi-service-availability-time-slots/introduction#all-apis_wix-service-availability_multi-service-availability-time-slots_introduction_availability-vs-bookability).
   *
   * By default,
   * + The response does not contains `unavailable` TimeSlots.For example, if there are no available resources to provide one of the services from `2024-01-30T14:30:00` to `2024-01-30T15:30:00`, we don't return TimeSlots with `NestedTimeSlot`.`localStartDate` within this range for this service.
   * + The response contains both `bookable` and `un-bookable` TimeSlots.For example, if one of the services has a booking policy which enforces booking the service up to 10 minutes before the session starts, we return TimeSlots with the violating `NestedTimeSlot`.`localStartDate`, with `bookable` as `false`. If you want to list only __bookable__ TimeSlots you should pass `bookable` as `true`.
   * + If booking one of the `NestedTimeSlot`s violates one of the corresponding service's booking policies, the `TimeSlot` returns with `bookable` as false. There is no indication which service's policy was violated.
   *
   * <blockquote class="important">
   * <p><strong>Important:</strong>
   * Because of DST, there are edge cases where certain times either do not exist or exist twice for a local time zone.
   * Read more about <a href="https://bo.wix.com/wix-docs/rest/all-apis/wix-service-availability/multi-service-availability-time-slots/introduction#all-apis_wix-service-availability_multi-service-availability-time-slots_introduction_daylight-saving-time-dst-handling">DST Handling</a></p>
   * </blockquote>
   *
   * ### ListAvailabilityTimeSlots runs with the following defaults:
   * + `localStartDate` is sorted in `ASC` order.
   * + `cursorPaging`.`limit` is `1000`.
   * @public
   * @documentationMaturity preview
   * @permissionId BOOKINGS.AVAILABILITY_READ_MULTI_SERVICE_TIME_SLOTS
   */
  function listMultiServiceAvailabilityTimeSlots(options?: ListMultiServiceAvailabilityTimeSlotsOptions): Promise<ListMultiServiceAvailabilityTimeSlotsResponse>;
  interface ListMultiServiceAvailabilityTimeSlotsOptions {
      /**
       * Services for which the multiService time slots are being returned for.
       * Each service contains its own resources filters within.
       *
       * MinSize: `2`.
       * MaxSize: `8`.
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      services?: Service$2[];
      /**
       * Lower boundary for `localStartDate` to include in response, in ISO-8601 format.
       * For example, "2024-01-30T13:30:00".
       *
       * Each returned `TimeSlot` in response has a `localStartDate`
       * within the provided `fromLocalDate` and `toLocalDate` exclusive.
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      fromLocalDate?: string | null;
      /**
       * Upper boundary for `localStartDate` to include in response, in ISO-8601 format.
       * For example, "2024-01-30T14:30:00".
       *
       * Each returned `TimeSlot` in response has a `localStartDate`
       * within the provided `fromLocalDate` and `toLocalDate` exclusive.
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      toLocalDate?: string | null;
      /**
       * Time zone, in IANA time zone format.
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      timeZone?: string | null;
      /**
       * Location for which the multiService TimeSlots are being returned for.
       *
       * You can specify location or location type for which the TimeSlots will be returned for.
       * If locationType is `BUSINESS`, you __must__ provide a locationId.
       *
       * <blockquote class="warning">
       * <p><strong>warning:</strong><br/>
       * Supports filtering by location type, or by location ID. </br>
       * Other fields like <code class="grey-background">name</code> are ignored.</p>
       * </blockquote>
       *
       * Required, unless `cursorPaging`.`cursor` is provided.
       */
      location?: Location$7;
      /**
       * Whether the `TimeSlot` is bookable according to all of the services booking policies.
       *
       * If booking any of the `TimeSlot`.`NestedTimeSlot`s violates any of its services bookings policies,
       * returns as `false`. Otherwise, returns as `true`.
       *
       * > __Note:__
       * > A `TimeSlot` with a `NestedTimeSlot` that doesn't meet its service's bookings policies will be returned with `bookable` = false,
       * > while a `TimeSlot` with no available resources will not be returned at all.
       */
      bookable?: boolean | null;
      /**
       * Indicators for service's booking policy violations for booking the `TimeSlot`.
       *
       * A bookable time slot must not violate any policy,
       * therefor, this filter is only relevant when `bookable` filter is false.
       *
       * Each nested field is checked on all `NestedTimeSlot`s. For example, if only one of the `NestedTimeSlot`'s
       * has a service with `tooEarlyToBook` same as in the request, we return the `TimeSlot` regardless of whether
       * the other `NestedTimeSlots` has the same `tooEarlyToBook` as in request.
       *
       * Each nested field is checked on its own. For example, if `tooEarlyToBook` is defined and `bookOnlineDisabled` is not defined
       * we return slots for which `tooEarlyToBook` is same as on the request, regardless of `bookOnlineDisabled`.
       */
      bookingPolicyViolations?: BookingPolicyViolations$1;
      /**
       * Maximum number of slots to load for each day. For example, if `timeSlotsPerDay` is set to `3`,
       * we return at most 3 available TimeSlots for each day within the date range specified in request.
       *
       * By default,
       * if `bookable` filter was not specified,
       * and a day has both `bookable` and `un-bookable` slots, `bookable` slots are returned first.
       *
       * If the number of `bookable` slots is less than the requested `timeSlotsPerDay`,
       * `un-bookable` slots will be returned according to the specified filters.
       */
      timeSlotsPerDay?: number | null;
      /**
       * CursorPaging.
       *
       * Enables you to fetch TimeSlots in smaller, more manageable chunks
       * by setting a limit on the number of results returned in response.
       * This is useful in order to enhance efficiency of data retrieval and reduce load on both the client and server.
       *
       * If there are more results than the specified limit, the response will contain a `cursorPagingMetaData`
       * with a cursor pointing to next page of results. In order to fetch the next page of results, you should pass the
       * returned cursor to the next call as `cursorPaging`.`cursor`.
       *
       * For the first call, you should only specify the `limit` for the results page.
       * For each following call, you should only pass the previous returned cursor as `cursorPaging`.`cursor`
       * the `cursorPaging`.`limit`. You may pass a different `limit`.
       * No need to specify any additional parameters.
       *
       * <blockquote class="important">
       * <p><strong>Important:</strong><br/>
       * If you only provide a <code class="grey-background">cursorPaging</code>. <code class="grey-background">cursor</code>,
       * the response will contain the default size of results which is `1000`.
       * </p>
       * </blockquote>
       */
      cursorPaging?: CommonCursorPaging;
  }
  /**
   * Retrieves an available multiService `TimeSlot` that match the provided filters.
   *
   * Throws `SlotNotFound` if there is no such available time slot.
   *
   * <blockquote class="important">
   * <p><strong>Important:</strong><br/>
   * Currently supported only for services of type <code class="grey-background">APPOINTMENT</code>.</p>
   * </blockquote>
   *
   * By default,
   * if you don't provide a `service`.`includeResourceTypeIds` or `service`.`resourceIds` in request,
   * we return for each `TimeSlot`.`NestedTimeSlot` all `AvailableResources` with all `AvailableResources`.`resources` which are available to provide
   * the corresponding service within the time slot.
   *
   * If you specify `service`.`includeResourceTypeIds` or `service`.`resourceIds` in request,
   * the returned `TimeSlot`.`NestedTimeSlot` for this service will contain only `AvailableResources` with at least one available resource
   * which match the given resources filters,
   * each contains all available resources out of those requested.
   *
   * + Notes:
   * + All nested time slots share the same location.
   * + You can pass up to 8 services.
   *
   * <blockquote class="tip">
   * <p><strong>Tip:</strong><br/>
   * Use this API in order to get the availability of a specific <code class="grey-background">TimeSlot</code> out of those returned from  <code class="grey-background">ListMultiServiceAvailabilityTimeSlots</code> API.</p>
   * </blockquote>
   * @param services - Services for which the multiService TimeSlots are being returned for.
   * Each service contains its own resources filters within.
   *
   * MinSize: 2.
   * MaxSize: 8.
   * @param localStartDate - Local start date of the time slot, in ISO-8601 format.
   * For example, "2024-01-30T13:30:00".
   * @param localEndDate - Local end date of the time slot, in ISO-8601 format.
   * For example, "2024-01-30T14:30:00".
   * @param timeZone - Time zone, in IANA time zone format.
   * @param location - The location of the time slot.
   *
   * You must provide a specific `locationType`.
   * If locationType is `BUSINESS`, you __must__ also provide a `locationId`.
   *
   * <blockquote class="warning">
   * <p>Supports filtering by location type, or by location ID.
   * Other fields like <code class="grey-background">name</code> are ignored.</p>
   * </blockquote>
   * @public
   * @documentationMaturity preview
   * @requiredField localEndDate
   * @requiredField localStartDate
   * @requiredField location
   * @requiredField location.locationType
   * @requiredField services
   * @requiredField services.serviceId
   * @requiredField timeZone
   * @permissionId BOOKINGS.AVAILABILITY_READ_MULTI_SERVICE_TIME_SLOTS
   */
  function getMultiServiceAvailabilityTimeSlot(services: Service$2[], localStartDate: string, localEndDate: string, timeZone: string | null, location: Location$7): Promise<GetMultiServiceAvailabilityTimeSlotResponse>;
  
  type bookingsAvailabilityV2TimeSlotMultiServiceAvailabilityTimeSlots_universal_d_TimeSlot = TimeSlot;
  type bookingsAvailabilityV2TimeSlotMultiServiceAvailabilityTimeSlots_universal_d_EventInfo = EventInfo;
  type bookingsAvailabilityV2TimeSlotMultiServiceAvailabilityTimeSlots_universal_d_NestedTimeSlot = NestedTimeSlot;
  type bookingsAvailabilityV2TimeSlotMultiServiceAvailabilityTimeSlots_universal_d_CalculateEventBasedAvailabilityRequest = CalculateEventBasedAvailabilityRequest;
  type bookingsAvailabilityV2TimeSlotMultiServiceAvailabilityTimeSlots_universal_d_CalculateEventBasedAvailabilityResponse = CalculateEventBasedAvailabilityResponse;
  type bookingsAvailabilityV2TimeSlotMultiServiceAvailabilityTimeSlots_universal_d_ListEventTimeSlotsRequest = ListEventTimeSlotsRequest;
  type bookingsAvailabilityV2TimeSlotMultiServiceAvailabilityTimeSlots_universal_d_ListEventTimeSlotsResponse = ListEventTimeSlotsResponse;
  type bookingsAvailabilityV2TimeSlotMultiServiceAvailabilityTimeSlots_universal_d_ListMultiServiceAvailabilityTimeSlotsRequest = ListMultiServiceAvailabilityTimeSlotsRequest;
  type bookingsAvailabilityV2TimeSlotMultiServiceAvailabilityTimeSlots_universal_d_CommonCursorPaging = CommonCursorPaging;
  type bookingsAvailabilityV2TimeSlotMultiServiceAvailabilityTimeSlots_universal_d_ListMultiServiceAvailabilityTimeSlotsResponse = ListMultiServiceAvailabilityTimeSlotsResponse;
  type bookingsAvailabilityV2TimeSlotMultiServiceAvailabilityTimeSlots_universal_d_CommonCursorPagingMetadata = CommonCursorPagingMetadata;
  type bookingsAvailabilityV2TimeSlotMultiServiceAvailabilityTimeSlots_universal_d_CommonCursors = CommonCursors;
  type bookingsAvailabilityV2TimeSlotMultiServiceAvailabilityTimeSlots_universal_d_GetMultiServiceAvailabilityTimeSlotRequest = GetMultiServiceAvailabilityTimeSlotRequest;
  type bookingsAvailabilityV2TimeSlotMultiServiceAvailabilityTimeSlots_universal_d_GetMultiServiceAvailabilityTimeSlotResponse = GetMultiServiceAvailabilityTimeSlotResponse;
  type bookingsAvailabilityV2TimeSlotMultiServiceAvailabilityTimeSlots_universal_d_ListAvailabilityTimeSlotsRequest = ListAvailabilityTimeSlotsRequest;
  type bookingsAvailabilityV2TimeSlotMultiServiceAvailabilityTimeSlots_universal_d_CustomerChoices = CustomerChoices;
  type bookingsAvailabilityV2TimeSlotMultiServiceAvailabilityTimeSlots_universal_d_ListAvailabilityTimeSlotsResponse = ListAvailabilityTimeSlotsResponse;
  type bookingsAvailabilityV2TimeSlotMultiServiceAvailabilityTimeSlots_universal_d_GetAvailabilityTimeSlotRequest = GetAvailabilityTimeSlotRequest;
  type bookingsAvailabilityV2TimeSlotMultiServiceAvailabilityTimeSlots_universal_d_GetAvailabilityTimeSlotResponse = GetAvailabilityTimeSlotResponse;
  const bookingsAvailabilityV2TimeSlotMultiServiceAvailabilityTimeSlots_universal_d_listMultiServiceAvailabilityTimeSlots: typeof listMultiServiceAvailabilityTimeSlots;
  type bookingsAvailabilityV2TimeSlotMultiServiceAvailabilityTimeSlots_universal_d_ListMultiServiceAvailabilityTimeSlotsOptions = ListMultiServiceAvailabilityTimeSlotsOptions;
  const bookingsAvailabilityV2TimeSlotMultiServiceAvailabilityTimeSlots_universal_d_getMultiServiceAvailabilityTimeSlot: typeof getMultiServiceAvailabilityTimeSlot;
  namespace bookingsAvailabilityV2TimeSlotMultiServiceAvailabilityTimeSlots_universal_d {
    export {
      bookingsAvailabilityV2TimeSlotMultiServiceAvailabilityTimeSlots_universal_d_TimeSlot as TimeSlot,
      Location$7 as Location,
      LocationType$7 as LocationType,
      bookingsAvailabilityV2TimeSlotMultiServiceAvailabilityTimeSlots_universal_d_EventInfo as EventInfo,
      WaitingList$1 as WaitingList,
      BookingPolicyViolations$1 as BookingPolicyViolations,
      AvailableResources$1 as AvailableResources,
      Resource$4 as Resource,
      bookingsAvailabilityV2TimeSlotMultiServiceAvailabilityTimeSlots_universal_d_NestedTimeSlot as NestedTimeSlot,
      bookingsAvailabilityV2TimeSlotMultiServiceAvailabilityTimeSlots_universal_d_CalculateEventBasedAvailabilityRequest as CalculateEventBasedAvailabilityRequest,
      CursorPaging$a as CursorPaging,
      bookingsAvailabilityV2TimeSlotMultiServiceAvailabilityTimeSlots_universal_d_CalculateEventBasedAvailabilityResponse as CalculateEventBasedAvailabilityResponse,
      CursorPagingMetadata$8 as CursorPagingMetadata,
      Cursors$b as Cursors,
      bookingsAvailabilityV2TimeSlotMultiServiceAvailabilityTimeSlots_universal_d_ListEventTimeSlotsRequest as ListEventTimeSlotsRequest,
      bookingsAvailabilityV2TimeSlotMultiServiceAvailabilityTimeSlots_universal_d_ListEventTimeSlotsResponse as ListEventTimeSlotsResponse,
      bookingsAvailabilityV2TimeSlotMultiServiceAvailabilityTimeSlots_universal_d_ListMultiServiceAvailabilityTimeSlotsRequest as ListMultiServiceAvailabilityTimeSlotsRequest,
      Service$2 as Service,
      bookingsAvailabilityV2TimeSlotMultiServiceAvailabilityTimeSlots_universal_d_CommonCursorPaging as CommonCursorPaging,
      bookingsAvailabilityV2TimeSlotMultiServiceAvailabilityTimeSlots_universal_d_ListMultiServiceAvailabilityTimeSlotsResponse as ListMultiServiceAvailabilityTimeSlotsResponse,
      bookingsAvailabilityV2TimeSlotMultiServiceAvailabilityTimeSlots_universal_d_CommonCursorPagingMetadata as CommonCursorPagingMetadata,
      bookingsAvailabilityV2TimeSlotMultiServiceAvailabilityTimeSlots_universal_d_CommonCursors as CommonCursors,
      bookingsAvailabilityV2TimeSlotMultiServiceAvailabilityTimeSlots_universal_d_GetMultiServiceAvailabilityTimeSlotRequest as GetMultiServiceAvailabilityTimeSlotRequest,
      bookingsAvailabilityV2TimeSlotMultiServiceAvailabilityTimeSlots_universal_d_GetMultiServiceAvailabilityTimeSlotResponse as GetMultiServiceAvailabilityTimeSlotResponse,
      bookingsAvailabilityV2TimeSlotMultiServiceAvailabilityTimeSlots_universal_d_ListAvailabilityTimeSlotsRequest as ListAvailabilityTimeSlotsRequest,
      bookingsAvailabilityV2TimeSlotMultiServiceAvailabilityTimeSlots_universal_d_CustomerChoices as CustomerChoices,
      ResourceType$2 as ResourceType,
      bookingsAvailabilityV2TimeSlotMultiServiceAvailabilityTimeSlots_universal_d_ListAvailabilityTimeSlotsResponse as ListAvailabilityTimeSlotsResponse,
      bookingsAvailabilityV2TimeSlotMultiServiceAvailabilityTimeSlots_universal_d_GetAvailabilityTimeSlotRequest as GetAvailabilityTimeSlotRequest,
      bookingsAvailabilityV2TimeSlotMultiServiceAvailabilityTimeSlots_universal_d_GetAvailabilityTimeSlotResponse as GetAvailabilityTimeSlotResponse,
      bookingsAvailabilityV2TimeSlotMultiServiceAvailabilityTimeSlots_universal_d_listMultiServiceAvailabilityTimeSlots as listMultiServiceAvailabilityTimeSlots,
      bookingsAvailabilityV2TimeSlotMultiServiceAvailabilityTimeSlots_universal_d_ListMultiServiceAvailabilityTimeSlotsOptions as ListMultiServiceAvailabilityTimeSlotsOptions,
      bookingsAvailabilityV2TimeSlotMultiServiceAvailabilityTimeSlots_universal_d_getMultiServiceAvailabilityTimeSlot as getMultiServiceAvailabilityTimeSlot,
    };
  }
  
  interface ExternalCalendar {
  }
  interface ListProvidersRequest {
  }
  interface ListProvidersResponse {
      /**
       * Retrieves a list of the external calendar providers for which the site supports integration.
       *
       *
       * The list of external calendar providers includes:
       *
       * + External calendar providers that are supported by default, such as Google, Apple, and Microsoft.
       * + External calenders for which the site owner has enabled integration by installing an app.
       *
       * For each external calendar provider, the list contains information about supported connection methods and features.
       * For each provider, check `features.connectMethods` to find out whether to use `connectByCredentials()` or `connectByOAuth()` to establish a connection.
       */
      providers?: Provider[];
  }
  interface Provider {
      /** ID of the external calendar provider. */
      _id?: string | null;
      /** Name of the external calendar provider. */
      name?: string | null;
      /** External calendar provider type. */
      calendarType?: CalendarType$3;
      /** Features the external calendar provider supports. */
      features?: ProviderFeatures;
      /**
       * ID of the calendar provider.
       * Deprecated.  Please use `id` instead.
       * @internal
       * @deprecated
       */
      appDefId?: string | null;
  }
  enum CalendarType$3 {
      UNDEFINED = "UNDEFINED",
      GOOGLE = "GOOGLE",
      I_CAL = "I_CAL",
      /** Use `MICROSOFT` instead. */
      OUTLOOK = "OUTLOOK",
      /** Use `MICROSOFT` instead. */
      OFFICE_365 = "OFFICE_365",
      MICROSOFT = "MICROSOFT",
      OTHER = "OTHER"
  }
  interface ProviderFeatures {
      /**
       * Supported connection methods.
       *
       * For providers supporting `OAUTH`, connect with the `connectByOAuth()` function.
       * For providers supporting `CREDENTIALS`, connect with the `connectByCredentials()` function.
       */
      connectMethods?: ConnectMethod[];
      /**
       * Whether the sync configuration can be updated after a connection is established.
       *
       * If `true`, you can update the sync configuration using the `updateSyncConfig()` function.
       */
      updateSyncConfig?: boolean | null;
      /**
       * Whether events can be imported from external calendars to the Wix calendar.
       *
       * + `NOT_SUPPORTED`: Importing events from the external calendar is not supported.
       * + `PRIMARY_CALENDAR_ONLY`: Events can be imported only from an external calendar designated as primary.
       * + `SPECIFIC_CALENDARS`: Events can be imported from specific external calendars. Use `listCalendars()` to get a list of calendars for a connected external calendar account.
       */
      listEventFromCalendars?: ListEventFromCalendars;
      /**
       * Whether Wix calendar sessions can be exported to the external calendar.
       *
       * + `NOT_SUPPORTED`: Exporting events to an external calendar is not supported.
       * + `PRIMARY_CALENDAR_ONLY`: Events can only be exported only to an external calendar designated as primary.
       * + `SPECIFIC_CALENDARS`: Events can be exported to specific external calendars. Use `listCalendars()` to get a list of calendars for a connected external calendar account.
       * + `DEDICATED_CALENDAR`: Events can be exported to a newly created, dedicated external calendar in the connected external calendar account.
       */
      syncToCalendar?: SyncToCalendar;
  }
  enum ConnectMethod {
      UNDEFINED = "UNDEFINED",
      OAUTH = "OAUTH",
      CREDENTIALS = "CREDENTIALS"
  }
  enum ListEventFromCalendars {
      /** Dont use. */
      UNDEFINED = "UNDEFINED",
      /** Listing events from the external calendar is not supported. */
      NOT_SUPPORTED = "NOT_SUPPORTED",
      /** Listing events from the primary external calendar only. */
      PRIMARY_CALENDAR_ONLY = "PRIMARY_CALENDAR_ONLY",
      /**
       * Listing events from specific external calendars.
       * The external calendars can be listed using the `ExternalCalendarService.ListCalendars` API.
       */
      SPECIFIC_CALENDARS = "SPECIFIC_CALENDARS"
  }
  enum SyncToCalendar {
      /** Dont use. */
      UNDEFINED = "UNDEFINED",
      /** Syncing Wix calendar sessions to the external calendar is not supported. */
      NOT_SUPPORTED = "NOT_SUPPORTED",
      /** Syncing Wix calendar sessions to the primary external calendar only. */
      PRIMARY_CALENDAR_ONLY = "PRIMARY_CALENDAR_ONLY",
      /** Syncing Wix calendar sessions to a specific external calendar. */
      SPECIFIC_CALENDAR = "SPECIFIC_CALENDAR",
      /** Syncing Wix calendar sessions to a new external calendar. */
      DEDICATED_CALENDAR = "DEDICATED_CALENDAR"
  }
  interface GetConnectionRequest {
      /** ID of the connection to retrieve. */
      connectionId: string | null;
  }
  interface GetConnectionResponse {
      /** Retrieved external calendar connection. */
      connection?: Connection;
  }
  interface Connection {
      /** External calendar connection ID. */
      _id?: string | null;
      /** ID of the external calendar provider. */
      providerId?: string | null;
      /** External calendar type. */
      calendarType?: CalendarType$3;
      /** ID of the schedule connected to the external calendar. */
      scheduleId?: string | null;
      /** ID of the Wix user the external calendar connection belongs to. */
      userId?: string | null;
      /** ID of the Wix App the external calendar connection belongs to. */
      appId?: string | null;
      /** Email address associated with the external calendar account. Empty until sync is completed successfully. */
      externalAccountEmail?: string | null;
      /**
       * Connection status.
       *
       * + `CONNECTED`: A connection has been established with the external calendar.
       * + `SYNC_IN_PROGRESS`: A sync is in progress.
       * + `SYNCED`: External calendar sync complete.
       * + `DISCONNECTED`: External calendar has been disconnected.
       * + `ERROR`: An error occurred when syncing with the external calendar.
       */
      status?: Status$3;
      /**
       * Reason for the error, if `status` is `ERROR`.
       *
       * + `TOKEN_REVOKED`: External calendar access token revoked.
       * + `EXTERNAL_CALENDAR_CREATION_FAILED`: External calendar creation failed.
       * + `EXTERNAL_CALENDAR_DELETED`: External calendar was deleted.
       */
      errorReason?: ErrorReason;
      /**
       * Sync configuration. Contains settings for enabling, configuring, or disabling functionality, including:
       *
       * + Importing events from one or more specified calendars in the connected external calendar account.
       * + Exporting events from the Wix site's calendar to an external calendar.
       */
      syncConfig?: ConnectionSyncConfig;
      /**
       * Deprecated. Use `errorReason` instead.
       * @internal
       * @deprecated
       */
      syncToErrorReason?: SyncToErrorReason;
  }
  enum Status$3 {
      /** Dont use. */
      UNDEFINED = "UNDEFINED",
      /** External calendar is connected to the corresponding schedule id. */
      CONNECTED = "CONNECTED",
      /** Sync in progress. */
      SYNC_IN_PROGRESS = "SYNC_IN_PROGRESS",
      /** Calendars are in-sync. */
      SYNCED = "SYNCED",
      /** External calender is disconnected. */
      DISCONNECTED = "DISCONNECTED",
      /** The calendars sync is in error state. */
      ERROR = "ERROR"
  }
  enum ErrorReason {
      /** Empty or error reason is unknown. */
      UNDEFINED = "UNDEFINED",
      /** External calendar access token revoked. */
      TOKEN_REVOKED = "TOKEN_REVOKED",
      /** External calendar creation failed. */
      EXTERNAL_CALENDAR_CREATION_FAILED = "EXTERNAL_CALENDAR_CREATION_FAILED",
      /** External Calendar was deleted. */
      EXTERNAL_CALENDAR_DELETED = "EXTERNAL_CALENDAR_DELETED"
  }
  interface ConnectionSyncConfig {
      /**
       * Configuration for importing events from external calendars.
       * If enabled, use the `listEvents()` function to retrieve a list of events from external calendars.
       */
      listEventFromCalendars?: ConnectionSyncConfigListEventFromCalendars;
      /** Configuration for exporting calendars from the Wix site's calendar to a connected external calendar. */
      syncToCalendar?: ConnectionSyncConfigSyncToCalendar;
  }
  interface Calendar {
      /**
       * External calendar ID.
       * @readonly
       */
      _id?: string | null;
      /**
       * Display name of the external calendar.
       * For example, "Primary" or "Birthdays".
       */
      name?: string | null;
  }
  interface PrimaryCalendar {
  }
  interface Calendars {
      calendars?: Calendar[];
  }
  interface DedicatedCalendar {
  }
  interface ConnectionSyncConfigListEventFromCalendars extends ConnectionSyncConfigListEventFromCalendarsListFromOneOf {
      /**
       * Import events only from the primary external calendar. Enable this by passing an empty object.
       *
       * **Note**: Not all external calendar providers designate a primary calendar.
       */
      primaryCalendar?: PrimaryCalendar;
      /**
       * Import events from a list of specified external calendars.
       *
       * **Note**: The list can include the primary calendar.
       */
      calendars?: Calendars;
      /** Whether to enable importing events from external calendars through this connection. */
      enabled?: boolean | null;
  }
  /** @oneof */
  interface ConnectionSyncConfigListEventFromCalendarsListFromOneOf {
      /**
       * Import events only from the primary external calendar. Enable this by passing an empty object.
       *
       * **Note**: Not all external calendar providers designate a primary calendar.
       */
      primaryCalendar?: PrimaryCalendar;
      /**
       * Import events from a list of specified external calendars.
       *
       * **Note**: The list can include the primary calendar.
       */
      calendars?: Calendars;
  }
  interface ConnectionSyncConfigSyncToCalendar extends ConnectionSyncConfigSyncToCalendarSyncToOneOf {
      /** Sync to the primary external calendar. Enable this by passing an empty object. */
      primaryCalendar?: PrimaryCalendar;
      /** Sync to a dedicated external calendar. Enable this by passing an empty object. */
      dedicatedCalendar?: DedicatedCalendar;
      /** Whether to enable exporting events to an external calendars through this connection. */
      enabled?: boolean | null;
      /**
       * Whether to append the participant name to the event summary, for sessions having a single participant. E.g 1:1 Booking Sessions.
       * Default is false.
       * Note: DRAFT/PROPOSAL. Not implemented and aimed to replace `session.external_calendar_overrides`.
       * @internal
       */
      appendSingleParticipantNameToEventSummary?: boolean | null;
  }
  /** @oneof */
  interface ConnectionSyncConfigSyncToCalendarSyncToOneOf {
      /** Sync to the primary external calendar. Enable this by passing an empty object. */
      primaryCalendar?: PrimaryCalendar;
      /** Sync to a dedicated external calendar. Enable this by passing an empty object. */
      dedicatedCalendar?: DedicatedCalendar;
  }
  enum SyncToErrorReason {
      /** No sync error. */
      UNDEFINED = "UNDEFINED",
      /** Could not create calendar to sync sessions to. */
      CALENDAR_CREATION_FAILURE = "CALENDAR_CREATION_FAILURE",
      /** Calendar was deleted while sync was in progress. */
      CALENDAR_DELETED = "CALENDAR_DELETED"
  }
  interface ListConnectionsRequest {
      /**
       * Schedule IDs to filter by. If provided, only connections between external calendars and the specified schedules is returned.
       *
       * Default: Returns all connections.
       */
      scheduleIds?: string[] | null;
      /**
       * Whether to return a partial list of connections if details can't be retrieved for some connections.
       *
       * Default: `false`
       */
      partialFailure?: boolean | null;
  }
  interface ListConnectionsResponse {
      /** List of external calendar connections. */
      connections?: Connection[];
      /** List of provider IDs for connections for which retrieval failed. Returned only if `partialFailure` parameter is `true` in the request. */
      failedProviderIds?: string[] | null;
  }
  interface ConnectByOAuthRequest {
      /** ID of the schedule to connect with the external calendar account. */
      scheduleId: string | null;
      /**
       * ID of the external calendar provider. Find this with the `listProviders()` function.
       *
       */
      providerId: string | null;
      /**
       * URL to redirect the user to after they authorize access to the external calendar account.
       *
       * If the connection is successfully established, the user is redirected to this URL with a query parameter `connectionId` containing the new connection ID.
       * If the attempt to connect fails, the user is redirected to this URL with a query parameter `error` containing the error type.
       */
      redirectUrl: string | null;
      /**
       * Deprecated.
       * @internal
       * @deprecated
       */
      calendarType?: CalendarType$3;
  }
  interface ConnectByOAuthResponse {
      /** URL of the external calendar authorization page to redirect the user to. */
      oauthUrl?: string | null;
  }
  interface RawHttpRequest {
      body?: Uint8Array;
      pathParams?: PathParametersEntry[];
      queryParams?: QueryParametersEntry[];
      headers?: HeadersEntry[];
      method?: string;
      rawPath?: string;
      rawQuery?: string;
  }
  interface PathParametersEntry {
      key?: string;
      value?: string;
  }
  interface QueryParametersEntry {
      key?: string;
      value?: string;
  }
  interface HeadersEntry {
      key?: string;
      value?: string;
  }
  interface RawHttpResponse {
      body?: Uint8Array;
      statusCode?: number | null;
      headers?: HeadersEntry[];
  }
  interface ConnectByCredentialsRequest {
      /** ID of the schedule to connect with the external calendar account. */
      scheduleId: string | null;
      /** ID of the external calendar provider. Find this with the `listProviders()` function. */
      providerId: string | null;
      /** Email address for the external calendar account. */
      email: string | null;
      /** Password for the external calendar account. */
      password: string | null;
  }
  interface ConnectByCredentialsResponse {
      /** Established connection details. */
      connection?: Connection;
  }
  interface ListCalendarsRequest {
      /** ID of the external calendar connection to list calendars for. */
      connectionId: string | null;
  }
  interface ListCalendarsResponse {
      /** List of calendars belonging to the external calendar account. */
      calendars?: Calendar[];
  }
  interface UpdateSyncConfigRequest {
      /** ID of the external calendar connection to update. */
      connectionId: string | null;
      /** Updated sync configuration details. */
      syncConfig: ConnectionSyncConfig;
      /**
       * Optional list of fields to update. If provided, only the specified fields are updated.
       * @internal
       */
      fieldMask?: string[];
  }
  interface UpdateSyncConfigResponse {
      /** Connection with updated sync configuration. */
      connection?: Connection;
  }
  interface DisconnectRequest {
      /** ID of the external calendar connection to disconnect. */
      connectionId: string | null;
  }
  interface DisconnectResponse {
      /** Updated connection details. */
      connection?: Connection;
  }
  interface ListEventsRequest {
      /**
       * Date and time from which to retrieve events,
       * formatted according to [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt).
       * Required, unless `cursorPaging.cursor` is provided.
       *
       * Events which start before the `from` time and end after it are included in the returned list.
       */
      from?: string | null;
      /**
       * Date and time until which to retrieve events,
       * formatted according to [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt).
       * Required, unless `cursorPaging.cursor` is provided.
       *
       * Events which start before the `to` time and end after it are included in the returned list.
       */
      to?: string | null;
      /**
       * Schedule IDs to filter by. If provided, the returned list includes only events belonging to external calendars connected to the specified schedules.
       * Maximum of 100 schedule IDs per request.
       */
      scheduleIds?: string[] | null;
      /**
       * Wix user IDs to filter by. If provided, the returned list includes only events belonging to external calendars connected to schedules belonging to the specified Wix users.
       * Maximum of 100 Wix user IDs per request.
       */
      userIds?: string[] | null;
      /**
       * Whether to include only all-day events in the returned list.
       * If `true`, only all-day events are returned.
       * If `false`, only events with a specified time are returned.
       *
       * Default: All events are returned.
       */
      allDay?: boolean | null;
      /**
       * Predefined sets of fields to return.
       * - `NO_PI`: Returns event objects without personal information.
       * - `OWN_PI`: Returns complete event objects, including personal information.
       *
       * Default: `NO_PI`
       */
      fieldsets?: string[];
      /** Pagination options. */
      cursorPaging?: CursorPaging$9;
      /**
       * Whether to return a partial list of events if details can't be retrieved for some connections.
       *
       * Default: `false`
       */
      partialFailure?: boolean | null;
      /**
       * Deprecated.
       * @internal
       * @deprecated
       */
      includePi?: boolean | null;
  }
  interface CursorPaging$9 {
      /**
       * Number of events to load.
       * Max: `1000`
       */
      limit?: number | null;
      /**
       * Pointer to the next or previous page in the list of results.
       *
       * You can get the relevant cursor token
       * from the `pagingMetadata` object in the previous call's response.
       * Not relevant for the first request.
       */
      cursor?: string | null;
  }
  interface ListEventsResponse {
      /** List of external calendar events matching the filters. */
      events?: Event$2[];
      /** Paging metadata. */
      pagingMetadata?: CursorPagingMetadata$7;
      /** List of provider IDs for connections for which retrieval of events failed. Returned only if `partialFailure` parameter is `true` in the request. */
      failedProviderIds?: string[] | null;
      /**
       * @internal
       * @deprecated
       */
      paging?: CursorPagingMetadata$7;
  }
  /** An external calendar event. */
  interface Event$2 {
      /** ID of the schedule connected to the external calendar the event belongs to. */
      scheduleId?: string | null;
      /** External calendar type. */
      calendarType?: CalendarType$3;
      /**
       * Display name of the external calendar.
       * For example, "Primary" or "Birthdays".
       */
      calendarName?: string | null;
      /** Event title. */
      title?: string | null;
      /** Start date and time of the event (inclusive), formatted according to [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt). */
      start?: string | null;
      /** End date and time of the event (exclusive), formatted according to [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt). */
      end?: string | null;
      /**
       * Whether the event is an all-day event.
       *
       * Default: `false`
       */
      allDay?: boolean | null;
      /**
       * ID of the Wix user the schedule belongs to.
       * For example, the ID of the staff member (resource) who owns the schedule.
       */
      scheduleOwnerId?: string | null;
      /**
       * Name of the Wix user the schedule belongs to.
       * For example, the name of the staff member (resource) who owns the schedule.
       */
      scheduleOwnerName?: string | null;
  }
  interface CursorPagingMetadata$7 {
      /** Number of items returned in the response. */
      count?: number | null;
      /** Offset that was requested. */
      cursors?: Cursors$a;
      /**
       * Indicates if there are more results after the current page.
       * If `true`, another page of results can be retrieved.
       * If `false`, this is the last page.
       */
      hasNext?: boolean | null;
  }
  interface Cursors$a {
      /** Cursor pointing to next page in the list of results. */
      next?: string | null;
  }
  interface ScheduleNotification$3 extends ScheduleNotificationEventOneOf$3 {
      scheduleCreated?: ScheduleCreated$3;
      scheduleUpdated?: ScheduleUpdated$3;
      scheduleCancelled?: ScheduleCancelled$3;
      sessionCreated?: SessionCreated$3;
      sessionUpdated?: SessionUpdated$3;
      sessionCancelled?: SessionCancelled$3;
      availabilityPolicyUpdated?: AvailabilityPolicyUpdated$3;
      /** @deprecated */
      intervalSplit?: IntervalSplit$3;
      recurringSessionSplit?: RecurringSessionSplit$3;
      /**
       * Inspect `schedule.scheduleOwnerUserId` on `scheduleUpdated` instead.
       * @deprecated
       */
      scheduleUnassignedFromUser?: ScheduleUnassignedFromUser$3;
      /**
       * supported only for schedule migration apis.
       * @internal
       */
      multipleSessionsCreated?: MultipleSessionsCreated$3;
      /**
       * supported only for schedule migration apis.
       * @internal
       */
      migrationEvent?: MigrationEvent$3;
      preserveFutureSessionsWithParticipants?: boolean | null;
      /**
       * Whether to notify participants about changed sessions. deprecated, use participant_notification
       * @deprecated
       */
      notifyParticipants?: boolean;
      /** site properties. Optional. Given in create schedule notification. */
      siteProperties?: SitePropertiesOnScheduleCreation$3;
      instanceId?: string;
      /**
       * true when the schedule belongs to a site that is rolled out to calendar v3
       * @internal
       */
      rolledOut?: boolean | null;
  }
  /** @oneof */
  interface ScheduleNotificationEventOneOf$3 {
      scheduleCreated?: ScheduleCreated$3;
      scheduleUpdated?: ScheduleUpdated$3;
      scheduleCancelled?: ScheduleCancelled$3;
      sessionCreated?: SessionCreated$3;
      sessionUpdated?: SessionUpdated$3;
      sessionCancelled?: SessionCancelled$3;
      availabilityPolicyUpdated?: AvailabilityPolicyUpdated$3;
      /** @deprecated */
      intervalSplit?: IntervalSplit$3;
      recurringSessionSplit?: RecurringSessionSplit$3;
      /**
       * Inspect `schedule.scheduleOwnerUserId` on `scheduleUpdated` instead.
       * @deprecated
       */
      scheduleUnassignedFromUser?: ScheduleUnassignedFromUser$3;
      /**
       * supported only for schedule migration apis.
       * @internal
       */
      multipleSessionsCreated?: MultipleSessionsCreated$3;
      /**
       * supported only for schedule migration apis.
       * @internal
       */
      migrationEvent?: MigrationEvent$3;
  }
  interface ScheduleCreated$3 {
      schedule?: Schedule$4;
  }
  interface Schedule$4 {
      /** Schedule ID. */
      _id?: string;
      /** ID of the schedule's owner entity. This may be a resource ID or a service ID. */
      scheduleOwnerId?: string | null;
      /**
       * Start time of the first session in the schedule.
       * @internal
       * @readonly
       */
      firstSessionStart?: Date | null;
      /**
       * End time of the last session in the schedule.
       * @internal
       * @readonly
       */
      lastSessionEnd?: Date | null;
      /**
       * Schedule's time zone in [Area/Location](https://en.wikipedia.org/wiki/Tz_database) format. Read-only.
       * Derived from the Wix Business time zone.
       * @readonly
       */
      timeZone?: string | null;
      /**
       * Deprecated. Please use the [Sessions API](https://dev.wix.com/api/rest/wix-bookings/schedules-and-sessions/session) instead.
       * @deprecated
       */
      intervals?: RecurringInterval$3[];
      /** Default title for the schedule's sessions. Maximum length: 6000 characters. */
      title?: string | null;
      /**
       * __Deprecated.__
       * Tags for grouping schedules. These tags are the default tags for the schedule's sessions.
       * The Wix Bookings app uses the following predefined tags to set schedule type: `"INDIVIDUAL"`, `"GROUP"`, and `"COURSE"`. Once the schedule type is set using these tags, you cannot update it. In addition to the app's tags, you can create and update your own tags.
       * @deprecated
       */
      tags?: string[] | null;
      /** Default location for the schedule's sessions. */
      location?: Location$6;
      /**
       * Maximum number of participants that can be added to the schedule's sessions.
       * Must be at most `1` for schedule whose availability is affected by another schedule. E.g, appointment schedules of the Wix Bookings app.
       */
      capacity?: number | null;
      /**
       * Deprecated. Please use the [Booking Services V2](https://dev.wix.com/api/rest/wix-bookings/services-v2) payment instead.
       * @deprecated
       */
      rate?: Rate$3;
      /**
       * __Deprecated.__
       * @deprecated
       */
      availability?: Availability$3;
      /**
       * Number of participants registered to sessions in this schedule, calculated as the sum of the party sizes.
       * @readonly
       */
      totalNumberOfParticipants?: number;
      /**
       * *Partial list** of participants which are registered to sessions in this schedule.
       * Participants who are registered in the schedule are automatically registered to any session that is created for the schedule.
       * To retrieve the full list of schedule participants please use the [Query Extended Bookings API](https://dev.wix.com/api/rest/wix-bookings/bookings-reader-v2/query-extended-bookings).
       * @readonly
       */
      participants?: Participant$3[];
      /**
       * __Deprecated.__
       * @deprecated
       */
      externalCalendarOverrides?: ExternalCalendarOverrides$3;
      /**
       * Schedule status.
       * @readonly
       */
      status?: ScheduleStatus$3;
      /**
       * Schedule creation date.
       * @readonly
       */
      created?: Date | null;
      /**
       * Schedule last update date.
       * @readonly
       */
      updated?: Date | null;
      /**
       * Schedule version number, updated each time the schedule is updated.
       * @readonly
       */
      version?: number;
      /**
       * The schedule version, updated each time the schedule or the schedule participants are updated.
       * @internal
       * @readonly
       */
      versions?: Version$3;
      /**
       * Fields which were inherited from the Business Info page under Settings in the Dashboard.
       * @readonly
       */
      inheritedFields?: string[];
      /**
       * __Deprecated.__
       * @deprecated
       */
      conferenceProvider?: ConferenceProvider$3;
      /**
       * A conference created for the schedule. This is used when a participant is added to a schedule.
       * **Partially deprecated.** Only `hostUrl` and `guestUrl` are to be supported.
       * @deprecated
       */
      calendarConference?: CalendarConference$3;
      /**
       * The name of the schedule owner. It may be a resource name or a service name. Optional.
       * @internal
       */
      scheduleOwnerName?: string | null;
      /**
       * The user id of the schedule owner. Optional.
       * Currently, in Bookings system, it would be present when the schedule is owned by a staff resource and the resource is connected to a user.
       * NOT IMPLEMENTED. YET.
       * @internal
       * @readonly
       */
      scheduleOwnerUserId?: string | null;
  }
  interface RecurringInterval$3 {
      /**
       * The recurring interval identifier.
       * @readonly
       */
      _id?: string;
      /** The start time of the recurring interval. Required. */
      start?: Date | null;
      /** The end time of the recurring interval. Optional. Empty value indicates that there is no end time. */
      end?: Date | null;
      /** The interval rules. The day, hour and minutes the interval is recurring. */
      interval?: Interval$4;
      /** The frequency of the interval. Optional. The default is frequency with the default repetition. */
      frequency?: Frequency$3;
      /** Specifies the list of linked schedules and the way this link affects the corresponding schedules' availability. Can be calculated from the schedule or overridden on the recurring interval. */
      affectedSchedules?: LinkedSchedule$3[];
      /** The type of recurring interval. */
      intervalType?: RecurringIntervalType$3;
  }
  interface Interval$4 {
      /** The day the interval accrue. Optional. The default is the day of the recurring interval's start time. */
      daysOfWeek?: Day$3;
      /** The hour of the day the interval accrue. must be consistent with the Interval start time. Options. The default is 0. minimum: 0, maximum: 23. */
      hourOfDay?: number | null;
      /** The minutes of hour the interval accrue. must be consistent with the Interval end time. Options. The default is 0. minimum: 0, maximum: 59. */
      minuteOfHour?: number | null;
      /** The duration of the interval in minutes. Required. Part of the session end time calculation. */
      duration?: number;
  }
  enum Day$3 {
      /** Undefined. */
      UNDEFINED = "UNDEFINED",
      /** Monday. */
      MON = "MON",
      /** Tuesday. */
      TUE = "TUE",
      /** Wednesday. */
      WED = "WED",
      /** Thursday. */
      THU = "THU",
      /** Friday. */
      FRI = "FRI",
      /** Saturday. */
      SAT = "SAT",
      /** Sunday. */
      SUN = "SUN"
  }
  interface Frequency$3 {
      /** The frequency of the recurrence in weeks. i.e. when this value is 4, the interval occurs every 4 weeks. Optional. The default is 1. minimum: 1, maximum: 52. */
      repetition?: number | null;
  }
  interface LinkedSchedule$3 {
      /** Schedule ID. */
      scheduleId?: string;
      /**
       * Sets this schedule's availability for the duration of the linked schedule's sessions.  Default is `"BUSY"`.
       * If set to `"BUSY"`, this schedule cannot have any available slots during the linked schedule's sessions.
       * If set to `"FREE"`, this schedule can have available slots during the linked schedule's sessions.
       */
      transparency?: Transparency$3;
      /**
       * Owner ID, of the linked schedule.
       * @readonly
       */
      scheduleOwnerId?: string;
      /**
       * The name of the linked schedule owner. It may be a resource name or a service name. Optional.
       * This field is inherited from the schedule identified by scheduleId above.
       * @internal
       * @readonly
       */
      scheduleOwnerName?: string | null;
      /**
       * The user id of the linked schedule owner. Optional.
       * This field is inherited from the schedule identified by scheduleId above.
       * NOT IMPLEMENTED. YET.
       * @internal
       * @readonly
       */
      scheduleOwnerUserId?: string | null;
  }
  enum Transparency$3 {
      UNDEFINED = "UNDEFINED",
      /** The schedule can have available slots during the session. */
      FREE = "FREE",
      /** The schedule cannot have available slots during the session. Default value. */
      BUSY = "BUSY"
  }
  enum RecurringIntervalType$3 {
      /** The default value. Sessions for this interval will be of type EVENT. */
      UNDEFINED = "UNDEFINED",
      /** A recurring interval of events */
      EVENT = "EVENT",
      /** Deprecated */
      TIME_AVAILABILITY = "TIME_AVAILABILITY",
      /** A recurring interval for availability */
      AVAILABILITY = "AVAILABILITY"
  }
  interface Location$6 {
      /**
       * Location type.
       * One of:
       * - `"OWNER_BUSINESS"` The business address as set in the sites general settings.
       * - `"OWNER_CUSTOM"` The address as set when creating the service.
       * - `"CUSTOM"` The address set for the individual session.
       */
      locationType?: LocationType$6;
      /**
       * Free text address used when locationType is `OWNER_CUSTOM`.
       * @deprecated
       */
      address?: string | null;
      /** Custom address, used when locationType is `"OWNER_CUSTOM"`. Might be used when locationType is `"CUSTOM"` in case the owner sets a custom address for the session which is different from the default. */
      customAddress?: Address$7;
      /**
       * The Wix Business location formatted address.
       * Valid when `locationType` is `OWNER_BUSINESS`. Defaults to the business's location.
       * To retrieve the full location data please use the [Locations API](https://dev.wix.com/api/rest/business-info/locations).
       * @internal
       */
      businessLocation?: LocationsLocation$3;
  }
  enum LocationType$6 {
      UNDEFINED = "UNDEFINED",
      OWNER_BUSINESS = "OWNER_BUSINESS",
      OWNER_CUSTOM = "OWNER_CUSTOM",
      CUSTOM = "CUSTOM"
  }
  /** Physical address */
  interface Address$7 extends AddressStreetOneOf$6 {
      /** Street name, number and apartment number. */
      streetAddress?: StreetAddress$6;
      /** Main address line, usually street and number, as free text. */
      addressLine?: string | null;
      /** Country code. */
      country?: string | null;
      /** Subdivision. Usually state, region, prefecture or province code, according to [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). */
      subdivision?: string | null;
      /** City name. */
      city?: string | null;
      /** Zip/postal code. */
      postalCode?: string | null;
      /** Free text providing more detailed address info. Usually contains Apt, Suite, and Floor. */
      addressLine2?: string | null;
      /** A string containing the full address of this location. */
      formattedAddress?: string | null;
      /** Free text to help find the address. */
      hint?: string | null;
      /** Coordinates of the physical address. */
      geocode?: AddressLocation$6;
      /** Country full name. */
      countryFullname?: string | null;
      /** Multi-level subdivisions from top to bottom. */
      subdivisions?: Subdivision$6[];
  }
  /** @oneof */
  interface AddressStreetOneOf$6 {
      /** Street name, number and apartment number. */
      streetAddress?: StreetAddress$6;
      /** Main address line, usually street and number, as free text. */
      addressLine?: string | null;
  }
  interface StreetAddress$6 {
      /** Street number. */
      number?: string;
      /** Street name. */
      name?: string;
      /** Apartment number. */
      apt?: string;
  }
  interface AddressLocation$6 {
      /** Address latitude. */
      latitude?: number | null;
      /** Address longitude. */
      longitude?: number | null;
  }
  interface Subdivision$6 {
      /** Subdivision code. Usually state, region, prefecture or province code, according to [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). */
      code?: string;
      /** Subdivision full name. */
      name?: string;
  }
  interface LocationsLocation$3 {
      /**
       * Location ID.
       * @readonly
       */
      _id?: string | null;
      /** Location name. */
      name?: string;
      /** Location description. */
      description?: string | null;
      /**
       * Whether this is the default location. There can only be one default location per site. The default location can't be archived.
       * @readonly
       */
      default?: boolean;
      /**
       * Location status. Defaults to `ACTIVE`.
       * __Note:__ [Archiving a location](https://www.wix.com/velo/reference/wix-business-tools-v2/locations/archivelocation)
       * doesn't affect the location's status. `INACTIVE` is currently not supported.
       */
      status?: LocationStatus$3;
      /**
       * Location type.
       *
       * **Note:** Currently not supported.
       * @deprecated
       */
      locationType?: LocationsLocationType$3;
      /** Fax number. */
      fax?: string | null;
      /** Timezone in `America/New_York` format. */
      timeZone?: string | null;
      /** Email address. */
      email?: string | null;
      /** Phone number. */
      phone?: string | null;
      /** Address. */
      address?: LocationsAddress$3;
      /**
       * Business schedule. Array of weekly recurring time periods when the location is open for business. Limited to 100 time periods.
       *
       * __Note:__ Not supported by Wix Bookings.
       */
      businessSchedule?: BusinessSchedule$4;
      /**
       * Revision number, which increments by 1 each time the location is updated.
       * To prevent conflicting changes, the existing revision must be used when updating a location.
       */
      revision?: string | null;
      /**
       * Whether the location is archived. Archived locations can't be updated.
       * __Note:__ [Archiving a location](https://www.wix.com/velo/reference/wix-business-tools-v2/locations/archivelocation)
       * doesn't affect its `status`.
       * @readonly
       */
      archived?: boolean;
      /** Location types. */
      locationTypes?: LocationsLocationType$3[];
  }
  /** For future use */
  enum LocationStatus$3 {
      ACTIVE = "ACTIVE",
      INACTIVE = "INACTIVE"
  }
  /** For future use */
  enum LocationsLocationType$3 {
      UNKNOWN = "UNKNOWN",
      BRANCH = "BRANCH",
      OFFICES = "OFFICES",
      RECEPTION = "RECEPTION",
      HEADQUARTERS = "HEADQUARTERS",
      INVENTORY = "INVENTORY"
  }
  interface LocationsAddress$3 {
      /** 2-letter country code in an [ISO-3166 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format. */
      country?: string | null;
      /** Code for a subdivision (such as state, prefecture, or province) in [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) format. */
      subdivision?: string | null;
      /** City name. */
      city?: string | null;
      /** Postal or zip code. */
      postalCode?: string | null;
      /** Street address. Includes street name, number, and apartment number in separate fields. */
      streetAddress?: LocationsStreetAddress$3;
      /** Full address of the location. */
      formatted?: string | null;
      /** Geographic coordinates of location. */
      location?: LocationsAddressLocation$3;
  }
  /** Street address. Includes street name, number, and apartment number in separate fields. */
  interface LocationsStreetAddress$3 {
      /** Street number. */
      number?: string;
      /** Street name. */
      name?: string;
      /** Apartment number. */
      apt?: string;
  }
  /** Address Geolocation */
  interface LocationsAddressLocation$3 {
      /** Latitude of the location. Must be between -90 and 90. */
      latitude?: number | null;
      /** Longitude of the location. Must be between -180 and 180. */
      longitude?: number | null;
  }
  /** Business schedule. Regular and exceptional time periods when the business is open or the service is available. */
  interface BusinessSchedule$4 {
      /** Weekly recurring time periods when the business is regularly open or the service is available. Limited to 100 time periods. */
      periods?: TimePeriod$4[];
      /** Exceptions to the business's regular hours. The business can be open or closed during the exception. */
      specialHourPeriod?: SpecialHourPeriod$4[];
  }
  /** Weekly recurring time periods when the business is regularly open or the service is available. */
  interface TimePeriod$4 {
      /** Day of the week the period starts on. */
      openDay?: DayOfWeek$4;
      /**
       * Time the period starts in 24-hour [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) extended format. Valid values are `00:00` to `24:00`, where `24:00` represents
       * midnight at the end of the specified day.
       */
      openTime?: string;
      /** Day of the week the period ends on. */
      closeDay?: DayOfWeek$4;
      /**
       * Time the period ends in 24-hour [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) extended format. Valid values are `00:00` to `24:00`, where `24:00` represents
       * midnight at the end of the specified day.
       *
       * __Note:__ If `openDay` and `closeDay` specify the same day of the week `closeTime` must be later than `openTime`.
       */
      closeTime?: string;
  }
  /** Enumerates the days of the week. */
  enum DayOfWeek$4 {
      MONDAY = "MONDAY",
      TUESDAY = "TUESDAY",
      WEDNESDAY = "WEDNESDAY",
      THURSDAY = "THURSDAY",
      FRIDAY = "FRIDAY",
      SATURDAY = "SATURDAY",
      SUNDAY = "SUNDAY"
  }
  /** Exception to the business's regular hours. The business can be open or closed during the exception. */
  interface SpecialHourPeriod$4 {
      /** Start date and time of the exception in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format and [Coordinated Universal Time (UTC)](https://en.wikipedia.org/wiki/Coordinated_Universal_Time). */
      startDate?: string;
      /** End date and time of the exception in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format and [Coordinated Universal Time (UTC)](https://en.wikipedia.org/wiki/Coordinated_Universal_Time). */
      endDate?: string;
      /**
       * Whether the business is closed (or the service is not available) during the exception.
       *
       * Default: `true`.
       */
      isClosed?: boolean;
      /** Additional info about the exception. For example, "We close earlier on New Year's Eve." */
      comment?: string;
  }
  interface Rate$3 {
      /**
       * Mapping between a named price option, for example, adult or child prices, and the price, currency, and down payment amount.
       * When present in an update request, the `default_varied_price` is ignored to support backward compatibility.
       */
      labeledPriceOptions?: Record<string, Price$4>;
      /**
       * Textual price information used when **Price Per Session** is set to **Custom Price** in the app's service details page.
       * When present in an update request, the `default_varied_price` is ignored to support backward compatibility.
       */
      priceText?: string | null;
      /**
       * Default service price. Always available when a service has
       * [variants](https://support.wix.com/en/article/about-service-categories-in-wix-bookings).
       * Sometimes also available for services without variants.
       * @internal
       */
      defaultVariedPrice?: Price$4;
  }
  interface Price$4 {
      /** Required payment amount. */
      amount?: string;
      /** Currency in which the amount is quoted. */
      currency?: string;
      /** Amount of a down payment or deposit as part of the transaction. */
      downPayAmount?: string;
  }
  /**
   * <!-- Needs updating when recurrence has been tested
   * Schedule's availability calculation is executed by the schedule's available intervals and this additional information.
   * Schedule's available intervals are recurring intervals (defined in the schedule) minus sessions that has no more spots for bookings (including time between_slots), or schedule's sessions with open spots for bookings.-->
   */
  interface Availability$3 {
      /** Date and time the schedule starts to be available for booking. */
      start?: Date | null;
      /** Date and time the schedule stops being available for booking. No value indicates no end time. */
      end?: Date | null;
      /** Other schedules that impact the availability calculation. Relevant only when there are availability constraints. */
      linkedSchedules?: LinkedSchedule$3[];
      /** Constraints for calculating the schedule's availability. */
      constraints?: AvailabilityConstraints$3;
      /**
       * Not supported yet.
       * A list of possible locations for the session when `use_default_location` is set to `false`. Slots are generated for each location. Only one of the possible locations can be chosen by the customer.
       *
       * **NOTE**: When using the `locations` parameter, the default location is not automatically included in the list.
       * @internal
       */
      locations?: Location$6[];
      /**
       * Not supported yet.
       * Whether the schedule's slots are only available at the schedule's default location, as set in `schedule.location`. If set to `false`, the `locations` array is used to set the possible locations of the schedule's sessions.
       * Default is `true`.
       * @internal
       */
      useDefaultLocation?: boolean | null;
  }
  /** Describes how to calculate the specific slots that are available for booking. */
  interface AvailabilityConstraints$3 {
      /**
       * A list of duration options for slots, in minutes. Minimum value for a duration is 1.
       * The availability calculation generates slots with these durations, where there is no conflict with existing sessions or other availability constraints.
       */
      slotDurations?: number[];
      /**
       * The number of minutes between the `end` of one slot, and the `start` of the next.
       * Minimum value is 0, maximum value is 120.
       */
      timeBetweenSlots?: number;
      /**
       * Specify how to split the slots in intervals of minutes.
       * This value indicates the time between available slots' start time. e.g., from 5 minute slots (3:00, 3:05, 3:15) and 1 hour slots (3:00, 4:00, 5:00).
       * Optional. The default is the first duration in slot_durations field.
       * Deprecated. Use the `split_slots_interval.value_in_minutes`.
       * @deprecated
       */
      splitInterval?: number | null;
      /**
       * An object defining the time between available slots' start times.  For example, a slot with slots_split_interval=5 can start every 5 minutes. The default is the slot duration.
       * @readonly
       */
      slotsSplitInterval?: SplitInterval$3;
  }
  /** The time between available slots' start times. For example, For 5 minute slots, 3:00, 3:05, 3:15 etc. For 1 hour slots, 3:00, 4:00, 5:00 etc. */
  interface SplitInterval$3 {
      /**
       * Whether the slot duration is used as the split interval value.
       * If `same_as_duration` is `true`, the `value_in_minutes` is the sum of the first duration in
       * `schedule.availabilityConstraints.SlotDurations` field, and `schedule.availabilityConstraints.TimeBetweenSlots` field.
       */
      sameAsDuration?: boolean | null;
      /** Number of minutes between available slots' start times when `same_as_duration` is `false`. */
      valueInMinutes?: number | null;
  }
  interface Participant$3 {
      /** Participant ID. Currently represents the booking.id. */
      _id?: string;
      /** Contact ID. */
      contactId?: string | null;
      /** Participant's name. */
      name?: string | null;
      /** Participant's phone number. */
      phone?: string | null;
      /** Participant's email address. */
      email?: string | null;
      /** Group or party size. The number of people attending. Defaults to 0. Maximum is 250. */
      partySize?: number;
      /**
       * Approval status for the participant.
       * <!-- Commented out untill updateParticipant is exposed Generally the same status as the booking, unless updated using the `updateParticipant()` API. Defaults to `"UNDEFINED"`.-->
       */
      approvalStatus?: ApprovalStatus$3;
      /**
       * Whether the participant was inherited from the schedule, as opposed to being booked directly to the session.
       * @readonly
       */
      inherited?: boolean;
  }
  enum ApprovalStatus$3 {
      /** Default. */
      UNDEFINED = "UNDEFINED",
      /** Pending business approval. */
      PENDING = "PENDING",
      /** Approved by the business. */
      APPROVED = "APPROVED",
      /** Declined by the business. */
      DECLINED = "DECLINED"
  }
  interface ExternalCalendarOverrides$3 {
      /** Synced title of the external calendar event. */
      title?: string | null;
      /** Synced description of the external calendar event. */
      description?: string | null;
  }
  enum ScheduleStatus$3 {
      UNDEFINED = "UNDEFINED",
      /** The default value when the schedule is created. */
      CREATED = "CREATED",
      /** The schedule has been canceled. */
      CANCELLED = "CANCELLED"
  }
  interface Version$3 {
      /** Schedule version number, updated each time the schedule is updated. */
      scheduleVersion?: number | null;
      /** Participants version number, updated each time the schedule participants are updated. */
      participantsVersion?: number | null;
  }
  interface ConferenceProvider$3 {
      /** Conferencing provider ID */
      providerId?: string;
  }
  interface CalendarConference$3 {
      /** Wix Calendar conference ID. */
      _id?: string;
      /** Conference meeting ID in the provider's conferencing system. */
      externalId?: string;
      /**
       * A generated id for the conference entity - Base62($providerId$accountOwnerId$conferenceId)
       * @internal
       */
      conferenceId?: string | null;
      /** Conference provider ID. */
      providerId?: string;
      /** URL used by the host to start the conference. */
      hostUrl?: string;
      /** URL used by a guest to join the conference. */
      guestUrl?: string;
      /** Password to join the conference. */
      password?: string | null;
      /** Conference description. */
      description?: string | null;
      /** Conference type. */
      conferenceType?: ConferenceType$3;
      /** ID of the account owner in the video conferencing service. */
      accountOwnerId?: string | null;
  }
  enum ConferenceType$3 {
      UNDEFINED = "UNDEFINED",
      /** API-generated online meeting. */
      ONLINE_MEETING_PROVIDER = "ONLINE_MEETING_PROVIDER",
      /** User-defined meeting. */
      CUSTOM = "CUSTOM"
  }
  interface ScheduleUpdated$3 {
      /** The old schedule before the update. */
      oldSchedule?: Schedule$4;
      /** The new schedule after the update. */
      newSchedule?: Schedule$4;
      /**
       * Recurring sessions updated event. If this field is given, the reason for the schedule updated event was
       * updating at least one of the given schedule's recurring sessions.
       * This event is triggered by create/update/delete recurring session apis.
       */
      recurringSessions?: RecurringSessionsUpdated$3;
      /** Whether to notify participants about the change and an optional custom message */
      participantNotification?: ParticipantNotification$7;
      /**
       * Whether this notification was created as a result of an anonymization request, such as GDPR.
       * An anonymized participant will have the following details:
       * name = "deleted"
       * phone = "deleted"
       * email = "deleted@deleted.com"
       */
      triggeredByAnonymizeRequest?: boolean | null;
  }
  interface RecurringSessionsUpdated$3 {
      /** Old schedule's recurring session list. */
      oldRecurringSessions?: Session$3[];
      /** New schedule's recurring session list. */
      newRecurringSessions?: Session$3[];
  }
  interface Session$3 {
      /**
       * Session ID.
       * @readonly
       */
      _id?: string | null;
      /** ID of the schedule that the session belongs to. */
      scheduleId?: string;
      /**
       * ID of the resource or service that the session's schedule belongs to.
       * @readonly
       */
      scheduleOwnerId?: string | null;
      /** Original start date and time of the session in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Coordinated_Universal_Time_(UTC)) format. */
      originalStart?: Date | null;
      /** An object specifying the start date and time of the session. If the session is a recurring session, `start` must contain a `localDateTime`. */
      start?: CalendarDateTime$3;
      /**
       * An object specifying the end date and time of the session. The `end` time must be after the `start` time and be same type as `start`.
       * If the session is a recurring session, `end` must contain a `localDateTime`.
       */
      end?: CalendarDateTime$3;
      /**
       * An object specifying a list of schedules and the way each schedule's availability is affected by the session. For example, the schedule of an instructor is affected by sessions of the class that they instruct.
       * The array is inherited from the schedule and can be overridden even if the session is a recurring session.
       */
      affectedSchedules?: LinkedSchedule$3[];
      /**
       * Session title.
       * The value is inherited from the schedule and can be overridden unless the session is a recurring session.
       */
      title?: string | null;
      /**
       * __Deprecated.__
       * Tags for the session.
       * The value is inherited from the schedule and can be overridden unless the session is a recurring session.
       * @deprecated
       */
      tags?: string[] | null;
      /**
       * An object describing the location where the session takes place.
       * Defaults to the schedule location.
       * For single sessions, `session.location.businessLocation` can only be provided for locations that are defined in the schedule using `schedule.location` or `schedule.availability.locations`.
       */
      location?: Location$6;
      /**
       * Maximum number of participants that can be added to the session. Defaults to the schedule capacity.
       * The value is inherited from the schedule and can be overridden unless the session is a recurring session.
       */
      capacity?: number | null;
      /**
       * The remaining number of participants that can be added to the session. Read-only.
       * Can be negative, in case the session is over capacity.
       * @internal
       * @readonly
       */
      remainingCapacity?: number | null;
      /**
       * Deprecated. Please use the [Booking Services V2](https://dev.wix.com/api/rest/wix-bookings/services-v2) payment instead.
       * @deprecated
       */
      rate?: Rate$3;
      /**
       * Time reserved after the session end time, derived from the schedule availability constraints and the time between slots. Read-only.
       * If the session is a recurring session, this field must be empty.
       */
      timeReservedAfter?: number | null;
      /**
       * Additional information about the session.
       * Notes are not supported for recurring sessions.
       */
      notes?: string;
      /**
       * The number of participants booked for the session. Read-only.
       * Calculated as the sum of the party sizes.
       * @readonly
       */
      totalNumberOfParticipants?: number;
      /**
       * *Partial list** list of participants booked for the session.
       * The list includes participants who have registered for this specific session, and participants who have registered for a schedule that includes this session.
       * If the session is a recurring session, this field must be empty.
       * To retrieve the full list of session participants please use the [Query Extended Bookings API](https://dev.wix.com/api/rest/wix-bookings/bookings-reader-v2/query-extended-bookings).
       */
      participants?: Participant$3[];
      /**
       * A list of properties for which values were inherited from the schedule.
       * This does not include participants that were inherited from the schedule.
       * @readonly
       */
      inheritedFields?: string[];
      /**
       * Information about the external calendar, if the session originated in an external calendar.
       * @internal
       * @readonly
       */
      externalCalendarInfo?: ExternalCalendarInfo$3;
      /**
       * __Deprecated.__
       * @deprecated
       */
      externalCalendarOverrides?: ExternalCalendarOverrides$3;
      /**
       * Session status.
       * @readonly
       */
      status?: SessionStatus$1;
      /**
       * Recurring interval ID. Defined when a session will be a recurring session. read-only. Optional.
       * For exmaple, when creating a class service  with recurring sessions, you add a recurrence rule to create recurring sessions.
       * This field is omitted for single sessions or instances of recurring sessions.
       * Specified when the session was originally generated from a schedule recurring interval.
       * Deprecated. Use `recurringSessionId`.
       * @readonly
       * @deprecated
       */
      recurringIntervalId?: string | null;
      /**
       * The ID of the recurring session if this session is an instance of a recurrence. Use this ID to update the recurrence and all of the instances.
       * @readonly
       */
      recurringSessionId?: string | null;
      /** Session type. */
      type?: SessionType$3;
      /**
       * A conference created for the session according to the details set in the schedule's conference provider information.
       * If the session is a recurring session, this field is inherited from the schedule.
       * **Partially deprecated.** Only `hostUrl` and `guestUrl` are to be supported.
       * @deprecated
       */
      calendarConference?: CalendarConference$3;
      /**
       * A string representing a recurrence rule (RRULE) for a recurring session, as defined in [iCalendar RFC 5545](https://icalendar.org/iCalendar-RFC-5545/3-3-10-recurrence-rule.html).
       * If the session is an instance of a recurrence pattern, the `instanceOfRecurrence` property will be contain the recurrence rule and this property will be empty.
       * The RRULE defines a rule for repeating a session.
       * Supported parameters are:
       *
       * |Keyword|Description|Supported values|
       * |--|--|---|
       * |`FREQ`|The frequency at which the session is recurs. Required.|`WEEKLY`|
       * |`INTERVAL`|How often, in terms of `FREQ`, the session recurs. Default is 1. Optional.|
       * |`UNTIL`|The UTC end date and time of the recurrence. Optional.|
       * |`BYDAY`|Day of the week when the event should recur. Required.|One of: `MO`, `TU`, `WE`, `TH`, `FR`, `SA`, `SU`|
       *
       *
       * For example, a session that repeats every second week on a Monday until January 7, 2022 at 8 AM:
       * `"FREQ=WEEKLY;INTERVAL=2;BYDAY=MO;UNTIL=20220107T080000Z"`
       *
       * <!--ORIGINAL COMMENTS:
       * `FREQ`  The frequency with which the session should be repeated (such as DAILY or WEEKLY).
       * Supported `WEEKLY` value is supported.
       * INTERVAL  Works together with FREQ to specify how often the session should be repeated. For example, FREQ=WEEKLY;INTERVAL=2 means once every two weeks. Optional. Default value is 1.
       * COUNT  The number of times this event should be repeated. Not yet supported.
       * UNTIL  The UTC date & time until which the session should be repeated. This parameter is optional. When it is not specified, the event repeats forever.
       * The format is a short ISO date, followed by 'T' and a short time with seconds and without milliseconds, terminated by the UTC designator 'Z'. For example, until Jan. 19th 2018 at 7:00 AM: 'UNTIL=20180119T070000Z'.
       * BYDAY - The days of the week when the event should be repeated. Currently, only a single day is supported. This parameter is mandatory.
       * Possible values are: MO, TU, WE, TH, FR, SA, SU
       * Note that DTSTART and DTEND lines are not allowed in this field; session start and end times are specified in the start and end fields.
       * **Example**: FREQ=WEEKLY;INTERVAL=2;BYDAY=MO;UNTIL=20200427T070000Z
       * ORIGINAL COMMENTS-->
       */
      recurrence?: string | null;
      /**
       * A string representing a recurrence rule (RRULE) if the session is an instance of a recurrence pattern.
       * Empty when the session is not an instance of a recurrence rule, or if the session defines a recurrence pattern, and `recurrence` is not empty.
       * @readonly
       */
      instanceOfRecurrence?: string | null;
      /**
       * The name of the schedule owner. It may be a resource name or a service name. Optional.
       * @internal
       * @readonly
       */
      scheduleOwnerName?: string | null;
      /**
       * The user id of the schedule owner. Optional.
       * NOT IMPLEMENTED YET.
       * @internal
       * @readonly
       */
      scheduleOwnerUserId?: string | null;
      /**
       * The session version.
       * Composed by the schedule, session and participants versions.
       * @readonly
       */
      version?: SessionVersion$3;
      /**
       * The ID of the event in the new Calendar Events V3 API.
       * @internal
       * @readonly
       */
      eventId?: string | null;
  }
  interface CalendarDateTime$3 {
      /**
       * UTC date-time in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Coordinated_Universal_Time_(UTC)) format. If a time zone offset is specified, the time is converted to UTC. For example, if you specify  `new Date('2021-01-06T16:00:00.000-07:00')`, the stored value will be `"2021-01-06T23:00:00.000Z"`.
       * Required if `localDateTime` is not specified.
       * If `localDateTime` is specified, `timestamp` is calculated as `localDateTime`, using the business's time zone.
       */
      timestamp?: Date | null;
      /** An object containing the local date and time for the business's time zone. */
      localDateTime?: LocalDateTime$3;
      /**
       * The time zone. Optional. Derived from the schedule's time zone.
       * In case this field is associated with recurring session, this field is empty.
       * @readonly
       */
      timeZone?: string | null;
  }
  interface LocalDateTime$3 {
      /** Year. 4-digit format. */
      year?: number | null;
      /** Month number, from 1-12. */
      monthOfYear?: number | null;
      /** Day of the month, from 1-31. */
      dayOfMonth?: number | null;
      /** Hour of the day in 24-hour format, from 0-23. */
      hourOfDay?: number | null;
      /** Minute, from 0-59. */
      minutesOfHour?: number | null;
  }
  interface ExternalCalendarInfo$3 {
      /** The external calendar type (e.g. Google Calendar, iCal, etc). */
      calendarType?: CalendarType$3;
  }
  enum SessionStatus$1 {
      UNDEFINED = "UNDEFINED",
      /** The session is confirmed. Default status. */
      CONFIRMED = "CONFIRMED",
      /**
       * The session is cancelled.
       * A cancelled session can be the cancellation of a recurring session that should no longer be displayed or a deleted single session.
       * The ListSessions returns cancelled sessions only if 'includeDelete' flag is set to true.
       */
      CANCELLED = "CANCELLED"
  }
  enum SessionType$3 {
      UNDEFINED = "UNDEFINED",
      /**
       * The session creates an event on the calendar for the owner of the schedule that the session belongs to.
       * Default type.
       */
      EVENT = "EVENT",
      /** The session represents a resource's available working hours. */
      WORKING_HOURS = "WORKING_HOURS",
      /** Deprecated. please use WORKING_HOURS */
      TIME_AVAILABILITY = "TIME_AVAILABILITY",
      /** Deprecated. The session represents a resource's available hours. please use WORKING_HOURS */
      AVAILABILITY = "AVAILABILITY"
  }
  interface SessionVersion$3 {
      /**
       * Schedule version number, updated each time the schedule is updated.
       * @internal
       */
      scheduleVersion?: number;
      /**
       * Session version number, updated each time the session is updated.
       * @internal
       */
      sessionVersion?: number;
      /**
       * Participants version number, updated each time the session participants are updated.
       * @internal
       */
      participantsVersion?: number | null;
      /** Incremental version number, which is updated on each change to the session or on changes affecting the session. */
      number?: string | null;
  }
  interface ParticipantNotification$7 {
      /**
       * Whether to send the message about the changes to the customer.
       *
       * Default: `false`
       */
      notifyParticipants?: boolean;
      /** Custom message to send to the participants about the changes to the booking. */
      message?: string | null;
      /**
       * Optional additional metadata.
       * Supported only in V3 APIs.
       * @internal
       */
      metadata?: Record<string, string>;
  }
  interface ScheduleCancelled$3 {
      schedule?: Schedule$4;
      /** Whether to notify participants about the change and an optional custom message */
      participantNotification?: ParticipantNotification$7;
      oldSchedule?: Schedule$4;
  }
  interface SessionCreated$3 {
      session?: Session$3;
  }
  interface SessionUpdated$3 {
      oldSession?: Session$3;
      newSession?: Session$3;
      /** Whether to notify participants about the change and an optional custom message */
      participantNotification?: ParticipantNotification$7;
      /**
       * Whether this notification was created as a result of an anonymization request, such as GDPR.
       * An anonymized participant will have the following details:
       * name = "deleted"
       * phone = "deleted"
       * email = "deleted@deleted.com"
       */
      triggeredByAnonymizeRequest?: boolean | null;
  }
  interface SessionCancelled$3 {
      session?: Session$3;
      /** Whether to notify participants about the change and an optional custom message */
      participantNotification?: ParticipantNotification$7;
  }
  interface AvailabilityPolicyUpdated$3 {
      availabilityPolicy?: AvailabilityPolicy$3;
  }
  /** Availability policy applied to all site schedules. */
  interface AvailabilityPolicy$3 {
      /** Specify how to split the schedule slots in intervals of minutes. */
      splitInterval?: SplitInterval$3;
  }
  interface IntervalSplit$3 {
      scheduleId?: string;
      intervals?: RecurringInterval$3[];
      newScheduleVersion?: number | null;
      oldScheduleVersion?: number | null;
  }
  interface RecurringSessionSplit$3 {
      scheduleId?: string;
      recurringSessions?: Session$3[];
      newScheduleVersion?: number | null;
      oldScheduleVersion?: number | null;
  }
  /** Schedule unassigned from user. */
  interface ScheduleUnassignedFromUser$3 {
      /** The Wix user id. */
      userId?: string | null;
      /** The schedule that was unassigned from the user. */
      schedule?: Schedule$4;
  }
  interface MultipleSessionsCreated$3 {
      schedulesWithSessions?: ScheduleWithSessions$3[];
  }
  interface ScheduleWithSessions$3 {
      schedule?: Schedule$4;
      siteProperties?: SitePropertiesOnScheduleCreation$3;
      sessions?: Session$3[];
  }
  interface SitePropertiesOnScheduleCreation$3 {
      /** The global time zone value. */
      timeZone?: string | null;
  }
  interface MigrationEvent$3 {
      migrationData?: MigrationData$3;
  }
  interface MigrationData$3 {
      businessId?: string | null;
      staffs?: StaffData$3[];
  }
  interface StaffData$3 {
      resourceId?: string;
      syncRequestEmail?: string;
      refreshToken?: string;
  }
  interface Empty$6 {
  }
  /**
   * Retrieves a list of the external calendar providers for which the site supports integration.
   *
   *
   * The list of external calendar providers includes:
   *
   * + External calendar providers that are supported by default, such as Google, Apple, and Microsoft.
   * + External calenders for which the site owner has enabled integration by installing an app.
   *
   * For each external calendar provider, the list contains information about supported connection methods and features.
   * For each provider, check `features.connectMethods` to find out whether to use `connectByCredentials()` or `connectByOAuth()` to establish a connection.
   *
   * @public
   * @documentationMaturity preview
   * @permissionId CALENDAR.LIST_EXTERNAL_CALENDAR_PROVIDERS
   * @adminMethod
   */
  function listProviders(): Promise<ListProvidersResponse>;
  /**
   * Retrieves an external calendar connection by ID.
   *
   *
   * The external calendar connection contains details of the connection between a Wix site's calendar and calendars hosted by an external provider.
   *
   * The `syncConfig` property contains configuration details for importing events from an external calendar, exporting events to an external calendar, or both.
   * @param connectionId - ID of the connection to retrieve.
   * @public
   * @documentationMaturity preview
   * @requiredField connectionId
   * @permissionId CALENDAR.READ_OWN_EXTERNAL_CALENDAR_CONNECTIONS
   * @permissionId CALENDAR.READ_ALL_EXTERNAL_CALENDAR_CONNECTIONS
   * @adminMethod
   */
  function getConnection(connectionId: string | null): Promise<GetConnectionResponse>;
  /**
   * Retrieves a list of external calendar connections.
   *
   *
   * Each external calendar connections contain details of a connection between a Wix site's calendar and calendars hosted by an external provider.
   *
   * The `syncConfig` property of each connection contains configuration details for importing events from an external calendar, exporting events to an external calendar, or both.
   * @public
   * @documentationMaturity preview
   * @permissionId CALENDAR.READ_OWN_EXTERNAL_CALENDAR_CONNECTIONS
   * @permissionId CALENDAR.READ_ALL_EXTERNAL_CALENDAR_CONNECTIONS
   * @adminMethod
   */
  function listConnections(options?: ListConnectionsOptions): Promise<ListConnectionsResponse>;
  interface ListConnectionsOptions {
      /**
       * Schedule IDs to filter by. If provided, only connections between external calendars and the specified schedules is returned.
       *
       * Default: Returns all connections.
       */
      scheduleIds?: string[] | null;
      /**
       * Whether to return a partial list of connections if details can't be retrieved for some connections.
       *
       * Default: `false`
       */
      partialFailure?: boolean | null;
  }
  /**
   * Connects to an external calendar using the OAuth authorization protocol.
   *
   *
   * The authorization flow should take place as follows:
   *
   * 1. Call the function with the appropriate parameters.
   * 2. Redirect the user to the URL received in the response.
   * 3. The user authorizes access.
   * 4. The user is redirected to the URL you provide in the `redirectUrl` parameter, with a query parameter `connectionId` containing the new connection ID.
   *
   * If the attempt to connect fails, the user is still redirected to the URL you provide in the `redirectUrl` parameter,
   * but with a query parameter `error` containing one of the following values:
   *
   * - `reject`: The user rejected the authorization request.
   * - `unsupported`: Connecting to the user's external account type is not supported by the provider.
   * - `internal`: An error unrelated to the client or the request that prevents the server from fulfilling the request.
   *
   * Once a connection is successfully created, use `listEvents()` to obtain an up-to-date list of events in the connected external calendars.
   *
   * > **Note:**
   * > Use `listProviders()` to find out whether to connect to a particular provider using this endpoint or `connectByCredentials()`.
   * @param scheduleId - ID of the schedule to connect with the external calendar account.
   * @param redirectUrl - URL to redirect the user to after they authorize access to the external calendar account.
   *
   * If the connection is successfully established, the user is redirected to this URL with a query parameter `connectionId` containing the new connection ID.
   * If the attempt to connect fails, the user is redirected to this URL with a query parameter `error` containing the error type.
   * @public
   * @documentationMaturity preview
   * @requiredField providerId
   * @requiredField redirectUrl
   * @requiredField scheduleId
   * @param providerId - ID of the external calendar provider. Find this with the `listProviders()` function.
   * @permissionId CALENDAR.MANAGE_OWN_EXTERNAL_CALENDAR_CONNECTIONS
   * @permissionId CALENDAR.MANAGE_ALL_EXTERNAL_CALENDAR_CONNECTIONS
   * @adminMethod
   */
  function connectByOAuth(providerId: string | null, scheduleId: string | null, redirectUrl: string | null, options?: ConnectByOAuthOptions): Promise<ConnectByOAuthResponse>;
  interface ConnectByOAuthOptions {
      /**
       * Deprecated.
       * @internal
       * @deprecated
       */
      calendarType?: CalendarType$3;
  }
  /** @internal
   * @documentationMaturity preview
   * @adminMethod
   */
  function oAuthCompleted(options?: OAuthCompletedOptions): Promise<RawHttpResponse>;
  interface OAuthCompletedOptions {
      body?: Uint8Array;
      pathParams?: PathParametersEntry[];
      queryParams?: QueryParametersEntry[];
      headers?: HeadersEntry[];
      method?: string;
      rawPath?: string;
      rawQuery?: string;
  }
  /**
   * Connects to an external calendar by directly providing the external calendar account credentials.
   *
   *
   * Once a connection is successfully created, use `listEvents()` to obtain an up-to-date list of events in the connected external calendars.
   *
   * > **Note:**
   * > Use `listProviders()` to find out whether to connect to a particular provider using this method or `connectByOAuth()`.
   * @param scheduleId - ID of the schedule to connect with the external calendar account.
   * @param email - Email address for the external calendar account.
   * @param password - Password for the external calendar account.
   * @public
   * @documentationMaturity preview
   * @requiredField email
   * @requiredField password
   * @requiredField providerId
   * @requiredField scheduleId
   * @param providerId - ID of the external calendar provider. Find this with the `listProviders()` function.
   * @permissionId CALENDAR.MANAGE_OWN_EXTERNAL_CALENDAR_CONNECTIONS
   * @permissionId CALENDAR.MANAGE_ALL_EXTERNAL_CALENDAR_CONNECTIONS
   * @adminMethod
   */
  function connectByCredentials(providerId: string | null, scheduleId: string | null, email: string | null, password: string | null): Promise<ConnectByCredentialsResponse>;
  /**
   * Retrieves a list of calendars belonging to the connected external calendar account.
   *
   *
   * > **Note:**
   * > Before using this function, establish a connection with an external calendar using `connectByCredentials()` or `connectByOAuth()`.
   * @param connectionId - ID of the external calendar connection to list calendars for.
   * @public
   * @documentationMaturity preview
   * @requiredField connectionId
   * @permissionId CALENDAR.READ_OWN_EXTERNAL_CALENDAR_CONNECTIONS
   * @adminMethod
   */
  function listCalendars(connectionId: string | null): Promise<ListCalendarsResponse>;
  /**
   * Updates the specified external calendar connection's sync configuration.
   *
   *
   * Use Update Sync Config to update a connection's `syncConfig` property.
   * The `syncConfig` property contains settings for enabling, configuring, or disabling functionality, including:
   *
   * + Importing events from one or more specified calendars in the connected external calendar account. If this is enabled, use `listEvents()` to retrieve a list of events from the external calendar.
   * + Exporting events from the Wix site's calendar to an external calendar.
   *
   * To see an external calendar connection's existing sync configuration, use `getConnection()` or `listConnections()` and see the `syncConfig` property.
   *
   * > **Note:**
   * > Supported functionality depends on the provider. Use `listProviders()` to see details about providers' supported features.
   * @param connectionId - ID of the external calendar connection to update.
   * @param syncConfig - Updated sync configuration details.
   * @public
   * @documentationMaturity preview
   * @requiredField connectionId
   * @requiredField syncConfig
   * @permissionId CALENDAR.MANAGE_OWN_EXTERNAL_CALENDAR_CONNECTIONS
   * @adminMethod
   */
  function updateSyncConfig(connectionId: string | null, syncConfig: ConnectionSyncConfig, options?: UpdateSyncConfigOptions): Promise<UpdateSyncConfigResponse>;
  interface UpdateSyncConfigOptions {
      /**
       * Optional list of fields to update. If provided, only the specified fields are updated.
       * @internal
       */
      fieldMask?: string[];
  }
  /**
   * Disconnects from an external calendar.
   *
   *
   * When an external calendar is disconnected, the external calendar connection's `status` is changed to `DISCONNECTED`.
   *
   * After disconnecting, `listEvents()` no longer returns events from the disconnected external calendar.
   * Exported Wix calendar sessions are deleted from the external calendar.
   * @param connectionId - ID of the external calendar connection to disconnect.
   * @public
   * @documentationMaturity preview
   * @requiredField connectionId
   * @permissionId CALENDAR.MANAGE_OWN_EXTERNAL_CALENDAR_CONNECTIONS
   * @permissionId CALENDAR.MANAGE_ALL_EXTERNAL_CALENDAR_CONNECTIONS
   * @adminMethod
   */
  function disconnect(connectionId: string | null): Promise<DisconnectResponse>;
  /**
   * Retrieves a list of events from all connected external calendars, based on the provided filtering and paging.
   *
   *
   * Use List Events to retrieve an aggregated list of events in the connected external calendars for a specified time range, sorted by start date.
   *
   * > **Note:**
   * > Before using this function, establish a connection with an external calendar using `connectByCredentials()` or `connectByOAuth()`.
   * @public
   * @documentationMaturity preview
   * @permissionId CALENDAR.READ_EXTERNAL_CALENDAR_EVENTS
   * @adminMethod
   */
  function listEvents(options?: ListEventsOptions): Promise<ListEventsResponse>;
  interface ListEventsOptions {
      /**
       * Date and time from which to retrieve events,
       * formatted according to [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt).
       * Required, unless `cursorPaging.cursor` is provided.
       *
       * Events which start before the `from` time and end after it are included in the returned list.
       */
      from?: string | null;
      /**
       * Date and time until which to retrieve events,
       * formatted according to [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt).
       * Required, unless `cursorPaging.cursor` is provided.
       *
       * Events which start before the `to` time and end after it are included in the returned list.
       */
      to?: string | null;
      /**
       * Schedule IDs to filter by. If provided, the returned list includes only events belonging to external calendars connected to the specified schedules.
       * Maximum of 100 schedule IDs per request.
       */
      scheduleIds?: string[] | null;
      /**
       * Wix user IDs to filter by. If provided, the returned list includes only events belonging to external calendars connected to schedules belonging to the specified Wix users.
       * Maximum of 100 Wix user IDs per request.
       */
      userIds?: string[] | null;
      /**
       * Whether to include only all-day events in the returned list.
       * If `true`, only all-day events are returned.
       * If `false`, only events with a specified time are returned.
       *
       * Default: All events are returned.
       */
      allDay?: boolean | null;
      /**
       * Predefined sets of fields to return.
       * - `NO_PI`: Returns event objects without personal information.
       * - `OWN_PI`: Returns complete event objects, including personal information.
       *
       * Default: `NO_PI`
       */
      fieldsets?: string[];
      /** Pagination options. */
      cursorPaging?: CursorPaging$9;
      /**
       * Whether to return a partial list of events if details can't be retrieved for some connections.
       *
       * Default: `false`
       */
      partialFailure?: boolean | null;
      /**
       * Deprecated.
       * @internal
       * @deprecated
       */
      includePi?: boolean | null;
  }
  
  type bookingsCalendarV2ExternalCalendar_universal_d_ExternalCalendar = ExternalCalendar;
  type bookingsCalendarV2ExternalCalendar_universal_d_ListProvidersRequest = ListProvidersRequest;
  type bookingsCalendarV2ExternalCalendar_universal_d_ListProvidersResponse = ListProvidersResponse;
  type bookingsCalendarV2ExternalCalendar_universal_d_Provider = Provider;
  type bookingsCalendarV2ExternalCalendar_universal_d_ProviderFeatures = ProviderFeatures;
  type bookingsCalendarV2ExternalCalendar_universal_d_ConnectMethod = ConnectMethod;
  const bookingsCalendarV2ExternalCalendar_universal_d_ConnectMethod: typeof ConnectMethod;
  type bookingsCalendarV2ExternalCalendar_universal_d_ListEventFromCalendars = ListEventFromCalendars;
  const bookingsCalendarV2ExternalCalendar_universal_d_ListEventFromCalendars: typeof ListEventFromCalendars;
  type bookingsCalendarV2ExternalCalendar_universal_d_SyncToCalendar = SyncToCalendar;
  const bookingsCalendarV2ExternalCalendar_universal_d_SyncToCalendar: typeof SyncToCalendar;
  type bookingsCalendarV2ExternalCalendar_universal_d_GetConnectionRequest = GetConnectionRequest;
  type bookingsCalendarV2ExternalCalendar_universal_d_GetConnectionResponse = GetConnectionResponse;
  type bookingsCalendarV2ExternalCalendar_universal_d_Connection = Connection;
  type bookingsCalendarV2ExternalCalendar_universal_d_ErrorReason = ErrorReason;
  const bookingsCalendarV2ExternalCalendar_universal_d_ErrorReason: typeof ErrorReason;
  type bookingsCalendarV2ExternalCalendar_universal_d_ConnectionSyncConfig = ConnectionSyncConfig;
  type bookingsCalendarV2ExternalCalendar_universal_d_Calendar = Calendar;
  type bookingsCalendarV2ExternalCalendar_universal_d_PrimaryCalendar = PrimaryCalendar;
  type bookingsCalendarV2ExternalCalendar_universal_d_Calendars = Calendars;
  type bookingsCalendarV2ExternalCalendar_universal_d_DedicatedCalendar = DedicatedCalendar;
  type bookingsCalendarV2ExternalCalendar_universal_d_ConnectionSyncConfigListEventFromCalendars = ConnectionSyncConfigListEventFromCalendars;
  type bookingsCalendarV2ExternalCalendar_universal_d_ConnectionSyncConfigListEventFromCalendarsListFromOneOf = ConnectionSyncConfigListEventFromCalendarsListFromOneOf;
  type bookingsCalendarV2ExternalCalendar_universal_d_ConnectionSyncConfigSyncToCalendar = ConnectionSyncConfigSyncToCalendar;
  type bookingsCalendarV2ExternalCalendar_universal_d_ConnectionSyncConfigSyncToCalendarSyncToOneOf = ConnectionSyncConfigSyncToCalendarSyncToOneOf;
  type bookingsCalendarV2ExternalCalendar_universal_d_SyncToErrorReason = SyncToErrorReason;
  const bookingsCalendarV2ExternalCalendar_universal_d_SyncToErrorReason: typeof SyncToErrorReason;
  type bookingsCalendarV2ExternalCalendar_universal_d_ListConnectionsRequest = ListConnectionsRequest;
  type bookingsCalendarV2ExternalCalendar_universal_d_ListConnectionsResponse = ListConnectionsResponse;
  type bookingsCalendarV2ExternalCalendar_universal_d_ConnectByOAuthRequest = ConnectByOAuthRequest;
  type bookingsCalendarV2ExternalCalendar_universal_d_ConnectByOAuthResponse = ConnectByOAuthResponse;
  type bookingsCalendarV2ExternalCalendar_universal_d_RawHttpRequest = RawHttpRequest;
  type bookingsCalendarV2ExternalCalendar_universal_d_PathParametersEntry = PathParametersEntry;
  type bookingsCalendarV2ExternalCalendar_universal_d_QueryParametersEntry = QueryParametersEntry;
  type bookingsCalendarV2ExternalCalendar_universal_d_HeadersEntry = HeadersEntry;
  type bookingsCalendarV2ExternalCalendar_universal_d_RawHttpResponse = RawHttpResponse;
  type bookingsCalendarV2ExternalCalendar_universal_d_ConnectByCredentialsRequest = ConnectByCredentialsRequest;
  type bookingsCalendarV2ExternalCalendar_universal_d_ConnectByCredentialsResponse = ConnectByCredentialsResponse;
  type bookingsCalendarV2ExternalCalendar_universal_d_ListCalendarsRequest = ListCalendarsRequest;
  type bookingsCalendarV2ExternalCalendar_universal_d_ListCalendarsResponse = ListCalendarsResponse;
  type bookingsCalendarV2ExternalCalendar_universal_d_UpdateSyncConfigRequest = UpdateSyncConfigRequest;
  type bookingsCalendarV2ExternalCalendar_universal_d_UpdateSyncConfigResponse = UpdateSyncConfigResponse;
  type bookingsCalendarV2ExternalCalendar_universal_d_DisconnectRequest = DisconnectRequest;
  type bookingsCalendarV2ExternalCalendar_universal_d_DisconnectResponse = DisconnectResponse;
  type bookingsCalendarV2ExternalCalendar_universal_d_ListEventsRequest = ListEventsRequest;
  type bookingsCalendarV2ExternalCalendar_universal_d_ListEventsResponse = ListEventsResponse;
  const bookingsCalendarV2ExternalCalendar_universal_d_listProviders: typeof listProviders;
  const bookingsCalendarV2ExternalCalendar_universal_d_getConnection: typeof getConnection;
  const bookingsCalendarV2ExternalCalendar_universal_d_listConnections: typeof listConnections;
  type bookingsCalendarV2ExternalCalendar_universal_d_ListConnectionsOptions = ListConnectionsOptions;
  const bookingsCalendarV2ExternalCalendar_universal_d_connectByOAuth: typeof connectByOAuth;
  type bookingsCalendarV2ExternalCalendar_universal_d_ConnectByOAuthOptions = ConnectByOAuthOptions;
  const bookingsCalendarV2ExternalCalendar_universal_d_oAuthCompleted: typeof oAuthCompleted;
  type bookingsCalendarV2ExternalCalendar_universal_d_OAuthCompletedOptions = OAuthCompletedOptions;
  const bookingsCalendarV2ExternalCalendar_universal_d_connectByCredentials: typeof connectByCredentials;
  const bookingsCalendarV2ExternalCalendar_universal_d_listCalendars: typeof listCalendars;
  const bookingsCalendarV2ExternalCalendar_universal_d_updateSyncConfig: typeof updateSyncConfig;
  type bookingsCalendarV2ExternalCalendar_universal_d_UpdateSyncConfigOptions = UpdateSyncConfigOptions;
  const bookingsCalendarV2ExternalCalendar_universal_d_disconnect: typeof disconnect;
  const bookingsCalendarV2ExternalCalendar_universal_d_listEvents: typeof listEvents;
  type bookingsCalendarV2ExternalCalendar_universal_d_ListEventsOptions = ListEventsOptions;
  namespace bookingsCalendarV2ExternalCalendar_universal_d {
    export {
      bookingsCalendarV2ExternalCalendar_universal_d_ExternalCalendar as ExternalCalendar,
      bookingsCalendarV2ExternalCalendar_universal_d_ListProvidersRequest as ListProvidersRequest,
      bookingsCalendarV2ExternalCalendar_universal_d_ListProvidersResponse as ListProvidersResponse,
      bookingsCalendarV2ExternalCalendar_universal_d_Provider as Provider,
      CalendarType$3 as CalendarType,
      bookingsCalendarV2ExternalCalendar_universal_d_ProviderFeatures as ProviderFeatures,
      bookingsCalendarV2ExternalCalendar_universal_d_ConnectMethod as ConnectMethod,
      bookingsCalendarV2ExternalCalendar_universal_d_ListEventFromCalendars as ListEventFromCalendars,
      bookingsCalendarV2ExternalCalendar_universal_d_SyncToCalendar as SyncToCalendar,
      bookingsCalendarV2ExternalCalendar_universal_d_GetConnectionRequest as GetConnectionRequest,
      bookingsCalendarV2ExternalCalendar_universal_d_GetConnectionResponse as GetConnectionResponse,
      bookingsCalendarV2ExternalCalendar_universal_d_Connection as Connection,
      Status$3 as Status,
      bookingsCalendarV2ExternalCalendar_universal_d_ErrorReason as ErrorReason,
      bookingsCalendarV2ExternalCalendar_universal_d_ConnectionSyncConfig as ConnectionSyncConfig,
      bookingsCalendarV2ExternalCalendar_universal_d_Calendar as Calendar,
      bookingsCalendarV2ExternalCalendar_universal_d_PrimaryCalendar as PrimaryCalendar,
      bookingsCalendarV2ExternalCalendar_universal_d_Calendars as Calendars,
      bookingsCalendarV2ExternalCalendar_universal_d_DedicatedCalendar as DedicatedCalendar,
      bookingsCalendarV2ExternalCalendar_universal_d_ConnectionSyncConfigListEventFromCalendars as ConnectionSyncConfigListEventFromCalendars,
      bookingsCalendarV2ExternalCalendar_universal_d_ConnectionSyncConfigListEventFromCalendarsListFromOneOf as ConnectionSyncConfigListEventFromCalendarsListFromOneOf,
      bookingsCalendarV2ExternalCalendar_universal_d_ConnectionSyncConfigSyncToCalendar as ConnectionSyncConfigSyncToCalendar,
      bookingsCalendarV2ExternalCalendar_universal_d_ConnectionSyncConfigSyncToCalendarSyncToOneOf as ConnectionSyncConfigSyncToCalendarSyncToOneOf,
      bookingsCalendarV2ExternalCalendar_universal_d_SyncToErrorReason as SyncToErrorReason,
      bookingsCalendarV2ExternalCalendar_universal_d_ListConnectionsRequest as ListConnectionsRequest,
      bookingsCalendarV2ExternalCalendar_universal_d_ListConnectionsResponse as ListConnectionsResponse,
      bookingsCalendarV2ExternalCalendar_universal_d_ConnectByOAuthRequest as ConnectByOAuthRequest,
      bookingsCalendarV2ExternalCalendar_universal_d_ConnectByOAuthResponse as ConnectByOAuthResponse,
      bookingsCalendarV2ExternalCalendar_universal_d_RawHttpRequest as RawHttpRequest,
      bookingsCalendarV2ExternalCalendar_universal_d_PathParametersEntry as PathParametersEntry,
      bookingsCalendarV2ExternalCalendar_universal_d_QueryParametersEntry as QueryParametersEntry,
      bookingsCalendarV2ExternalCalendar_universal_d_HeadersEntry as HeadersEntry,
      bookingsCalendarV2ExternalCalendar_universal_d_RawHttpResponse as RawHttpResponse,
      bookingsCalendarV2ExternalCalendar_universal_d_ConnectByCredentialsRequest as ConnectByCredentialsRequest,
      bookingsCalendarV2ExternalCalendar_universal_d_ConnectByCredentialsResponse as ConnectByCredentialsResponse,
      bookingsCalendarV2ExternalCalendar_universal_d_ListCalendarsRequest as ListCalendarsRequest,
      bookingsCalendarV2ExternalCalendar_universal_d_ListCalendarsResponse as ListCalendarsResponse,
      bookingsCalendarV2ExternalCalendar_universal_d_UpdateSyncConfigRequest as UpdateSyncConfigRequest,
      bookingsCalendarV2ExternalCalendar_universal_d_UpdateSyncConfigResponse as UpdateSyncConfigResponse,
      bookingsCalendarV2ExternalCalendar_universal_d_DisconnectRequest as DisconnectRequest,
      bookingsCalendarV2ExternalCalendar_universal_d_DisconnectResponse as DisconnectResponse,
      bookingsCalendarV2ExternalCalendar_universal_d_ListEventsRequest as ListEventsRequest,
      CursorPaging$9 as CursorPaging,
      bookingsCalendarV2ExternalCalendar_universal_d_ListEventsResponse as ListEventsResponse,
      Event$2 as Event,
      CursorPagingMetadata$7 as CursorPagingMetadata,
      Cursors$a as Cursors,
      ScheduleNotification$3 as ScheduleNotification,
      ScheduleNotificationEventOneOf$3 as ScheduleNotificationEventOneOf,
      ScheduleCreated$3 as ScheduleCreated,
      Schedule$4 as Schedule,
      RecurringInterval$3 as RecurringInterval,
      Interval$4 as Interval,
      Day$3 as Day,
      Frequency$3 as Frequency,
      LinkedSchedule$3 as LinkedSchedule,
      Transparency$3 as Transparency,
      RecurringIntervalType$3 as RecurringIntervalType,
      Location$6 as Location,
      LocationType$6 as LocationType,
      Address$7 as Address,
      AddressStreetOneOf$6 as AddressStreetOneOf,
      StreetAddress$6 as StreetAddress,
      AddressLocation$6 as AddressLocation,
      Subdivision$6 as Subdivision,
      LocationsLocation$3 as LocationsLocation,
      LocationStatus$3 as LocationStatus,
      LocationsLocationType$3 as LocationsLocationType,
      LocationsAddress$3 as LocationsAddress,
      LocationsStreetAddress$3 as LocationsStreetAddress,
      LocationsAddressLocation$3 as LocationsAddressLocation,
      BusinessSchedule$4 as BusinessSchedule,
      TimePeriod$4 as TimePeriod,
      DayOfWeek$4 as DayOfWeek,
      SpecialHourPeriod$4 as SpecialHourPeriod,
      Rate$3 as Rate,
      Price$4 as Price,
      Availability$3 as Availability,
      AvailabilityConstraints$3 as AvailabilityConstraints,
      SplitInterval$3 as SplitInterval,
      Participant$3 as Participant,
      ApprovalStatus$3 as ApprovalStatus,
      ExternalCalendarOverrides$3 as ExternalCalendarOverrides,
      ScheduleStatus$3 as ScheduleStatus,
      Version$3 as Version,
      ConferenceProvider$3 as ConferenceProvider,
      CalendarConference$3 as CalendarConference,
      ConferenceType$3 as ConferenceType,
      ScheduleUpdated$3 as ScheduleUpdated,
      RecurringSessionsUpdated$3 as RecurringSessionsUpdated,
      Session$3 as Session,
      CalendarDateTime$3 as CalendarDateTime,
      LocalDateTime$3 as LocalDateTime,
      ExternalCalendarInfo$3 as ExternalCalendarInfo,
      SessionStatus$1 as SessionStatus,
      SessionType$3 as SessionType,
      SessionVersion$3 as SessionVersion,
      ParticipantNotification$7 as ParticipantNotification,
      ScheduleCancelled$3 as ScheduleCancelled,
      SessionCreated$3 as SessionCreated,
      SessionUpdated$3 as SessionUpdated,
      SessionCancelled$3 as SessionCancelled,
      AvailabilityPolicyUpdated$3 as AvailabilityPolicyUpdated,
      AvailabilityPolicy$3 as AvailabilityPolicy,
      IntervalSplit$3 as IntervalSplit,
      RecurringSessionSplit$3 as RecurringSessionSplit,
      ScheduleUnassignedFromUser$3 as ScheduleUnassignedFromUser,
      MultipleSessionsCreated$3 as MultipleSessionsCreated,
      ScheduleWithSessions$3 as ScheduleWithSessions,
      SitePropertiesOnScheduleCreation$3 as SitePropertiesOnScheduleCreation,
      MigrationEvent$3 as MigrationEvent,
      MigrationData$3 as MigrationData,
      StaffData$3 as StaffData,
      Empty$6 as Empty,
      bookingsCalendarV2ExternalCalendar_universal_d_listProviders as listProviders,
      bookingsCalendarV2ExternalCalendar_universal_d_getConnection as getConnection,
      bookingsCalendarV2ExternalCalendar_universal_d_listConnections as listConnections,
      bookingsCalendarV2ExternalCalendar_universal_d_ListConnectionsOptions as ListConnectionsOptions,
      bookingsCalendarV2ExternalCalendar_universal_d_connectByOAuth as connectByOAuth,
      bookingsCalendarV2ExternalCalendar_universal_d_ConnectByOAuthOptions as ConnectByOAuthOptions,
      bookingsCalendarV2ExternalCalendar_universal_d_oAuthCompleted as oAuthCompleted,
      bookingsCalendarV2ExternalCalendar_universal_d_OAuthCompletedOptions as OAuthCompletedOptions,
      bookingsCalendarV2ExternalCalendar_universal_d_connectByCredentials as connectByCredentials,
      bookingsCalendarV2ExternalCalendar_universal_d_listCalendars as listCalendars,
      bookingsCalendarV2ExternalCalendar_universal_d_updateSyncConfig as updateSyncConfig,
      bookingsCalendarV2ExternalCalendar_universal_d_UpdateSyncConfigOptions as UpdateSyncConfigOptions,
      bookingsCalendarV2ExternalCalendar_universal_d_disconnect as disconnect,
      bookingsCalendarV2ExternalCalendar_universal_d_listEvents as listEvents,
      bookingsCalendarV2ExternalCalendar_universal_d_ListEventsOptions as ListEventsOptions,
    };
  }
  
  /**
   * The `serviceOptionsAndVariants` object links a service to its variants.
   * You can use it to offer customers different prices for a service,
   * depending on which choices they book.
   * Read more about [service options and variants](https://wix.wixanswers.com/app/kb/article/2e91a25b-b3c2-4cf7-9005-429a4929fc36/en).
   */
  interface ServiceOptionsAndVariants {
      /**
       * ID of the `serviceOptionsAndVariants` object.
       * @readonly
       */
      _id?: string | null;
      /** ID of the service related to these options and variants. */
      serviceId?: string | null;
      /** Service options. Note that currently only a single option is supported per service. */
      options?: ServiceOptions;
      /** Information about the service's variants. */
      variants?: ServiceVariants;
      /**
       * Price of the cheapest service variant.
       * @readonly
       */
      minPrice?: Money$3;
      /**
       * Price of the most expensive service variant.
       * @readonly
       */
      maxPrice?: Money$3;
      /**
       * Revision number, which increments by 1 each time the `serviceOptionsAndVariants` object is updated.
       * To prevent conflicting changes,
       * the current revision must be passed when updating and deleting the `serviceOptionsAndVariants` object.
       *
       * Ignored when creating a `serviceOptionsAndVariants` object.
       */
      revision?: string | null;
      /** Extensions enabling users to save custom data related to service options and variants. */
      extendedFields?: ExtendedFields$8;
  }
  interface ServiceOption extends ServiceOptionOptionSpecificDataOneOf {
      /** Details about the custom option. Available only for `CUSTOM` options. */
      customData?: CustomServiceOption;
      /** ID of the service option. */
      _id?: string;
      /** Type of the service option. */
      type?: ServiceOptionType;
  }
  /** @oneof */
  interface ServiceOptionOptionSpecificDataOneOf {
      /** Details about the custom option. Available only for `CUSTOM` options. */
      customData?: CustomServiceOption;
  }
  enum ServiceOptionType {
      UNKNOWN = "UNKNOWN",
      CUSTOM = "CUSTOM",
      STAFF_MEMBER = "STAFF_MEMBER"
  }
  interface CustomServiceOption {
      /**
       * Name of the service option. For example, `Age group`, `Location`, `Equipment`,
       * or `Time`.
       */
      name?: string;
      /**
       * Available choices for the service option. For example, `child`, `student`,
       * `adult`, and `senior` for a service option named `Age group`. Each value must
       * be unique. The value's case is ignored, meaning `Child` and `child` are
       * considered to be identical. Currently, only a single choice is supported
       * because a service can have only a single option.
       *
       * Max: 1 choice
       */
      choices?: string[];
  }
  interface ServiceVariant {
      /**
       * ID of the service variant.
       * Used by multilingual translations.
       * @internal
       */
      _id?: string | null;
      /**
       * Choices for the service option. Currently, only a single choice is supported
       * because a service can have only a single option.
       *
       * Max: 1 choice
       */
      choices?: ServiceChoice$3[];
      /** Information about the service variant's price. */
      price?: Money$3;
  }
  interface ServiceChoice$3 extends ServiceChoiceChoiceOneOf$3 {
      /** Name of the custom choice. */
      custom?: string;
      /**
       * ID of the staff member providing the service. This ID is the equivalent of the `resourceId`
       * of the staff member or the `scheduleOwnerId` of the relevant
       * schedule's
       * `availability.linkedSchedules`.
       */
      staffMemberId?: string;
      /**
       * ID of the service choice.
       * Used by multilingual translations.
       * @internal
       */
      _id?: string | null;
      /** ID of the service option. */
      optionId?: string;
  }
  /** @oneof */
  interface ServiceChoiceChoiceOneOf$3 {
      /** Name of the custom choice. */
      custom?: string;
      /**
       * ID of the staff member providing the service. This ID is the equivalent of the `resourceId`
       * of the staff member or the `scheduleOwnerId` of the relevant
       * [schedule's](https://dev.wix.com/api/rest/wix-bookings/schedules-and-sessions/schedule/schedule-object)
       * `availability.linkedSchedules`.
       */
      staffMemberId?: string;
  }
  /**
   * Money.
   * Default format to use. Sufficiently compliant with majority of standards: w3c, ISO 4217, ISO 20022, ISO 8583:2003.
   */
  interface Money$3 {
      /** Monetary amount. Decimal string with a period as a decimal separator (e.g., 3.99). Optionally, a single (-), to indicate that the amount is negative. */
      value?: string;
      /** Currency code. Must be valid ISO 4217 currency code (e.g., USD). */
      currency?: string;
      /** Monetary amount. Decimal string in local format (e.g., 1 000,30). Optionally, a single (-), to indicate that the amount is negative. */
      formattedValue?: string | null;
  }
  interface ServiceOptions {
      /**
       * Values of the service options.
       *
       * Max: 1 service option
       */
      values?: ServiceOption[];
  }
  interface ServiceVariants {
      /** Values of the service variants. */
      values?: ServiceVariant[];
  }
  interface ExtendedFields$8 {
      /**
       * Extended field data. Each key corresponds to the namespace of the app that created the extended fields.
       * The value of each key is structured according to the schema defined when the extended fields were configured.
       *
       * You can only access fields for which you have the appropriate permissions.
       *
       * Learn more about [extended fields](https://dev.wix.com/docs/rest/articles/getting-started/extended-fields).
       */
      namespaces?: Record<string, Record<string, any>>;
  }
  interface CreateServiceOptionsAndVariantsRequest {
      /** Service options and variants to create. */
      serviceOptionsAndVariants: ServiceOptionsAndVariants;
  }
  interface CreateServiceOptionsAndVariantsResponse {
      /** Information about the created service options and variants. */
      serviceOptionsAndVariants?: ServiceOptionsAndVariants;
  }
  interface CloneServiceOptionsAndVariantsRequest {
      /** ID of the `serviceOptionsAndVariants` object to clone. */
      cloneFromId: string;
      /** ID of the service that will be set for the cloned `serviceOptionsAndVariants` */
      targetServiceId: string;
  }
  interface CloneServiceOptionsAndVariantsResponse {
      /** The cloned `serviceOptionsAndVariants` object. */
      serviceOptionsAndVariants?: ServiceOptionsAndVariants;
  }
  interface GetServiceOptionsAndVariantsRequest {
      /** ID of the `serviceOptionsAndVariants` object to retrieve. */
      serviceOptionsAndVariantsId: string;
  }
  interface GetServiceOptionsAndVariantsResponse {
      /** Retrieved `serviceOptionsAndVariants` object. */
      serviceOptionsAndVariants?: ServiceOptionsAndVariants;
  }
  interface GetServiceOptionsAndVariantsByServiceIdRequest {
      /** ID of the service to retrieve options and variants for. */
      serviceId: string;
  }
  interface GetServiceOptionsAndVariantsByServiceIdResponse {
      /** Retrieved `serviceOptionsAndVariants` object. */
      serviceVariants?: ServiceOptionsAndVariants;
  }
  interface UpdateServiceOptionsAndVariantsRequest {
      /** `ServiceOptionsAndVariants` object to update. */
      serviceOptionsAndVariants: ServiceOptionsAndVariants;
      /**
       * Field mask containing information about the fields to update.
       * @internal
       */
      mask?: string[];
  }
  interface UpdateServiceOptionsAndVariantsResponse {
      /** Updated `serviceOptionsAndVariants` object. */
      serviceOptionsAndVariants?: ServiceOptionsAndVariants;
  }
  interface DeleteServiceOptionsAndVariantsRequest {
      /** ID of the `serviceOptionsAndVariants` object to delete. */
      serviceOptionsAndVariantsId: string;
      /** Revision of the `serviceOptionsAndVariants` object to delete. */
      revision?: string;
  }
  interface DeleteServiceOptionsAndVariantsResponse {
  }
  interface QueryServiceOptionsAndVariantsRequest {
      /** Information about filters, paging, and returned fields. */
      query: QueryV2$4;
  }
  interface QueryV2$4 extends QueryV2PagingMethodOneOf$4 {
      /** Paging options to limit and skip the number of items. */
      paging?: Paging$4;
      /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
      cursorPaging?: CursorPaging$8;
      /**
       * Filter object.
       *
       * Learn more about the [filter section](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#the-filter-section).
       */
      filter?: Record<string, any> | null;
      /**
       * Sort object.
       *
       * Learn more about the [sort section](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#the-sort-section).
       */
      sort?: Sorting$8[];
      /**
       * Array of projected fields. A list of specific field names to return. If `fieldsets` are also specified, the union of `fieldsets` and `fields` is returned.
       * @internal
       */
      fields?: string[];
      /**
       * Array of named, predefined sets of projected fields. A array of predefined named sets of fields to be returned. Specifying multiple `fieldsets` will return the union of fields from all sets. If `fields` are also specified, the union of `fieldsets` and `fields` is returned.
       * @internal
       */
      fieldsets?: string[];
  }
  /** @oneof */
  interface QueryV2PagingMethodOneOf$4 {
      /** Paging options to limit and skip the number of items. */
      paging?: Paging$4;
      /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
      cursorPaging?: CursorPaging$8;
  }
  interface Sorting$8 {
      /** Name of the field to sort by. */
      fieldName?: string;
      /** Sort order. */
      order?: SortOrder$8;
      /**
       * When `field_name` is a property of repeated field that is marked as `MATCH_ITEMS` and sort should be done by
       * a specific element from a collection, filter can/should be provided to ensure correct sort value is picked.
       *
       * If multiple filters are provided, they are combined with AND operator.
       *
       * Example:
       * Given we have document like {"id": "1", "nestedField": [{"price": 10, "region": "EU"}, {"price": 20, "region": "US"}]}
       * and `nestedField` is marked as `MATCH_ITEMS`, to ensure that sorting is done by correct region, filter should be
       * { fieldName: "nestedField.price", "select_items_by": [{"nestedField.region": "US"}] }
       * @internal
       */
      selectItemsBy?: Record<string, any>[] | null;
  }
  enum SortOrder$8 {
      ASC = "ASC",
      DESC = "DESC"
  }
  interface Paging$4 {
      /** Number of items to load. */
      limit?: number | null;
      /** Number of items to skip in the current sort order. */
      offset?: number | null;
  }
  interface CursorPaging$8 {
      /** Maximum number of items to return in the results. */
      limit?: number | null;
      /**
       * Pointer to the next or previous page in the list of results.
       *
       * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
       * Not relevant for the first request.
       */
      cursor?: string | null;
  }
  interface QueryServiceOptionsAndVariantsResponse {
      /** Retrieved `serviceOptionsAndVariants` objects. */
      serviceOptionsAndVariantsList?: ServiceOptionsAndVariants[];
      /** Paging metadata. */
      pagingMetadata?: PagingMetadataV2$3;
  }
  interface PagingMetadataV2$3 {
      /** Number of items returned in the response. */
      count?: number | null;
      /** Offset that was requested. */
      offset?: number | null;
      /** Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set. */
      total?: number | null;
      /** Flag that indicates the server failed to calculate the `total` field. */
      tooManyToCount?: boolean | null;
      /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
      cursors?: Cursors$9;
      /**
       * Indicates if there are more results after the current page.
       * If `true`, another page of results can be retrieved.
       * If `false`, this is the last page.
       * @internal
       */
      hasNext?: boolean | null;
  }
  interface Cursors$9 {
      /** Cursor string pointing to the next page in the list of results. */
      next?: string | null;
      /** Cursor pointing to the previous page in the list of results. */
      prev?: string | null;
  }
  interface ResourceNotification$1 {
      /**
       * Updated resource entity.
       * 'resource.schedules' is deprecated and will not be returned. Please use 'resource.scheduleIds' instead.
       */
      resource?: Resource$3;
      /** Event type. */
      event?: Event$1;
  }
  interface Resource$3 {
      /**
       * Resource ID.
       * @readonly
       */
      _id?: string | null;
      /** Resource name. */
      name?: string | null;
      /** Resource email address. */
      email?: string | null;
      /** Resource phone number. */
      phone?: string | null;
      /** Resource description. */
      description?: string | null;
      /**
       * Deprecated. Please use tags.
       * @deprecated
       */
      tag?: string | null;
      /** Resource tags. Tags are used to identify, group, and filter the different types of resources. For example, 'staff' or 'room'. */
      tags?: string[] | null;
      /** Resource images. */
      images?: string[];
      /**
       * Deprecated. Please use scheduleIds. List of the schedules owned by this resource. Min size 1.
       * @deprecated
       */
      schedules?: Schedule$3[];
      /**
       * List of IDs of schedules owned by this resource.
       * @readonly
       */
      scheduleIds?: string[] | null;
      /**
       * Resource status.
       * @readonly
       */
      status?: ResourceStatus$1;
      /**
       * Wix user ID, if the resource is associated with the Wix user.
       * A staff member resource can be associated with a Wix user via assignment of a permissions role in the business manager.
       * @readonly
       */
      wixUserId?: string | null;
      /**
       * The ID of the Resource Group that this resource belongs to. This is an optional field as not every resource is part of a group.
       * @internal
       */
      groupId?: string | null;
      /**
       * This field determines how to resolve the working hours of this resource. Defaults to `true` if was not set by the client.
       * When set to `true` then working hours (including location information) can be found in the sessions of a schedule that is connected to this resource.
       * If `false`, then the working hours are not specified as sessions of a connected schedule. Instead this resource is then by definition full-time available (7 x 24).
       * @internal
       */
      hasWorkingHoursSchedule?: boolean | null;
      /**
       * True if the resource is available in all locations, false if the resource is available only in a specific business location. Empty if `has_working_hours_schedule` is true.
       * Information on the location(s) can then be found in the sessions of one of the connected schedules.
       * @internal
       */
      availableInAllLocations?: boolean | null;
      /**
       * Information about business location connected to the resource. Should be empty if `available_in_all_locations` is true or if no business location exists in OS.
       * @internal
       */
      businessLocation?: BusinessLocation$3;
      /**
       * This schedule contains the sessions in which this resource is booked.
       * Equals to the first element of `schedules` array.
       * @internal
       * @readonly
       */
      eventsSchedule?: Schedule$3;
      /**
       * The type of of the resource. Currently this field is only filled for staff and will contain the ID as configured in the
       * BOOKINGS_RESOURCE_TYPES component of the Bookings app.
       * @internal
       * @readonly
       */
      type?: string | null;
  }
  interface Schedule$3 {
      /** Schedule ID. */
      _id?: string;
      /** ID of the schedule's owner entity. This may be a resource ID or a service ID. */
      scheduleOwnerId?: string | null;
      /**
       * Start time of the first session in the schedule.
       * @internal
       * @readonly
       */
      firstSessionStart?: Date | null;
      /**
       * End time of the last session in the schedule.
       * @internal
       * @readonly
       */
      lastSessionEnd?: Date | null;
      /**
       * Schedule's time zone in [Area/Location](https://en.wikipedia.org/wiki/Tz_database) format. Read-only.
       * Derived from the Wix Business time zone.
       * @readonly
       */
      timeZone?: string | null;
      /**
       * Deprecated. Please use the [Sessions API](https://dev.wix.com/api/rest/wix-bookings/schedules-and-sessions/session) instead.
       * @deprecated
       */
      intervals?: RecurringInterval$2[];
      /** Default title for the schedule's sessions. Maximum length: 6000 characters. */
      title?: string | null;
      /**
       * __Deprecated.__
       * Tags for grouping schedules. These tags are the default tags for the schedule's sessions.
       * The Wix Bookings app uses the following predefined tags to set schedule type: `"INDIVIDUAL"`, `"GROUP"`, and `"COURSE"`. Once the schedule type is set using these tags, you cannot update it. In addition to the app's tags, you can create and update your own tags.
       * @deprecated
       */
      tags?: string[] | null;
      /** Default location for the schedule's sessions. */
      location?: Location$5;
      /**
       * Maximum number of participants that can be added to the schedule's sessions.
       * Must be at most `1` for schedule whose availability is affected by another schedule. E.g, appointment schedules of the Wix Bookings app.
       */
      capacity?: number | null;
      /**
       * Deprecated. Please use the [Booking Services V2](https://dev.wix.com/api/rest/wix-bookings/services-v2) payment instead.
       * @deprecated
       */
      rate?: Rate$2;
      /**
       * __Deprecated.__
       * @deprecated
       */
      availability?: Availability$2;
      /**
       * Number of participants registered to sessions in this schedule, calculated as the sum of the party sizes.
       * @readonly
       */
      totalNumberOfParticipants?: number;
      /**
       * *Partial list** of participants which are registered to sessions in this schedule.
       * Participants who are registered in the schedule are automatically registered to any session that is created for the schedule.
       * To retrieve the full list of schedule participants please use the [Query Extended Bookings API](https://dev.wix.com/api/rest/wix-bookings/bookings-reader-v2/query-extended-bookings).
       * @readonly
       */
      participants?: Participant$2[];
      /**
       * __Deprecated.__
       * @deprecated
       */
      externalCalendarOverrides?: ExternalCalendarOverrides$2;
      /**
       * Schedule status.
       * @readonly
       */
      status?: ScheduleStatus$2;
      /**
       * Schedule creation date.
       * @readonly
       */
      created?: Date | null;
      /**
       * Schedule last update date.
       * @readonly
       */
      updated?: Date | null;
      /**
       * Schedule version number, updated each time the schedule is updated.
       * @readonly
       */
      version?: number;
      /**
       * The schedule version, updated each time the schedule or the schedule participants are updated.
       * @internal
       * @readonly
       */
      versions?: Version$2;
      /**
       * Fields which were inherited from the Business Info page under Settings in the Dashboard.
       * @readonly
       */
      inheritedFields?: string[];
      /**
       * __Deprecated.__
       * @deprecated
       */
      conferenceProvider?: ConferenceProvider$2;
      /**
       * A conference created for the schedule. This is used when a participant is added to a schedule.
       * **Partially deprecated.** Only `hostUrl` and `guestUrl` are to be supported.
       * @deprecated
       */
      calendarConference?: CalendarConference$2;
      /**
       * The name of the schedule owner. It may be a resource name or a service name. Optional.
       * @internal
       */
      scheduleOwnerName?: string | null;
      /**
       * The user id of the schedule owner. Optional.
       * Currently, in Bookings system, it would be present when the schedule is owned by a staff resource and the resource is connected to a user.
       * NOT IMPLEMENTED. YET.
       * @internal
       * @readonly
       */
      scheduleOwnerUserId?: string | null;
  }
  interface RecurringInterval$2 {
      /**
       * The recurring interval identifier.
       * @readonly
       */
      _id?: string;
      /** The start time of the recurring interval. Required. */
      start?: Date | null;
      /** The end time of the recurring interval. Optional. Empty value indicates that there is no end time. */
      end?: Date | null;
      /** The interval rules. The day, hour and minutes the interval is recurring. */
      interval?: Interval$3;
      /** The frequency of the interval. Optional. The default is frequency with the default repetition. */
      frequency?: Frequency$2;
      /** Specifies the list of linked schedules and the way this link affects the corresponding schedules' availability. Can be calculated from the schedule or overridden on the recurring interval. */
      affectedSchedules?: LinkedSchedule$2[];
      /** The type of recurring interval. */
      intervalType?: RecurringIntervalType$2;
  }
  interface Interval$3 {
      /** The day the interval accrue. Optional. The default is the day of the recurring interval's start time. */
      daysOfWeek?: Day$2;
      /** The hour of the day the interval accrue. must be consistent with the Interval start time. Options. The default is 0. minimum: 0, maximum: 23. */
      hourOfDay?: number | null;
      /** The minutes of hour the interval accrue. must be consistent with the Interval end time. Options. The default is 0. minimum: 0, maximum: 59. */
      minuteOfHour?: number | null;
      /** The duration of the interval in minutes. Required. Part of the session end time calculation. */
      duration?: number;
  }
  enum Day$2 {
      /** Undefined. */
      UNDEFINED = "UNDEFINED",
      /** Monday. */
      MON = "MON",
      /** Tuesday. */
      TUE = "TUE",
      /** Wednesday. */
      WED = "WED",
      /** Thursday. */
      THU = "THU",
      /** Friday. */
      FRI = "FRI",
      /** Saturday. */
      SAT = "SAT",
      /** Sunday. */
      SUN = "SUN"
  }
  interface Frequency$2 {
      /** The frequency of the recurrence in weeks. i.e. when this value is 4, the interval occurs every 4 weeks. Optional. The default is 1. minimum: 1, maximum: 52. */
      repetition?: number | null;
  }
  interface LinkedSchedule$2 {
      /** Schedule ID. */
      scheduleId?: string;
      /**
       * Sets this schedule's availability for the duration of the linked schedule's sessions.  Default is `"BUSY"`.
       * If set to `"BUSY"`, this schedule cannot have any available slots during the linked schedule's sessions.
       * If set to `"FREE"`, this schedule can have available slots during the linked schedule's sessions.
       */
      transparency?: Transparency$2;
      /**
       * Owner ID, of the linked schedule.
       * @readonly
       */
      scheduleOwnerId?: string;
      /**
       * The name of the linked schedule owner. It may be a resource name or a service name. Optional.
       * This field is inherited from the schedule identified by scheduleId above.
       * @internal
       * @readonly
       */
      scheduleOwnerName?: string | null;
      /**
       * The user id of the linked schedule owner. Optional.
       * This field is inherited from the schedule identified by scheduleId above.
       * NOT IMPLEMENTED. YET.
       * @internal
       * @readonly
       */
      scheduleOwnerUserId?: string | null;
  }
  enum Transparency$2 {
      UNDEFINED = "UNDEFINED",
      /** The schedule can have available slots during the session. */
      FREE = "FREE",
      /** The schedule cannot have available slots during the session. Default value. */
      BUSY = "BUSY"
  }
  enum RecurringIntervalType$2 {
      /** The default value. Sessions for this interval will be of type EVENT. */
      UNDEFINED = "UNDEFINED",
      /** A recurring interval of events */
      EVENT = "EVENT",
      /** Deprecated */
      TIME_AVAILABILITY = "TIME_AVAILABILITY",
      /** A recurring interval for availability */
      AVAILABILITY = "AVAILABILITY"
  }
  interface Location$5 {
      /**
       * Location type.
       * One of:
       * - `"OWNER_BUSINESS"` The business address as set in the sites general settings.
       * - `"OWNER_CUSTOM"` The address as set when creating the service.
       * - `"CUSTOM"` The address set for the individual session.
       */
      locationType?: LocationType$5;
      /**
       * Free text address used when locationType is `OWNER_CUSTOM`.
       * @deprecated
       */
      address?: string | null;
      /** Custom address, used when locationType is `"OWNER_CUSTOM"`. Might be used when locationType is `"CUSTOM"` in case the owner sets a custom address for the session which is different from the default. */
      customAddress?: Address$6;
      /**
       * The Wix Business location formatted address.
       * Valid when `locationType` is `OWNER_BUSINESS`. Defaults to the business's location.
       * To retrieve the full location data please use the [Locations API](https://dev.wix.com/api/rest/business-info/locations).
       * @internal
       */
      businessLocation?: LocationsLocation$2;
  }
  enum LocationType$5 {
      UNDEFINED = "UNDEFINED",
      OWNER_BUSINESS = "OWNER_BUSINESS",
      OWNER_CUSTOM = "OWNER_CUSTOM",
      CUSTOM = "CUSTOM"
  }
  /** Physical address */
  interface Address$6 extends AddressStreetOneOf$5 {
      /** Street name, number and apartment number. */
      streetAddress?: StreetAddress$5;
      /** Main address line, usually street and number, as free text. */
      addressLine?: string | null;
      /** Country code. */
      country?: string | null;
      /** Subdivision. Usually state, region, prefecture or province code, according to [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). */
      subdivision?: string | null;
      /** City name. */
      city?: string | null;
      /** Zip/postal code. */
      postalCode?: string | null;
      /** Free text providing more detailed address info. Usually contains Apt, Suite, and Floor. */
      addressLine2?: string | null;
      /** A string containing the full address of this location. */
      formattedAddress?: string | null;
      /** Free text to help find the address. */
      hint?: string | null;
      /** Coordinates of the physical address. */
      geocode?: AddressLocation$5;
      /** Country full name. */
      countryFullname?: string | null;
      /** Multi-level subdivisions from top to bottom. */
      subdivisions?: Subdivision$5[];
  }
  /** @oneof */
  interface AddressStreetOneOf$5 {
      /** Street name, number and apartment number. */
      streetAddress?: StreetAddress$5;
      /** Main address line, usually street and number, as free text. */
      addressLine?: string | null;
  }
  interface StreetAddress$5 {
      /** Street number. */
      number?: string;
      /** Street name. */
      name?: string;
      /** Apartment number. */
      apt?: string;
  }
  interface AddressLocation$5 {
      /** Address latitude. */
      latitude?: number | null;
      /** Address longitude. */
      longitude?: number | null;
  }
  interface Subdivision$5 {
      /** Subdivision code. Usually state, region, prefecture or province code, according to [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). */
      code?: string;
      /** Subdivision full name. */
      name?: string;
  }
  interface LocationsLocation$2 {
      /**
       * Location ID.
       * @readonly
       */
      _id?: string | null;
      /** Location name. */
      name?: string;
      /** Location description. */
      description?: string | null;
      /**
       * Whether this is the default location. There can only be one default location per site. The default location can't be archived.
       * @readonly
       */
      default?: boolean;
      /**
       * Location status. Defaults to `ACTIVE`.
       * __Notes:__
       * - [Archiving a location](https://dev.wix.com/api/rest/business-info/locations/archive-location)
       * doesn't affect the location's status.
       * - `INACTIVE` status is currently not supported.
       */
      status?: LocationStatus$2;
      /**
       * Location type.
       *
       * **Note:** Currently not supported.
       * @deprecated
       */
      locationType?: LocationsLocationType$2;
      /** Fax number. */
      fax?: string | null;
      /** Timezone in `America/New_York` format. */
      timeZone?: string | null;
      /** Email address. */
      email?: string | null;
      /** Phone number. */
      phone?: string | null;
      /** Address. */
      address?: LocationsAddress$2;
      /**
       * Business schedule. Array of weekly recurring time periods when the location is open for business. Limited to 100 time periods.
       *
       * __Note:__ Not supported by Wix Bookings.
       */
      businessSchedule?: BusinessSchedule$3;
      /**
       * Revision number, which increments by 1 each time the location is updated.
       * To prevent conflicting changes, the existing revision must be used when updating a location.
       */
      revision?: string | null;
      /**
       * Whether the location is archived. Archived locations can't be updated.
       * __Note:__ [Archiving a location](https://dev.wix.com/api/rest/business-info/locations/archive-location)
       * doesn't affect its `status`.
       * @readonly
       */
      archived?: boolean;
      /** Location types. */
      locationTypes?: LocationsLocationType$2[];
  }
  /** For future use */
  enum LocationStatus$2 {
      ACTIVE = "ACTIVE",
      INACTIVE = "INACTIVE"
  }
  /** For future use */
  enum LocationsLocationType$2 {
      UNKNOWN = "UNKNOWN",
      BRANCH = "BRANCH",
      OFFICES = "OFFICES",
      RECEPTION = "RECEPTION",
      HEADQUARTERS = "HEADQUARTERS",
      INVENTORY = "INVENTORY"
  }
  interface LocationsAddress$2 {
      /** 2-letter country code in an [ISO-3166 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format. */
      country?: string | null;
      /** Code for a subdivision (such as state, prefecture, or province) in [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) format. */
      subdivision?: string | null;
      /** City name. */
      city?: string | null;
      /** Postal or zip code. */
      postalCode?: string | null;
      /** Street address. Includes street name, number, and apartment number in separate fields. */
      streetAddress?: LocationsStreetAddress$2;
      /** Full address of the location. */
      formatted?: string | null;
      /** Geographic coordinates of location. */
      location?: LocationsAddressLocation$2;
  }
  /** Street address. Includes street name, number, and apartment number in separate fields. */
  interface LocationsStreetAddress$2 {
      /** Street number. */
      number?: string;
      /** Street name. */
      name?: string;
      /** Apartment number. */
      apt?: string;
  }
  /** Address Geolocation */
  interface LocationsAddressLocation$2 {
      /** Latitude of the location. Must be between -90 and 90. */
      latitude?: number | null;
      /** Longitude of the location. Must be between -180 and 180. */
      longitude?: number | null;
  }
  /** Business schedule. Regular and exceptional time periods when the business is open or the service is available. */
  interface BusinessSchedule$3 {
      /** Weekly recurring time periods when the business is regularly open or the service is available. Limited to 100 time periods. */
      periods?: TimePeriod$3[];
      /** Exceptions to the business's regular hours. The business can be open or closed during the exception. */
      specialHourPeriod?: SpecialHourPeriod$3[];
  }
  /** Weekly recurring time periods when the business is regularly open or the service is available. */
  interface TimePeriod$3 {
      /** Day of the week the period starts on. */
      openDay?: DayOfWeek$3;
      /**
       * Time the period starts in 24-hour [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) extended format. Valid values are `00:00` to `24:00`, where `24:00` represents
       * midnight at the end of the specified day.
       */
      openTime?: string;
      /** Day of the week the period ends on. */
      closeDay?: DayOfWeek$3;
      /**
       * Time the period ends in 24-hour [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) extended format. Valid values are `00:00` to `24:00`, where `24:00` represents
       * midnight at the end of the specified day.
       *
       * __Note:__ If `openDay` and `closeDay` specify the same day of the week `closeTime` must be later than `openTime`.
       */
      closeTime?: string;
  }
  /** Enumerates the days of the week. */
  enum DayOfWeek$3 {
      MONDAY = "MONDAY",
      TUESDAY = "TUESDAY",
      WEDNESDAY = "WEDNESDAY",
      THURSDAY = "THURSDAY",
      FRIDAY = "FRIDAY",
      SATURDAY = "SATURDAY",
      SUNDAY = "SUNDAY"
  }
  /** Exception to the business's regular hours. The business can be open or closed during the exception. */
  interface SpecialHourPeriod$3 {
      /** Start date and time of the exception in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format and [Coordinated Universal Time (UTC)](https://en.wikipedia.org/wiki/Coordinated_Universal_Time). */
      startDate?: string;
      /** End date and time of the exception in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format and [Coordinated Universal Time (UTC)](https://en.wikipedia.org/wiki/Coordinated_Universal_Time). */
      endDate?: string;
      /**
       * Whether the business is closed (or the service is not available) during the exception.
       *
       * Default: `true`.
       */
      isClosed?: boolean;
      /** Additional info about the exception. For example, "We close earlier on New Year's Eve." */
      comment?: string;
  }
  interface Rate$2 {
      /**
       * Mapping between a named price option, for example, adult or child prices, and the price, currency, and down payment amount.
       * When present in an update request, the `default_varied_price` is ignored to support backward compatibility.
       */
      labeledPriceOptions?: Record<string, Price$3>;
      /**
       * Textual price information used when **Price Per Session** is set to **Custom Price** in the app's service details page.
       * When present in an update request, the `default_varied_price` is ignored to support backward compatibility.
       */
      priceText?: string | null;
      /**
       * Default service price. Always vailable when a service has
       * [variants](https://dev.wix.com/api/rest/wix-bookings/service-options-and-variants/introduction).
       * Sometimes also available for services without variants.
       * Ignored in [updates to a service](https://dev.wix.com/api/rest/wix-bookings/services/service/update-service),
       * when either `labeled_price_options` or `price_text` is also specified.
       * @internal
       */
      defaultVariedPrice?: Price$3;
  }
  interface Price$3 {
      /** Required payment amount. */
      amount?: string;
      /** Currency in which the amount is quoted. */
      currency?: string;
      /** Amount of a down payment or deposit as part of the transaction. */
      downPayAmount?: string;
  }
  /**
   * <!-- Needs updating when recurrence has been tested
   * Schedule's availability calculation is executed by the schedule's available intervals and this additional information.
   * Schedule's available intervals are recurring intervals (defined in the schedule) minus sessions that has no more spots for bookings (including time between_slots), or schedule's sessions with open spots for bookings.-->
   */
  interface Availability$2 {
      /** Date and time the schedule starts to be available for booking. */
      start?: Date | null;
      /** Date and time the schedule stops being available for booking. No value indicates no end time. */
      end?: Date | null;
      /** Other schedules that impact the availability calculation. Relevant only when there are availability constraints. */
      linkedSchedules?: LinkedSchedule$2[];
      /** Constraints for calculating the schedule's availability. */
      constraints?: AvailabilityConstraints$2;
      /**
       * Not supported yet.
       * A list of possible locations for the session when `use_default_location` is set to `false`. Slots are generated for each location. Only one of the possible locations can be chosen by the customer.
       *
       * **NOTE**: When using the `locations` parameter, the default location is not automatically included in the list.
       * @internal
       */
      locations?: Location$5[];
      /**
       * Not supported yet.
       * Whether the schedule's slots are only available at the schedule's default location, as set in `schedule.location`. If set to `false`, the `locations` array is used to set the possible locations of the schedule's sessions.
       * Default is `true`.
       * @internal
       */
      useDefaultLocation?: boolean | null;
  }
  /** Describes how to calculate the specific slots that are available for booking. */
  interface AvailabilityConstraints$2 {
      /**
       * A list of duration options for slots, in minutes. Minimum value for a duration is 1.
       * The availability calculation generates slots with these durations, where there is no conflict with existing sessions or other availability constraints.
       */
      slotDurations?: number[];
      /**
       * The number of minutes between the `end` of one slot, and the `start` of the next.
       * Minimum value is 0, maximum value is 120.
       */
      timeBetweenSlots?: number;
      /**
       * Specify how to split the slots in intervals of minutes.
       * This value indicates the time between available slots' start time. e.g., from 5 minute slots (3:00, 3:05, 3:15) and 1 hour slots (3:00, 4:00, 5:00).
       * Optional. The default is the first duration in slot_durations field.
       * Deprecated. Use the `split_slots_interval.value_in_minutes`.
       * @deprecated
       */
      splitInterval?: number | null;
      /**
       * An object defining the time between available slots' start times.  For example, a slot with slots_split_interval=5 can start every 5 minutes. The default is the slot duration.
       * @readonly
       */
      slotsSplitInterval?: SplitInterval$2;
  }
  /** The time between available slots' start times. For example, For 5 minute slots, 3:00, 3:05, 3:15 etc. For 1 hour slots, 3:00, 4:00, 5:00 etc. */
  interface SplitInterval$2 {
      /**
       * Whether the slot duration is used as the split interval value.
       * If `same_as_duration` is `true`, the `value_in_minutes` is the sum of the first duration in
       * `schedule.availabilityConstraints.SlotDurations` field, and `schedule.availabilityConstraints.TimeBetweenSlots` field.
       */
      sameAsDuration?: boolean | null;
      /** Number of minutes between available slots' start times when `same_as_duration` is `false`. */
      valueInMinutes?: number | null;
  }
  interface Participant$2 {
      /** Participant ID. Currently represents the booking.id. */
      _id?: string;
      /** Contact ID. */
      contactId?: string | null;
      /** Participant's name. */
      name?: string | null;
      /** Participant's phone number. */
      phone?: string | null;
      /** Participant's email address. */
      email?: string | null;
      /** Group or party size. The number of people attending. Defaults to 0. Maximum is 250. */
      partySize?: number;
      /**
       * Approval status for the participant.
       * <!-- Commented out untill updateParticipant is exposed Generally the same status as the booking, unless updated using the `updateParticipant()` API. Defaults to `"UNDEFINED"`.-->
       */
      approvalStatus?: ApprovalStatus$2;
      /**
       * Whether the participant was inherited from the schedule, as opposed to being booked directly to the session.
       * @readonly
       */
      inherited?: boolean;
  }
  enum ApprovalStatus$2 {
      /** Default. */
      UNDEFINED = "UNDEFINED",
      /** Pending business approval. */
      PENDING = "PENDING",
      /** Approved by the business. */
      APPROVED = "APPROVED",
      /** Declined by the business. */
      DECLINED = "DECLINED"
  }
  interface ExternalCalendarOverrides$2 {
      /** Synced title of the external calendar event. */
      title?: string | null;
      /** Synced description of the external calendar event. */
      description?: string | null;
  }
  enum ScheduleStatus$2 {
      UNDEFINED = "UNDEFINED",
      /** The default value when the schedule is created. */
      CREATED = "CREATED",
      /** The schedule has been canceled. */
      CANCELLED = "CANCELLED"
  }
  interface Version$2 {
      /** Schedule version number, updated each time the schedule is updated. */
      scheduleVersion?: number | null;
      /** Participants version number, updated each time the schedule participants are updated. */
      participantsVersion?: number | null;
  }
  interface ConferenceProvider$2 {
      /** Conferencing provider ID */
      providerId?: string;
  }
  interface CalendarConference$2 {
      /** Wix Calendar conference ID. */
      _id?: string;
      /** Conference meeting ID in the provider's conferencing system. */
      externalId?: string;
      /**
       * A generated id for the conference entity - Base62($providerId$accountOwnerId$conferenceId)
       * @internal
       */
      conferenceId?: string | null;
      /** Conference provider ID. */
      providerId?: string;
      /** URL used by the host to start the conference. */
      hostUrl?: string;
      /** URL used by a guest to join the conference. */
      guestUrl?: string;
      /** Password to join the conference. */
      password?: string | null;
      /** Conference description. */
      description?: string | null;
      /** Conference type. */
      conferenceType?: ConferenceType$2;
      /** ID of the account owner in the video conferencing service. */
      accountOwnerId?: string | null;
  }
  enum ConferenceType$2 {
      UNDEFINED = "UNDEFINED",
      /** API-generated online meeting. */
      ONLINE_MEETING_PROVIDER = "ONLINE_MEETING_PROVIDER",
      /** User-defined meeting. */
      CUSTOM = "CUSTOM"
  }
  enum ResourceStatus$1 {
      UNDEFINED = "UNDEFINED",
      /** Default status. */
      CREATED = "CREATED",
      /** The resource was deleted. */
      DELETED = "DELETED",
      /** The resource was updated. */
      UPDATED = "UPDATED"
  }
  interface BusinessLocation$3 {
      /** The ID of the business location. Has to be non-empty */
      locationId?: string;
  }
  enum Event$1 {
      UNDEFINED = "UNDEFINED",
      Updated = "Updated",
      Deleted = "Deleted",
      Created = "Created",
      Schedule_Updated = "Schedule_Updated"
  }
  interface Empty$5 {
  }
  /** An event sent in the system once the service is changed. */
  interface ServiceNotification extends ServiceNotificationMetadataOneOf {
      deleteMetadata?: DeleteMetadata;
      /** Updated service entity. */
      service?: Service$1;
      event?: ServiceNotificationEvent;
      policy?: BusinessServicesPolicy;
  }
  /** @oneof */
  interface ServiceNotificationMetadataOneOf {
      deleteMetadata?: DeleteMetadata;
  }
  /** A service describes the business offering that a business provides to its customers. */
  interface Service$1 {
      /**
       * Service ID.
       * @readonly
       */
      _id?: string | null;
      /** Information about the service. */
      info?: ServiceInfo;
      /** Description of the bookings policy for the service. */
      policy?: BookingPolicy$3;
      /** Payment options available for use when booking the service. */
      paymentOptions?: PaymentOptions$1;
      /** ID of the category to which the service belongs. */
      categoryId?: string | null;
      /** ID of the form that visitors fill out when booking the service. */
      bookingFormId?: string | null;
      /**
       * List of schedule IDs for the sessions and slots that can be booked for the service.
       * The list can include schedules with any `status` values, however the Bookings application only uses the schedules with a `status` of `"CREATED"`. There is only one schedule with a status of `"CREATED"` per service. The ID of that schedule must always be the first in the list.
       * @readonly
       */
      scheduleIds?: string[];
      /** Set of custom properties for the service. */
      customProperties?: Record<string, string>;
      /**
       * Service status.
       * @readonly
       */
      status?: ServiceStatus;
      /** Sort order of the service within its category. */
      sortOrder?: number | null;
      /**
       * Advanced SEO data
       * @deprecated
       */
      advancedSeoData?: SeoSchema$1;
      /** SEO data */
      seoData?: SeoSchema$1;
      /** Whether a conference is to be generated for the service. */
      includeConferenceOption?: boolean | null;
  }
  /** Information describing the service. */
  interface ServiceInfo {
      /** Service name. */
      name?: string | null;
      /** Service description. */
      description?: string | null;
      /**
       * Images associated with the service. Deprecated.
       * @deprecated
       */
      images?: string[];
      /** Short service description. */
      tagLine?: string | null;
      /** Images associated with the service. Optional. Not supported yet. */
      media?: Media$1;
  }
  interface Media$1 {
      /** Images associated with the service. */
      items?: MediaItem$2[];
      /** Primary image associated with the service. */
      mainMedia?: MediaItem$2;
      /** Cover image associated with the service. */
      coverMedia?: MediaItem$2;
  }
  interface MediaItem$2 extends MediaItemItemOneOf$1 {
      /** Image metadata. */
      image?: string;
  }
  /** @oneof */
  interface MediaItemItemOneOf$1 {
      /** Image metadata. */
      image?: string;
  }
  /** A set of rules defining the policies for booking the service for visitors and members. */
  interface BookingPolicy$3 {
      /** Maximum number of participants for a single booking. Defaults to 1. */
      maxParticipantsPerBooking?: number | null;
      /** Minimum number of minutes before the start of a session that a booking can be made. For a schedule, this is relative to the start time of the next session, excluding past sessions. Default value is taken form BusinessServicesPolicy. */
      bookUpToXMinutesBefore?: number | null;
      /** Minimum number of minutes before the start of a session that a booking can be canceled or rescheduled. Default value is taken form BusinessServicesPolicy. */
      cancelRescheduleUpToXMinutesBefore?: number | null;
      /** Whether online booking is available. Defaults to true. */
      isBookOnlineAllowed?: boolean | null;
      /** Whether bookings for the service can be canceled. Defaults to true. */
      isCancelAllowed?: boolean | null;
      /** Whether bookings for the service can be rescheduled. Defaults to true. */
      isRescheduleAllowed?: boolean | null;
      /** How far in advance a booking can be made. Default value is taken form BusinessServicesPolicy. */
      futureBookingsPolicy?: FutureBookingPolicy;
      /** Waitlist policy for the service. Default value is taken form BusinessServicesPolicy. */
      waitingListPolicy?: WaitingListPolicy;
      /** Bookings approval policy for the service. Empty by default. */
      bookingsApprovalPolicy?: BookingsApprovalPolicy;
      /**
       * A list of booking policy field names of fields that override the respective values of the default business booking policy.
       * Currently only 'service.policy.bookUpToXMinutesBefore' field is supported
       */
      overrideBusinessPolicyFields?: string[];
      /**
       * User defined cancellation policy message.
       * @readonly
       */
      cancellationPolicy?: string | null;
  }
  interface FutureBookingPolicy {
      /** Whether a limit is imposed on advance bookings. */
      shouldLimit?: boolean | null;
      /** How far in advance, in minutes, a session can be booked. Defaults to 10,080 minutes (3 days). */
      limitXMinutesToTheFuture?: number | null;
  }
  interface WaitingListPolicy {
      /** Whether waitlisting is enabled for the service. */
      isEnabled?: boolean | null;
      /** Number of spots available in the waitlist. Defaults to 10 spots. */
      capacity?: number | null;
      /** Amount of time a participant is given to book, once notified that a spot is available. Defaults to 10 minutes. */
      timeWindowMinutes?: number | null;
  }
  interface BookingsApprovalPolicy {
      /** Whether bookings to the service require approval. */
      isBusinessApprovalRequired?: boolean | null;
      /** Whether the booking requests affect the session or slot availability. For example, 3 booking requests for a 10-person session will cause the session to have 7 available spots, before the requests are approved. */
      requestsAffectsAvailability?: boolean | null;
  }
  /**
   * Payment options for the service. Multiple payment options can be enabled. For example:
   * For a service to be paid only online using WiX, then set wix_pay_online=true and the rest should be set to false.
   * For a service to accept payment online via Wix or in person, set the wix_pay_online=true & wix_pay_in_person=true.
   */
  interface PaymentOptions$1 {
      /** Whether a booking made for the service can be paid online through Wix. */
      wixPayOnline?: boolean | null;
      /** Whether a booking made for the service can be paid in person. */
      wixPayInPerson?: boolean | null;
      /** Whether a booking made for the service can be paid in a customized way, defined by the API. */
      custom?: boolean | null;
      /** Whether a booking made for the service can be paid using Wix Pricing Plans. */
      wixPaidPlan?: boolean | null;
  }
  enum ServiceStatus {
      /** The default service status. */
      CREATED = "CREATED",
      /** The service is deleted. */
      DELETED = "DELETED"
  }
  /**
   * The SEO schema object contains data about different types of meta tags. It makes sure that the information about your page is presented properly to search engines.
   * The search engines use this information for ranking purposes, or to display snippets in the search results.
   * This data will override other sources of tags (for example patterns) and will be included in the <head> section of the HTML document, while not being displayed on the page itself.
   */
  interface SeoSchema$1 {
      /** SEO tag information. */
      tags?: Tag$1[];
      /** SEO general settings. */
      settings?: Settings$1;
  }
  interface Keyword$1 {
      /** Keyword value. */
      term?: string;
      /** Whether the keyword is the main focus keyword. */
      isMain?: boolean;
      /** The source that added the keyword terms to the SEO settings. */
      origin?: string | null;
  }
  interface Tag$1 {
      /**
       * SEO tag type.
       *
       *
       * Supported values: `title`, `meta`, `script`, `link`.
       */
      type?: string;
      /**
       * A `{'key':'value'}` pair object where each SEO tag property (`'name'`, `'content'`, `'rel'`, `'href'`) contains a value.
       * For example: `{'name': 'description', 'content': 'the description itself'}`.
       */
      props?: Record<string, any> | null;
      /** SEO tag meta data. For example, `{height: 300, width: 240}`. */
      meta?: Record<string, any> | null;
      /** SEO tag inner content. For example, `<title> inner content </title>`. */
      children?: string;
      /** Whether the tag is a custom tag. */
      custom?: boolean;
      /** Whether the tag is disabled. */
      disabled?: boolean;
  }
  interface Settings$1 {
      /**
       * Whether the Auto Redirect feature, which creates `301 redirects` on a slug change, is enabled.
       *
       *
       * Default: `false` (Auto Redirect is enabled.)
       */
      preventAutoRedirect?: boolean;
      /** User-selected keyword terms for a specific page. */
      keywords?: Keyword$1[];
  }
  enum ServiceNotificationEvent {
      Unspecified = "Unspecified",
      Updated = "Updated",
      Deleted = "Deleted",
      Created = "Created"
  }
  /**
   * Defines the Bookings Policy applied to the business's services. The policy can be overridden for a service when setting the `Service.BookingsPolicy` property.
   * Unless overridden, each service inherits the settings in the business policy.
   */
  interface BusinessServicesPolicy {
      /** Minimum amount of time to make a booking before the start of the booked item. For sessions, this is relative to the start time of the session. For schedules, this is relative to the start time of the first session, excluding past sessions. Defaults to 0. */
      bookUpToXMinutesBefore?: number | null;
      /** Minimum time that a booking can be canceled or rescheduled before the session starts. Defaults to 0. */
      cancelRescheduleUpToXMinutesBefore?: number | null;
      /** An object specifying how far in advance a booking can be made. */
      futureBookingsPolicy?: FutureBookingPolicy;
      /** Waitlist policy for the service. Empty by default. */
      waitingListPolicy?: WaitingListPolicy;
      /** User defined cancellation policy message. */
      cancellationPolicy?: string | null;
  }
  interface DeleteMetadata {
      preserveFutureSessionsWithParticipants?: boolean;
      participantNotification?: ParticipantNotification$6;
  }
  interface ParticipantNotification$6 {
      /**
       * Whether to send the message about the changes to the customer.
       *
       * Default: `false`
       */
      notifyParticipants?: boolean;
      /** Custom message to send to the participants about the changes to the booking. */
      message?: string | null;
      /**
       * Optional additional metadata.
       * Supported only in V3 APIs.
       * @internal
       */
      metadata?: Record<string, string>;
  }
  interface ScheduleNotification$2 extends ScheduleNotificationEventOneOf$2 {
      scheduleCreated?: ScheduleCreated$2;
      scheduleUpdated?: ScheduleUpdated$2;
      scheduleCancelled?: ScheduleCancelled$2;
      sessionCreated?: SessionCreated$2;
      sessionUpdated?: SessionUpdated$2;
      sessionCancelled?: SessionCancelled$2;
      availabilityPolicyUpdated?: AvailabilityPolicyUpdated$2;
      /** @deprecated */
      intervalSplit?: IntervalSplit$2;
      recurringSessionSplit?: RecurringSessionSplit$2;
      /**
       * Inspect `schedule.scheduleOwnerUserId` on `scheduleUpdated` instead.
       * @deprecated
       */
      scheduleUnassignedFromUser?: ScheduleUnassignedFromUser$2;
      /**
       * supported only for schedule migration apis.
       * @internal
       */
      multipleSessionsCreated?: MultipleSessionsCreated$2;
      /**
       * supported only for schedule migration apis.
       * @internal
       */
      migrationEvent?: MigrationEvent$2;
      preserveFutureSessionsWithParticipants?: boolean | null;
      /**
       * Whether to notify participants about changed sessions. deprecated, use participant_notification
       * @deprecated
       */
      notifyParticipants?: boolean;
      /** site properties. Optional. Given in create schedule notification. */
      siteProperties?: SitePropertiesOnScheduleCreation$2;
      instanceId?: string;
      /**
       * true when the schedule belongs to a site that is rolled out to calendar v3
       * @internal
       */
      rolledOut?: boolean | null;
  }
  /** @oneof */
  interface ScheduleNotificationEventOneOf$2 {
      scheduleCreated?: ScheduleCreated$2;
      scheduleUpdated?: ScheduleUpdated$2;
      scheduleCancelled?: ScheduleCancelled$2;
      sessionCreated?: SessionCreated$2;
      sessionUpdated?: SessionUpdated$2;
      sessionCancelled?: SessionCancelled$2;
      availabilityPolicyUpdated?: AvailabilityPolicyUpdated$2;
      /** @deprecated */
      intervalSplit?: IntervalSplit$2;
      recurringSessionSplit?: RecurringSessionSplit$2;
      /**
       * Inspect `schedule.scheduleOwnerUserId` on `scheduleUpdated` instead.
       * @deprecated
       */
      scheduleUnassignedFromUser?: ScheduleUnassignedFromUser$2;
      /**
       * supported only for schedule migration apis.
       * @internal
       */
      multipleSessionsCreated?: MultipleSessionsCreated$2;
      /**
       * supported only for schedule migration apis.
       * @internal
       */
      migrationEvent?: MigrationEvent$2;
  }
  interface ScheduleCreated$2 {
      schedule?: Schedule$3;
  }
  interface ScheduleUpdated$2 {
      /** The old schedule before the update. */
      oldSchedule?: Schedule$3;
      /** The new schedule after the update. */
      newSchedule?: Schedule$3;
      /**
       * Recurring sessions updated event. If this field is given, the reason for the schedule updated event was
       * updating at least one of the given schedule's recurring sessions.
       * This event is triggered by create/update/delete recurring session apis.
       */
      recurringSessions?: RecurringSessionsUpdated$2;
      /** Whether to notify participants about the change and an optional custom message */
      participantNotification?: ParticipantNotification$6;
      /**
       * Whether this notification was created as a result of an anonymization request, such as GDPR.
       * An anonymized participant will have the following details:
       * name = "deleted"
       * phone = "deleted"
       * email = "deleted@deleted.com"
       */
      triggeredByAnonymizeRequest?: boolean | null;
  }
  interface RecurringSessionsUpdated$2 {
      /** Old schedule's recurring session list. */
      oldRecurringSessions?: Session$2[];
      /** New schedule's recurring session list. */
      newRecurringSessions?: Session$2[];
  }
  interface Session$2 {
      /**
       * Session ID.
       * @readonly
       */
      _id?: string | null;
      /** ID of the schedule that the session belongs to. */
      scheduleId?: string;
      /**
       * ID of the resource or service that the session's schedule belongs to.
       * @readonly
       */
      scheduleOwnerId?: string | null;
      /** Original start date and time of the session in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Coordinated_Universal_Time_(UTC)) format. */
      originalStart?: Date | null;
      /** An object specifying the start date and time of the session. If the session is a recurring session, `start` must contain a `localDateTime`. */
      start?: CalendarDateTime$2;
      /**
       * An object specifying the end date and time of the session. The `end` time must be after the `start` time and be same type as `start`.
       * If the session is a recurring session, `end` must contain a `localDateTime`.
       */
      end?: CalendarDateTime$2;
      /**
       * An object specifying a list of schedules and the way each schedule's availability is affected by the session. For example, the schedule of an instructor is affected by sessions of the class that they instruct.
       * The array is inherited from the schedule and can be overridden even if the session is a recurring session.
       */
      affectedSchedules?: LinkedSchedule$2[];
      /**
       * Session title.
       * The value is inherited from the schedule and can be overridden unless the session is a recurring session.
       */
      title?: string | null;
      /**
       * __Deprecated.__
       * Tags for the session.
       * The value is inherited from the schedule and can be overridden unless the session is a recurring session.
       * @deprecated
       */
      tags?: string[] | null;
      /**
       * An object describing the location where the session takes place.
       * Defaults to the schedule location.
       * For single sessions, `session.location.businessLocation` can only be provided for locations that are defined in the schedule using `schedule.location` or `schedule.availability.locations`.
       */
      location?: Location$5;
      /**
       * Maximum number of participants that can be added to the session. Defaults to the schedule capacity.
       * The value is inherited from the schedule and can be overridden unless the session is a recurring session.
       */
      capacity?: number | null;
      /**
       * The remaining number of participants that can be added to the session. Read-only.
       * Can be negative, in case the session is over capacity.
       * @internal
       * @readonly
       */
      remainingCapacity?: number | null;
      /**
       * Deprecated. Please use the [Booking Services V2](https://dev.wix.com/api/rest/wix-bookings/services-v2) payment instead.
       * @deprecated
       */
      rate?: Rate$2;
      /**
       * Time reserved after the session end time, derived from the schedule availability constraints and the time between slots. Read-only.
       * If the session is a recurring session, this field must be empty.
       */
      timeReservedAfter?: number | null;
      /**
       * Additional information about the session.
       * Notes are not supported for recurring sessions.
       */
      notes?: string;
      /**
       * The number of participants booked for the session. Read-only.
       * Calculated as the sum of the party sizes.
       * @readonly
       */
      totalNumberOfParticipants?: number;
      /**
       * *Partial list** list of participants booked for the session.
       * The list includes participants who have registered for this specific session, and participants who have registered for a schedule that includes this session.
       * If the session is a recurring session, this field must be empty.
       * To retrieve the full list of session participants please use the [Query Extended Bookings API](https://dev.wix.com/api/rest/wix-bookings/bookings-reader-v2/query-extended-bookings).
       */
      participants?: Participant$2[];
      /**
       * A list of properties for which values were inherited from the schedule.
       * This does not include participants that were inherited from the schedule.
       * @readonly
       */
      inheritedFields?: string[];
      /**
       * Information about the external calendar, if the session originated in an external calendar.
       * @internal
       * @readonly
       */
      externalCalendarInfo?: ExternalCalendarInfo$2;
      /**
       * __Deprecated.__
       * @deprecated
       */
      externalCalendarOverrides?: ExternalCalendarOverrides$2;
      /**
       * Session status.
       * @readonly
       */
      status?: Status$2;
      /**
       * Recurring interval ID. Defined when a session will be a recurring session. read-only. Optional.
       * For exmaple, when creating a class service  with recurring sessions, you add a recurrence rule to create recurring sessions.
       * This field is omitted for single sessions or instances of recurring sessions.
       * Specified when the session was originally generated from a schedule recurring interval.
       * Deprecated. Use `recurringSessionId`.
       * @readonly
       * @deprecated
       */
      recurringIntervalId?: string | null;
      /**
       * The ID of the recurring session if this session is an instance of a recurrence. Use this ID to update the recurrence and all of the instances.
       * @readonly
       */
      recurringSessionId?: string | null;
      /** Session type. */
      type?: SessionType$2;
      /**
       * A conference created for the session according to the details set in the schedule's conference provider information.
       * If the session is a recurring session, this field is inherited from the schedule.
       * **Partially deprecated.** Only `hostUrl` and `guestUrl` are to be supported.
       * @deprecated
       */
      calendarConference?: CalendarConference$2;
      /**
       * A string representing a recurrence rule (RRULE) for a recurring session, as defined in [iCalendar RFC 5545](https://icalendar.org/iCalendar-RFC-5545/3-3-10-recurrence-rule.html).
       * If the session is an instance of a recurrence pattern, the `instanceOfRecurrence` property will be contain the recurrence rule and this property will be empty.
       * The RRULE defines a rule for repeating a session.
       * Supported parameters are:
       *
       * |Keyword|Description|Supported values|
       * |--|--|---|
       * |`FREQ`|The frequency at which the session is recurs. Required.|`WEEKLY`|
       * |`INTERVAL`|How often, in terms of `FREQ`, the session recurs. Default is 1. Optional.|
       * |`UNTIL`|The UTC end date and time of the recurrence. Optional.|
       * |`BYDAY`|Day of the week when the event should recur. Required.|One of: `MO`, `TU`, `WE`, `TH`, `FR`, `SA`, `SU`|
       *
       *
       * For example, a session that repeats every second week on a Monday until January 7, 2022 at 8 AM:
       * `"FREQ=WEEKLY;INTERVAL=2;BYDAY=MO;UNTIL=20220107T080000Z"`
       *
       * <!--ORIGINAL COMMENTS:
       * `FREQ`  The frequency with which the session should be repeated (such as DAILY or WEEKLY).
       * Supported `WEEKLY` value is supported.
       * INTERVAL  Works together with FREQ to specify how often the session should be repeated. For example, FREQ=WEEKLY;INTERVAL=2 means once every two weeks. Optional. Default value is 1.
       * COUNT  The number of times this event should be repeated. Not yet supported.
       * UNTIL  The UTC date & time until which the session should be repeated. This parameter is optional. When it is not specified, the event repeats forever.
       * The format is a short ISO date, followed by 'T' and a short time with seconds and without milliseconds, terminated by the UTC designator 'Z'. For example, until Jan. 19th 2018 at 7:00 AM: 'UNTIL=20180119T070000Z'.
       * BYDAY - The days of the week when the event should be repeated. Currently, only a single day is supported. This parameter is mandatory.
       * Possible values are: MO, TU, WE, TH, FR, SA, SU
       * Note that DTSTART and DTEND lines are not allowed in this field; session start and end times are specified in the start and end fields.
       * **Example**: FREQ=WEEKLY;INTERVAL=2;BYDAY=MO;UNTIL=20200427T070000Z
       * ORIGINAL COMMENTS-->
       */
      recurrence?: string | null;
      /**
       * A string representing a recurrence rule (RRULE) if the session is an instance of a recurrence pattern.
       * Empty when the session is not an instance of a recurrence rule, or if the session defines a recurrence pattern, and `recurrence` is not empty.
       * @readonly
       */
      instanceOfRecurrence?: string | null;
      /**
       * The name of the schedule owner. It may be a resource name or a service name. Optional.
       * @internal
       * @readonly
       */
      scheduleOwnerName?: string | null;
      /**
       * The user id of the schedule owner. Optional.
       * NOT IMPLEMENTED YET.
       * @internal
       * @readonly
       */
      scheduleOwnerUserId?: string | null;
      /**
       * The session version.
       * Composed by the schedule, session and participants versions.
       * @readonly
       */
      version?: SessionVersion$2;
      /**
       * The ID of the event in the new Calendar Events V3 API.
       * @internal
       * @readonly
       */
      eventId?: string | null;
  }
  interface CalendarDateTime$2 {
      /**
       * UTC date-time in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Coordinated_Universal_Time_(UTC)) format. If a time zone offset is specified, the time is converted to UTC. For example, if you specify  `new Date('2021-01-06T16:00:00.000-07:00')`, the stored value will be `"2021-01-06T23:00:00.000Z"`.
       * Required if `localDateTime` is not specified.
       * If `localDateTime` is specified, `timestamp` is calculated as `localDateTime`, using the business's time zone.
       */
      timestamp?: Date | null;
      /** An object containing the local date and time for the business's time zone. */
      localDateTime?: LocalDateTime$2;
      /**
       * The time zone. Optional. Derived from the schedule's time zone.
       * In case this field is associated with recurring session, this field is empty.
       * @readonly
       */
      timeZone?: string | null;
  }
  interface LocalDateTime$2 {
      /** Year. 4-digit format. */
      year?: number | null;
      /** Month number, from 1-12. */
      monthOfYear?: number | null;
      /** Day of the month, from 1-31. */
      dayOfMonth?: number | null;
      /** Hour of the day in 24-hour format, from 0-23. */
      hourOfDay?: number | null;
      /** Minute, from 0-59. */
      minutesOfHour?: number | null;
  }
  interface ExternalCalendarInfo$2 {
      /** The external calendar type (e.g. Google Calendar, iCal, etc). */
      calendarType?: CalendarType$2;
  }
  enum CalendarType$2 {
      UNDEFINED = "UNDEFINED",
      GOOGLE = "GOOGLE",
      I_CAL = "I_CAL",
      /** Use `MICROSOFT` instead. */
      OUTLOOK = "OUTLOOK",
      /** Use `MICROSOFT` instead. */
      OFFICE_365 = "OFFICE_365",
      MICROSOFT = "MICROSOFT",
      OTHER = "OTHER"
  }
  enum Status$2 {
      UNDEFINED = "UNDEFINED",
      /** The session is confirmed. Default status. */
      CONFIRMED = "CONFIRMED",
      /**
       * The session is cancelled.
       * A cancelled session can be the cancellation of a recurring session that should no longer be displayed or a deleted single session.
       * The ListSessions returns cancelled sessions only if 'includeDelete' flag is set to true.
       */
      CANCELLED = "CANCELLED"
  }
  enum SessionType$2 {
      UNDEFINED = "UNDEFINED",
      /**
       * The session creates an event on the calendar for the owner of the schedule that the session belongs to.
       * Default type.
       */
      EVENT = "EVENT",
      /** The session represents a resource's available working hours. */
      WORKING_HOURS = "WORKING_HOURS",
      /** Deprecated. please use WORKING_HOURS */
      TIME_AVAILABILITY = "TIME_AVAILABILITY",
      /** Deprecated. The session represents a resource's available hours. please use WORKING_HOURS */
      AVAILABILITY = "AVAILABILITY"
  }
  interface SessionVersion$2 {
      /**
       * Schedule version number, updated each time the schedule is updated.
       * @internal
       */
      scheduleVersion?: number;
      /**
       * Session version number, updated each time the session is updated.
       * @internal
       */
      sessionVersion?: number;
      /**
       * Participants version number, updated each time the session participants are updated.
       * @internal
       */
      participantsVersion?: number | null;
      /** Incremental version number, which is updated on each change to the session or on changes affecting the session. */
      number?: string | null;
  }
  interface ScheduleCancelled$2 {
      schedule?: Schedule$3;
      /** Whether to notify participants about the change and an optional custom message */
      participantNotification?: ParticipantNotification$6;
      oldSchedule?: Schedule$3;
  }
  interface SessionCreated$2 {
      session?: Session$2;
  }
  interface SessionUpdated$2 {
      oldSession?: Session$2;
      newSession?: Session$2;
      /** Whether to notify participants about the change and an optional custom message */
      participantNotification?: ParticipantNotification$6;
      /**
       * Whether this notification was created as a result of an anonymization request, such as GDPR.
       * An anonymized participant will have the following details:
       * name = "deleted"
       * phone = "deleted"
       * email = "deleted@deleted.com"
       */
      triggeredByAnonymizeRequest?: boolean | null;
  }
  interface SessionCancelled$2 {
      session?: Session$2;
      /** Whether to notify participants about the change and an optional custom message */
      participantNotification?: ParticipantNotification$6;
  }
  interface AvailabilityPolicyUpdated$2 {
      availabilityPolicy?: AvailabilityPolicy$2;
  }
  /** Availability policy applied to all site schedules. */
  interface AvailabilityPolicy$2 {
      /** Specify how to split the schedule slots in intervals of minutes. */
      splitInterval?: SplitInterval$2;
  }
  interface IntervalSplit$2 {
      scheduleId?: string;
      intervals?: RecurringInterval$2[];
      newScheduleVersion?: number | null;
      oldScheduleVersion?: number | null;
  }
  interface RecurringSessionSplit$2 {
      scheduleId?: string;
      recurringSessions?: Session$2[];
      newScheduleVersion?: number | null;
      oldScheduleVersion?: number | null;
  }
  /** Schedule unassigned from user. */
  interface ScheduleUnassignedFromUser$2 {
      /** The Wix user id. */
      userId?: string | null;
      /** The schedule that was unassigned from the user. */
      schedule?: Schedule$3;
  }
  interface MultipleSessionsCreated$2 {
      schedulesWithSessions?: ScheduleWithSessions$2[];
  }
  interface ScheduleWithSessions$2 {
      schedule?: Schedule$3;
      siteProperties?: SitePropertiesOnScheduleCreation$2;
      sessions?: Session$2[];
  }
  interface SitePropertiesOnScheduleCreation$2 {
      /** The global time zone value. */
      timeZone?: string | null;
  }
  interface MigrationEvent$2 {
      migrationData?: MigrationData$2;
  }
  interface MigrationData$2 {
      businessId?: string | null;
      staffs?: StaffData$2[];
  }
  interface StaffData$2 {
      resourceId?: string;
      syncRequestEmail?: string;
      refreshToken?: string;
  }
  interface DomainEvent$9 extends DomainEventBodyOneOf$9 {
      createdEvent?: EntityCreatedEvent$9;
      updatedEvent?: EntityUpdatedEvent$9;
      deletedEvent?: EntityDeletedEvent$9;
      actionEvent?: ActionEvent$9;
      /**
       * Unique event ID.
       * Allows clients to ignore duplicate webhooks.
       */
      _id?: string;
      /**
       * Assumes actions are also always typed to an entity_type
       * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
       */
      entityFqdn?: string;
      /**
       * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
       * This is although the created/updated/deleted notion is duplication of the oneof types
       * Example: created/updated/deleted/started/completed/email_opened
       */
      slug?: string;
      /** ID of the entity associated with the event. */
      entityId?: string;
      /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
      eventTime?: Date | null;
      /**
       * Whether the event was triggered as a result of a privacy regulation application
       * (for example, GDPR).
       */
      triggeredByAnonymizeRequest?: boolean | null;
      /** If present, indicates the action that triggered the event. */
      originatedFrom?: string | null;
      /**
       * A sequence number defining the order of updates to the underlying entity.
       * For example, given that some entity was updated at 16:00 and than again at 16:01,
       * it is guaranteed that the sequence number of the second update is strictly higher than the first.
       * As the consumer, you can use this value to ensure that you handle messages in the correct order.
       * To do so, you will need to persist this number on your end, and compare the sequence number from the
       * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
       */
      entityEventSequence?: string | null;
  }
  /** @oneof */
  interface DomainEventBodyOneOf$9 {
      createdEvent?: EntityCreatedEvent$9;
      updatedEvent?: EntityUpdatedEvent$9;
      deletedEvent?: EntityDeletedEvent$9;
      actionEvent?: ActionEvent$9;
  }
  interface EntityCreatedEvent$9 {
      entityAsJson?: string;
      /**
       * Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity
       * @internal
       */
      triggeredByUndelete?: boolean | null;
      /** Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity */
      restoreInfo?: RestoreInfo$9;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface RestoreInfo$9 {
      deletedDate?: Date | null;
  }
  interface EntityUpdatedEvent$9 {
      /**
       * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
       * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
       * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
       */
      currentEntityAsJson?: string;
      /**
       * This field is currently part of the of the EntityUpdatedEvent msg, but scala/node libraries which implements the domain events standard
       * wont populate it / have any reference to it in the API.
       * The main reason for it is that fetching the old entity from the DB will have a performance hit on an update operation so unless truly needed,
       * the developer should send only the new (current) entity.
       * An additional reason is not wanting to send this additional entity over the wire (kafka) since in some cases it can be really big
       * Developers that must reflect the old entity will have to implement their own domain event sender mechanism which will follow the DomainEvent proto message.
       * @internal
       * @deprecated
       */
      previousEntityAsJson?: string | null;
      /**
       * WIP - This property will hold both names and values of the updated fields of the entity.
       * For more details please see [adr](https://docs.google.com/document/d/1PdqsOM20Ph2HAkmx8zvUnzzk3Sekp3BR9h34wSvsRnI/edit#heading=h.phlw87mh2imx) or [issue](https://github.com/wix-private/nile-tracker/issues/363)
       * @internal
       */
      modifiedFields?: Record<string, any>;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface EntityDeletedEvent$9 {
      /**
       * Indicates if the entity is sent to trash-bin. only available when trash-bin is enabled
       * @internal
       */
      movedToTrash?: boolean | null;
      /** Entity that was deleted */
      deletedEntityAsJson?: string | null;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface ActionEvent$9 {
      bodyAsJson?: string;
  }
  /** Encapsulates all details written to the Greyhound topic when a site's properties are updated. */
  interface SitePropertiesNotification$2 {
      /** The site ID for which this update notification applies. */
      metasiteId?: string;
      /** The actual update event. */
      event?: SitePropertiesEvent$2;
      /** A convenience set of mappings from the MetaSite ID to its constituent services. */
      translations?: Translation$2[];
      /** Context of the notification */
      changeContext?: ChangeContext$2;
  }
  /** The actual update event for a particular notification. */
  interface SitePropertiesEvent$2 {
      /** Version of the site's properties represented by this update. */
      version?: number;
      /**
       * Set of properties that were updated - corresponds to the fields in "properties".
       * @internal
       */
      fields?: string[];
      /** Updated properties. */
      properties?: Properties$2;
  }
  interface Properties$2 {
      /** Site categories. */
      categories?: Categories$2;
      /** Site locale. */
      locale?: Locale$2;
      /**
       * Site language.
       *
       * Two-letter language code in [ISO 639-1 alpha-2](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format.
       */
      language?: string | null;
      /**
       * Site currency format used to bill customers.
       *
       * Three-letter currency code in [ISO-4217 alphabetic](https://en.wikipedia.org/wiki/ISO_4217#Active_codes) format.
       */
      paymentCurrency?: string | null;
      /** Timezone in `America/New_York` format. */
      timeZone?: string | null;
      /** Email address. */
      email?: string | null;
      /** Phone number. */
      phone?: string | null;
      /** Fax number. */
      fax?: string | null;
      /** Address. */
      address?: V4Address$1;
      /** Site display name. */
      siteDisplayName?: string | null;
      /** Business name. */
      businessName?: string | null;
      /** Path to the site's logo in Wix Media (without Wix Media base URL). */
      logo?: string | null;
      /** Site description. */
      description?: string | null;
      /**
       * Business schedule. Regular and exceptional time periods when the business is open or the service is available.
       *
       * __Note:__ Not supported by Wix Bookings.
       */
      businessSchedule?: BusinessSchedule$3;
      /** Supported languages of a site and the primary language. */
      multilingual?: Multilingual$2;
      /** Cookie policy the site owner defined for their site (before the users interacts with/limits it). */
      consentPolicy?: ConsentPolicy$2;
      /**
       * Supported values: `FITNESS SERVICE`, `RESTAURANT`, `BLOG`, `STORE`, `EVENT`, `UNKNOWN`.
       *
       * Site business type.
       */
      businessConfig?: string | null;
      /** External site url that uses Wix as its headless business solution */
      externalSiteUrl?: string | null;
      /** Track clicks analytics */
      trackClicksAnalytics?: boolean;
  }
  interface Categories$2 {
      /** Primary site category. */
      primary?: string;
      /** Secondary site category. */
      secondary?: string[];
      /** Business Term Id */
      businessTermId?: string | null;
  }
  interface Locale$2 {
      /** Two-letter language code in [ISO 639-1 alpha-2](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format. */
      languageCode?: string;
      /** Two-letter country code in [ISO-3166 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2#Officially_assigned_code_elements) format. */
      country?: string;
  }
  interface V4Address$1 {
      /** Street name. */
      street?: string;
      /** City name. */
      city?: string;
      /** Two-letter country code in an [ISO-3166 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format. */
      country?: string;
      /** State. */
      state?: string;
      /** Zip or postal code. */
      zip?: string;
      /** Extra information to be displayed in the address. */
      hint?: AddressHint$2;
      /** Whether this address represents a physical location. */
      isPhysical?: boolean;
      /** Google-formatted version of this address. */
      googleFormattedAddress?: string;
      /** Street number. */
      streetNumber?: string;
      /** Apartment number. */
      apartmentNumber?: string;
      /** Geographic coordinates of location. */
      coordinates?: GeoCoordinates$2;
  }
  /**
   * Extra information on displayed addresses.
   * This is used for display purposes. Used to add additional data about the address, such as "In the passage".
   * Free text. In addition the user can state where he wants that additional description - before, after, or instead
   * the address string.
   */
  interface AddressHint$2 {
      /** Extra text displayed next to, or instead of, the actual address. */
      text?: string;
      /** Where the extra text should be displayed. */
      placement?: PlacementType$2;
  }
  /** Where the extra text should be displayed: before, after or instead of the actual address. */
  enum PlacementType$2 {
      BEFORE = "BEFORE",
      AFTER = "AFTER",
      REPLACE = "REPLACE"
  }
  /** Geocoordinates for a particular address. */
  interface GeoCoordinates$2 {
      /** Latitude of the location. Must be between -90 and 90. */
      latitude?: number;
      /** Longitude of the location. Must be between -180 and 180. */
      longitude?: number;
  }
  interface Multilingual$2 {
      /** Supported languages list. */
      supportedLanguages?: SupportedLanguage$2[];
      /** Whether to redirect to user language. */
      autoRedirect?: boolean;
  }
  interface SupportedLanguage$2 {
      /** Two-letter language code in [ISO 639-1 alpha-2](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format. */
      languageCode?: string;
      /** Locale. */
      locale?: Locale$2;
      /** Whether the supported language is the primary language for the site. */
      isPrimary?: boolean;
      /** Language icon. */
      countryCode?: string;
      /** How the language will be resolved. For internal use. */
      resolutionMethod?: ResolutionMethod$2;
  }
  enum ResolutionMethod$2 {
      QUERY_PARAM = "QUERY_PARAM",
      SUBDOMAIN = "SUBDOMAIN",
      SUBDIRECTORY = "SUBDIRECTORY"
  }
  interface ConsentPolicy$2 {
      /** Whether the site uses cookies that are essential to site operation. */
      essential?: boolean | null;
      /** Whether the site uses cookies that affect site performance and other functional measurements. */
      functional?: boolean | null;
      /** Whether the site uses cookies that collect analytics about how the site is used (in order to improve it). */
      analytics?: boolean | null;
      /** Whether the site uses cookies that collect information allowing better customization of the experience for a current visitor. */
      advertising?: boolean | null;
      /** CCPA compliance flag. */
      dataToThirdParty?: boolean | null;
  }
  /** A single mapping from the MetaSite ID to a particular service. */
  interface Translation$2 {
      /** The service type. */
      serviceType?: string;
      /** The application definition ID; this only applies to services of type ThirdPartyApps. */
      appDefId?: string;
      /** The instance ID of the service. */
      instanceId?: string;
  }
  interface ChangeContext$2 extends ChangeContextPayloadOneOf$2 {
      /** Properties were updated. */
      propertiesChange?: PropertiesChange$2;
      /** Default properties were created on site creation. */
      siteCreated?: SiteCreated$4;
      /** Properties were cloned on site cloning. */
      siteCloned?: SiteCloned$2;
  }
  /** @oneof */
  interface ChangeContextPayloadOneOf$2 {
      /** Properties were updated. */
      propertiesChange?: PropertiesChange$2;
      /** Default properties were created on site creation. */
      siteCreated?: SiteCreated$4;
      /** Properties were cloned on site cloning. */
      siteCloned?: SiteCloned$2;
  }
  interface PropertiesChange$2 {
  }
  interface SiteCreated$4 {
      /** Origin template site id. */
      originTemplateId?: string | null;
  }
  interface SiteCloned$2 {
      /** Origin site id. */
      originMetaSiteId?: string;
  }
  interface MessageEnvelope$8 {
      /** App instance ID. */
      instanceId?: string | null;
      /** Event type. */
      eventType?: string;
      /** The identification type and identity data. */
      identity?: IdentificationData$a;
      /** Stringify payload. */
      data?: string;
  }
  interface IdentificationData$a extends IdentificationDataIdOneOf$a {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
      /** @readonly */
      identityType?: WebhookIdentityType$8;
  }
  /** @oneof */
  interface IdentificationDataIdOneOf$a {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
  }
  enum WebhookIdentityType$8 {
      UNKNOWN = "UNKNOWN",
      ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
      MEMBER = "MEMBER",
      WIX_USER = "WIX_USER",
      APP = "APP"
  }
  /**
   * Creates options and variants for a service.
   *
   * Before creating the `serviceOptionsAndVariants` object you need to anticipate and manually define
   * all variants based on the defined options and their choices. You then pass
   * the `options` and `variants` arrays in the
   * request. Variants aren't automatically calculated from the defined options and choices.
   *
   * __Current Limitations:__
   *
   * + Only a single `serviceOptionsAndVariants` object is supported per service.
   *
   * + Only a single option is supported per `serviceOptionsAndVariants` object. This means that services are limited to a single option. Therefore, `variants`provides pricing details for either all choices of the single option (for `CUSTOM` options) or all staff members providing the service (for `STAFF_MEMBER` options).
   *
   * For a list of error messages, see [Create Service Options and Variants Errors](https://dev.wix.com/api/rest/wix-bookings/service-options-and-variants/error-messages#service-options-and-variants_error-messages_create-service-options-and-variants-errors).
   * @param serviceOptionsAndVariants - Service options and variants to create.
   * @public
   * @documentationMaturity preview
   * @requiredField serviceOptionsAndVariants
   * @requiredField serviceOptionsAndVariants.options
   * @requiredField serviceOptionsAndVariants.serviceId
   * @requiredField serviceOptionsAndVariants.variants
   * @permissionId BOOKINGS.SERVICE_OPTIONS_AND_VARIANTS_CREATE
   * @adminMethod
   * @returns Information about the created service options and variants.
   */
  function createServiceOptionsAndVariants(serviceOptionsAndVariants: ServiceOptionsAndVariants): Promise<ServiceOptionsAndVariants>;
  /**
   * Clones a `serviceOptionsAndVariants` object. This function can be called, for example, to duplicate a service.
   * The cloned service contains the original service options and variants.
   *
   * Each option
   * in the cloned service has a newly-generated ID that is copied to all choices of the variants in the
   * clone. The cloned service references the service provided in the request by `target_service_id`.
   * @param cloneFromId - ID of the `serviceOptionsAndVariants` object to clone.
   * @param targetServiceId - ID of the service that will be set for the cloned `serviceOptionsAndVariants`
   * @public
   * @documentationMaturity preview
   * @requiredField cloneFromId
   * @requiredField targetServiceId
   * @permissionId BOOKINGS.SERVICE_OPTIONS_AND_VARIANTS_CREATE
   * @adminMethod
   */
  function cloneServiceOptionsAndVariants(cloneFromId: string, targetServiceId: string): Promise<CloneServiceOptionsAndVariantsResponse>;
  /**
   * Retrieves a `serviceOptionsAndVariants` object by `service_options_and_variants_id`.
   * @param serviceOptionsAndVariantsId - ID of the `serviceOptionsAndVariants` object to retrieve.
   * @public
   * @documentationMaturity preview
   * @requiredField serviceOptionsAndVariantsId
   * @permissionId BOOKINGS.SERVICE_OPTIONS_AND_VARIANTS_READ
   * @returns Retrieved `serviceOptionsAndVariants` object.
   */
  function getServiceOptionsAndVariants(serviceOptionsAndVariantsId: string): Promise<ServiceOptionsAndVariants>;
  /**
   * Retrieves a service's options and variants by `service_id`.
   * @param serviceId - ID of the service to retrieve options and variants for.
   * @public
   * @documentationMaturity preview
   * @requiredField serviceId
   * @permissionId BOOKINGS.SERVICE_OPTIONS_AND_VARIANTS_READ
   */
  function getServiceOptionsAndVariantsByServiceId(serviceId: string): Promise<GetServiceOptionsAndVariantsByServiceIdResponse>;
  /**
   * Updates the specified fields of the `serviceOptionsAndVariants` object.
   *
   * Currently, only a single option is supported per `serviceOptionsAndVariants` object.
   *
   * If you want to update `variants`, you must pass the full list of supported variants.
   *
   * If you want to update `options`, you must pass the full list of supported options.
   * @param _id - ID of the `serviceOptionsAndVariants` object.
   * @public
   * @documentationMaturity preview
   * @requiredField _id
   * @requiredField serviceOptionsAndVariants
   * @requiredField serviceOptionsAndVariants.revision
   * @param serviceOptionsAndVariants - Service options and variants to update.
   * @param options - Options for updating the service options and variants.
   * @permissionId BOOKINGS.SERVICE_OPTIONS_AND_VARIANTS_UPDATE
   * @adminMethod
   * @returns Updated `serviceOptionsAndVariants` object.
   */
  function updateServiceOptionsAndVariants(_id: string | null, serviceOptionsAndVariants: UpdateServiceOptionsAndVariants, options?: UpdateServiceOptionsAndVariantsOptions): Promise<ServiceOptionsAndVariants>;
  interface UpdateServiceOptionsAndVariants {
      /**
       * ID of the `serviceOptionsAndVariants` object.
       * @readonly
       */
      _id?: string | null;
      /** ID of the service related to these options and variants. */
      serviceId?: string | null;
      /** Service options. Note that currently only a single option is supported per service. */
      options?: ServiceOptions;
      /** Information about the service's variants. */
      variants?: ServiceVariants;
      /**
       * Price of the cheapest service variant.
       * @readonly
       */
      minPrice?: Money$3;
      /**
       * Price of the most expensive service variant.
       * @readonly
       */
      maxPrice?: Money$3;
      /**
       * Revision number, which increments by 1 each time the `serviceOptionsAndVariants` object is updated.
       * To prevent conflicting changes,
       * the current revision must be passed when updating and deleting the `serviceOptionsAndVariants` object.
       *
       * Ignored when creating a `serviceOptionsAndVariants` object.
       */
      revision?: string | null;
      /** Extensions enabling users to save custom data related to service options and variants. */
      extendedFields?: ExtendedFields$8;
  }
  interface UpdateServiceOptionsAndVariantsOptions {
      /**
       * Field mask containing information about the fields to update.
       * @internal
       */
      mask?: string[];
  }
  /**
   * Deletes a `serviceOptionsAndVariants` object.
   *
   *
   * Because each service has only a single `serviceOptionsAndVariants` object, the
   * service won't have any supported options and variants any longer. Instead,
   * the standard Wix Bookings service price calculation is used.
   * @param serviceOptionsAndVariantsId - ID of the `serviceOptionsAndVariants` object to delete.
   * @public
   * @documentationMaturity preview
   * @requiredField serviceOptionsAndVariantsId
   * @param options - Options for deleting the service options and variants.
   * @permissionId BOOKINGS.SERVICE_OPTIONS_AND_VARIANTS_DELETE
   * @adminMethod
   */
  function deleteServiceOptionsAndVariants(serviceOptionsAndVariantsId: string, options?: DeleteServiceOptionsAndVariantsOptions): Promise<void>;
  interface DeleteServiceOptionsAndVariantsOptions {
      /** Revision of the `serviceOptionsAndVariants` object to delete. */
      revision?: string;
  }
  /**
   * Retrieves a list of `serviceOptionsAndVariants`, given the provided paging, filtering, and sorting.
   *
   * queryServiceOptionsAndVariants() runs with these defaults, which you can override:
   *
   * - `id` is sorted in `ASC` order
   * - `cursorPaging.limit` is `100`
   *
   * For a detailed list of supported filtering operations see
   * [supported filters](https://www.wix.com/velo/reference/wix-bookings-v2/serviceoptionsandvariants/filters).
   * @public
   * @documentationMaturity preview
   * @permissionId BOOKINGS.SERVICE_OPTIONS_AND_VARIANTS_READ
   */
  function queryServiceOptionsAndVariants(): ServiceOptionsAndVariantsListQueryBuilder;
  interface QueryCursorResult$5 {
      cursors: Cursors$9;
      hasNext: () => boolean;
      hasPrev: () => boolean;
      length: number;
      pageSize: number;
  }
  interface ServiceOptionsAndVariantsListQueryResult extends QueryCursorResult$5 {
      items: ServiceOptionsAndVariants[];
      query: ServiceOptionsAndVariantsListQueryBuilder;
      next: () => Promise<ServiceOptionsAndVariantsListQueryResult>;
      prev: () => Promise<ServiceOptionsAndVariantsListQueryResult>;
  }
  interface ServiceOptionsAndVariantsListQueryBuilder {
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       * @documentationMaturity preview
       */
      eq: (propertyName: '_id' | 'serviceId', value: any) => ServiceOptionsAndVariantsListQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       * @documentationMaturity preview
       */
      ne: (propertyName: '_id' | 'serviceId', value: any) => ServiceOptionsAndVariantsListQueryBuilder;
      /** @param propertyName - Property whose value is compared with `values`.
       * @param values - List of values to compare against.
       * @documentationMaturity preview
       */
      hasSome: (propertyName: 'options.values.id' | 'options.values.type' | 'variants.values.choices.custom' | 'variants.values.choices.optionId' | 'variants.values.price.value' | 'variants.values.price.currency', value: any[]) => ServiceOptionsAndVariantsListQueryBuilder;
      /**
       * Refines a query to match items where the specified property is in a short list of specified values.
       * @documentationMaturity preview */
      in: (propertyName: '_id' | 'serviceId', value: any) => ServiceOptionsAndVariantsListQueryBuilder;
      /**
       * Refines a query to match items where the specified property is in a list of specified values, such as from another table.
       * @documentationMaturity preview */
      exists: (propertyName: 'options.values' | 'variants.values', value: boolean) => ServiceOptionsAndVariantsListQueryBuilder;
      /**
       * Adds a sort to a query, sorting by the specified properties in ascending order.
       *
       * The `ascending()` function refines a `CUSTOM_QUERY_BUILDER_NAME` to sort by the value of `propertyName` in ascending order. You can specify multiple properties for sorting in ascending order by passing each property name as an additional argument. `ascending()` sorts the results in the order the properties are passed. You can sort the following types:
       *
       * - Number: Sorts numerically.
       * - Date: Sorts by date and time.
       * - String: Sorts lexicographically, so `'abc'` comes after `'XYZ'`. If a property contains a number stored as a string (for example, `'0'`), that value is sorted alphabetically and not numerically. If a property doesn't have a value, that value is ranked lowest.
       * @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments.
       * @documentationMaturity preview
       */
      ascending: (...propertyNames: Array<'_id' | 'serviceId'>) => ServiceOptionsAndVariantsListQueryBuilder;
      /**
       * Adds a sort to a query, sorting by the specified properties in descending order.
       *
       * The `descending()` function refines a `CUSTOM_QUERY_BUILDER_NAME` to sort by the value of `propertyName` in descending order.
       *
       * You can specify multiple properties for sorting in descending order by passing each property name as an additional argument. `descending()` sorts the results in the order the properties are passed. You can sort the following types:
       *
       * - Number: Sorts numerically.
       * - Date: Sorts by date and time.
       * - String: Sorts lexicographically, so `'abc'` comes after `'XYZ'`. If a property contains a number stored as a string (for example, `'0'`), that value is sorted alphabetically and not numerically. If a property doesn't have a value, that value is ranked lowest.
       * @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments.
       * @documentationMaturity preview
       */
      descending: (...propertyNames: Array<'_id' | 'serviceId'>) => ServiceOptionsAndVariantsListQueryBuilder;
      /** @param limit - Number of items to return, which is also the `pageSize` of the results object.
       * @documentationMaturity preview
       */
      limit: (limit: number) => ServiceOptionsAndVariantsListQueryBuilder;
      /** @param cursor - A pointer to specific record
       * @documentationMaturity preview
       */
      skipTo: (cursor: string) => ServiceOptionsAndVariantsListQueryBuilder;
      /** @documentationMaturity preview */
      find: () => Promise<ServiceOptionsAndVariantsListQueryResult>;
  }
  
  type bookingsCatalogV1ServiceOptionsAndVariants_universal_d_ServiceOptionsAndVariants = ServiceOptionsAndVariants;
  type bookingsCatalogV1ServiceOptionsAndVariants_universal_d_ServiceOption = ServiceOption;
  type bookingsCatalogV1ServiceOptionsAndVariants_universal_d_ServiceOptionOptionSpecificDataOneOf = ServiceOptionOptionSpecificDataOneOf;
  type bookingsCatalogV1ServiceOptionsAndVariants_universal_d_ServiceOptionType = ServiceOptionType;
  const bookingsCatalogV1ServiceOptionsAndVariants_universal_d_ServiceOptionType: typeof ServiceOptionType;
  type bookingsCatalogV1ServiceOptionsAndVariants_universal_d_CustomServiceOption = CustomServiceOption;
  type bookingsCatalogV1ServiceOptionsAndVariants_universal_d_ServiceVariant = ServiceVariant;
  type bookingsCatalogV1ServiceOptionsAndVariants_universal_d_ServiceOptions = ServiceOptions;
  type bookingsCatalogV1ServiceOptionsAndVariants_universal_d_ServiceVariants = ServiceVariants;
  type bookingsCatalogV1ServiceOptionsAndVariants_universal_d_CreateServiceOptionsAndVariantsRequest = CreateServiceOptionsAndVariantsRequest;
  type bookingsCatalogV1ServiceOptionsAndVariants_universal_d_CreateServiceOptionsAndVariantsResponse = CreateServiceOptionsAndVariantsResponse;
  type bookingsCatalogV1ServiceOptionsAndVariants_universal_d_CloneServiceOptionsAndVariantsRequest = CloneServiceOptionsAndVariantsRequest;
  type bookingsCatalogV1ServiceOptionsAndVariants_universal_d_CloneServiceOptionsAndVariantsResponse = CloneServiceOptionsAndVariantsResponse;
  type bookingsCatalogV1ServiceOptionsAndVariants_universal_d_GetServiceOptionsAndVariantsRequest = GetServiceOptionsAndVariantsRequest;
  type bookingsCatalogV1ServiceOptionsAndVariants_universal_d_GetServiceOptionsAndVariantsResponse = GetServiceOptionsAndVariantsResponse;
  type bookingsCatalogV1ServiceOptionsAndVariants_universal_d_GetServiceOptionsAndVariantsByServiceIdRequest = GetServiceOptionsAndVariantsByServiceIdRequest;
  type bookingsCatalogV1ServiceOptionsAndVariants_universal_d_GetServiceOptionsAndVariantsByServiceIdResponse = GetServiceOptionsAndVariantsByServiceIdResponse;
  type bookingsCatalogV1ServiceOptionsAndVariants_universal_d_UpdateServiceOptionsAndVariantsRequest = UpdateServiceOptionsAndVariantsRequest;
  type bookingsCatalogV1ServiceOptionsAndVariants_universal_d_UpdateServiceOptionsAndVariantsResponse = UpdateServiceOptionsAndVariantsResponse;
  type bookingsCatalogV1ServiceOptionsAndVariants_universal_d_DeleteServiceOptionsAndVariantsRequest = DeleteServiceOptionsAndVariantsRequest;
  type bookingsCatalogV1ServiceOptionsAndVariants_universal_d_DeleteServiceOptionsAndVariantsResponse = DeleteServiceOptionsAndVariantsResponse;
  type bookingsCatalogV1ServiceOptionsAndVariants_universal_d_QueryServiceOptionsAndVariantsRequest = QueryServiceOptionsAndVariantsRequest;
  type bookingsCatalogV1ServiceOptionsAndVariants_universal_d_QueryServiceOptionsAndVariantsResponse = QueryServiceOptionsAndVariantsResponse;
  type bookingsCatalogV1ServiceOptionsAndVariants_universal_d_ServiceNotification = ServiceNotification;
  type bookingsCatalogV1ServiceOptionsAndVariants_universal_d_ServiceNotificationMetadataOneOf = ServiceNotificationMetadataOneOf;
  type bookingsCatalogV1ServiceOptionsAndVariants_universal_d_ServiceInfo = ServiceInfo;
  type bookingsCatalogV1ServiceOptionsAndVariants_universal_d_FutureBookingPolicy = FutureBookingPolicy;
  type bookingsCatalogV1ServiceOptionsAndVariants_universal_d_WaitingListPolicy = WaitingListPolicy;
  type bookingsCatalogV1ServiceOptionsAndVariants_universal_d_BookingsApprovalPolicy = BookingsApprovalPolicy;
  type bookingsCatalogV1ServiceOptionsAndVariants_universal_d_ServiceStatus = ServiceStatus;
  const bookingsCatalogV1ServiceOptionsAndVariants_universal_d_ServiceStatus: typeof ServiceStatus;
  type bookingsCatalogV1ServiceOptionsAndVariants_universal_d_ServiceNotificationEvent = ServiceNotificationEvent;
  const bookingsCatalogV1ServiceOptionsAndVariants_universal_d_ServiceNotificationEvent: typeof ServiceNotificationEvent;
  type bookingsCatalogV1ServiceOptionsAndVariants_universal_d_BusinessServicesPolicy = BusinessServicesPolicy;
  type bookingsCatalogV1ServiceOptionsAndVariants_universal_d_DeleteMetadata = DeleteMetadata;
  const bookingsCatalogV1ServiceOptionsAndVariants_universal_d_createServiceOptionsAndVariants: typeof createServiceOptionsAndVariants;
  const bookingsCatalogV1ServiceOptionsAndVariants_universal_d_cloneServiceOptionsAndVariants: typeof cloneServiceOptionsAndVariants;
  const bookingsCatalogV1ServiceOptionsAndVariants_universal_d_getServiceOptionsAndVariants: typeof getServiceOptionsAndVariants;
  const bookingsCatalogV1ServiceOptionsAndVariants_universal_d_getServiceOptionsAndVariantsByServiceId: typeof getServiceOptionsAndVariantsByServiceId;
  const bookingsCatalogV1ServiceOptionsAndVariants_universal_d_updateServiceOptionsAndVariants: typeof updateServiceOptionsAndVariants;
  type bookingsCatalogV1ServiceOptionsAndVariants_universal_d_UpdateServiceOptionsAndVariants = UpdateServiceOptionsAndVariants;
  type bookingsCatalogV1ServiceOptionsAndVariants_universal_d_UpdateServiceOptionsAndVariantsOptions = UpdateServiceOptionsAndVariantsOptions;
  const bookingsCatalogV1ServiceOptionsAndVariants_universal_d_deleteServiceOptionsAndVariants: typeof deleteServiceOptionsAndVariants;
  type bookingsCatalogV1ServiceOptionsAndVariants_universal_d_DeleteServiceOptionsAndVariantsOptions = DeleteServiceOptionsAndVariantsOptions;
  const bookingsCatalogV1ServiceOptionsAndVariants_universal_d_queryServiceOptionsAndVariants: typeof queryServiceOptionsAndVariants;
  type bookingsCatalogV1ServiceOptionsAndVariants_universal_d_ServiceOptionsAndVariantsListQueryResult = ServiceOptionsAndVariantsListQueryResult;
  type bookingsCatalogV1ServiceOptionsAndVariants_universal_d_ServiceOptionsAndVariantsListQueryBuilder = ServiceOptionsAndVariantsListQueryBuilder;
  namespace bookingsCatalogV1ServiceOptionsAndVariants_universal_d {
    export {
      bookingsCatalogV1ServiceOptionsAndVariants_universal_d_ServiceOptionsAndVariants as ServiceOptionsAndVariants,
      bookingsCatalogV1ServiceOptionsAndVariants_universal_d_ServiceOption as ServiceOption,
      bookingsCatalogV1ServiceOptionsAndVariants_universal_d_ServiceOptionOptionSpecificDataOneOf as ServiceOptionOptionSpecificDataOneOf,
      bookingsCatalogV1ServiceOptionsAndVariants_universal_d_ServiceOptionType as ServiceOptionType,
      bookingsCatalogV1ServiceOptionsAndVariants_universal_d_CustomServiceOption as CustomServiceOption,
      bookingsCatalogV1ServiceOptionsAndVariants_universal_d_ServiceVariant as ServiceVariant,
      ServiceChoice$3 as ServiceChoice,
      ServiceChoiceChoiceOneOf$3 as ServiceChoiceChoiceOneOf,
      Money$3 as Money,
      bookingsCatalogV1ServiceOptionsAndVariants_universal_d_ServiceOptions as ServiceOptions,
      bookingsCatalogV1ServiceOptionsAndVariants_universal_d_ServiceVariants as ServiceVariants,
      ExtendedFields$8 as ExtendedFields,
      bookingsCatalogV1ServiceOptionsAndVariants_universal_d_CreateServiceOptionsAndVariantsRequest as CreateServiceOptionsAndVariantsRequest,
      bookingsCatalogV1ServiceOptionsAndVariants_universal_d_CreateServiceOptionsAndVariantsResponse as CreateServiceOptionsAndVariantsResponse,
      bookingsCatalogV1ServiceOptionsAndVariants_universal_d_CloneServiceOptionsAndVariantsRequest as CloneServiceOptionsAndVariantsRequest,
      bookingsCatalogV1ServiceOptionsAndVariants_universal_d_CloneServiceOptionsAndVariantsResponse as CloneServiceOptionsAndVariantsResponse,
      bookingsCatalogV1ServiceOptionsAndVariants_universal_d_GetServiceOptionsAndVariantsRequest as GetServiceOptionsAndVariantsRequest,
      bookingsCatalogV1ServiceOptionsAndVariants_universal_d_GetServiceOptionsAndVariantsResponse as GetServiceOptionsAndVariantsResponse,
      bookingsCatalogV1ServiceOptionsAndVariants_universal_d_GetServiceOptionsAndVariantsByServiceIdRequest as GetServiceOptionsAndVariantsByServiceIdRequest,
      bookingsCatalogV1ServiceOptionsAndVariants_universal_d_GetServiceOptionsAndVariantsByServiceIdResponse as GetServiceOptionsAndVariantsByServiceIdResponse,
      bookingsCatalogV1ServiceOptionsAndVariants_universal_d_UpdateServiceOptionsAndVariantsRequest as UpdateServiceOptionsAndVariantsRequest,
      bookingsCatalogV1ServiceOptionsAndVariants_universal_d_UpdateServiceOptionsAndVariantsResponse as UpdateServiceOptionsAndVariantsResponse,
      bookingsCatalogV1ServiceOptionsAndVariants_universal_d_DeleteServiceOptionsAndVariantsRequest as DeleteServiceOptionsAndVariantsRequest,
      bookingsCatalogV1ServiceOptionsAndVariants_universal_d_DeleteServiceOptionsAndVariantsResponse as DeleteServiceOptionsAndVariantsResponse,
      bookingsCatalogV1ServiceOptionsAndVariants_universal_d_QueryServiceOptionsAndVariantsRequest as QueryServiceOptionsAndVariantsRequest,
      QueryV2$4 as QueryV2,
      QueryV2PagingMethodOneOf$4 as QueryV2PagingMethodOneOf,
      Sorting$8 as Sorting,
      SortOrder$8 as SortOrder,
      Paging$4 as Paging,
      CursorPaging$8 as CursorPaging,
      bookingsCatalogV1ServiceOptionsAndVariants_universal_d_QueryServiceOptionsAndVariantsResponse as QueryServiceOptionsAndVariantsResponse,
      PagingMetadataV2$3 as PagingMetadataV2,
      Cursors$9 as Cursors,
      ResourceNotification$1 as ResourceNotification,
      Resource$3 as Resource,
      Schedule$3 as Schedule,
      RecurringInterval$2 as RecurringInterval,
      Interval$3 as Interval,
      Day$2 as Day,
      Frequency$2 as Frequency,
      LinkedSchedule$2 as LinkedSchedule,
      Transparency$2 as Transparency,
      RecurringIntervalType$2 as RecurringIntervalType,
      Location$5 as Location,
      LocationType$5 as LocationType,
      Address$6 as Address,
      AddressStreetOneOf$5 as AddressStreetOneOf,
      StreetAddress$5 as StreetAddress,
      AddressLocation$5 as AddressLocation,
      Subdivision$5 as Subdivision,
      LocationsLocation$2 as LocationsLocation,
      LocationStatus$2 as LocationStatus,
      LocationsLocationType$2 as LocationsLocationType,
      LocationsAddress$2 as LocationsAddress,
      LocationsStreetAddress$2 as LocationsStreetAddress,
      LocationsAddressLocation$2 as LocationsAddressLocation,
      BusinessSchedule$3 as BusinessSchedule,
      TimePeriod$3 as TimePeriod,
      DayOfWeek$3 as DayOfWeek,
      SpecialHourPeriod$3 as SpecialHourPeriod,
      Rate$2 as Rate,
      Price$3 as Price,
      Availability$2 as Availability,
      AvailabilityConstraints$2 as AvailabilityConstraints,
      SplitInterval$2 as SplitInterval,
      Participant$2 as Participant,
      ApprovalStatus$2 as ApprovalStatus,
      ExternalCalendarOverrides$2 as ExternalCalendarOverrides,
      ScheduleStatus$2 as ScheduleStatus,
      Version$2 as Version,
      ConferenceProvider$2 as ConferenceProvider,
      CalendarConference$2 as CalendarConference,
      ConferenceType$2 as ConferenceType,
      ResourceStatus$1 as ResourceStatus,
      BusinessLocation$3 as BusinessLocation,
      Event$1 as Event,
      Empty$5 as Empty,
      bookingsCatalogV1ServiceOptionsAndVariants_universal_d_ServiceNotification as ServiceNotification,
      bookingsCatalogV1ServiceOptionsAndVariants_universal_d_ServiceNotificationMetadataOneOf as ServiceNotificationMetadataOneOf,
      Service$1 as Service,
      bookingsCatalogV1ServiceOptionsAndVariants_universal_d_ServiceInfo as ServiceInfo,
      Media$1 as Media,
      MediaItem$2 as MediaItem,
      MediaItemItemOneOf$1 as MediaItemItemOneOf,
      BookingPolicy$3 as BookingPolicy,
      bookingsCatalogV1ServiceOptionsAndVariants_universal_d_FutureBookingPolicy as FutureBookingPolicy,
      bookingsCatalogV1ServiceOptionsAndVariants_universal_d_WaitingListPolicy as WaitingListPolicy,
      bookingsCatalogV1ServiceOptionsAndVariants_universal_d_BookingsApprovalPolicy as BookingsApprovalPolicy,
      PaymentOptions$1 as PaymentOptions,
      bookingsCatalogV1ServiceOptionsAndVariants_universal_d_ServiceStatus as ServiceStatus,
      SeoSchema$1 as SeoSchema,
      Keyword$1 as Keyword,
      Tag$1 as Tag,
      Settings$1 as Settings,
      bookingsCatalogV1ServiceOptionsAndVariants_universal_d_ServiceNotificationEvent as ServiceNotificationEvent,
      bookingsCatalogV1ServiceOptionsAndVariants_universal_d_BusinessServicesPolicy as BusinessServicesPolicy,
      bookingsCatalogV1ServiceOptionsAndVariants_universal_d_DeleteMetadata as DeleteMetadata,
      ParticipantNotification$6 as ParticipantNotification,
      ScheduleNotification$2 as ScheduleNotification,
      ScheduleNotificationEventOneOf$2 as ScheduleNotificationEventOneOf,
      ScheduleCreated$2 as ScheduleCreated,
      ScheduleUpdated$2 as ScheduleUpdated,
      RecurringSessionsUpdated$2 as RecurringSessionsUpdated,
      Session$2 as Session,
      CalendarDateTime$2 as CalendarDateTime,
      LocalDateTime$2 as LocalDateTime,
      ExternalCalendarInfo$2 as ExternalCalendarInfo,
      CalendarType$2 as CalendarType,
      Status$2 as Status,
      SessionType$2 as SessionType,
      SessionVersion$2 as SessionVersion,
      ScheduleCancelled$2 as ScheduleCancelled,
      SessionCreated$2 as SessionCreated,
      SessionUpdated$2 as SessionUpdated,
      SessionCancelled$2 as SessionCancelled,
      AvailabilityPolicyUpdated$2 as AvailabilityPolicyUpdated,
      AvailabilityPolicy$2 as AvailabilityPolicy,
      IntervalSplit$2 as IntervalSplit,
      RecurringSessionSplit$2 as RecurringSessionSplit,
      ScheduleUnassignedFromUser$2 as ScheduleUnassignedFromUser,
      MultipleSessionsCreated$2 as MultipleSessionsCreated,
      ScheduleWithSessions$2 as ScheduleWithSessions,
      SitePropertiesOnScheduleCreation$2 as SitePropertiesOnScheduleCreation,
      MigrationEvent$2 as MigrationEvent,
      MigrationData$2 as MigrationData,
      StaffData$2 as StaffData,
      DomainEvent$9 as DomainEvent,
      DomainEventBodyOneOf$9 as DomainEventBodyOneOf,
      EntityCreatedEvent$9 as EntityCreatedEvent,
      RestoreInfo$9 as RestoreInfo,
      EntityUpdatedEvent$9 as EntityUpdatedEvent,
      EntityDeletedEvent$9 as EntityDeletedEvent,
      ActionEvent$9 as ActionEvent,
      SitePropertiesNotification$2 as SitePropertiesNotification,
      SitePropertiesEvent$2 as SitePropertiesEvent,
      Properties$2 as Properties,
      Categories$2 as Categories,
      Locale$2 as Locale,
      V4Address$1 as V4Address,
      AddressHint$2 as AddressHint,
      PlacementType$2 as PlacementType,
      GeoCoordinates$2 as GeoCoordinates,
      Multilingual$2 as Multilingual,
      SupportedLanguage$2 as SupportedLanguage,
      ResolutionMethod$2 as ResolutionMethod,
      ConsentPolicy$2 as ConsentPolicy,
      Translation$2 as Translation,
      ChangeContext$2 as ChangeContext,
      ChangeContextPayloadOneOf$2 as ChangeContextPayloadOneOf,
      PropertiesChange$2 as PropertiesChange,
      SiteCreated$4 as SiteCreated,
      SiteCloned$2 as SiteCloned,
      MessageEnvelope$8 as MessageEnvelope,
      IdentificationData$a as IdentificationData,
      IdentificationDataIdOneOf$a as IdentificationDataIdOneOf,
      WebhookIdentityType$8 as WebhookIdentityType,
      bookingsCatalogV1ServiceOptionsAndVariants_universal_d_createServiceOptionsAndVariants as createServiceOptionsAndVariants,
      bookingsCatalogV1ServiceOptionsAndVariants_universal_d_cloneServiceOptionsAndVariants as cloneServiceOptionsAndVariants,
      bookingsCatalogV1ServiceOptionsAndVariants_universal_d_getServiceOptionsAndVariants as getServiceOptionsAndVariants,
      bookingsCatalogV1ServiceOptionsAndVariants_universal_d_getServiceOptionsAndVariantsByServiceId as getServiceOptionsAndVariantsByServiceId,
      bookingsCatalogV1ServiceOptionsAndVariants_universal_d_updateServiceOptionsAndVariants as updateServiceOptionsAndVariants,
      bookingsCatalogV1ServiceOptionsAndVariants_universal_d_UpdateServiceOptionsAndVariants as UpdateServiceOptionsAndVariants,
      bookingsCatalogV1ServiceOptionsAndVariants_universal_d_UpdateServiceOptionsAndVariantsOptions as UpdateServiceOptionsAndVariantsOptions,
      bookingsCatalogV1ServiceOptionsAndVariants_universal_d_deleteServiceOptionsAndVariants as deleteServiceOptionsAndVariants,
      bookingsCatalogV1ServiceOptionsAndVariants_universal_d_DeleteServiceOptionsAndVariantsOptions as DeleteServiceOptionsAndVariantsOptions,
      bookingsCatalogV1ServiceOptionsAndVariants_universal_d_queryServiceOptionsAndVariants as queryServiceOptionsAndVariants,
      bookingsCatalogV1ServiceOptionsAndVariants_universal_d_ServiceOptionsAndVariantsListQueryResult as ServiceOptionsAndVariantsListQueryResult,
      bookingsCatalogV1ServiceOptionsAndVariants_universal_d_ServiceOptionsAndVariantsListQueryBuilder as ServiceOptionsAndVariantsListQueryBuilder,
    };
  }
  
  interface BookingFee {
      /**
       * Booking fee ID.
       * @readonly
       */
      _id?: string | null;
      /** ID of the booking associated with the fee. */
      bookingId?: string | null;
      /** Cancellation fee details. */
      cancellationFee?: CancellationFee;
      /**
       * Information about the [booking policy snapshot](https://dev.wix.com/docs/sdk/backend-modules/bookings/booking-policy-snapshots/introduction)
       * according to which the fee was created.
       */
      policyDetails?: PolicyDetails;
  }
  interface CancellationFee {
      /** Price the customer must pay. */
      price?: Money$2;
      /**
       * Status of the booking fee.
       *
       * + `UNKNOWN_STATUS`: There is no eCommerce order associated with the booking.
       * + `PREVIEW`: The fee is informational only; the customer doesn't have to pay it. For example, it shows how much the customer would owe if they canceled the booking now.
       * + `NOT_YET_APPLIED_TO_ORDER`: The booking fee hasn't been added to the eCommerce order yet.
       * + `APPLIED_TO_ORDER`: The booking fee has been added to the eCommerce order. The customer may not have paid it yet.
       */
      status?: BookingFeeStatus$1;
      /**
       * Information about what triggered the creation of the booking fee.
       *
       * + `UNKNOWN_STATUS`: There is no information about what triggered the creation of the booking fee.
       * + `NOT_ATTENDED`: The booking fee was created because the customer didn't show up to the booking or canceled after the expiration of the last cancellation window.
       * + `BOOKING_CANCELED`: The booking fee was created because the customer canceled the booking before the expiration of the last cancellation window.
       * @readonly
       */
      trigger?: Trigger;
  }
  /**
   * Money.
   * Default format to use. Sufficiently compliant with majority of standards: w3c, ISO 4217, ISO 20022, ISO 8583:2003.
   */
  interface Money$2 {
      /** Monetary amount. Decimal string with a period as a decimal separator (e.g., 3.99). Optionally, a single (-), to indicate that the amount is negative. */
      value?: string;
      /** Currency code. Must be valid ISO 4217 currency code (e.g., USD). */
      currency?: string;
      /**
       * Monetary amount. Decimal string in local format (e.g., 1 000,30). Optionally, a single (-), to indicate that the amount is negative.
       * @readonly
       */
      formattedValue?: string | null;
  }
  enum BookingFeeStatus$1 {
      UNKNOWN_STATUS = "UNKNOWN_STATUS",
      PREVIEW = "PREVIEW",
      NOT_YET_APPLIED_TO_ORDER = "NOT_YET_APPLIED_TO_ORDER",
      APPLIED_TO_ORDER = "APPLIED_TO_ORDER"
  }
  /** the domain event trigger the booking fee calculation */
  enum Trigger {
      UNKNOWN_TRIGGER = "UNKNOWN_TRIGGER",
      NOT_ATTENDED = "NOT_ATTENDED",
      BOOKING_CANCELED = "BOOKING_CANCELED"
  }
  interface PolicyDetails {
      /**
       * ID of the booking policy.
       * @readonly
       */
      _id?: string | null;
      /** Description of the booking policy. */
      description?: string | null;
  }
  interface FailedToApplyBookingFeeToOrder {
      /** Booking fee which couldn't to be applied to the eCommerce order. */
      bookingFee?: BookingFee;
      /**
       * IDs of the booking fees that are related to the booking fee which couldn't be
       * applied to the eCommerce order.
       */
      relatedBookingFeeIds?: string[];
      /** Information about the affected eCommerce order. */
      ecomOrderInfo?: EcomOrderInfo;
      /**
       * Information about whether to notify the business about failing to apply the
       * booking fees to the eCommerce order and the message to send.
       */
      businessNotification?: BusinessNotification;
      /**
       * Failure date and time.
       * @internal
       */
      failureDate?: Date | null;
  }
  interface EcomOrderInfo {
      /** Order ID. */
      orderId?: string | null;
      /** Additional fee price. */
      additionalFeePrice?: Price$2;
      /** The eCommerce additional fee id that was created on the order. */
      additionalFeeId?: string | null;
  }
  interface Price$2 {
      /** Amount. */
      amount?: string;
      /**
       * Amount formatted with currency symbol.
       * @readonly
       */
      formattedAmount?: string;
  }
  interface BusinessNotification {
      /**
       * Whether to notify the business about changes made to the booking fees.
       * Default is false.
       */
      notifyBusiness?: boolean | null;
      /** Optional custom message to send. */
      message?: string | null;
  }
  interface FailedToCollectAppliedBookingFees {
      /**
       * IDs of the bookings for which the booking fees couldn't be collected from the
       * customer.
       */
      bookingIds?: string[];
      /** Information about the affected eCommerce order. */
      ecomOrderInfo?: EcomOrderInfo;
      /**
       * Information about whether to notify the business about failing to collect the
       * booking fees from the customer and the message to send.
       */
      businessNotification?: BusinessNotification;
      /**
       * Failure date and time.
       * @internal
       */
      failureDate?: Date | null;
  }
  interface ListBookingFeesByBookingIdsRequest {
      /** IDs of the bookings to retrieve booking fees for. */
      bookingIds?: string[];
      /** IDs of the multi service bookings to retrieve booking fees for. */
      multiServiceBookingIds?: string[];
  }
  interface ListBookingFeesByBookingIdsResponse {
      /** List of retrieved booking fees. */
      bookingFees?: BookingFee[];
      /** Paging metadata. */
      pagingMetadata?: CursorPagingMetadata$6;
  }
  interface CursorPagingMetadata$6 {
      /** Number of items returned in the response. */
      count?: number | null;
      /** Cursor strings that point to the next page, previous page, or both. */
      cursors?: Cursors$8;
      /**
       * Whether there are more pages to retrieve following the current page.
       *
       * + `true`: Another page of results can be retrieved.
       * + `false`: This is the last page.
       */
      hasNext?: boolean | null;
  }
  interface Cursors$8 {
      /** Cursor string pointing to the next page in the list of results. */
      next?: string | null;
      /** Cursor pointing to the previous page in the list of results. */
      prev?: string | null;
  }
  interface ApplyBookingFeesToOrderRequest {
      /** IDs of the bookings for which to apply booking fees to an eCommerce order. */
      bookingIds: string[] | null;
      /**
       * Custome price override for the additional fee that's added to the eCommerce
       * order. The override mustn't exceed the sum of all booking fees. You must have
       * the `OVERRIDE_BOOKING_FEE_PRICE` permission to use this property.
       */
      priceOverride?: Money$2;
      /**
       * Information about the message to the business and whether to send it if the
       * booking fee application to the eCommerce order fails.
       */
      businessNotification?: BusinessNotification;
  }
  interface ApplyBookingFeesToOrderResponse {
      /**
       * Booking fees that were applied as a single additional fee to the eCommerce
       * order.
       */
      bookingFees?: BookingFee[];
      /** Information about the eCommerce order to which the booking fees are applied. */
      ecomOrderInfo?: EcomOrderInfo;
  }
  interface ListNonPreviewBookingFeesByBookingIdsRequest {
      /** IDs of the bookings to retrieve booking fees for. */
      bookingIds: string[];
  }
  interface ListNonPreviewBookingFeesByBookingIdsResponse {
      /** List of retrieved booking fees. */
      bookingFees?: BookingFee[];
  }
  interface CollectAppliedBookingFeesRequest {
      /**
       * ID of the eCommmerce order that includes the booking fees as a single
       * `additionalFee`.
       */
      orderId: string | null;
      /** ID of the additional fee that's related to all given booking fees. */
      additionalFeeId: string | null;
      /**
       * Information about whether to notify the business about failing to collect the
       * booking fees from the customer and the message to send.
       */
      businessNotification?: BusinessNotification;
  }
  interface CollectAppliedBookingFeesResponse {
      /** Collected amount. */
      collectedPrice?: Price$2;
  }
  interface DomainEvent$8 extends DomainEventBodyOneOf$8 {
      createdEvent?: EntityCreatedEvent$8;
      updatedEvent?: EntityUpdatedEvent$8;
      deletedEvent?: EntityDeletedEvent$8;
      actionEvent?: ActionEvent$8;
      /**
       * Unique event ID.
       * Allows clients to ignore duplicate webhooks.
       */
      _id?: string;
      /**
       * Assumes actions are also always typed to an entity_type
       * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
       */
      entityFqdn?: string;
      /**
       * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
       * This is although the created/updated/deleted notion is duplication of the oneof types
       * Example: created/updated/deleted/started/completed/email_opened
       */
      slug?: string;
      /** ID of the entity associated with the event. */
      entityId?: string;
      /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
      eventTime?: Date | null;
      /**
       * Whether the event was triggered as a result of a privacy regulation application
       * (for example, GDPR).
       */
      triggeredByAnonymizeRequest?: boolean | null;
      /** If present, indicates the action that triggered the event. */
      originatedFrom?: string | null;
      /**
       * A sequence number defining the order of updates to the underlying entity.
       * For example, given that some entity was updated at 16:00 and than again at 16:01,
       * it is guaranteed that the sequence number of the second update is strictly higher than the first.
       * As the consumer, you can use this value to ensure that you handle messages in the correct order.
       * To do so, you will need to persist this number on your end, and compare the sequence number from the
       * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
       */
      entityEventSequence?: string | null;
  }
  /** @oneof */
  interface DomainEventBodyOneOf$8 {
      createdEvent?: EntityCreatedEvent$8;
      updatedEvent?: EntityUpdatedEvent$8;
      deletedEvent?: EntityDeletedEvent$8;
      actionEvent?: ActionEvent$8;
  }
  interface EntityCreatedEvent$8 {
      entityAsJson?: string;
      /**
       * Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity
       * @internal
       */
      triggeredByUndelete?: boolean | null;
      /** Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity */
      restoreInfo?: RestoreInfo$8;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface RestoreInfo$8 {
      deletedDate?: Date | null;
  }
  interface EntityUpdatedEvent$8 {
      /**
       * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
       * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
       * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
       */
      currentEntityAsJson?: string;
      /**
       * This field is currently part of the of the EntityUpdatedEvent msg, but scala/node libraries which implements the domain events standard
       * wont populate it / have any reference to it in the API.
       * The main reason for it is that fetching the old entity from the DB will have a performance hit on an update operation so unless truly needed,
       * the developer should send only the new (current) entity.
       * An additional reason is not wanting to send this additional entity over the wire (kafka) since in some cases it can be really big
       * Developers that must reflect the old entity will have to implement their own domain event sender mechanism which will follow the DomainEvent proto message.
       * @internal
       * @deprecated
       */
      previousEntityAsJson?: string | null;
      /**
       * WIP - This property will hold both names and values of the updated fields of the entity.
       * For more details please see [adr](https://docs.google.com/document/d/1PdqsOM20Ph2HAkmx8zvUnzzk3Sekp3BR9h34wSvsRnI/edit#heading=h.phlw87mh2imx) or [issue](https://github.com/wix-private/nile-tracker/issues/363)
       * @internal
       */
      modifiedFields?: Record<string, any>;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface EntityDeletedEvent$8 {
      /**
       * Indicates if the entity is sent to trash-bin. only available when trash-bin is enabled
       * @internal
       */
      movedToTrash?: boolean | null;
      /** Entity that was deleted */
      deletedEntityAsJson?: string | null;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface ActionEvent$8 {
      bodyAsJson?: string;
  }
  interface MessageEnvelope$7 {
      /** App instance ID. */
      instanceId?: string | null;
      /** Event type. */
      eventType?: string;
      /** The identification type and identity data. */
      identity?: IdentificationData$9;
      /** Stringify payload. */
      data?: string;
  }
  interface IdentificationData$9 extends IdentificationDataIdOneOf$9 {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
      /** @readonly */
      identityType?: WebhookIdentityType$7;
  }
  /** @oneof */
  interface IdentificationDataIdOneOf$9 {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
  }
  enum WebhookIdentityType$7 {
      UNKNOWN = "UNKNOWN",
      ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
      MEMBER = "MEMBER",
      WIX_USER = "WIX_USER",
      APP = "APP"
  }
  /**
   * Retrieves booking fees by booking IDs and multi service booking IDs.
   *
   *
   * Instead of returning `bookingFee` objects with the `cancellationFee.price.value`
   * set to `0.00`, the endpoint doesn't return a `bookingFee` object for the relevant
   * booking IDs. For example, no `bookingFee` object is returned if the canceled
   * booking was free or if the booking was canceled before the start of the earliest
   * cancellation window.
   *
   * If the service's booking policy has been updated since the booking was created,
   * booking fees are calculated according to the
   * [policy snapshot](https://dev.wix.com/docs/sdk/backend-modules/bookings/booking-policy-snapshots/introduction)
   * rather than the current version of the policy.
   *
   * This endpoint calculates the cancellation fee amount based on the time of the
   * call, you can't specify a time. Similarly, it calculates the cancellation fee
   * based on the number of participants who canceled, not a provided number.
   *
   * A `cancellationFee.status` of `PREVIEW` indicates that the booking fee is
   * informational only; the customer isn't required to pay it. When the `status` is
   * set to `UNKNOWN_STATUS` there is no eCommerce order associated with the booking. For
   * example, if a custom checkout was used for the booking instead of the
   * [Wix eCommerce checkout](https://dev.wix.com/docs/sdk/backend-modules/ecom/checkout/setup).
   *
   * If multiple events would trigger the calculation of a booking fee, for example
   * when a booking is first canceled and then marked as not attended, Wix calculates
   * the booking fee based on the first trigger. In this example, the booking
   * cancellation.
   * @public
   * @documentationMaturity preview
   * @param options - Options to use when listing booking fees.
   * @permissionId BOOKINGS.BOOKING_FEES_READ
   */
  function listBookingFeesByBookingIds(options?: ListBookingFeesByBookingIdsOptions): Promise<ListBookingFeesByBookingIdsResponse>;
  interface ListBookingFeesByBookingIdsOptions {
      /** IDs of the bookings to retrieve booking fees for. */
      bookingIds?: string[];
      /** IDs of the multi service bookings to retrieve booking fees for. */
      multiServiceBookingIds?: string[];
  }
  /**
   * Applies booking fees to an
   * [eCommerce order](https://dev.wix.com/docs/sdk/backend-modules/ecom/orders/setup).
   *
   *
   * The booking fees are added as a single additional fee to the eCommerce order.
   * The order's `additionalFee.lineItemIds` array is set to the list of corresponding
   * booking IDs. By default, the `additionalFee.price.amount` is the sum of all
   * booking fee prices. But you may provide a `priceOverride` instead. The override
   * price can't be higher than the sum of all booking fees.
   *
   * Apply Booking Fees to Order also updates the prices of all affected line items
   * in the relevant eCommerce order to zero. After a cancellation fee is applied
   * to an eCommerce order, the cancellation fee's `price.value` is updated to `0.00`
   * and its trigger is set to `UNKNOWN_TRIGGER`. You can retrieve the fee amount
   * from the corresponding `additionalFee` object of the eCommerce order with
   * [getOrder()](https://dev.wix.com/docs/sdk/backend-modules/ecom/orders/get-order).
   *
   * If you apply multiple booking fees to an eCommerce order, they either all fail or
   * all succeed together. For example, the call fails if the booking fees are associated
   * with different eCommmerce orders.
   * @param bookingIds - IDs of the bookings for which to apply booking fees to an eCommerce order.
   * @public
   * @documentationMaturity preview
   * @requiredField bookingIds
   * @requiredField options.priceOverride.currency
   * @requiredField options.priceOverride.value
   * @param options - Options to use when applying booking fees to an eCommerce order.
   * @permissionId BOOKINGS.BOOKING_FEE_APPLY_TO_ORDER
   * @adminMethod
   */
  function applyBookingFeesToOrder(bookingIds: string[] | null, options?: ApplyBookingFeesToOrderOptions): Promise<ApplyBookingFeesToOrderResponse>;
  interface ApplyBookingFeesToOrderOptions {
      /**
       * Custome price override for the additional fee that's added to the eCommerce
       * order. The override mustn't exceed the sum of all booking fees. You must have
       * the `OVERRIDE_BOOKING_FEE_PRICE` permission to use this property.
       */
      priceOverride?: Money$2;
      /**
       * Information about the message to the business and whether to send it if the
       * booking fee application to the eCommerce order fails.
       */
      businessNotification?: BusinessNotification;
  }
  /**
   * Retrieves non-preview booking fees by booking IDs.
   *
   * Returns only booking fees with status `APPLIED_TO_ORDER` or `NOT_YET_APPLIED_TO_ORDER`.
   *
   * Use [listBookingFeesByBookingIds()](https://dev.wix.com/docs/sdk/backend-modules/bookings/booking-fees/list-booking-fees-by-booking-ids) to retrieve all booking fees.
   *
   * For performance reasons when retrieving only booking fees with status  `APPLIED_TO_ORDER` or `NOT_YET_APPLIED_TO_ORDER`, we recommend using this method over listBookingFeesByBookingIds().
   * @param bookingIds - IDs of the bookings to retrieve booking fees for.
   * @internal
   * @documentationMaturity preview
   * @requiredField bookingIds
   * @permissionId BOOKINGS.BOOKING_FEES_READ
   */
  function listNonPreviewBookingFeesByBookingIds(bookingIds: string[]): Promise<ListNonPreviewBookingFeesByBookingIdsResponse>;
  /**
   * Collects booking fees by charging the customer using the payment method that's
   * saved on the corresponding [eCommerce order](https://dev.wix.com/docs/sdk/backend-modules/ecom/orders/setup).
   *
   *
   * <blockquote class="warning">
   *
   * __Warning:__
   * Currently, there is no validation that prevents idempotent requests.
   * This means that your code must make sure to not charge customers multiple
   * times for the same booking fee. You could use [listTransactionsForSingleOrder()](https://dev.wix.com/docs/sdk/backend-modules/ecom/order-transactions/list-transactions-for-single-order) to check which charges were made previously for an eCommerce order.
   * </blockquote>
   *
   * An HTTP status of `200` means that all booking fees were successfully collected.
   * Any other HTPP status means that collection failed.
   *
   * Collects the order's `additionalFees.price.amount` that's related to the
   * booking fees. If there are multiple additional fees on the eCommerce order,
   * the amount that's collected differs from `priceSummary.totalAdditionalFees.amount`.
   *
   * Possible failure reason's include:
   * + The order's `status` isn't `APPROVED`.
   * + There is no payment method saved on the order.
   * + The order's `balanceSummary.balance.amount` is lower than the
   * `additionalFees.price.amount` to collect.
   * + The order's `additionalFeeId` doesn't belong to a Wix Bookings cancellation fee.
   * @param orderId - ID of the eCommmerce order that includes the booking fees as a single
   * `additionalFee`.
   * @public
   * @documentationMaturity preview
   * @requiredField options.additionalFeeId
   * @requiredField orderId
   * @param options - Options to use when collecting booking fees that have been applied to an eCommerce order.
   * @permissionId BOOKINGS.BOOKING_FEE_COLLECT
   * @adminMethod
   */
  function collectAppliedBookingFees(orderId: string | null, options?: CollectAppliedBookingFeesOptions): Promise<CollectAppliedBookingFeesResponse>;
  interface CollectAppliedBookingFeesOptions {
      /** ID of the additional fee that's related to all given booking fees. */
      additionalFeeId: string | null;
      /**
       * Information about whether to notify the business about failing to collect the
       * booking fees from the customer and the message to send.
       */
      businessNotification?: BusinessNotification;
  }
  
  type bookingsFeesV1BookingFee_universal_d_BookingFee = BookingFee;
  type bookingsFeesV1BookingFee_universal_d_CancellationFee = CancellationFee;
  type bookingsFeesV1BookingFee_universal_d_Trigger = Trigger;
  const bookingsFeesV1BookingFee_universal_d_Trigger: typeof Trigger;
  type bookingsFeesV1BookingFee_universal_d_PolicyDetails = PolicyDetails;
  type bookingsFeesV1BookingFee_universal_d_FailedToApplyBookingFeeToOrder = FailedToApplyBookingFeeToOrder;
  type bookingsFeesV1BookingFee_universal_d_EcomOrderInfo = EcomOrderInfo;
  type bookingsFeesV1BookingFee_universal_d_BusinessNotification = BusinessNotification;
  type bookingsFeesV1BookingFee_universal_d_FailedToCollectAppliedBookingFees = FailedToCollectAppliedBookingFees;
  type bookingsFeesV1BookingFee_universal_d_ListBookingFeesByBookingIdsRequest = ListBookingFeesByBookingIdsRequest;
  type bookingsFeesV1BookingFee_universal_d_ListBookingFeesByBookingIdsResponse = ListBookingFeesByBookingIdsResponse;
  type bookingsFeesV1BookingFee_universal_d_ApplyBookingFeesToOrderRequest = ApplyBookingFeesToOrderRequest;
  type bookingsFeesV1BookingFee_universal_d_ApplyBookingFeesToOrderResponse = ApplyBookingFeesToOrderResponse;
  type bookingsFeesV1BookingFee_universal_d_ListNonPreviewBookingFeesByBookingIdsRequest = ListNonPreviewBookingFeesByBookingIdsRequest;
  type bookingsFeesV1BookingFee_universal_d_ListNonPreviewBookingFeesByBookingIdsResponse = ListNonPreviewBookingFeesByBookingIdsResponse;
  type bookingsFeesV1BookingFee_universal_d_CollectAppliedBookingFeesRequest = CollectAppliedBookingFeesRequest;
  type bookingsFeesV1BookingFee_universal_d_CollectAppliedBookingFeesResponse = CollectAppliedBookingFeesResponse;
  const bookingsFeesV1BookingFee_universal_d_listBookingFeesByBookingIds: typeof listBookingFeesByBookingIds;
  type bookingsFeesV1BookingFee_universal_d_ListBookingFeesByBookingIdsOptions = ListBookingFeesByBookingIdsOptions;
  const bookingsFeesV1BookingFee_universal_d_applyBookingFeesToOrder: typeof applyBookingFeesToOrder;
  type bookingsFeesV1BookingFee_universal_d_ApplyBookingFeesToOrderOptions = ApplyBookingFeesToOrderOptions;
  const bookingsFeesV1BookingFee_universal_d_listNonPreviewBookingFeesByBookingIds: typeof listNonPreviewBookingFeesByBookingIds;
  const bookingsFeesV1BookingFee_universal_d_collectAppliedBookingFees: typeof collectAppliedBookingFees;
  type bookingsFeesV1BookingFee_universal_d_CollectAppliedBookingFeesOptions = CollectAppliedBookingFeesOptions;
  namespace bookingsFeesV1BookingFee_universal_d {
    export {
      bookingsFeesV1BookingFee_universal_d_BookingFee as BookingFee,
      bookingsFeesV1BookingFee_universal_d_CancellationFee as CancellationFee,
      Money$2 as Money,
      BookingFeeStatus$1 as BookingFeeStatus,
      bookingsFeesV1BookingFee_universal_d_Trigger as Trigger,
      bookingsFeesV1BookingFee_universal_d_PolicyDetails as PolicyDetails,
      bookingsFeesV1BookingFee_universal_d_FailedToApplyBookingFeeToOrder as FailedToApplyBookingFeeToOrder,
      bookingsFeesV1BookingFee_universal_d_EcomOrderInfo as EcomOrderInfo,
      Price$2 as Price,
      bookingsFeesV1BookingFee_universal_d_BusinessNotification as BusinessNotification,
      bookingsFeesV1BookingFee_universal_d_FailedToCollectAppliedBookingFees as FailedToCollectAppliedBookingFees,
      bookingsFeesV1BookingFee_universal_d_ListBookingFeesByBookingIdsRequest as ListBookingFeesByBookingIdsRequest,
      bookingsFeesV1BookingFee_universal_d_ListBookingFeesByBookingIdsResponse as ListBookingFeesByBookingIdsResponse,
      CursorPagingMetadata$6 as CursorPagingMetadata,
      Cursors$8 as Cursors,
      bookingsFeesV1BookingFee_universal_d_ApplyBookingFeesToOrderRequest as ApplyBookingFeesToOrderRequest,
      bookingsFeesV1BookingFee_universal_d_ApplyBookingFeesToOrderResponse as ApplyBookingFeesToOrderResponse,
      bookingsFeesV1BookingFee_universal_d_ListNonPreviewBookingFeesByBookingIdsRequest as ListNonPreviewBookingFeesByBookingIdsRequest,
      bookingsFeesV1BookingFee_universal_d_ListNonPreviewBookingFeesByBookingIdsResponse as ListNonPreviewBookingFeesByBookingIdsResponse,
      bookingsFeesV1BookingFee_universal_d_CollectAppliedBookingFeesRequest as CollectAppliedBookingFeesRequest,
      bookingsFeesV1BookingFee_universal_d_CollectAppliedBookingFeesResponse as CollectAppliedBookingFeesResponse,
      DomainEvent$8 as DomainEvent,
      DomainEventBodyOneOf$8 as DomainEventBodyOneOf,
      EntityCreatedEvent$8 as EntityCreatedEvent,
      RestoreInfo$8 as RestoreInfo,
      EntityUpdatedEvent$8 as EntityUpdatedEvent,
      EntityDeletedEvent$8 as EntityDeletedEvent,
      ActionEvent$8 as ActionEvent,
      MessageEnvelope$7 as MessageEnvelope,
      IdentificationData$9 as IdentificationData,
      IdentificationDataIdOneOf$9 as IdentificationDataIdOneOf,
      WebhookIdentityType$7 as WebhookIdentityType,
      bookingsFeesV1BookingFee_universal_d_listBookingFeesByBookingIds as listBookingFeesByBookingIds,
      bookingsFeesV1BookingFee_universal_d_ListBookingFeesByBookingIdsOptions as ListBookingFeesByBookingIdsOptions,
      bookingsFeesV1BookingFee_universal_d_applyBookingFeesToOrder as applyBookingFeesToOrder,
      bookingsFeesV1BookingFee_universal_d_ApplyBookingFeesToOrderOptions as ApplyBookingFeesToOrderOptions,
      bookingsFeesV1BookingFee_universal_d_listNonPreviewBookingFeesByBookingIds as listNonPreviewBookingFeesByBookingIds,
      bookingsFeesV1BookingFee_universal_d_collectAppliedBookingFees as collectAppliedBookingFees,
      bookingsFeesV1BookingFee_universal_d_CollectAppliedBookingFeesOptions as CollectAppliedBookingFeesOptions,
    };
  }
  
  /**
   * The `bookingPolicySnapshot` object is the version of a service's booking policy
   * at the time a booking is created. This allows you for example to charge
   * customers the correct cancellation fee even after a service's cancellation
   * policy has been updated.
   */
  interface BookingPolicySnapshot {
      /**
       * Booking policy snapshot ID.
       * @readonly
       */
      _id?: string | null;
      /** ID of the booking that's associated with this policy snapshot. */
      bookingId?: string | null;
      /**
       * Snapshot of the [booking policy](https://dev.wix.com/docs/sdk/backend-modules/bookings/booking-policies/get-booking-policy).
       * at the time the corresponding booking was created.
       */
      policy?: BookingPolicy$2;
      /**
       * Date and time the booking policy snapshot was created in `YYYY-MM-DDThh:mm:ssZ` format.
       * @readonly
       */
      _createdDate?: Date | null;
  }
  /**
   * `BookingPolicy` is the main entity of `BookingPolicyService` and specifies a set of rules for booking a service
   * by visitors and members.
   *
   * Each `BookingPolicy` consists of a number of sub-policies. When the Bookings App is provisioned to a meta site then a
   * default `BookingPolicy` will be created with defaults for each of these sub-policies. This also applies when a request
   * is received to create a new `BookingPolicy` and one or more of these sub-policies are not provided.
   *
   * Sub-policies are defined in separate objects as specified below.
   * - The `CancellationPolicy` object defines the policy for canceling a booked session.
   * - The `ReschedulePolicy` object defines the policy for rescheduling booked session.
   *
   * By default each sub-policy is disabled. A more detailed specification of the default settings of each sub-policy
   * can be found in the description of the corresponding object.
   *
   * Partial updates are supported on the main entity level, however in order to update a sub-policy the client needs to provide the whole sub-policy object.
   */
  interface BookingPolicy$2 {
      /**
       * Booking policy ID.
       * @readonly
       */
      _id?: string | null;
      /**
       * Revision number, which increments by 1 each time the booking policy is updated. To prevent conflicting changes, the current `revision` must be passed when updating the booking policy.
       * @readonly
       */
      revision?: string | null;
      /**
       * Date and time the booking policy was created.
       * @readonly
       */
      _createdDate?: Date | null;
      /**
       * Date and time the booking policy was updated.
       * @readonly
       */
      _updatedDate?: Date | null;
      /** Name of the booking policy. */
      name?: string | null;
      /** Custom description for the booking policy and whether the booking policy is displayed to the participant. */
      customPolicyDescription?: PolicyDescription$2;
      /**
       * Whether the booking policy is the default.
       * @readonly
       */
      default?: boolean | null;
      /** Rule for canceling a booking. */
      cancellationPolicy?: CancellationPolicy$2;
      /** Rule for rescheduling a booking. */
      reschedulePolicy?: ReschedulePolicy$2;
      /** Rules for cancellation fees. */
      cancellationFeePolicy?: CancellationFeePolicy$2;
      /** Rule for saving credit card details. */
      saveCreditCardPolicy?: SaveCreditCardPolicy$2;
  }
  /** A description of the booking policy to display to participants. */
  interface PolicyDescription$2 {
      /**
       * Whether the description is displayed to the participant. `true` means the
       * description is displayed.
       *
       * Default: `false`
       */
      enabled?: boolean;
      /**
       * Description of the booking policy.
       *
       * Default: Empty
       * Max length: 2500 characters
       */
      description?: string;
      /**
       * Description of the translated booking policy.
       *
       * Default: Empty
       * Max length: 2500 characters
       */
      descriptionTranslated?: string | null;
  }
  /** The rule for canceling a booked session. */
  interface CancellationPolicy$2 {
      /**
       * Whether customers can cancel the booking. `true` means customers can cancel
       * the booking.
       *
       * Default: `false`
       */
      enabled?: boolean;
      /**
       * Whether there's a limit on the latest cancellation time. `false` means
       * customers can cancel the booking until the last minute before the course or
       * session starts.
       *
       * Default: `false`
       */
      limitLatestCancellation?: boolean;
      /**
       * Minimum number of minutes before the start of the session customers can cancel.
       * For courses, this refers to the start of the first course session.
       *
       * Default: `1440` minutes (1 day)
       * Min: `1` minute
       */
      latestCancellationInMinutes?: number;
  }
  /** The rule for rescheduling a booked session. */
  interface ReschedulePolicy$2 {
      /**
       * Whether customers can reschedule a booking for an appointment-based service.
       * `true` means customers can reschedule.
       *
       * Default: `false`
       */
      enabled?: boolean;
      /**
       * Whether there's a limit on the latest supported rescheduling time. `false`
       * means customers can reschedule until the last minute before the session start.
       *
       * Default: `false`
       */
      limitLatestReschedule?: boolean;
      /**
       * Minimum number of minutes before the session start session customers can
       * reschedule their booking.
       *
       * Default: `1440` minutes (1 day)
       * Min: `1` minute
       */
      latestRescheduleInMinutes?: number;
  }
  interface CancellationFeePolicy$2 {
      /**
       * Whether customers must pay a cancellation fee when canceling a booking.
       *
       * Default: `false`
       */
      enabled?: boolean;
      /**
       * Time windows relative to the session start during which customers can cancel
       * their booking. Each window includes details about the fee for canceling
       * within it.
       */
      cancellationWindows?: CancellationWindow$2[];
      /**
       * Whether Wix automatically charges the cancellation fee from the customer once
       * they cancel their booking.
       *
       * Default: true
       */
      autoCollectFeeEnabled?: boolean | null;
  }
  /**
   * Money.
   * Default format to use. Sufficiently compliant with majority of standards: w3c, ISO 4217, ISO 20022, ISO 8583:2003.
   */
  interface Money$1 {
      /** Monetary amount. Decimal string with a period as a decimal separator (e.g., 3.99). Optionally, a single (-), to indicate that the amount is negative. */
      value?: string;
      /** Currency code. Must be valid ISO 4217 currency code (e.g., USD). */
      currency?: string;
      /** Monetary amount. Decimal string in local format (e.g., 1 000,30). Optionally, a single (-), to indicate that the amount is negative. */
      formattedValue?: string | null;
  }
  interface CancellationWindow$2 extends CancellationWindowFeeOneOf$2 {
      /** Fixed amount customers must pay when canceling the booking within this window. */
      amount?: Money$1;
      /**
       * Percentage of the booking price customers must pay when canceling within this window.
       *
       * Min: `0.01` percent
       * Max: `100` percent
       */
      percentage?: string;
      /**
       * Start of the cancellation window in minutes before the session start. For
       * courses, this refers to the start of the first course session.
       */
      startInMinutes?: number | null;
  }
  /** @oneof */
  interface CancellationWindowFeeOneOf$2 {
      /** Fixed amount customers must pay when canceling the booking within this window. */
      amount?: Money$1;
      /**
       * Percentage of the booking price customers must pay when canceling within this window.
       *
       * Min: `0.01` percent
       * Max: `100` percent
       */
      percentage?: string;
  }
  interface SaveCreditCardPolicy$2 {
      /**
       * Whether Wix stores credit card details of the customer. Storing the details
       * allows Wix to prefill the checkout and thus increases the likelyhood that the
       * customer completes the booking process.
       *
       * Default: `false`
       */
      enabled?: boolean;
  }
  interface ListPolicySnapshotsByBookingIdsRequest {
      /** List of booking IDs to retrieve policy snapshots for. */
      bookingIds: string[] | null;
  }
  interface ListPolicySnapshotsByBookingIdsResponse {
      /** Retrieved booking Policy snapshots. */
      bookingPolicySnapshots?: BookingPolicySnapshot[];
  }
  interface DomainEvent$7 extends DomainEventBodyOneOf$7 {
      createdEvent?: EntityCreatedEvent$7;
      updatedEvent?: EntityUpdatedEvent$7;
      deletedEvent?: EntityDeletedEvent$7;
      actionEvent?: ActionEvent$7;
      /**
       * Unique event ID.
       * Allows clients to ignore duplicate webhooks.
       */
      _id?: string;
      /**
       * Assumes actions are also always typed to an entity_type
       * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
       */
      entityFqdn?: string;
      /**
       * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
       * This is although the created/updated/deleted notion is duplication of the oneof types
       * Example: created/updated/deleted/started/completed/email_opened
       */
      slug?: string;
      /** ID of the entity associated with the event. */
      entityId?: string;
      /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
      eventTime?: Date | null;
      /**
       * Whether the event was triggered as a result of a privacy regulation application
       * (for example, GDPR).
       */
      triggeredByAnonymizeRequest?: boolean | null;
      /** If present, indicates the action that triggered the event. */
      originatedFrom?: string | null;
      /**
       * A sequence number defining the order of updates to the underlying entity.
       * For example, given that some entity was updated at 16:00 and than again at 16:01,
       * it is guaranteed that the sequence number of the second update is strictly higher than the first.
       * As the consumer, you can use this value to ensure that you handle messages in the correct order.
       * To do so, you will need to persist this number on your end, and compare the sequence number from the
       * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
       */
      entityEventSequence?: string | null;
  }
  /** @oneof */
  interface DomainEventBodyOneOf$7 {
      createdEvent?: EntityCreatedEvent$7;
      updatedEvent?: EntityUpdatedEvent$7;
      deletedEvent?: EntityDeletedEvent$7;
      actionEvent?: ActionEvent$7;
  }
  interface EntityCreatedEvent$7 {
      entityAsJson?: string;
      /**
       * Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity
       * @internal
       */
      triggeredByUndelete?: boolean | null;
      /** Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity */
      restoreInfo?: RestoreInfo$7;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface RestoreInfo$7 {
      deletedDate?: Date | null;
  }
  interface EntityUpdatedEvent$7 {
      /**
       * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
       * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
       * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
       */
      currentEntityAsJson?: string;
      /**
       * This field is currently part of the of the EntityUpdatedEvent msg, but scala/node libraries which implements the domain events standard
       * wont populate it / have any reference to it in the API.
       * The main reason for it is that fetching the old entity from the DB will have a performance hit on an update operation so unless truly needed,
       * the developer should send only the new (current) entity.
       * An additional reason is not wanting to send this additional entity over the wire (kafka) since in some cases it can be really big
       * Developers that must reflect the old entity will have to implement their own domain event sender mechanism which will follow the DomainEvent proto message.
       * @internal
       * @deprecated
       */
      previousEntityAsJson?: string | null;
      /**
       * WIP - This property will hold both names and values of the updated fields of the entity.
       * For more details please see [adr](https://docs.google.com/document/d/1PdqsOM20Ph2HAkmx8zvUnzzk3Sekp3BR9h34wSvsRnI/edit#heading=h.phlw87mh2imx) or [issue](https://github.com/wix-private/nile-tracker/issues/363)
       * @internal
       */
      modifiedFields?: Record<string, any>;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface EntityDeletedEvent$7 {
      /**
       * Indicates if the entity is sent to trash-bin. only available when trash-bin is enabled
       * @internal
       */
      movedToTrash?: boolean | null;
      /** Entity that was deleted */
      deletedEntityAsJson?: string | null;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface ActionEvent$7 {
      bodyAsJson?: string;
  }
  interface Empty$4 {
  }
  /**
   * Retrieves a list of booking policy snapshots by booking IDs.
   * @param bookingIds - List of booking IDs to retrieve policy snapshots for.
   * @public
   * @documentationMaturity preview
   * @requiredField bookingIds
   * @permissionId BOOKINGS.BOOKING_POLICY_SNAPSHOT_READ
   */
  function listPolicySnapshotsByBookingIds(bookingIds: string[] | null): Promise<ListPolicySnapshotsByBookingIdsResponse>;
  
  type bookingsPolicySnapshotsV1BookingPolicySnapshot_universal_d_BookingPolicySnapshot = BookingPolicySnapshot;
  type bookingsPolicySnapshotsV1BookingPolicySnapshot_universal_d_ListPolicySnapshotsByBookingIdsRequest = ListPolicySnapshotsByBookingIdsRequest;
  type bookingsPolicySnapshotsV1BookingPolicySnapshot_universal_d_ListPolicySnapshotsByBookingIdsResponse = ListPolicySnapshotsByBookingIdsResponse;
  const bookingsPolicySnapshotsV1BookingPolicySnapshot_universal_d_listPolicySnapshotsByBookingIds: typeof listPolicySnapshotsByBookingIds;
  namespace bookingsPolicySnapshotsV1BookingPolicySnapshot_universal_d {
    export {
      bookingsPolicySnapshotsV1BookingPolicySnapshot_universal_d_BookingPolicySnapshot as BookingPolicySnapshot,
      BookingPolicy$2 as BookingPolicy,
      PolicyDescription$2 as PolicyDescription,
      CancellationPolicy$2 as CancellationPolicy,
      ReschedulePolicy$2 as ReschedulePolicy,
      CancellationFeePolicy$2 as CancellationFeePolicy,
      Money$1 as Money,
      CancellationWindow$2 as CancellationWindow,
      CancellationWindowFeeOneOf$2 as CancellationWindowFeeOneOf,
      SaveCreditCardPolicy$2 as SaveCreditCardPolicy,
      bookingsPolicySnapshotsV1BookingPolicySnapshot_universal_d_ListPolicySnapshotsByBookingIdsRequest as ListPolicySnapshotsByBookingIdsRequest,
      bookingsPolicySnapshotsV1BookingPolicySnapshot_universal_d_ListPolicySnapshotsByBookingIdsResponse as ListPolicySnapshotsByBookingIdsResponse,
      DomainEvent$7 as DomainEvent,
      DomainEventBodyOneOf$7 as DomainEventBodyOneOf,
      EntityCreatedEvent$7 as EntityCreatedEvent,
      RestoreInfo$7 as RestoreInfo,
      EntityUpdatedEvent$7 as EntityUpdatedEvent,
      EntityDeletedEvent$7 as EntityDeletedEvent,
      ActionEvent$7 as ActionEvent,
      Empty$4 as Empty,
      bookingsPolicySnapshotsV1BookingPolicySnapshot_universal_d_listPolicySnapshotsByBookingIds as listPolicySnapshotsByBookingIds,
    };
  }
  
  /** extended bookings */
  interface ExtendedBooking {
      /** Booking. */
      booking?: Booking$2;
      /**
       * Information about which actions the customer can perform for the
       * booking. Available only when passing `withBookingAllowedActions` as `true`.
       */
      allowedActions?: AllowedActions$1;
      /**
       * Information about attendance. Available only when passing
       * `withBookingAttendanceInfo` as `true`.
       */
      attendance?: Attendance$1;
      /**
       * Information about the online conferencing details. Available only when passing
       * `withBookingConferencingDetails` as `true`.
       */
      conferencingDetails?: ConferencingDetails;
      /**
       * Information about the booking's policy settings according to the relevant
       * [booking policy snapshot](https://dev.wix.com/docs/rest/business-solutions/bookings/services/booking-policy-snapshots/introduction).
       * Available only when passing `withBookingPolicySettings` as `true`.
       * @internal
       */
      bookingPolicySettings?: BookingPolicySettings$1;
      /**
       * Information about the booking fee statuses. Available only when passing
       * `withBookingFeeDetailsBooking` as `true`. No details are returned when there
       * is no booking fee for the booking. For example, when a booking was canceled
       * before the start of the earliest cancellation window or the customer hasn't
       * canceled the booking yet.
       * @internal
       */
      bookingFeeDetails?: BookingFeeDetails;
  }
  enum AttendanceStatus$1 {
      NOT_SET = "NOT_SET",
      ATTENDED = "ATTENDED",
      NOT_ATTENDED = "NOT_ATTENDED"
  }
  /** The booking object, version 2. */
  interface Booking$2 extends BookingParticipantsInfoOneOf$2 {
      /** Total number of participants. Available only when the booking includes a single service variant. */
      totalParticipants?: number;
      /**
       * Information about the booked service choices and participants.
       * Available only when the booking includes multiple service variants.
       */
      participantsChoices?: ParticipantChoices$2;
      /**
       * Booking ID.
       * @readonly
       */
      _id?: string | null;
      /** An object describing the slot or schedule that was booked. */
      bookedEntity?: BookedEntity$2;
      /** Contact details of the site visitor or member making the booking. */
      contactDetails?: ContactDetails$2;
      /** Additional custom fields submitted with the booking form. */
      additionalFields?: CustomFormField$2[];
      /**
       * Number of participants.
       * @internal
       */
      numberOfParticipants?: number | null;
      /**
       * Internal business note
       * @internal
       * @deprecated
       */
      internalBusinessNote?: string | null;
      /**
       * Booking status.
       *
       * Supported values:
       * - `CREATED`: The booking was created.
       * - `UPDATED`: The booking was updated.
       * - `PENDING`: The booking is waiting to be confirmed or declined by the business owner. A booking is automatically set as `PENDING` if the service is configured to require manual business onwer confirmation and an [eCommerce order](https://dev.wix.com/docs/rest/business-solutions/e-commerce/orders/introduction) was created.
       * - `CONFIRMED`: The booking was confirmed. A booking is automatically confirmed if the service is configured to automatically confirm bookings and an [eCommerce order](https://dev.wix.com/docs/rest/business-solutions/e-commerce/orders/introduction) was created. If the service isn't configured to automatically confirm bookings, you can use [Confirm Or Decline Booking](https://dev.wix.com/docs/rest/business-solutions/bookings/bookings-and-time-slots/bookings-v2/bookings-v2-and-confirmation/confirm-or-decline-booking).
       * - `DECLINED`: The booking was declined by the business owner. A booking is also declined if an [eCommerce order](https://dev.wix.com/docs/rest/business-solutions/e-commerce/orders/introduction) was created that resulted in a double booking.
       * - `CANCELED`: The booking was canceled.
       * - `WAITING_LIST`: The booking is on a wait list.
       */
      status?: BookingStatus$2;
      /**
       * Payment status.
       * One of:
       * - `"NOT_PAID"` The booking is not paid for.
       * - `"PAID"` The booking is fully paid.
       * - `"PARTIALLY_PAID"` The booking is partially paid.
       * - `"REFUNDED"` The booking is refunded.
       * - `"EXEMPT"` The booking is free of charge.
       */
      paymentStatus?: PaymentStatus$2;
      /**
       * Selected payment option.
       * One of the payment options offered by the service, or another option if `skipSelectedPaymentOptionValidation` is `true`.
       * When undefined, the payment option is resolved by the service configuration on checkout.
       */
      selectedPaymentOption?: SelectedPaymentOption$2;
      /**
       * Date and time the booking was created.
       * @readonly
       */
      _createdDate?: Date | null;
      /** External ID provided by the client app on creation. */
      externalUserId?: string | null;
      /**
       * An object describing the platform and application that made the booking.
       * @internal
       */
      bookingSource?: BookingSource$2;
      /**
       * The last notification used by Cancel, Confirm, Decline, or Reschedule Booking.
       * @internal
       * @deprecated
       */
      participantNotification?: ParticipantNotification$5;
      /**
       * When value is set to True, an SMS reminder would be sent to the phone number specified in the ContactDetails, 24 hours before the session starts.
       * @internal
       * @deprecated
       */
      sendSmsReminder?: boolean | null;
      /** Revision number to be used when updating, rescheduling, or cancelling the booking. Revision number, which increments by 1 each time the booking is updated, rescheduled, or canceled. To prevent conflicting changes,the current revision must be passed when updating the booking. */
      revision?: string | null;
      /**
       * ID of the creator of the Booking.
       * If `appId` and another ID are present, the other ID takes precedence.
       * @readonly
       */
      createdBy?: IdentificationData$8;
      /**
       * The start date of this booking. For a slot, this is the start date of the slot. For a schedule, this is the start date of the first session.
       * @readonly
       */
      startDate?: Date | null;
      /**
       * The end date of this booking. For a slot, this is the end date of the slot. For a schedule, this is the end date of the last session.
       * @readonly
       */
      endDate?: Date | null;
      /**
       * Sets the booking flow behavior. Some behaviors require permissions.
       * @internal
       */
      flowControlSettings?: FlowControlSettings$2;
      /**
       * Date and time the booking was updated.
       * @readonly
       */
      _updatedDate?: Date | null;
      /**
       * Custom field data for this object. Extended fields must be configured in the app dashboard before they can be accessed with API calls.
       * For usage of extended fields with [Wix Forms](https://dev.wix.com/docs/rest/crm/forms/form-schema-api/introduction-to-forms), after configuring your form custom fields, pass the form field values under the `_user_fields` namespace.
       * For example, if you have a custom form field named `age`, pass it as `"extendedFields":{"_user_fields": { "age": 22 }}`.
       */
      extendedFields?: ExtendedFields$7;
      /**
       * Whether this booking overlaps another existing confirmed booking. Returned when: `true`
       * @readonly
       */
      doubleBooked?: boolean | null;
      /**
       * whether this booking availability should be checked with v1 or v2
       * @internal
       */
      v2Availability?: boolean | null;
      /**
       * Multi service booking info of which the booking is part of.
       * @internal
       * @readonly
       */
      multiServiceBookingInfo?: MultiServiceBookingInfo$2;
      /**
       * The date this booking was canceled on
       * @internal
       * @readonly
       */
      canceledDate?: Date | null;
      /**
       * whether this booking availability should be checked with v1 or v2
       * @internal
       */
      v2AvailabilityProxy?: boolean | null;
      /**
       * Having booking language means that the booking was made in a secondary language, having no booking.language implies that the booking was made using the main language
       * @internal
       */
      language?: string | null;
  }
  /** @oneof */
  interface BookingParticipantsInfoOneOf$2 {
      /** Total number of participants. Available only when the booking includes a single service variant. */
      totalParticipants?: number;
      /**
       * Information about the booked service choices and participants.
       * Available only when the booking includes multiple service variants.
       */
      participantsChoices?: ParticipantChoices$2;
  }
  enum MultiServiceBookingType$2 {
      /**
       * Multi service booking will be considered available if its bookings are
       * available as returned from ListMultiServiceAvailabilityTimeSlots API.
       * See [List Multi Service Availability Time Slots] (url) documentation // todo: complete url
       */
      SEQUENTIAL_BOOKINGS = "SEQUENTIAL_BOOKINGS",
      /**
       * Multi service booking will be considered available if each of its bookings is available separately.
       * Not supported yet
       */
      SEPARATE_BOOKINGS = "SEPARATE_BOOKINGS",
      /** Not supported yet */
      PARALLEL_BOOKINGS = "PARALLEL_BOOKINGS"
  }
  interface BookedEntity$2 extends BookedEntityItemOneOf$2 {
      /** The booked slot, once booked becomes a session, The booking is automatically assigned to the session if it already exists, or creates a session if one doesn't already exist. */
      slot?: BookedSlot$2;
      /** The booked schedule. The booking is automatically assigned to the schedule's sessions. */
      schedule?: BookedSchedule$2;
      /**
       * Session title at the time of booking.
       * If session doesn't exist at the time of the booking, service name is used.
       * @readonly
       */
      title?: string | null;
      /**
       * If the user made the booking in a secondary language, this field will contain the translated title.
       * @internal
       * @readonly
       */
      titleTranslated?: string | null;
      /**
       * List of tags for the booking.
       * System-assigned tags for sessions and schedules are:
       * + "INDIVIDUAL" Appointments, including appointments with more than 1 participant.
       * + "GROUP" Individual classes.
       * + "COURSE" Courses.
       */
      tags?: string[] | null;
  }
  /** @oneof */
  interface BookedEntityItemOneOf$2 {
      /** The booked slot, once booked becomes a session, The booking is automatically assigned to the session if it already exists, or creates a session if one doesn't already exist. */
      slot?: BookedSlot$2;
      /** The booked schedule. The booking is automatically assigned to the schedule's sessions. */
      schedule?: BookedSchedule$2;
  }
  interface BookedSlot$2 {
      /**
       * ID of the underlying session when session is a single session or generated from a recurring session.
       * If `sessionId` is defined in the `Create Booking` request, the `startDate`, `endDate`, `timezone`, `resource`, and `location` fields are ignored and populated from the existing session's information.
       */
      sessionId?: string | null;
      /** Service ID. */
      serviceId?: string;
      /** Schedule ID. Required. */
      scheduleId?: string;
      /**
       * Calendar 3 event ID
       * If not empty, on all write flows (create / update) gets priority over session_id.
       * so if both session_id and event_id are provided, the session_id that will be set on the booking will be based on the event_id.
       * Otherwise, if event_id is empty on write flow,
       */
      eventId?: string | null;
      /**
       * The start time of this slot in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339)
       * format.
       */
      startDate?: string | null;
      /**
       * The end time of this slot in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339)
       * format.
       */
      endDate?: string | null;
      /** The timezone according to which the slot was shown to the user when booking, and should be shown in future. */
      timezone?: string | null;
      /**
       * The enriched resource assigned to the slot, can be either the requested resource or the resource chosen by the system.
       * When populated, the given resource will be booked according to it's availability.
       * When empty, If `skip_availability_validation` is `false`, a random available resource will be assigned to the slot upon confirmation,
       * otherwise one of the service resources will be assigned to the slot randomly upon confirmation.
       * This resource is the slot primary resource.
       */
      resource?: BookedResource$2;
      /** Location where the slot's session takes place. */
      location?: Location$4;
      /**
       * Optional.
       * In addition to the `resource` field, these are the additional enriched resources that are assigned to the slot.
       * For example the room, equipment or the additional staff member that are assigned to the slot.
       * @internal
       */
      additionalResources?: BookedResource$2[];
  }
  interface BookedResource$2 {
      /** Booked resource ID. */
      _id?: string;
      /** Resource's name at the time of booking. */
      name?: string | null;
      /**
       * Resource's name translated to the language the booking was made in if applicable.
       * @internal
       * @readonly
       */
      nameTranslated?: string | null;
      /** Resource's email at the time of booking. */
      email?: string | null;
      /** Resource's schedule ID. */
      scheduleId?: string | null;
      /**
       * Indicates whether the resource was specifically requested or should be auto selected by the Server.
       * The value will be true if the resource was explicitly given in the request, otherwise false.
       * @internal
       * @readonly
       */
      explicitlyRequested?: boolean | null;
      /**
       * Resource's type.
       * @internal
       * @readonly
       */
      type?: string | null;
  }
  interface Location$4 {
      /**
       * Business location ID. Available only for locations that are business locations,
       * meaning the `location_type` is `"OWNER_BUSINESS"`.
       */
      _id?: string | null;
      /** Location name. */
      name?: string | null;
      /** The full address of this location. */
      formattedAddress?: string | null;
      /** The full translated address of this location. */
      formattedAddressTranslated?: string | null;
      /**
       * Location type.
       *
       * - `"OWNER_BUSINESS"`: The business address, as set in the sites general settings.
       * - `"OWNER_CUSTOM"`: The address as set when creating the service.
       * - `"CUSTOM"`: The address as set for the individual session.
       */
      locationType?: LocationType$4;
  }
  enum LocationType$4 {
      UNDEFINED = "UNDEFINED",
      OWNER_BUSINESS = "OWNER_BUSINESS",
      OWNER_CUSTOM = "OWNER_CUSTOM",
      CUSTOM = "CUSTOM"
  }
  interface BookedSchedule$2 {
      /** Schedule ID. */
      scheduleId?: string;
      /** Booked service ID. */
      serviceId?: string | null;
      /**
       * Location where the schedule's sessions take place. Read only.
       * @readonly
       */
      location?: Location$4;
      /** The timezone according to which the slot was shown to the user when booking, and should be shown in future. */
      timezone?: string | null;
      /**
       * The start time of the first session in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339)
       * format. Required.
       * @readonly
       */
      firstSessionStart?: string | null;
      /**
       * The end time of the last session in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339)
       * format. Required.
       * @readonly
       */
      lastSessionEnd?: string | null;
  }
  interface ContactDetails$2 {
      /** Contact's ID. */
      contactId?: string | null;
      /** Contact's first name. When populated from a standard booking form, this property corresponds to the **Name** field. */
      firstName?: string | null;
      /** Contact's last name. */
      lastName?: string | null;
      /** Contact's email, used to create a new contact or get existing one from the [Contacts API](https://dev.wix.com/api/rest/contacts/contacts). Used to validate coupon usage limitations per contact. If not passed, the coupon usage limitation will not be enforced. (Coupon usage limitation validation is not supported yet). */
      email?: string | null;
      /** Contact's phone number. */
      phone?: string | null;
      /** Contact's full address. */
      fullAddress?: Address$5;
      /**
       * Contact's time zone.
       * @deprecated
       */
      timeZone?: string | null;
      /** Contact's country in [ISO 3166-1 alpha-2 code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format. */
      countryCode?: string | null;
  }
  /** Physical address */
  interface Address$5 extends AddressStreetOneOf$4 {
      /** Street name, number and apartment number. */
      streetAddress?: StreetAddress$4;
      /** Main address line, usually street and number, as free text. */
      addressLine?: string | null;
      /** Country code. */
      country?: string | null;
      /** Subdivision. Usually state, region, prefecture or province code, according to [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). */
      subdivision?: string | null;
      /** City name. */
      city?: string | null;
      /** Zip/postal code. */
      postalCode?: string | null;
      /** Free text providing more detailed address info. Usually contains Apt, Suite, and Floor. */
      addressLine2?: string | null;
      /** A string containing the full address of this location. */
      formattedAddress?: string | null;
      /** Free text to help find the address. */
      hint?: string | null;
      /** Coordinates of the physical address. */
      geocode?: AddressLocation$4;
      /** Country full name. */
      countryFullname?: string | null;
      /** Multi-level subdivisions from top to bottom. */
      subdivisions?: Subdivision$4[];
  }
  /** @oneof */
  interface AddressStreetOneOf$4 {
      /** Street name, number and apartment number. */
      streetAddress?: StreetAddress$4;
      /** Main address line, usually street and number, as free text. */
      addressLine?: string | null;
  }
  interface StreetAddress$4 {
      /** Street number. */
      number?: string;
      /** Street name. */
      name?: string;
      /** Apartment number. */
      apt?: string;
  }
  interface AddressLocation$4 {
      /** Address latitude. */
      latitude?: number | null;
      /** Address longitude. */
      longitude?: number | null;
  }
  interface Subdivision$4 {
      /** Subdivision code. Usually state, region, prefecture or province code, according to [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). */
      code?: string;
      /** Subdivision full name. */
      name?: string;
  }
  interface CustomFormField$2 {
      /** ID of the form field as defined in the form. */
      _id?: string;
      /** Value that was submitted for this field. */
      value?: string | null;
      /**
       * Form field's label at the time of submission.
       * @readonly
       */
      label?: string | null;
      valueType?: ValueType$2;
  }
  enum ValueType$2 {
      /** Short text. This is the default value type. */
      SHORT_TEXT = "SHORT_TEXT",
      /** Long text */
      LONG_TEXT = "LONG_TEXT",
      /** a text that represent the check box value: if selected the value is "true", otherwise "false". */
      CHECK_BOX = "CHECK_BOX"
  }
  /** Booking status. */
  enum BookingStatus$2 {
      CREATED = "CREATED",
      CONFIRMED = "CONFIRMED",
      CANCELED = "CANCELED",
      PENDING = "PENDING",
      DECLINED = "DECLINED",
      WAITING_LIST = "WAITING_LIST"
  }
  /**
   * Payment status.
   * Automatically updated when using eCom checkout APIs.
   */
  enum PaymentStatus$2 {
      UNDEFINED = "UNDEFINED",
      NOT_PAID = "NOT_PAID",
      PAID = "PAID",
      /** not supported yet. */
      PARTIALLY_PAID = "PARTIALLY_PAID",
      /** not supported yet */
      REFUNDED = "REFUNDED",
      EXEMPT = "EXEMPT"
  }
  /**
   * The selected payment option.
   * One of the payment options offered by the service.
   * This field is be set when the user selects an option during booking.
   * If left undefined, the payment option is resolved by the service configuration on checkout.
   */
  enum SelectedPaymentOption$2 {
      UNDEFINED = "UNDEFINED",
      OFFLINE = "OFFLINE",
      ONLINE = "ONLINE",
      MEMBERSHIP = "MEMBERSHIP",
      /** Payment can only be done using a membership and must be manually redeemed in the dashboard by the site owner. */
      MEMBERSHIP_OFFLINE = "MEMBERSHIP_OFFLINE"
  }
  interface BookingSource$2 {
      /** Platform from which a booking was created */
      platform?: Platform$2;
      /** Actor that created this booking. */
      actor?: Actor$2;
      /**
       * Wix site ID of the application that created the booking.
       * @readonly
       */
      appDefId?: string | null;
      /**
       * Name of the application that created the booking, as saved in Wix Developers Center at the time of booking.
       * @readonly
       */
      appName?: string | null;
  }
  enum Platform$2 {
      UNDEFINED_PLATFORM = "UNDEFINED_PLATFORM",
      WEB = "WEB",
      MOBILE_APP = "MOBILE_APP"
  }
  enum Actor$2 {
      UNDEFINED_ACTOR = "UNDEFINED_ACTOR",
      BUSINESS = "BUSINESS",
      CUSTOMER = "CUSTOMER"
  }
  interface ParticipantNotification$5 {
      /**
       * Whether to send the message about the changes to the customer.
       *
       * Default: `false`
       */
      notifyParticipants?: boolean;
      /** Custom message to send to the participants about the changes to the booking. */
      message?: string | null;
      /**
       * Optional additional metadata.
       * Supported only in V3 APIs.
       * @internal
       */
      metadata?: Record<string, string>;
  }
  interface IdentificationData$8 extends IdentificationDataIdOneOf$8 {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
      /** ID of of a contact in the site's [CRM by Ascend](https://www.wix.com/ascend/crm) system. */
      contactId?: string | null;
      /**
       * @internal
       * @readonly
       */
      identityType?: IdentityType$3;
  }
  /** @oneof */
  interface IdentificationDataIdOneOf$8 {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
  }
  enum IdentityType$3 {
      UNKNOWN = "UNKNOWN",
      ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
      MEMBER = "MEMBER",
      WIX_USER = "WIX_USER",
      APP = "APP"
  }
  interface FlowControlSettings$2 {
      /**
       * When true, skips the service defined booking-window in the booking policy.
       * Requires BOOKINGS.IGNORE_BOOKING_POLICY permissions.
       * private because it's confusing to external users - collides with skip_availability_validation
       * and yet, clients send it (though always with skip_availability_validation=true) so we're not just removing it
       * When removing, we need to use proto's `reserved` field
       * @internal
       * @deprecated
       */
      ignoreBookingWindow?: boolean;
      /**
       * When true, skips availability checking and allows booking.
       * Requires BOOKINGS.OVERRIDE_AVAILABILITY permissions.
       */
      skipAvailabilityValidation?: boolean;
      /**
       * When true, allows booking a confirmation-required service without requiring confirmation.
       * Requires BOOKINGS.IGNORE_BOOKING_POLICY permissions.
       */
      skipBusinessConfirmation?: boolean;
      /**
       * When true, skips selected payment option checking as defined in `selectedPaymentOption` field
       * and allows booking.
       * Requires BOOKINGS.MANAGE_PAYMENTS permissions.
       */
      skipSelectedPaymentOptionValidation?: boolean;
      /** When true, refunds the booking's payment when the booking is canceled. */
      withRefund?: boolean | null;
  }
  interface ExtendedFields$7 {
      /**
       * Extended field data. Each key corresponds to the namespace of the app that created the extended fields.
       * The value of each key is structured according to the schema defined when the extended fields were configured.
       *
       * You can only access fields for which you have the appropriate permissions.
       *
       * Learn more about [extended fields](https://dev.wix.com/docs/rest/articles/getting-started/extended-fields).
       */
      namespaces?: Record<string, Record<string, any>>;
  }
  interface ParticipantChoices$2 {
      /** Information about the booked service choices. Includes the number of participants. */
      serviceChoices?: ServiceChoices$2[];
  }
  interface ServiceChoices$2 {
      /** Number of participants for this variant. */
      numberOfParticipants?: number | null;
      /** Service choices for these participants. */
      choices?: ServiceChoice$2[];
  }
  interface ServiceChoice$2 extends ServiceChoiceChoiceOneOf$2 {
      /**
       * Value for one of the choices in the [`CustomServiceOption.choices`](https://example.com) list.
       * Choices are specific values for an option the customer can choose to book. For example,
       * the option `ageGroup` may have these choices: `child`, `student`, `adult`, and `senior`.
       * Each choice may have a different price.
       */
      custom?: string;
      /**
       * ID of the corresponding option for the choice. For example, the choice `child`
       * could correspond to the option `ageGroup`. In this case, `optionId` is the ID
       * for the `ageGroup` option.
       */
      optionId?: string;
  }
  /** @oneof */
  interface ServiceChoiceChoiceOneOf$2 {
      /**
       * Value for one of the choices in the [`CustomServiceOption.choices`](https://example.com) list.
       * Choices are specific values for an option the customer can choose to book. For example,
       * the option `ageGroup` may have these choices: `child`, `student`, `adult`, and `senior`.
       * Each choice may have a different price.
       */
      custom?: string;
  }
  interface MultiServiceBookingInfo$2 {
      /**
       * Multi service booking ID.
       * @readonly
       */
      _id?: string | null;
      /** Multi service booking type. */
      type?: MultiServiceBookingType$2;
  }
  /** Possible allowed actions for a Booking */
  interface AllowedActions$1 {
      /** Whether the customer is allowed to cancel the booking. */
      cancel?: boolean;
      /** Whether the customer is allowed to reschedule the booking. */
      reschedule?: boolean;
      /**
       * Whether the customer is allowed to add another service to the booking.
       * @internal
       */
      bookAnother?: boolean;
      /**
       * Deprecated.
       * Whether the customer is entitled to a refund when canceling the booking.
       * @deprecated
       */
      refund?: boolean | null;
  }
  interface Attendance$1 {
      /**
       * ID of the attendance object.
       * @readonly
       */
      _id?: string | null;
      /**
       * General Information about the booking's attendance.
       *
       * + `NOT_SET`: There is no available attendance information.
       * + `ATTENDED`: At least 1 participant attended the session.
       * + `NOT_ATTENDED`: No participant attended the session.
       */
      status?: AttendanceStatus$1;
      /** Total number of participants that attended the session. */
      numberOfAttendees?: number;
  }
  interface ConferencingDetails {
      /** URL used by a guest to join the conference. */
      guestUrl?: string | null;
      /** Optional conference password. */
      password?: string | null;
      /**
       * Optional conference description.
       * @internal
       */
      description?: string | null;
  }
  interface BookingPolicySettings$1 {
      /** Whether the booking has an active cancellation fee policy. */
      cancellationFeeEnabled?: boolean | null;
      /**
       * Whether the booking has an active rescheduling fee policy.
       * @internal
       */
      reschedulingFeeEnabled?: boolean | null;
  }
  interface BookingFeeDetails {
      /** The cancellation fee status. */
      cancellationFeeStatus?: BookingFeeStatus;
      /**
       * The rescheduling fee status.
       * @internal
       */
      reschedulingFeeStatus?: BookingFeeStatus;
  }
  enum BookingFeeStatus {
      UNKNOWN_STATUS = "UNKNOWN_STATUS",
      NOT_YET_APPLIED_TO_ORDER = "NOT_YET_APPLIED_TO_ORDER",
      APPLIED_TO_ORDER = "APPLIED_TO_ORDER"
  }
  interface QueryExtendedBookingRequest {
      /** Information about filters, paging, and sorting. */
      query: QueryV2$3;
      /**
       * Whether information about which actions the customer can perform
       * for the bookings is returned.
       */
      withBookingAllowedActions?: boolean;
      /** Whether information about the attendance for the bookings is returned. */
      withBookingAttendanceInfo?: boolean;
      /**
       * Filters the retrieved bookings by the booking ID that corresponds to
       * specified `sessionId`. The `booking.id` is calculated by calling
       * [Get Session](https://dev.wix.com/api/rest/wix-bookings/schedules-and-sessions/session/get-session)
       * and saving the returned values for `participants.Id`.
       * These participant IDs are then used as `booking.id`.
       * This filter overrides the `booking.id` filter inside the query object.
       *
       * __Note__: Bookings for courses don't include a `sessionId`. For these
       * bookings, you must use this field to filter by session ID.
       */
      sessionId?: string | null;
      /**
       * Whether information about the total entities is returned.
       * @internal
       */
      withPagingMetadataTotal?: boolean;
      /**
       * Whether information about the online conferencing details for the bookings is returned.
       * @internal
       */
      withBookingConferencingDetails?: boolean;
      /**
       * Whether to retrieve information about booking policy settings.
       * You must have the `BOOKINGS.BOOKING_POLICY_SNAPSHOT_READ` permission scope
       * when passing `true`.
       *
       * Default: `false`.
       * @internal
       */
      withBookingPolicySettings?: boolean;
      /**
       * Whether to retrieve information about the booking fee statuses.
       * Information about booking fees with a status of `PREVIEW` isn't returned.
       * You must have the `BOOKINGS.BOOKING_FEES_READ` permission scope when passing
       * `true`. In order to retrieve complete booking fee objects or to get information
       * about `PREVIEW` fees, use [List Booking Fees By Booking Ids](https://dev.wix.com/docs/rest/business-solutions/bookings/booking-fees/list-booking-fees-by-booking-ids)
       * instead.
       *
       * Default: `false`.
       * @internal
       */
      withBookingFeeDetails?: boolean;
  }
  interface QueryV2$3 extends QueryV2PagingMethodOneOf$3 {
      /** Paging options to limit and skip the number of items. */
      paging?: Paging$3;
      /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
      cursorPaging?: CursorPaging$7;
      /**
       * Filter object in the following format:
       * `"filter" : {
       * "fieldName1": "value1",
       * "fieldName2":{"$operator":"value2"}
       * }`
       * Example of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`, `$contains`
       */
      filter?: Record<string, any> | null;
      /**
       * Sort object in the following format:
       * `[{"fieldName":"sortField1","order":"ASC"},{"fieldName":"sortField2","order":"DESC"}]`
       */
      sort?: Sorting$7[];
      /** Array of projected fields. A list of specific field names to return. If `fieldsets` are also specified, the union of `fieldsets` and `fields` is returned. */
      fields?: string[];
      /** Array of named, predefined sets of projected fields. A array of predefined named sets of fields to be returned. Specifying multiple `fieldsets` will return the union of fields from all sets. If `fields` are also specified, the union of `fieldsets` and `fields` is returned. */
      fieldsets?: string[];
  }
  /** @oneof */
  interface QueryV2PagingMethodOneOf$3 {
      /** Paging options to limit and skip the number of items. */
      paging?: Paging$3;
      /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
      cursorPaging?: CursorPaging$7;
  }
  interface Sorting$7 {
      /** Name of the field to sort by. */
      fieldName?: string;
      /** Sort order. */
      order?: SortOrder$7;
      /**
       * When `field_name` is a property of repeated field that is marked as `MATCH_ITEMS` and sort should be done by
       * a specific element from a collection, filter can/should be provided to ensure correct sort value is picked.
       *
       * If multiple filters are provided, they are combined with AND operator.
       *
       * Example:
       * Given we have document like {"id": "1", "nestedField": [{"price": 10, "region": "EU"}, {"price": 20, "region": "US"}]}
       * and `nestedField` is marked as `MATCH_ITEMS`, to ensure that sorting is done by correct region, filter should be
       * { fieldName: "nestedField.price", "select_items_by": [{"nestedField.region": "US"}] }
       * @internal
       */
      selectItemsBy?: Record<string, any>[] | null;
  }
  enum SortOrder$7 {
      ASC = "ASC",
      DESC = "DESC"
  }
  interface Paging$3 {
      /** Number of items to load. */
      limit?: number | null;
      /** Number of items to skip in the current sort order. */
      offset?: number | null;
  }
  interface CursorPaging$7 {
      /** Maximum number of items to return in the results. */
      limit?: number | null;
      /**
       * Pointer to the next or previous page in the list of results.
       *
       * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
       * Not relevant for the first request.
       */
      cursor?: string | null;
  }
  interface QueryExtendedBookingResponse {
      /**
       * Retrieved bookings and additional information about attendance or actions
       * the customer can perform
       */
      extendedBookings?: ExtendedBooking[];
      /** Paging metadata. */
      pagingMetadata?: PagingMetadataV2$2;
  }
  interface PagingMetadataV2$2 {
      /** Number of items returned in the response. */
      count?: number | null;
      /** Offset that was requested. */
      offset?: number | null;
      /** Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set. */
      total?: number | null;
      /** Flag that indicates the server failed to calculate the `total` field. */
      tooManyToCount?: boolean | null;
      /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
      cursors?: Cursors$7;
      /**
       * Indicates if there are more results after the current page.
       * If `true`, another page of results can be retrieved.
       * If `false`, this is the last page.
       * @internal
       */
      hasNext?: boolean | null;
  }
  interface Cursors$7 {
      /** Cursor string pointing to the next page in the list of results. */
      next?: string | null;
      /** Cursor pointing to the previous page in the list of results. */
      prev?: string | null;
  }
  interface QueryExtendedBookingsRequest {
      /** Information about filters, paging, and sorting. */
      query: CommonQueryV2;
      /**
       * Whether information about which actions the customer can perform
       * for the bookings is returned.
       */
      withBookingAllowedActions?: boolean;
      /** Whether information about the attendance for the bookings is returned. */
      withBookingAttendanceInfo?: boolean;
      /** Whether information about the online conferencing details for the bookings is returned. */
      withBookingConferencingDetails?: boolean;
      /**
       * Whether to retrieve information about booking policy settings.
       * You must have the `BOOKINGS.BOOKING_POLICY_SNAPSHOT_READ` permission scope
       * when passing `true`.
       *
       * Default: `false`.
       * @internal
       */
      withBookingPolicySettings?: boolean;
      /**
       * Whether to retrieve information about the booking fee statuses.
       * Information about booking fees with a status of `PREVIEW` isn't returned.
       * You must have the `BOOKINGS.BOOKING_FEES_READ` permission scope when passing
       * `true`. In order to retrieve complete booking fee objects or to get information
       * about `PREVIEW` fees, use [List Booking Fees By Booking Ids](https://dev.wix.com/docs/rest/business-solutions/bookings/booking-fees/list-booking-fees-by-booking-ids)
       * instead.
       *
       * Default: `false`.
       * @internal
       */
      withBookingFeeDetails?: boolean;
  }
  interface CommonQueryV2 extends CommonQueryV2PagingMethodOneOf {
      /** Paging options to limit and skip the number of items. */
      paging?: CommonPaging;
      /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
      cursorPaging?: CursorPaging$7;
      /**
       * Filter object in the following format:
       * `"filter" : {
       * "fieldName1": "value1",
       * "fieldName2":{"$operator":"value2"}
       * }`
       * Example of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`, `$contains`
       *
       *   See [Supported Filters](https://www.wix.com/velo/reference/wix-bookings-v2/extendedbookings/supported-filters)
       * for a full list.
       */
      filter?: Record<string, any> | null;
      /**
       * Sort object in the following format:
       * `[{"fieldName":"sortField1","order":"ASC"},{"fieldName":"sortField2","order":"DESC"}]`
       */
      sort?: Sorting$7[];
  }
  /** @oneof */
  interface CommonQueryV2PagingMethodOneOf {
      /** Paging options to limit and skip the number of items. */
      paging?: CommonPaging;
      /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
      cursorPaging?: CursorPaging$7;
  }
  interface CommonPaging {
      /** Number of items to load. */
      limit?: number | null;
      /** Number of items to skip in the current sort order. */
      offset?: number | null;
  }
  interface QueryExtendedBookingsResponse {
      /**
       * Retrieved bookings and additional information, such as information about about the attendance or actions
       * the customer can perform.
       */
      extendedBookings?: ExtendedBooking[];
      /** Paging metadata. */
      pagingMetadata?: PagingMetadataV2$2;
  }
  /**
   * > **Deprecation Notice**
   * >
   * > **This endpoint has been replaced with [Query Extended Bookings](https://dev.wix.com/api/rest/wix-bookings/bookings-reader-v2/query-extended-bookings) and will be removed on May 31, 2025.**
   * > **If your app uses this endpoint, we recommend updating your code as soon as possible.**
   *
   *
   * Retrieves a list of bookings, given the provided paging, filtering, and sorting.
   *
   *
   * You can also retrieve information about which actions the customer can perform
   * for the bookings. To do so, pass `withBookingAllowedActions` as `true`.
   *
   * Query Bookings runs with these defaults:
   *
   * - `createdDate` sorted in `DESC` order
   * - `cursorPaging.limit` is `50`
   *
   * You can check the overview about all
   * [supported filters](https://dev.wix.com/api/rest/wix-bookings/bookings-reader-v2/supported-filters)
   * for more information.
   *
   * `query.fields` and `query.fieldsets` aren't supported for this endpoint.
   *
   * You can only specify a filter only once per query. If a filter is provided
   * more than once, only the first occurrence affects the returned bookings.
   *
   * When using filters for dates, you must use [UTC time](https://en.wikipedia.org/wiki/Coordinated_Universal_Time).
   *
   * Bookings belonging to a schedule don't have a `sessionId`. Therefore you
   * must use the `sessionId` filter that isn't part of the `query` object to
   * filter bookings for courses.
   *
   * To learn about working with _Query_ endpoints, see
   * [API Query Language](https://dev.wix.com/api/rest/getting-started/api-query-language),
   * [Sorting and Paging](https://dev.wix.com/api/rest/getting-started/sorting-and-paging),
   * and [Field Projection](https://dev.wix.com/api/rest/getting-started/field-projection).
   *
   * When calling Query Bookings, the retrieved data may not contain your most recent changes. See
   * [Wix-data and Eventual Consistency](reference/wix-data/introduction#wix-data_introduction_wix-data-and-eventual-consistency)
   * for more information.
   * @public
   * @documentationMaturity preview
   * @requiredField query
   * @param query - Information about filters, paging, and sorting.
   * @param options - Additional options for performing the query.
   * @permissionId BOOKINGS.BOOKING_READ
   * @deprecated
   */
  function query$1(query: QueryV2$3, options?: QueryOptions$1): Promise<QueryExtendedBookingResponse>;
  interface QueryOptions$1 {
      /**
       * Whether information about which actions the customer can perform
       * for the bookings is returned.
       */
      withBookingAllowedActions?: boolean;
      /** Whether information about the attendance for the bookings is returned. */
      withBookingAttendanceInfo?: boolean;
      /**
       * Filters the retrieved bookings by the booking ID that corresponds to
       * specified `sessionId`. The `booking.id` is calculated by calling
       * [Get Session](https://dev.wix.com/api/rest/wix-bookings/schedules-and-sessions/session/get-session)
       * and saving the returned values for `participants.Id`.
       * These participant IDs are then used as `booking.id`.
       * This filter overrides the `booking.id` filter inside the query object.
       *
       * __Note__: Bookings for courses don't include a `sessionId`. For these
       * bookings, you must use this field to filter by session ID.
       */
      sessionId?: string | null;
      /**
       * Whether information about the total entities is returned.
       * @internal
       */
      withPagingMetadataTotal?: boolean;
      /**
       * Whether information about the online conferencing details for the bookings is returned.
       * @internal
       */
      withBookingConferencingDetails?: boolean;
      /**
       * Whether to retrieve information about booking policy settings.
       * You must have the `BOOKINGS.BOOKING_POLICY_SNAPSHOT_READ` permission scope
       * when passing `true`.
       *
       * Default: `false`.
       * @internal
       */
      withBookingPolicySettings?: boolean;
      /**
       * Whether to retrieve information about the booking fee statuses.
       * Information about booking fees with a status of `PREVIEW` isn't returned.
       * You must have the `BOOKINGS.BOOKING_FEES_READ` permission scope when passing
       * `true`. In order to retrieve complete booking fee objects or to get information
       * about `PREVIEW` fees, use [List Booking Fees By Booking Ids](https://dev.wix.com/docs/rest/business-solutions/bookings/booking-fees/list-booking-fees-by-booking-ids)
       * instead.
       *
       * Default: `false`.
       * @internal
       */
      withBookingFeeDetails?: boolean;
  }
  /**
   * Retrieves a list of bookings, including additional extended information, given the provided paging, filtering, and sorting.
   *
   * Up to 100 extended bookings can be returned per request.
   *
   * `queryExtendedBookings()` runs with these defaults, which you can override:
   *
   * - `createdDate` sorted in `DESC` order
   * - `cursorPaging.limit` is `50`
   *
   *
   * You can retrieve information about which actions the customer can perform
   * for the bookings. To do so, pass `withBookingAllowedActions` as `true`.
   *
   *
   * For field support, see
   * [supported filters](https://www.wix.com/velo/reference/wix-bookings-v2/extendedbookings/supported-filters)
   * for more information.
   *
   * You can specify a filter only once per query. If you specify a filter
   * more than once, only the first filter determines the extended bookings that are returned.
   *
   * When filtering by date, you must use [UTC time](https://en.wikipedia.org/wiki/Coordinated_Universal_Time).
   * @public
   * @documentationMaturity preview
   * @requiredField query
   * @param query - Information about filters, paging, and sorting.
   * @param options - Additional options for performing the query.
   * @permissionId BOOKINGS.BOOKING_READ
   * @permissionId BOOKINGS.MANAGE_BOOKINGS
   * @permissionId BOOKINGS.BOOKING_READ_ANY
   */
  function queryExtendedBookings(query: CommonQueryV2, options?: QueryExtendedBookingsOptions): Promise<QueryExtendedBookingsResponse>;
  interface QueryExtendedBookingsOptions {
      /**
       * Whether information about which actions the customer can perform
       * for the bookings is returned.
       */
      withBookingAllowedActions?: boolean;
      /** Whether information about the attendance for the bookings is returned. */
      withBookingAttendanceInfo?: boolean;
      /** Whether information about the online conferencing details for the bookings is returned. */
      withBookingConferencingDetails?: boolean;
      /**
       * Whether to retrieve information about booking policy settings.
       * You must have the `BOOKINGS.BOOKING_POLICY_SNAPSHOT_READ` permission scope
       * when passing `true`.
       *
       * Default: `false`.
       * @internal
       */
      withBookingPolicySettings?: boolean;
      /**
       * Whether to retrieve information about the booking fee statuses.
       * Information about booking fees with a status of `PREVIEW` isn't returned.
       * You must have the `BOOKINGS.BOOKING_FEES_READ` permission scope when passing
       * `true`. In order to retrieve complete booking fee objects or to get information
       * about `PREVIEW` fees, use [List Booking Fees By Booking Ids](https://dev.wix.com/docs/rest/business-solutions/bookings/booking-fees/list-booking-fees-by-booking-ids)
       * instead.
       *
       * Default: `false`.
       * @internal
       */
      withBookingFeeDetails?: boolean;
  }
  
  type bookingsReaderV2ExtendedBooking_universal_d_ExtendedBooking = ExtendedBooking;
  type bookingsReaderV2ExtendedBooking_universal_d_ConferencingDetails = ConferencingDetails;
  type bookingsReaderV2ExtendedBooking_universal_d_BookingFeeDetails = BookingFeeDetails;
  type bookingsReaderV2ExtendedBooking_universal_d_BookingFeeStatus = BookingFeeStatus;
  const bookingsReaderV2ExtendedBooking_universal_d_BookingFeeStatus: typeof BookingFeeStatus;
  type bookingsReaderV2ExtendedBooking_universal_d_QueryExtendedBookingRequest = QueryExtendedBookingRequest;
  type bookingsReaderV2ExtendedBooking_universal_d_QueryExtendedBookingResponse = QueryExtendedBookingResponse;
  type bookingsReaderV2ExtendedBooking_universal_d_QueryExtendedBookingsRequest = QueryExtendedBookingsRequest;
  type bookingsReaderV2ExtendedBooking_universal_d_CommonQueryV2 = CommonQueryV2;
  type bookingsReaderV2ExtendedBooking_universal_d_CommonQueryV2PagingMethodOneOf = CommonQueryV2PagingMethodOneOf;
  type bookingsReaderV2ExtendedBooking_universal_d_CommonPaging = CommonPaging;
  type bookingsReaderV2ExtendedBooking_universal_d_QueryExtendedBookingsResponse = QueryExtendedBookingsResponse;
  const bookingsReaderV2ExtendedBooking_universal_d_queryExtendedBookings: typeof queryExtendedBookings;
  type bookingsReaderV2ExtendedBooking_universal_d_QueryExtendedBookingsOptions = QueryExtendedBookingsOptions;
  namespace bookingsReaderV2ExtendedBooking_universal_d {
    export {
      bookingsReaderV2ExtendedBooking_universal_d_ExtendedBooking as ExtendedBooking,
      AttendanceStatus$1 as AttendanceStatus,
      Booking$2 as Booking,
      BookingParticipantsInfoOneOf$2 as BookingParticipantsInfoOneOf,
      MultiServiceBookingType$2 as MultiServiceBookingType,
      BookedEntity$2 as BookedEntity,
      BookedEntityItemOneOf$2 as BookedEntityItemOneOf,
      BookedSlot$2 as BookedSlot,
      BookedResource$2 as BookedResource,
      Location$4 as Location,
      LocationType$4 as LocationType,
      BookedSchedule$2 as BookedSchedule,
      ContactDetails$2 as ContactDetails,
      Address$5 as Address,
      AddressStreetOneOf$4 as AddressStreetOneOf,
      StreetAddress$4 as StreetAddress,
      AddressLocation$4 as AddressLocation,
      Subdivision$4 as Subdivision,
      CustomFormField$2 as CustomFormField,
      ValueType$2 as ValueType,
      BookingStatus$2 as BookingStatus,
      PaymentStatus$2 as PaymentStatus,
      SelectedPaymentOption$2 as SelectedPaymentOption,
      BookingSource$2 as BookingSource,
      Platform$2 as Platform,
      Actor$2 as Actor,
      ParticipantNotification$5 as ParticipantNotification,
      IdentificationData$8 as IdentificationData,
      IdentificationDataIdOneOf$8 as IdentificationDataIdOneOf,
      IdentityType$3 as IdentityType,
      FlowControlSettings$2 as FlowControlSettings,
      ExtendedFields$7 as ExtendedFields,
      ParticipantChoices$2 as ParticipantChoices,
      ServiceChoices$2 as ServiceChoices,
      ServiceChoice$2 as ServiceChoice,
      ServiceChoiceChoiceOneOf$2 as ServiceChoiceChoiceOneOf,
      MultiServiceBookingInfo$2 as MultiServiceBookingInfo,
      AllowedActions$1 as AllowedActions,
      Attendance$1 as Attendance,
      bookingsReaderV2ExtendedBooking_universal_d_ConferencingDetails as ConferencingDetails,
      BookingPolicySettings$1 as BookingPolicySettings,
      bookingsReaderV2ExtendedBooking_universal_d_BookingFeeDetails as BookingFeeDetails,
      bookingsReaderV2ExtendedBooking_universal_d_BookingFeeStatus as BookingFeeStatus,
      bookingsReaderV2ExtendedBooking_universal_d_QueryExtendedBookingRequest as QueryExtendedBookingRequest,
      QueryV2$3 as QueryV2,
      QueryV2PagingMethodOneOf$3 as QueryV2PagingMethodOneOf,
      Sorting$7 as Sorting,
      SortOrder$7 as SortOrder,
      Paging$3 as Paging,
      CursorPaging$7 as CursorPaging,
      bookingsReaderV2ExtendedBooking_universal_d_QueryExtendedBookingResponse as QueryExtendedBookingResponse,
      PagingMetadataV2$2 as PagingMetadataV2,
      Cursors$7 as Cursors,
      bookingsReaderV2ExtendedBooking_universal_d_QueryExtendedBookingsRequest as QueryExtendedBookingsRequest,
      bookingsReaderV2ExtendedBooking_universal_d_CommonQueryV2 as CommonQueryV2,
      bookingsReaderV2ExtendedBooking_universal_d_CommonQueryV2PagingMethodOneOf as CommonQueryV2PagingMethodOneOf,
      bookingsReaderV2ExtendedBooking_universal_d_CommonPaging as CommonPaging,
      bookingsReaderV2ExtendedBooking_universal_d_QueryExtendedBookingsResponse as QueryExtendedBookingsResponse,
      query$1 as query,
      QueryOptions$1 as QueryOptions,
      bookingsReaderV2ExtendedBooking_universal_d_queryExtendedBookings as queryExtendedBookings,
      bookingsReaderV2ExtendedBooking_universal_d_QueryExtendedBookingsOptions as QueryExtendedBookingsOptions,
    };
  }
  
  /**
   * A resource represents an entity that can be scheduled for use, such as a room or a staff member.
   * The availability of a resource is tracked to ensure that it can be allocated at a requested time slot and to prevent double bookings.
   * Read more about resources in this [article](https://support.wix.com/en/article/wix-bookings-managing-your-resources).
   */
  interface Resource$2 extends ResourceCompositionDetailsOneOf {
      /**
       * Details of a single resource.
       * @internal
       * @deprecated Details of a single resource.
       * @targetRemovalDate 2025-01-01
       */
      singleResource?: SingleResource;
      /**
       * Resource ID
       * @readonly
       */
      _id?: string | null;
      /**
       * Revision number, which increments by 1 each time the staff member is updated.
       * To prevent conflicting changes,
       * the current revision must be passed when updating the staff member.
       * @readonly
       */
      revision?: string | null;
      /**
       * Represents the time this resource was created.
       * @readonly
       */
      _createdDate?: Date | null;
      /**
       * Represents the time this resource was last updated.
       * @readonly
       */
      _updatedDate?: Date | null;
      /** Name of the resource. */
      name?: string | null;
      /**
       * The type of the resource.
       *
       * Resources can be created without a type. However, this field must be set to ensure that a resource can be allocated
       * at a requested time slot and to prevent double bookings.
       *
       * The value to assign to this field depends on how the type is managed. There are 2 options:
       * - The resource type is managed by a user (for example the site owner or contributor) in the Resources section of the
       * dashboard or it is managed via the `/v2/resource-types` endpoint.
       * In this case, the `type` field must be set to the id of the resource type entity.
       * - The resource type is managed by an app implementing the `BOOKINGS_RESOURCE_TYPES_PROVIDER` SPI component.
       * In this case the `type` field must match one of the `id` fields in the `bookingsResourceTypes` structure of the SPI configuration.
       *
       * Once a type has been set it cannot be modified.
       * @deprecated
       * @replacedBy type_id
       * @targetRemovalDate 2025-01-01
       */
      type?: string | null;
      typeId?: string | null;
      /**
       * Schedule details that specify the working hours and locations of this resource.
       *
       * When this field is not set or  `working_hours_schedules.enabled` is `false` then the resource is assumed to be
       * available full time (7 x 24) at the locations specified in the field `location_options`.
       * When both `working_hours_schedules` and `location_options` are set then `working_hours_schedules` takes precedence.
       */
      workingHoursSchedules?: ResourceWorkingHoursSchedules;
      /**
       * Location details that specify where this resource is available.
       *
       * If this field is not supplied then `location_options.available_in_all_locations` is set to `true`.
       */
      locationOptions?: LocationOptions$1;
      /**
       * This schedule contains the sessions in which this resource has been booked.
       * @readonly
       */
      eventsSchedule?: EventsSchedule;
      /**
       * The ID of the app of which this resource belongs to.
       * Default: Bookings App ID.
       * @internal
       */
      appId?: string | null;
      /**
       * Specifies whether this resource is managed by a user (site owner, contributor, etc) or by an app.
       * Default: `WIX_USER`.
       * @internal
       */
      managementType?: ManagementType;
      /** Extensions enabling users to save custom data related to the resource. */
      extendedFields?: ExtendedFields$6;
  }
  /** @oneof */
  interface ResourceCompositionDetailsOneOf {
      /**
       * Details of a single resource.
       * @internal
       * @deprecated Details of a single resource.
       * @targetRemovalDate 2025-01-01
       */
      singleResource?: SingleResource;
  }
  interface WorkingHoursSchedule$1 {
      /** schedule ID */
      _id?: string | null;
      /**
       * Whether this schedule is used by multiple resources or unique for this resource.
       *
       * `true` if it is a shared schedule (for example from a business or location), `false` this is a custom schedule specific to the resource.
       * Default: `false`.
       * @readonly
       */
      shared?: boolean | null;
  }
  interface SingleResource {
      /**
       * Schedule details that specify the working hours and locations of this resource.
       *
       * When this field is not set or  `working_hours_schedules.enabled` is `false` then the resource is assumed to be
       * available full time (7 x 24) at the locations specified in the field `location_options`.
       * When both `working_hours_schedules` and `location_options` are set then `working_hours_schedules` takes precedence.
       */
      workingHoursSchedules?: WorkingHoursSchedules;
      /**
       * Location details that specify where this resource is available.
       *
       * If this field is not supplied then `location_options.available_in_all_locations` is set to `true`.
       */
      locationOptions?: LocationOptions$1;
      /**
       * This schedule contains the sessions in which this resource has been booked.
       * @readonly
       */
      eventsSchedule?: Schedule$2;
  }
  interface WorkingHoursSchedules {
      /**
       * Whether the working hours schedules is enabled.
       *
       * `true` if the working_hours_schedules should be considered for availability, `false` otherwise.
       * Default: `false`.
       * This field is currently marked as `NOT_IMPLEMENTED` until Resource Management will use this from the dashboard or through the API.
       */
      enabled?: boolean | null;
      /** schedules specifying all the working hours of the resource. Currently a single schedule is supported. */
      values?: Schedule$2[];
  }
  /** Deprecated and subject to removal */
  interface Schedule$2 {
      /** schedule ID */
      scheduleId?: string | null;
      /**
       * Whether this schedule is used by multiple resources or unique for this resource.
       *
       * `true` if it is a shared schedule (for example from a business or location), `false` this is a custom schedule specific to the resource.
       * Default: `false`.
       */
      shared?: boolean | null;
  }
  interface LocationOptions$1 {
      /**
       * `true` if the resource is available in all locations, `false` if the resource is available only in specific locations.
       * Default: `false`.
       */
      availableInAllLocations?: boolean | null;
      /**
       * Details of specific locations. It must be left empty if `available_in_all_locations` is `true`.
       * If supplied then the field `specific_location_options.available_in_business_locations` must be set to `true`.
       */
      specificLocationOptions?: SpecificLocation$1;
  }
  interface SpecificLocation$1 {
      /**
       * `true` if the resource can be used at a customer selected location, `false` otherwise.
       * Read more about locations in this [article](https://dev.wix.com/docs/rest/business-solutions/bookings/services/services-v2/about-service-locations).
       * Default: `false`.
       * @internal
       */
      availableInCustomerLocations?: boolean | null;
      /**
       * `true` if the resource is available in custom locations, `false` otherwise.
       * Default: `false`.
       * @internal
       */
      availableInCustomLocations?: boolean | null;
      /**
       * `true` if the resource is available in some business locations, `false` otherwise.
       * Default: `false`.
       */
      availableInBusinessLocations?: boolean | null;
      /**
       * Information about business locations. Should be empty if `available_in_business_locations` is `false` or if no business location exists in Locations.
       * Currently a single business location can be set.
       * Read more about business locations in this [article](https://dev.wix.com/docs/rest/business-management/locations/introduction).
       */
      businessLocations?: BusinessLocation$2[];
  }
  interface BusinessLocation$2 {
      /** The ID of the business location. Must not be empty. */
      locationId?: string | null;
  }
  interface ResourceWorkingHoursSchedules {
      /** schedules specifying all the working hours of the resource. Currently a single schedule is supported. */
      values?: WorkingHoursSchedule$1[];
  }
  interface EventsSchedule {
      /** schedule ID */
      _id?: string | null;
  }
  enum ManagementType {
      UNKNOWN_MANAGEMENT_TYPE = "UNKNOWN_MANAGEMENT_TYPE",
      /** The resource is managed by an app. */
      APP = "APP",
      /** The resource is managed by a Wix user. */
      WIX_USER = "WIX_USER"
  }
  interface ExtendedFields$6 {
      /**
       * Extended field data. Each key corresponds to the namespace of the app that created the extended fields.
       * The value of each key is structured according to the schema defined when the extended fields were configured.
       *
       * You can only access fields for which you have the appropriate permissions.
       *
       * Learn more about [extended fields](https://dev.wix.com/docs/rest/articles/getting-started/extended-fields).
       */
      namespaces?: Record<string, Record<string, any>>;
  }
  interface CreateResourceRequest {
      /** Resource to be created. */
      resource: Resource$2;
  }
  interface CreateResourceResponse {
      /** The created resource. */
      resource?: Resource$2;
  }
  interface BulkCreateResourcesRequest {
      /** Resources to create. */
      resources: Resource$2[];
      /** `true` if the created entities must be included in the response, otherwise no entities are included in the response. */
      returnEntity?: boolean;
  }
  interface BulkCreateResourcesResponse {
      /** The result of each resource creation. */
      results?: BulkResourceResult[];
      /** Create statistics. */
      bulkActionMetadata?: BulkActionMetadata$3;
  }
  interface BulkResourceResult {
      /** Item metadata */
      itemMetadata?: ItemMetadata$3;
      /** The resulting resource after the bulk operation. */
      item?: Resource$2;
  }
  interface ItemMetadata$3 {
      /** Item ID. Should always be available, unless it's impossible (for example, when failing to create an item). */
      _id?: string | null;
      /** Index of the item within the request array. Allows for correlation between request and response items. */
      originalIndex?: number;
      /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
      success?: boolean;
      /** Details about the error in case of failure. */
      error?: ApplicationError$3;
  }
  interface ApplicationError$3 {
      /** Error code. */
      code?: string;
      /** Description of the error. */
      description?: string;
      /** Data related to the error. */
      data?: Record<string, any> | null;
  }
  interface BulkActionMetadata$3 {
      /** Number of items that were successfully processed. */
      totalSuccesses?: number;
      /** Number of items that couldn't be processed. */
      totalFailures?: number;
      /** Number of failures without details because detailed failure threshold was exceeded. */
      undetailedFailures?: number;
  }
  interface GetResourceRequest {
      /** Id of the resource to retrieve. */
      resourceId: string;
  }
  interface GetResourceResponse {
      /** The retrieved resource. */
      resource?: Resource$2;
  }
  interface GetDeletedResourceRequest {
      /** Id of the resource to retrieve. */
      resourceId: string;
  }
  interface GetDeletedResourceResponse {
      /** The retrieved resource. */
      resource?: Resource$2;
  }
  interface ListDeletedResourcesRequest {
      /** The ids of the resources to retrieve. */
      resourceIds?: string[];
      /** Paging parameter, enabling to pass a limit and a cursor. */
      paging?: CursorPaging$6;
  }
  interface CursorPaging$6 {
      /** Maximum number of items to return in the results. */
      limit?: number | null;
      /**
       * Pointer to the next or previous page in the list of results.
       *
       * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
       * Not relevant for the first request.
       */
      cursor?: string | null;
  }
  interface ListDeletedResourcesResponse {
      /** The retrieved Resources */
      resources?: Resource$2[];
      /** Paging metadata */
      pagingMetadata?: CursorPagingMetadata$5;
  }
  interface CursorPagingMetadata$5 {
      /** Number of items returned in the response. */
      count?: number | null;
      /** Cursor strings that point to the next page, previous page, or both. */
      cursors?: Cursors$6;
      /**
       * Whether there are more pages to retrieve following the current page.
       *
       * + `true`: Another page of results can be retrieved.
       * + `false`: This is the last page.
       */
      hasNext?: boolean | null;
  }
  interface Cursors$6 {
      /** Cursor string pointing to the next page in the list of results. */
      next?: string | null;
      /** Cursor pointing to the previous page in the list of results. */
      prev?: string | null;
  }
  interface RemoveResourceFromTrashBinRequest {
      /** Id of the resource to remove from the trash bin. */
      resourceId: string;
  }
  interface RemoveResourceFromTrashBinResponse {
  }
  interface RestoreResourceFromTrashBinRequest {
      /** Id of the resource to restore from the trash bin. */
      resourceId: string;
  }
  interface RestoreResourceFromTrashBinResponse {
      /** The restored resource. */
      resource?: Resource$2;
  }
  interface UpdateResourceRequest {
      /** Resource to be updated, may be partial. */
      resource: Resource$2;
      /**
       * Explicit list of fields to update.
       * @internal
       */
      mask?: string[];
  }
  interface UpdateResourceResponse {
      /** The updated resource. */
      resource?: Resource$2;
  }
  interface DeleteResourceRequest {
      /** Id of the resource to delete. */
      resourceId: string;
  }
  interface DeleteResourceResponse {
  }
  interface BulkDeleteResourcesRequest {
      /** The ids of the resources to delete. */
      ids: string[];
  }
  interface BulkDeleteResourcesResponse {
      /** The result of each resource removal. */
      results?: BulkResourceResult[];
      /** Delete statistics. */
      bulkActionMetadata?: BulkActionMetadata$3;
  }
  interface SearchResourcesRequest {
      /** Search condition */
      search?: CursorSearch$2;
  }
  interface CursorSearch$2 extends CursorSearchPagingMethodOneOf$2 {
      /**
       * Cursor pointing to page of results.
       * When requesting 'cursor_paging.cursor', no `filter`, `sort` or `search` can be provided.
       */
      cursorPaging?: CursorPaging$6;
      /** A filter object. See documentation [here](https://bo.wix.com/wix-docs/rnd/platformization-guidelines/api-query-language#platformization-guidelines_api-query-language_defining-in-protobuf) */
      filter?: Record<string, any> | null;
      /** Sort object in the form [{"fieldName":"sortField1"},{"fieldName":"sortField2","direction":"DESC"}] */
      sort?: Sorting$6[];
      /** Aggregations | Faceted search: refers to a way to explore large amounts of data by displaying summaries about various partitions of the data and later allowing to narrow the navigation to a specific partition. */
      aggregations?: Aggregation$1[];
      /** Free text to match in searchable fields */
      search?: SearchDetails$2;
      /**
       * UTC offset or IANA time zone. Valid values are
       * ISO 8601 UTC offsets, such as +02:00 or -06:00,
       * and IANA time zone IDs, such as Europe/Rome
       *
       * Affects all filters and aggregations returned values.
       * You may override this behavior in a specific filter by providing
       * timestamps including time zone. e.g. `"2023-12-20T10:52:34.795Z"`
       */
      timeZone?: string | null;
  }
  /** @oneof */
  interface CursorSearchPagingMethodOneOf$2 {
      /**
       * Cursor pointing to page of results.
       * When requesting 'cursor_paging.cursor', no `filter`, `sort` or `search` can be provided.
       */
      cursorPaging?: CursorPaging$6;
  }
  interface Sorting$6 {
      /** Name of the field to sort by. */
      fieldName?: string;
      /** Sort order. */
      order?: SortOrder$6;
      /**
       * When `field_name` is a property of repeated field that is marked as `MATCH_ITEMS` and sort should be done by
       * a specific element from a collection, filter can/should be provided to ensure correct sort value is picked.
       *
       * If multiple filters are provided, they are combined with AND operator.
       *
       * Example:
       * Given we have document like {"id": "1", "nestedField": [{"price": 10, "region": "EU"}, {"price": 20, "region": "US"}]}
       * and `nestedField` is marked as `MATCH_ITEMS`, to ensure that sorting is done by correct region, filter should be
       * { fieldName: "nestedField.price", "select_items_by": [{"nestedField.region": "US"}] }
       * @internal
       */
      selectItemsBy?: Record<string, any>[] | null;
  }
  enum SortOrder$6 {
      ASC = "ASC",
      DESC = "DESC"
  }
  interface Aggregation$1 extends AggregationKindOneOf$1 {
      /** Value aggregation */
      value?: ValueAggregation$1;
      /** Range aggregation */
      range?: RangeAggregation$1;
      /** Scalar aggregation */
      scalar?: ScalarAggregation$1;
      /** Date histogram aggregation */
      dateHistogram?: DateHistogramAggregation$1;
      /** Nested aggregation */
      nested?: NestedAggregation$1;
      /** User-defined name of aggregation, should be unique, will appear in aggregation results */
      name?: string | null;
      /** Type of aggregation, client must provide matching aggregation field below */
      type?: AggregationType$2;
      /** Field to aggregate by, use dot notation to specify json path */
      fieldPath?: string;
      /**
       * deprecated, use `nested` instead
       * @deprecated deprecated, use `nested` instead
       * @replacedBy kind.nested
       * @targetRemovalDate 2024-03-30
       */
      groupBy?: GroupByAggregation$1;
  }
  /** @oneof */
  interface AggregationKindOneOf$1 {
      /** Value aggregation */
      value?: ValueAggregation$1;
      /** Range aggregation */
      range?: RangeAggregation$1;
      /** Scalar aggregation */
      scalar?: ScalarAggregation$1;
      /** Date histogram aggregation */
      dateHistogram?: DateHistogramAggregation$1;
      /** Nested aggregation */
      nested?: NestedAggregation$1;
  }
  interface RangeBucket$1 {
      /** Inclusive lower bound of the range. Required if to is not given */
      from?: number | null;
      /** Exclusive upper bound of the range. Required if from is not given */
      to?: number | null;
  }
  enum SortType$1 {
      /** Should sort by number of matches */
      COUNT = "COUNT",
      /** Should sort by value of the field alphabetically */
      VALUE = "VALUE"
  }
  enum SortDirection$1 {
      /** Should sort in descending order */
      DESC = "DESC",
      /** Should sort in ascending order */
      ASC = "ASC"
  }
  enum MissingValues$1 {
      /** Should missing values be excluded from the aggregation results */
      EXCLUDE = "EXCLUDE",
      /** Should missing values be included in the aggregation results */
      INCLUDE = "INCLUDE"
  }
  interface IncludeMissingValuesOptions$1 {
      /** Can specify custom bucket name. Defaults are [string -> "N/A"], [int -> "0"], [bool -> "false"] ... */
      addToBucket?: string;
  }
  enum ScalarType$2 {
      UNKNOWN_SCALAR_TYPE = "UNKNOWN_SCALAR_TYPE",
      /** Count of distinct values */
      COUNT_DISTINCT = "COUNT_DISTINCT",
      /** Minimum value */
      MIN = "MIN",
      /** Maximum value */
      MAX = "MAX",
      /** Sum of values */
      SUM = "SUM",
      /** Average of values */
      AVG = "AVG"
  }
  interface ValueAggregation$1 extends ValueAggregationOptionsOneOf$1 {
      /** Options for including missing values */
      includeOptions?: IncludeMissingValuesOptions$1;
      /** Should sort by number of matches or value of the field */
      sortType?: SortType$1;
      /** Should sort in ascending or descending order */
      sortDirection?: SortDirection$1;
      /** How many aggregations would you like to return? Can be between 1 and 250. 10 is the default. */
      limit?: number | null;
      /** Should missing values be included or excluded from the aggregation results. Default is EXCLUDE */
      missingValues?: MissingValues$1;
  }
  /** @oneof */
  interface ValueAggregationOptionsOneOf$1 {
      /** Options for including missing values */
      includeOptions?: IncludeMissingValuesOptions$1;
  }
  enum NestedAggregationType$1 {
      UNKNOWN_AGGREGATION_TYPE = "UNKNOWN_AGGREGATION_TYPE",
      /** An aggregation where result buckets are dynamically built - one per unique value */
      VALUE = "VALUE",
      /** An aggregation, where user can define set of ranges - each representing a bucket */
      RANGE = "RANGE",
      /** A single-value metric aggregation - e.g. min, max, sum, avg */
      SCALAR = "SCALAR",
      /** An aggregation, where result buckets are dynamically built - one per time interval (hour, day, week, etc.) */
      DATE_HISTOGRAM = "DATE_HISTOGRAM"
  }
  interface RangeAggregation$1 {
      /** List of range buckets, where during aggregation each entity will be placed in the first bucket where its value falls into based on provided range bounds */
      buckets?: RangeBucket$1[];
  }
  interface ScalarAggregation$1 {
      /** Define the operator for the scalar aggregation */
      type?: ScalarType$2;
  }
  interface DateHistogramAggregation$1 {
      /** Interval for date histogram aggregation */
      interval?: Interval$2;
  }
  enum Interval$2 {
      UNKNOWN_INTERVAL = "UNKNOWN_INTERVAL",
      /** Yearly interval */
      YEAR = "YEAR",
      /** Monthly interval */
      MONTH = "MONTH",
      /** Weekly interval */
      WEEK = "WEEK",
      /** Daily interval */
      DAY = "DAY",
      /** Hourly interval */
      HOUR = "HOUR",
      /** Minute interval */
      MINUTE = "MINUTE",
      /** Second interval */
      SECOND = "SECOND"
  }
  interface NestedAggregationItem$1 extends NestedAggregationItemKindOneOf$1 {
      /** Value aggregation */
      value?: ValueAggregation$1;
      /** Range aggregation */
      range?: RangeAggregation$1;
      /** Scalar aggregation */
      scalar?: ScalarAggregation$1;
      /** Date histogram aggregation */
      dateHistogram?: DateHistogramAggregation$1;
      /** User-defined name of aggregation, should be unique, will appear in aggregation results */
      name?: string | null;
      /** Type of aggregation, client must provide matching aggregation field below */
      type?: NestedAggregationType$1;
      /** Field to aggregate by, use dont notation to specify json path */
      fieldPath?: string;
  }
  /** @oneof */
  interface NestedAggregationItemKindOneOf$1 {
      /** Value aggregation */
      value?: ValueAggregation$1;
      /** Range aggregation */
      range?: RangeAggregation$1;
      /** Scalar aggregation */
      scalar?: ScalarAggregation$1;
      /** Date histogram aggregation */
      dateHistogram?: DateHistogramAggregation$1;
  }
  enum AggregationType$2 {
      UNKNOWN_AGGREGATION_TYPE = "UNKNOWN_AGGREGATION_TYPE",
      /** An aggregation where result buckets are dynamically built - one per unique value */
      VALUE = "VALUE",
      /** An aggregation, where user can define set of ranges - each representing a bucket */
      RANGE = "RANGE",
      /** A single-value metric aggregation - e.g. min, max, sum, avg */
      SCALAR = "SCALAR",
      /** An aggregation, where result buckets are dynamically built - one per time interval (hour, day, week, etc.) */
      DATE_HISTOGRAM = "DATE_HISTOGRAM",
      /** Multi-level aggregation, where each next aggregation is nested within previous one */
      NESTED = "NESTED"
  }
  /** Nested aggregation expressed through a list of aggregation where each next aggregation is nested within previous one */
  interface NestedAggregation$1 {
      /** Flattened list of aggregations, where each next aggregation is nested within previous one */
      nestedAggregations?: NestedAggregationItem$1[];
  }
  interface GroupByAggregation$1 extends GroupByAggregationKindOneOf$1 {
      /** Value aggregation configuration */
      value?: ValueAggregation$1;
      /** User-defined name of aggregation, should be unique, will appear in aggregation results */
      name?: string | null;
      /** Field to aggregate by */
      fieldPath?: string;
  }
  /** @oneof */
  interface GroupByAggregationKindOneOf$1 {
      /** Value aggregation configuration */
      value?: ValueAggregation$1;
  }
  interface SearchDetails$2 {
      /** Defines how separate search terms in `expression` are combined */
      mode?: Mode$2;
      /** Search term or expression */
      expression?: string | null;
      /** Fields to search in. If empty - will search in all searchable fields. Use dot notation to specify json path */
      fields?: string[];
      /** Flag if should use auto fuzzy search (allowing typos by a managed proximity algorithm) */
      fuzzy?: boolean;
  }
  enum Mode$2 {
      /** Any of the search terms must be present */
      OR = "OR",
      /** All search terms must be present */
      AND = "AND"
  }
  interface SearchResourcesResponse {
      /** The retrieved resources */
      resources?: Resource$2[];
      /** Paging metadata */
      pagingMetadata?: CursorPagingMetadata$5;
      /** Aggregation results */
      aggregationData?: AggregationData$2;
  }
  interface AggregationData$2 {
      /** key = aggregation name (as derived from search request) */
      results?: AggregationResults$2[];
  }
  interface ValueAggregationResult$2 {
      /** Value of the field */
      value?: string;
      /** Count of entities with this value */
      count?: number;
  }
  interface RangeAggregationResult$2 {
      /** Inclusive lower bound of the range */
      from?: number | null;
      /** Exclusive upper bound of the range */
      to?: number | null;
      /** Count of entities in this range */
      count?: number;
  }
  interface NestedAggregationResults$2 extends NestedAggregationResultsResultOneOf$2 {
      /** Value aggregation results */
      values?: ValueResults$2;
      /** Range aggregation results */
      ranges?: RangeResults$2;
      /** Scalar aggregation results */
      scalar?: AggregationResultsScalarResult;
      /** User-defined name of aggregation, matches the one provided in request */
      name?: string;
      /** Type of aggregation that matches result */
      type?: AggregationType$2;
      /** Field to aggregate by, matches the one provided in request */
      fieldPath?: string;
  }
  /** @oneof */
  interface NestedAggregationResultsResultOneOf$2 {
      /** Value aggregation results */
      values?: ValueResults$2;
      /** Range aggregation results */
      ranges?: RangeResults$2;
      /** Scalar aggregation results */
      scalar?: AggregationResultsScalarResult;
  }
  interface ValueResults$2 {
      /** List of value aggregations */
      results?: ValueAggregationResult$2[];
  }
  interface RangeResults$2 {
      /** List of ranges returned in same order as requested */
      results?: RangeAggregationResult$2[];
  }
  interface AggregationResultsScalarResult {
      /** Type of scalar aggregation */
      type?: ScalarType$2;
      /** Value of the scalar aggregation */
      value?: number;
  }
  interface NestedValueAggregationResult$2 {
      /** Value of the field */
      value?: string;
      /** Nested aggregations */
      nestedResults?: NestedAggregationResults$2;
  }
  interface ValueResult$1 {
      /** Value of the field */
      value?: string;
      /** Count of entities with this value */
      count?: number | null;
  }
  interface RangeResult$1 {
      /** Inclusive lower bound of the range */
      from?: number | null;
      /** Exclusive upper bound of the range */
      to?: number | null;
      /** Count of entities in this range */
      count?: number | null;
  }
  interface ScalarResult$2 {
      /** Value of the scalar aggregation */
      value?: number;
  }
  interface NestedResultValue$1 extends NestedResultValueResultOneOf$1 {
      /** Value aggregation result */
      value?: ValueResult$1;
      /** Range aggregation result */
      range?: RangeResult$1;
      /** Scalar aggregation result */
      scalar?: ScalarResult$2;
      /** Date histogram aggregation result */
      dateHistogram?: ValueResult$1;
  }
  /** @oneof */
  interface NestedResultValueResultOneOf$1 {
      /** Value aggregation result */
      value?: ValueResult$1;
      /** Range aggregation result */
      range?: RangeResult$1;
      /** Scalar aggregation result */
      scalar?: ScalarResult$2;
      /** Date histogram aggregation result */
      dateHistogram?: ValueResult$1;
  }
  interface Results$1 {
      /** List of nested aggregations */
      results?: Record<string, NestedResultValue$1>;
  }
  interface DateHistogramResult$1 {
      /** Date in ISO 8601 format */
      value?: string;
      /** Count of documents in the bucket */
      count?: number;
  }
  interface GroupByValueResults$2 {
      /** List of value aggregations */
      results?: NestedValueAggregationResult$2[];
  }
  interface DateHistogramResults$1 {
      /** List of date histogram aggregations */
      results?: DateHistogramResult$1[];
  }
  /**
   * Results of `NESTED` aggregation type in a flattened form
   * aggregations in resulting array are keyed by requested aggregation `name`.
   */
  interface NestedResults$1 {
      /** List of nested aggregations */
      results?: Results$1[];
  }
  interface AggregationResults$2 extends AggregationResultsResultOneOf$2 {
      /** Value aggregation results */
      values?: ValueResults$2;
      /** Range aggregation results */
      ranges?: RangeResults$2;
      /** Scalar aggregation results */
      scalar?: AggregationResultsScalarResult;
      /** Group by value aggregation results */
      groupedByValue?: GroupByValueResults$2;
      /** Date histogram aggregation results */
      dateHistogram?: DateHistogramResults$1;
      /** Nested aggregation results */
      nested?: NestedResults$1;
      /** User-defined name of aggregation as derived from search request */
      name?: string;
      /** Type of aggregation that must match provided kind as derived from search request */
      type?: AggregationType$2;
      /** Field to aggregate by as derived from search request */
      fieldPath?: string;
  }
  /** @oneof */
  interface AggregationResultsResultOneOf$2 {
      /** Value aggregation results */
      values?: ValueResults$2;
      /** Range aggregation results */
      ranges?: RangeResults$2;
      /** Scalar aggregation results */
      scalar?: AggregationResultsScalarResult;
      /** Group by value aggregation results */
      groupedByValue?: GroupByValueResults$2;
      /** Date histogram aggregation results */
      dateHistogram?: DateHistogramResults$1;
      /** Nested aggregation results */
      nested?: NestedResults$1;
  }
  interface QueryResourcesRequest {
      /** WQL expression. */
      query?: CursorQuery$4;
  }
  interface CursorQuery$4 extends CursorQueryPagingMethodOneOf$4 {
      /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
      cursorPaging?: CursorPaging$6;
      /**
       * Filter object in the following format:
       * `"filter" : {
       * "fieldName1": "value1",
       * "fieldName2":{"$operator":"value2"}
       * }`
       * Example of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`, `$contains`
       */
      filter?: Record<string, any> | null;
      /**
       * Sort object in the following format:
       * `[{"fieldName":"sortField1","order":"ASC"},{"fieldName":"sortField2","order":"DESC"}]`
       */
      sort?: Sorting$6[];
  }
  /** @oneof */
  interface CursorQueryPagingMethodOneOf$4 {
      /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
      cursorPaging?: CursorPaging$6;
  }
  interface QueryResourcesResponse {
      /** The retrieved Resources. */
      resources?: Resource$2[];
      /** Paging metadata */
      pagingMetadata?: CursorPagingMetadata$5;
  }
  interface CountResourcesRequest {
      /** Filter to apply on resources to count. */
      filter?: Record<string, any> | null;
      /**
       * @deprecated
       * @targetRemovalDate 2024-05-01
       */
      search?: SearchDetails$2;
  }
  interface CountResourcesResponse {
      /** The number of resources matching the given filter. */
      count?: number;
  }
  interface ImportResourceRequest {
      /** Resource to be imported. */
      resource?: Resource$2;
  }
  interface ImportResourceResponse {
      /** The imported resource. */
      resource?: Resource$2;
  }
  interface FixResourceSchedulesRequest {
      /** Id of the resource of which the schedules must be fixed */
      resourceId?: string;
      /** the working hours schedule that must be set for this resource. */
      workingHoursSchedule?: Schedule$2;
  }
  interface FixResourceSchedulesResponse {
      /** The resource with the fixed schedule IDs. */
      resource?: Resource$2;
  }
  interface ReindexTenantRequest {
  }
  interface ReindexTenantResponse {
  }
  interface MetaSiteSpecialEvent$1 extends MetaSiteSpecialEventPayloadOneOf$1 {
      /** Emitted on a meta site creation. */
      siteCreated?: SiteCreated$3;
      /** Emitted on a meta site transfer completion. */
      siteTransferred?: SiteTransferred$1;
      /** Emitted on a meta site deletion. */
      siteDeleted?: SiteDeleted$1;
      /** Emitted on a meta site restoration. */
      siteUndeleted?: SiteUndeleted$1;
      /** Emitted on the first* publish of the meta site (* switching from unpublished to published state). */
      sitePublished?: SitePublished$1;
      /** Emitted on a meta site unpublish. */
      siteUnpublished?: SiteUnpublished$1;
      /** Emitted when meta site is marked as template. */
      siteMarkedAsTemplate?: SiteMarkedAsTemplate$1;
      /** Emitted when meta site is marked as a WixSite. */
      siteMarkedAsWixSite?: SiteMarkedAsWixSite$1;
      /** Emitted when an application is provisioned (installed). */
      serviceProvisioned?: ServiceProvisioned$1;
      /** Emitted when an application is removed (uninstalled). */
      serviceRemoved?: ServiceRemoved$1;
      /** Emitted when meta site name (URL slug) is changed. */
      siteRenamedPayload?: SiteRenamed$1;
      /** Emitted when meta site was permanently deleted. */
      hardDeleted?: SiteHardDeleted$1;
      /** Emitted on a namespace change. */
      namespaceChanged?: NamespaceChanged$1;
      /** Emitted when Studio is attached. */
      studioAssigned?: StudioAssigned$1;
      /** Emitted when Studio is detached. */
      studioUnassigned?: StudioUnassigned$1;
      /** A meta site id. */
      metaSiteId?: string;
      /** A meta site version. Monotonically increasing. */
      version?: string;
      /** A timestamp of the event. */
      timestamp?: string;
      /**
       * TODO(meta-site): Change validation once validations are disabled for consumers
       * More context: https://wix.slack.com/archives/C0UHEBPFT/p1720957844413149 and https://wix.slack.com/archives/CFWKX325T/p1728892152855659
       */
      assets?: Asset$1[];
  }
  /** @oneof */
  interface MetaSiteSpecialEventPayloadOneOf$1 {
      /** Emitted on a meta site creation. */
      siteCreated?: SiteCreated$3;
      /** Emitted on a meta site transfer completion. */
      siteTransferred?: SiteTransferred$1;
      /** Emitted on a meta site deletion. */
      siteDeleted?: SiteDeleted$1;
      /** Emitted on a meta site restoration. */
      siteUndeleted?: SiteUndeleted$1;
      /** Emitted on the first* publish of the meta site (* switching from unpublished to published state). */
      sitePublished?: SitePublished$1;
      /** Emitted on a meta site unpublish. */
      siteUnpublished?: SiteUnpublished$1;
      /** Emitted when meta site is marked as template. */
      siteMarkedAsTemplate?: SiteMarkedAsTemplate$1;
      /** Emitted when meta site is marked as a WixSite. */
      siteMarkedAsWixSite?: SiteMarkedAsWixSite$1;
      /** Emitted when an application is provisioned (installed). */
      serviceProvisioned?: ServiceProvisioned$1;
      /** Emitted when an application is removed (uninstalled). */
      serviceRemoved?: ServiceRemoved$1;
      /** Emitted when meta site name (URL slug) is changed. */
      siteRenamedPayload?: SiteRenamed$1;
      /** Emitted when meta site was permanently deleted. */
      hardDeleted?: SiteHardDeleted$1;
      /** Emitted on a namespace change. */
      namespaceChanged?: NamespaceChanged$1;
      /** Emitted when Studio is attached. */
      studioAssigned?: StudioAssigned$1;
      /** Emitted when Studio is detached. */
      studioUnassigned?: StudioUnassigned$1;
  }
  interface Asset$1 {
      /** An application definition id (app_id in dev-center). For legacy reasons may be UUID or a string (from Java Enum). */
      appDefId?: string;
      /** An instance id. For legacy reasons may be UUID or a string. */
      instanceId?: string;
      /** An application state. */
      state?: State$1;
  }
  enum State$1 {
      UNKNOWN = "UNKNOWN",
      ENABLED = "ENABLED",
      DISABLED = "DISABLED",
      PENDING = "PENDING",
      DEMO = "DEMO"
  }
  interface SiteCreated$3 {
      /** A template identifier (empty if not created from a template). */
      originTemplateId?: string;
      /** An account id of the owner. */
      ownerId?: string;
      /** A context in which meta site was created. */
      context?: SiteCreatedContext$1;
      /**
       * A meta site id from which this site was created.
       *
       * In case of a creation from a template it's a template id.
       * In case of a site duplication ("Save As" in dashboard or duplicate in UM) it's an id of a source site.
       */
      originMetaSiteId?: string | null;
      /** A meta site name (URL slug). */
      siteName?: string;
      /** A namespace. */
      namespace?: Namespace$1;
  }
  enum SiteCreatedContext$1 {
      /** A valid option, we don't expose all reasons why site might be created. */
      OTHER = "OTHER",
      /** A meta site was created from template. */
      FROM_TEMPLATE = "FROM_TEMPLATE",
      /** A meta site was created by copying of the transfferred meta site. */
      DUPLICATE_BY_SITE_TRANSFER = "DUPLICATE_BY_SITE_TRANSFER",
      /** A copy of existing meta site. */
      DUPLICATE = "DUPLICATE",
      /** A meta site was created as a transfferred site (copy of the original), old flow, should die soon. */
      OLD_SITE_TRANSFER = "OLD_SITE_TRANSFER",
      /** deprecated A meta site was created for Flash editor. */
      FLASH = "FLASH"
  }
  enum Namespace$1 {
      UNKNOWN_NAMESPACE = "UNKNOWN_NAMESPACE",
      /** Default namespace for UGC sites. MetaSites with this namespace will be shown in a user's site list by default. */
      WIX = "WIX",
      /** ShoutOut stand alone product. These are siteless (no actual Wix site, no HtmlWeb). MetaSites with this namespace will *not* be shown in a user's site list by default. */
      SHOUT_OUT = "SHOUT_OUT",
      /** MetaSites created by the Albums product, they appear as part of the Albums app. MetaSites with this namespace will *not* be shown in a user's site list by default. */
      ALBUMS = "ALBUMS",
      /** Part of the WixStores migration flow, a user tries to migrate and gets this site to view and if the user likes it then stores removes this namespace and deletes the old site with the old stores. MetaSites with this namespace will *not* be shown in a user's site list by default. */
      WIX_STORES_TEST_DRIVE = "WIX_STORES_TEST_DRIVE",
      /** Hotels standalone (siteless). MetaSites with this namespace will *not* be shown in a user's site list by default. */
      HOTELS = "HOTELS",
      /** Clubs siteless MetaSites, a club without a wix website. MetaSites with this namespace will *not* be shown in a user's site list by default. */
      CLUBS = "CLUBS",
      /** A partially created ADI website. MetaSites with this namespace will *not* be shown in a user's site list by default. */
      ONBOARDING_DRAFT = "ONBOARDING_DRAFT",
      /** AppBuilder for AppStudio / shmite (c). MetaSites with this namespace will *not* be shown in a user's site list by default. */
      DEV_SITE = "DEV_SITE",
      /** LogoMaker websites offered to the user after logo purchase. MetaSites with this namespace will *not* be shown in a user's site list by default. */
      LOGOS = "LOGOS",
      /** VideoMaker websites offered to the user after video purchase. MetaSites with this namespace will *not* be shown in a user's site list by default. */
      VIDEO_MAKER = "VIDEO_MAKER",
      /** MetaSites with this namespace will *not* be shown in a user's site list by default. */
      PARTNER_DASHBOARD = "PARTNER_DASHBOARD",
      /** MetaSites with this namespace will *not* be shown in a user's site list by default. */
      DEV_CENTER_COMPANY = "DEV_CENTER_COMPANY",
      /**
       * A draft created by HTML editor on open. Upon "first save" it will be moved to be of WIX domain.
       *
       * Meta site with this namespace will *not* be shown in a user's site list by default.
       */
      HTML_DRAFT = "HTML_DRAFT",
      /**
       * the user-journey for Fitness users who want to start from managing their business instead of designing their website.
       * Will be accessible from Site List and will not have a website app.
       * Once the user attaches a site, the site will become a regular wixsite.
       */
      SITELESS_BUSINESS = "SITELESS_BUSINESS",
      /** Belongs to "strategic products" company. Supports new product in the creator's economy space. */
      CREATOR_ECONOMY = "CREATOR_ECONOMY",
      /** It is to be used in the Business First efforts. */
      DASHBOARD_FIRST = "DASHBOARD_FIRST",
      /** Bookings business flow with no site. */
      ANYWHERE = "ANYWHERE",
      /** Namespace for Headless Backoffice with no editor */
      HEADLESS = "HEADLESS",
      /**
       * Namespace for master site that will exist in parent account that will be referenced by subaccounts
       * The site will be used for account level CSM feature for enterprise
       */
      ACCOUNT_MASTER_CMS = "ACCOUNT_MASTER_CMS",
      /** Rise.ai Siteless account management for Gift Cards and Store Credit. */
      RISE = "RISE",
      /**
       * As part of the branded app new funnel, users now can create a meta site that will be branded app first.
       * There's a blank site behind the scene but it's blank).
       * The Mobile company will be the owner of this namespace.
       */
      BRANDED_FIRST = "BRANDED_FIRST",
      /** Nownia.com Siteless account management for Ai Scheduling Assistant. */
      NOWNIA = "NOWNIA",
      /**
       * UGC Templates are templates that are created by users for personal use and to sale to other users.
       * The Partners company owns this namespace.
       */
      UGC_TEMPLATE = "UGC_TEMPLATE",
      /** Codux Headless Sites */
      CODUX = "CODUX"
  }
  /** Site transferred to another user. */
  interface SiteTransferred$1 {
      /** A previous owner id (user that transfers meta site). */
      oldOwnerId?: string;
      /** A new owner id (user that accepts meta site). */
      newOwnerId?: string;
  }
  /** Soft deletion of the meta site. Could be restored. */
  interface SiteDeleted$1 {
      /** A deletion context. */
      deleteContext?: DeleteContext$1;
  }
  interface DeleteContext$1 {
      /** When the meta site was deleted. */
      dateDeleted?: Date | null;
      /** A status. */
      deleteStatus?: DeleteStatus$1;
      /** A reason (flow). */
      deleteOrigin?: string;
      /** A service that deleted it. */
      initiatorId?: string | null;
  }
  enum DeleteStatus$1 {
      UNKNOWN = "UNKNOWN",
      TRASH = "TRASH",
      DELETED = "DELETED",
      PENDING_PURGE = "PENDING_PURGE"
  }
  /** Restoration of the meta site. */
  interface SiteUndeleted$1 {
  }
  /** First publish of a meta site. Or subsequent publish after unpublish. */
  interface SitePublished$1 {
  }
  interface SiteUnpublished$1 {
      /** A list of URLs previously associated with the meta site. */
      urls?: string[];
  }
  interface SiteMarkedAsTemplate$1 {
  }
  interface SiteMarkedAsWixSite$1 {
  }
  interface ServiceProvisioned$1 {
      /** Either UUID or EmbeddedServiceType. */
      appDefId?: string;
      /** Not only UUID. Something here could be something weird. */
      instanceId?: string;
      /** An instance id from which this instance is originated. */
      originInstanceId?: string;
      /** A version. */
      version?: string | null;
      /** The origin meta site id */
      originMetaSiteId?: string | null;
  }
  interface ServiceRemoved$1 {
      /** Either UUID or EmbeddedServiceType. */
      appDefId?: string;
      /** Not only UUID. Something here could be something weird. */
      instanceId?: string;
      /** A version. */
      version?: string | null;
  }
  /** Rename of the site. Meaning, free public url has been changed as well. */
  interface SiteRenamed$1 {
      /** A new meta site name (URL slug). */
      newSiteName?: string;
      /** A previous meta site name (URL slug). */
      oldSiteName?: string;
  }
  /**
   * Hard deletion of the meta site.
   *
   * Could not be restored. Therefore it's desirable to cleanup data.
   */
  interface SiteHardDeleted$1 {
      /** A deletion context. */
      deleteContext?: DeleteContext$1;
  }
  interface NamespaceChanged$1 {
      /** A previous namespace. */
      oldNamespace?: Namespace$1;
      /** A new namespace. */
      newNamespace?: Namespace$1;
  }
  /** Assigned Studio editor */
  interface StudioAssigned$1 {
  }
  /** Unassigned Studio editor */
  interface StudioUnassigned$1 {
  }
  interface Empty$3 {
  }
  interface DomainEvent$6 extends DomainEventBodyOneOf$6 {
      createdEvent?: EntityCreatedEvent$6;
      updatedEvent?: EntityUpdatedEvent$6;
      deletedEvent?: EntityDeletedEvent$6;
      actionEvent?: ActionEvent$6;
      /**
       * Unique event ID.
       * Allows clients to ignore duplicate webhooks.
       */
      _id?: string;
      /**
       * Assumes actions are also always typed to an entity_type
       * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
       */
      entityFqdn?: string;
      /**
       * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
       * This is although the created/updated/deleted notion is duplication of the oneof types
       * Example: created/updated/deleted/started/completed/email_opened
       */
      slug?: string;
      /** ID of the entity associated with the event. */
      entityId?: string;
      /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
      eventTime?: Date | null;
      /**
       * Whether the event was triggered as a result of a privacy regulation application
       * (for example, GDPR).
       */
      triggeredByAnonymizeRequest?: boolean | null;
      /** If present, indicates the action that triggered the event. */
      originatedFrom?: string | null;
      /**
       * A sequence number defining the order of updates to the underlying entity.
       * For example, given that some entity was updated at 16:00 and than again at 16:01,
       * it is guaranteed that the sequence number of the second update is strictly higher than the first.
       * As the consumer, you can use this value to ensure that you handle messages in the correct order.
       * To do so, you will need to persist this number on your end, and compare the sequence number from the
       * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
       */
      entityEventSequence?: string | null;
  }
  /** @oneof */
  interface DomainEventBodyOneOf$6 {
      createdEvent?: EntityCreatedEvent$6;
      updatedEvent?: EntityUpdatedEvent$6;
      deletedEvent?: EntityDeletedEvent$6;
      actionEvent?: ActionEvent$6;
  }
  interface EntityCreatedEvent$6 {
      entityAsJson?: string;
      /**
       * Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity
       * @internal
       */
      triggeredByUndelete?: boolean | null;
      /** Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity */
      restoreInfo?: RestoreInfo$6;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface RestoreInfo$6 {
      deletedDate?: Date | null;
  }
  interface EntityUpdatedEvent$6 {
      /**
       * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
       * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
       * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
       */
      currentEntityAsJson?: string;
      /**
       * This field is currently part of the of the EntityUpdatedEvent msg, but scala/node libraries which implements the domain events standard
       * wont populate it / have any reference to it in the API.
       * The main reason for it is that fetching the old entity from the DB will have a performance hit on an update operation so unless truly needed,
       * the developer should send only the new (current) entity.
       * An additional reason is not wanting to send this additional entity over the wire (kafka) since in some cases it can be really big
       * Developers that must reflect the old entity will have to implement their own domain event sender mechanism which will follow the DomainEvent proto message.
       * @internal
       * @deprecated
       */
      previousEntityAsJson?: string | null;
      /**
       * WIP - This property will hold both names and values of the updated fields of the entity.
       * For more details please see [adr](https://docs.google.com/document/d/1PdqsOM20Ph2HAkmx8zvUnzzk3Sekp3BR9h34wSvsRnI/edit#heading=h.phlw87mh2imx) or [issue](https://github.com/wix-private/nile-tracker/issues/363)
       * @internal
       */
      modifiedFields?: Record<string, any>;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface EntityDeletedEvent$6 {
      /**
       * Indicates if the entity is sent to trash-bin. only available when trash-bin is enabled
       * @internal
       */
      movedToTrash?: boolean | null;
      /** Entity that was deleted */
      deletedEntityAsJson?: string | null;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface ActionEvent$6 {
      bodyAsJson?: string;
  }
  interface MessageEnvelope$6 {
      /** App instance ID. */
      instanceId?: string | null;
      /** Event type. */
      eventType?: string;
      /** The identification type and identity data. */
      identity?: IdentificationData$7;
      /** Stringify payload. */
      data?: string;
  }
  interface IdentificationData$7 extends IdentificationDataIdOneOf$7 {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
      /** @readonly */
      identityType?: WebhookIdentityType$6;
  }
  /** @oneof */
  interface IdentificationDataIdOneOf$7 {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
  }
  enum WebhookIdentityType$6 {
      UNKNOWN = "UNKNOWN",
      ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
      MEMBER = "MEMBER",
      WIX_USER = "WIX_USER",
      APP = "APP"
  }
  /**
   * Creates a new resource.
   *
   * By using the create API you can create a resource, set its name, working hours and location details.
   * The system creates an events schedule that contains the sessions in which the resource is booked.
   * @param resource - Resource to be created.
   * @public
   * @documentationMaturity preview
   * @requiredField resource
   * @requiredField resource.name
   * @permissionId BOOKINGS.RESOURCE_CREATE
   * @adminMethod
   * @returns The created resource.
   */
  function createResource(resource: Resource$2): Promise<Resource$2>;
  /**
   * Creates multiple resources.
   *
   * By using the bulk create API you can create multiple resources in a single request.
   * To query the created resources in the same order as they were sent in the request sort them by creation date and ID.
   * @param resources - Resources to create.
   * @public
   * @documentationMaturity preview
   * @requiredField resources
   * @requiredField resources.name
   * @permissionId BOOKINGS.RESOURCE_CREATE
   * @adminMethod
   */
  function bulkCreateResources(resources: Resource$2[], options?: BulkCreateResourcesOptions): Promise<BulkCreateResourcesResponse>;
  interface BulkCreateResourcesOptions {
      /** `true` if the created entities must be included in the response, otherwise no entities are included in the response. */
      returnEntity?: boolean;
  }
  /**
   * Retrieves a resource by id.
   * @param resourceId - Id of the resource to retrieve.
   * @public
   * @documentationMaturity preview
   * @requiredField resourceId
   * @permissionId BOOKINGS.RESOURCE_READ
   * @adminMethod
   * @returns The retrieved resource.
   */
  function getResource(resourceId: string): Promise<Resource$2>;
  /**
   * Retrieves a deleted resource from the trash bin.
   * @param resourceId - Id of the resource to retrieve.
   * @internal
   * @documentationMaturity preview
   * @requiredField resourceId
   * @permissionId BOOKINGS.RESOURCE_READ
   */
  function getDeletedResource(resourceId: string): Promise<GetDeletedResourceResponse>;
  /**
   * Retrieves a list of deleted resources from the trash bin.
   *
   * List runs with these defaults, which you can override:
   * - `paging.limit` is `50`.
   * @internal
   * @documentationMaturity preview
   * @permissionId BOOKINGS.RESOURCE_READ
   */
  function listDeletedResources(options?: ListDeletedResourcesOptions): Promise<ListDeletedResourcesResponse>;
  interface ListDeletedResourcesOptions {
      /** The ids of the resources to retrieve. */
      resourceIds?: string[];
      /** Paging parameter, enabling to pass a limit and a cursor. */
      paging?: CursorPaging$6;
  }
  /**
   * Removes a resource from the trash bin, permanently deleting it. This action is irreversible.
   * @param resourceId - Id of the resource to remove from the trash bin.
   * @internal
   * @documentationMaturity preview
   * @requiredField resourceId
   * @permissionId BOOKINGS.RESOURCE_REMOVE_FROM_TRASH_BIN
   * @adminMethod
   */
  function removeResourceFromTrashBin(resourceId: string): Promise<void>;
  /**
   * Restores a resource from the trash bin.
   * @param resourceId - Id of the resource to restore from the trash bin.
   * @internal
   * @documentationMaturity preview
   * @requiredField resourceId
   * @permissionId BOOKINGS.RESOURCE_RESTORE_FROM_TRASH_BIN
   * @adminMethod
   */
  function restoreResourceFromTrashBin(resourceId: string): Promise<RestoreResourceFromTrashBinResponse>;
  /**
   * Updates a resource.
   *
   * [Partial updates](https://dev.wix.com/api/rest/wix-bookings/bookings/patch-endpoints-and-field-masks-in-update-requests) are supported.
   *
   * Each time the resource is updated, `revision` increments by 1. You must include the current revision of the resource when updating it.
   * This ensures you're working with the latest service information and prevents unintended overwrites.
   * @param _id - Resource ID
   * @public
   * @documentationMaturity preview
   * @requiredField _id
   * @requiredField resource
   * @requiredField resource.revision
   * @permissionId BOOKINGS.RESOURCE_UPDATE
   * @adminMethod
   * @returns The updated resource.
   */
  function updateResource(_id: string | null, resource: UpdateResource, options?: UpdateResourceOptions): Promise<Resource$2>;
  interface UpdateResource {
      /**
       * Details of a single resource.
       * @internal
       * @deprecated Details of a single resource.
       * @targetRemovalDate 2025-01-01
       */
      singleResource?: SingleResource;
      /**
       * Resource ID
       * @readonly
       */
      _id?: string | null;
      /**
       * Revision number, which increments by 1 each time the staff member is updated.
       * To prevent conflicting changes,
       * the current revision must be passed when updating the staff member.
       * @readonly
       */
      revision?: string | null;
      /**
       * Represents the time this resource was created.
       * @readonly
       */
      _createdDate?: Date | null;
      /**
       * Represents the time this resource was last updated.
       * @readonly
       */
      _updatedDate?: Date | null;
      /** Name of the resource. */
      name?: string | null;
      /**
       * The type of the resource.
       *
       * Resources can be created without a type. However, this field must be set to ensure that a resource can be allocated
       * at a requested time slot and to prevent double bookings.
       *
       * The value to assign to this field depends on how the type is managed. There are 2 options:
       * - The resource type is managed by a user (for example the site owner or contributor) in the Resources section of the
       * dashboard or it is managed via the `/v2/resource-types` endpoint.
       * In this case, the `type` field must be set to the id of the resource type entity.
       * - The resource type is managed by an app implementing the `BOOKINGS_RESOURCE_TYPES_PROVIDER` SPI component.
       * In this case the `type` field must match one of the `id` fields in the `bookingsResourceTypes` structure of the SPI configuration.
       *
       * Once a type has been set it cannot be modified.
       * @deprecated
       * @replacedBy type_id
       * @targetRemovalDate 2025-01-01
       */
      type?: string | null;
      typeId?: string | null;
      /**
       * Schedule details that specify the working hours and locations of this resource.
       *
       * When this field is not set or  `working_hours_schedules.enabled` is `false` then the resource is assumed to be
       * available full time (7 x 24) at the locations specified in the field `location_options`.
       * When both `working_hours_schedules` and `location_options` are set then `working_hours_schedules` takes precedence.
       */
      workingHoursSchedules?: ResourceWorkingHoursSchedules;
      /**
       * Location details that specify where this resource is available.
       *
       * If this field is not supplied then `location_options.available_in_all_locations` is set to `true`.
       */
      locationOptions?: LocationOptions$1;
      /**
       * This schedule contains the sessions in which this resource has been booked.
       * @readonly
       */
      eventsSchedule?: EventsSchedule;
      /**
       * The ID of the app of which this resource belongs to.
       * Default: Bookings App ID.
       * @internal
       */
      appId?: string | null;
      /**
       * Specifies whether this resource is managed by a user (site owner, contributor, etc) or by an app.
       * Default: `WIX_USER`.
       * @internal
       */
      managementType?: ManagementType;
      /** Extensions enabling users to save custom data related to the resource. */
      extendedFields?: ExtendedFields$6;
  }
  interface UpdateResourceOptions {
      /**
       * Explicit list of fields to update.
       * @internal
       */
      mask?: string[];
  }
  /**
   * Deletes a resource.
   * @param resourceId - Id of the resource to delete.
   * @public
   * @documentationMaturity preview
   * @requiredField resourceId
   * @permissionId BOOKINGS.RESOURCE_DELETE
   * @adminMethod
   */
  function deleteResource(resourceId: string): Promise<void>;
  /**
   * Deletes multiple resources.
   * @param ids - The ids of the resources to delete.
   * @public
   * @documentationMaturity preview
   * @requiredField ids
   * @permissionId BOOKINGS.RESOURCE_DELETE
   * @adminMethod
   */
  function bulkDeleteResources(ids: string[]): Promise<BulkDeleteResourcesResponse>;
  /**
   * Retrieves a list of resources matching the provided search criteria.
   *
   * The search endpoints allow to perform advanced search including partial text search, exact match, and more.
   * The endpoint also allows to aggregate resources by type, name, app id, management type, management type and location options.
   * @internal
   * @documentationMaturity preview
   * @permissionId BOOKINGS.RESOURCE_READ
   * @adminMethod
   */
  function searchResources(options?: SearchResourcesOptions): Promise<SearchResourcesResponse>;
  interface SearchResourcesOptions {
      /** Search condition */
      search?: CursorSearch$2;
  }
  /**
   * Query resources using [WQL - Wix Query Language](https://dev.wix.com/api/rest/getting-started/api-query-language)
   * @public
   * @documentationMaturity preview
   * @permissionId BOOKINGS.RESOURCE_READ
   * @adminMethod
   */
  function queryResources(): ResourcesQueryBuilder;
  interface QueryCursorResult$4 {
      cursors: Cursors$6;
      hasNext: () => boolean;
      hasPrev: () => boolean;
      length: number;
      pageSize: number;
  }
  interface ResourcesQueryResult extends QueryCursorResult$4 {
      items: Resource$2[];
      query: ResourcesQueryBuilder;
      next: () => Promise<ResourcesQueryResult>;
      prev: () => Promise<ResourcesQueryResult>;
  }
  interface ResourcesQueryBuilder {
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       * @documentationMaturity preview
       */
      eq: (propertyName: 'singleResource.locationOptions.availableInAllLocations' | 'singleResource.locationOptions.specificLocationOptions.availableInBusinessLocations' | 'singleResource.locationOptions.specificLocationOptions.businessLocations.locationId' | '_id' | '_createdDate' | '_updatedDate' | 'name' | 'type', value: any) => ResourcesQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       * @documentationMaturity preview
       */
      ne: (propertyName: 'singleResource.locationOptions.availableInAllLocations' | 'singleResource.locationOptions.specificLocationOptions.availableInBusinessLocations' | 'singleResource.locationOptions.specificLocationOptions.businessLocations.locationId' | '_id' | '_createdDate' | '_updatedDate' | 'name' | 'type', value: any) => ResourcesQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       * @documentationMaturity preview
       */
      ge: (propertyName: '_createdDate' | '_updatedDate', value: any) => ResourcesQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       * @documentationMaturity preview
       */
      gt: (propertyName: '_createdDate' | '_updatedDate', value: any) => ResourcesQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       * @documentationMaturity preview
       */
      le: (propertyName: '_createdDate' | '_updatedDate', value: any) => ResourcesQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       * @documentationMaturity preview
       */
      lt: (propertyName: '_createdDate' | '_updatedDate', value: any) => ResourcesQueryBuilder;
      /** @param propertyName - Property whose value is compared with `string`.
       * @param string - String to compare against. Case-insensitive.
       * @documentationMaturity preview
       */
      startsWith: (propertyName: 'singleResource.locationOptions.specificLocationOptions.businessLocations.locationId' | '_id' | 'name' | 'type', value: string) => ResourcesQueryBuilder;
      /** @param propertyName - Property whose value is compared with `values`.
       * @param values - List of values to compare against.
       * @documentationMaturity preview
       */
      hasSome: (propertyName: 'singleResource.locationOptions.availableInAllLocations' | 'singleResource.locationOptions.specificLocationOptions.availableInBusinessLocations' | 'singleResource.locationOptions.specificLocationOptions.businessLocations.locationId' | '_id' | '_createdDate' | '_updatedDate' | 'name' | 'type', value: any[]) => ResourcesQueryBuilder;
      /** @documentationMaturity preview */
      in: (propertyName: 'singleResource.locationOptions.availableInAllLocations' | 'singleResource.locationOptions.specificLocationOptions.availableInBusinessLocations' | 'singleResource.locationOptions.specificLocationOptions.businessLocations.locationId' | '_id' | '_createdDate' | '_updatedDate' | 'name' | 'type', value: any) => ResourcesQueryBuilder;
      /** @documentationMaturity preview */
      exists: (propertyName: 'singleResource.locationOptions.availableInAllLocations' | 'singleResource.locationOptions.specificLocationOptions.availableInBusinessLocations' | 'singleResource.locationOptions.specificLocationOptions.businessLocations.locationId' | '_id' | '_createdDate' | '_updatedDate' | 'name' | 'type', value: boolean) => ResourcesQueryBuilder;
      /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments.
       * @documentationMaturity preview
       */
      ascending: (...propertyNames: Array<'singleResource.locationOptions.availableInAllLocations' | 'singleResource.locationOptions.specificLocationOptions.availableInCustomerLocations' | 'singleResource.locationOptions.specificLocationOptions.availableInCustomLocations' | 'singleResource.locationOptions.specificLocationOptions.availableInBusinessLocations' | 'singleResource.locationOptions.specificLocationOptions.businessLocations.locationId' | '_id' | '_createdDate' | '_updatedDate' | 'name' | 'type' | 'appId' | 'managementType'>) => ResourcesQueryBuilder;
      /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments.
       * @documentationMaturity preview
       */
      descending: (...propertyNames: Array<'singleResource.locationOptions.availableInAllLocations' | 'singleResource.locationOptions.specificLocationOptions.availableInCustomerLocations' | 'singleResource.locationOptions.specificLocationOptions.availableInCustomLocations' | 'singleResource.locationOptions.specificLocationOptions.availableInBusinessLocations' | 'singleResource.locationOptions.specificLocationOptions.businessLocations.locationId' | '_id' | '_createdDate' | '_updatedDate' | 'name' | 'type' | 'appId' | 'managementType'>) => ResourcesQueryBuilder;
      /** @param limit - Number of items to return, which is also the `pageSize` of the results object.
       * @documentationMaturity preview
       */
      limit: (limit: number) => ResourcesQueryBuilder;
      /** @param cursor - A pointer to specific record
       * @documentationMaturity preview
       */
      skipTo: (cursor: string) => ResourcesQueryBuilder;
      /** @documentationMaturity preview */
      find: () => Promise<ResourcesQueryResult>;
  }
  /**
   * Counts resources according to given criteria.
   *
   * Use [WQL filter](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#the-filter-section) to define the criteria.
   * @internal
   * @documentationMaturity preview
   * @permissionId BOOKINGS.RESOURCE_READ
   * @adminMethod
   */
  function countResources(options?: CountResourcesOptions): Promise<CountResourcesResponse>;
  interface CountResourcesOptions {
      /** Filter to apply on resources to count. */
      filter?: Record<string, any> | null;
      /**
       * @deprecated
       * @targetRemovalDate 2024-05-01
       */
      search?: SearchDetails$2;
  }
  
  type bookingsResourcesV2Resource_universal_d_ResourceCompositionDetailsOneOf = ResourceCompositionDetailsOneOf;
  type bookingsResourcesV2Resource_universal_d_SingleResource = SingleResource;
  type bookingsResourcesV2Resource_universal_d_WorkingHoursSchedules = WorkingHoursSchedules;
  type bookingsResourcesV2Resource_universal_d_ResourceWorkingHoursSchedules = ResourceWorkingHoursSchedules;
  type bookingsResourcesV2Resource_universal_d_EventsSchedule = EventsSchedule;
  type bookingsResourcesV2Resource_universal_d_ManagementType = ManagementType;
  const bookingsResourcesV2Resource_universal_d_ManagementType: typeof ManagementType;
  type bookingsResourcesV2Resource_universal_d_CreateResourceRequest = CreateResourceRequest;
  type bookingsResourcesV2Resource_universal_d_CreateResourceResponse = CreateResourceResponse;
  type bookingsResourcesV2Resource_universal_d_BulkCreateResourcesRequest = BulkCreateResourcesRequest;
  type bookingsResourcesV2Resource_universal_d_BulkCreateResourcesResponse = BulkCreateResourcesResponse;
  type bookingsResourcesV2Resource_universal_d_BulkResourceResult = BulkResourceResult;
  type bookingsResourcesV2Resource_universal_d_GetResourceRequest = GetResourceRequest;
  type bookingsResourcesV2Resource_universal_d_GetResourceResponse = GetResourceResponse;
  type bookingsResourcesV2Resource_universal_d_GetDeletedResourceRequest = GetDeletedResourceRequest;
  type bookingsResourcesV2Resource_universal_d_GetDeletedResourceResponse = GetDeletedResourceResponse;
  type bookingsResourcesV2Resource_universal_d_ListDeletedResourcesRequest = ListDeletedResourcesRequest;
  type bookingsResourcesV2Resource_universal_d_ListDeletedResourcesResponse = ListDeletedResourcesResponse;
  type bookingsResourcesV2Resource_universal_d_RemoveResourceFromTrashBinRequest = RemoveResourceFromTrashBinRequest;
  type bookingsResourcesV2Resource_universal_d_RemoveResourceFromTrashBinResponse = RemoveResourceFromTrashBinResponse;
  type bookingsResourcesV2Resource_universal_d_RestoreResourceFromTrashBinRequest = RestoreResourceFromTrashBinRequest;
  type bookingsResourcesV2Resource_universal_d_RestoreResourceFromTrashBinResponse = RestoreResourceFromTrashBinResponse;
  type bookingsResourcesV2Resource_universal_d_UpdateResourceRequest = UpdateResourceRequest;
  type bookingsResourcesV2Resource_universal_d_UpdateResourceResponse = UpdateResourceResponse;
  type bookingsResourcesV2Resource_universal_d_DeleteResourceRequest = DeleteResourceRequest;
  type bookingsResourcesV2Resource_universal_d_DeleteResourceResponse = DeleteResourceResponse;
  type bookingsResourcesV2Resource_universal_d_BulkDeleteResourcesRequest = BulkDeleteResourcesRequest;
  type bookingsResourcesV2Resource_universal_d_BulkDeleteResourcesResponse = BulkDeleteResourcesResponse;
  type bookingsResourcesV2Resource_universal_d_SearchResourcesRequest = SearchResourcesRequest;
  type bookingsResourcesV2Resource_universal_d_SearchResourcesResponse = SearchResourcesResponse;
  type bookingsResourcesV2Resource_universal_d_AggregationResultsScalarResult = AggregationResultsScalarResult;
  type bookingsResourcesV2Resource_universal_d_QueryResourcesRequest = QueryResourcesRequest;
  type bookingsResourcesV2Resource_universal_d_QueryResourcesResponse = QueryResourcesResponse;
  type bookingsResourcesV2Resource_universal_d_CountResourcesRequest = CountResourcesRequest;
  type bookingsResourcesV2Resource_universal_d_CountResourcesResponse = CountResourcesResponse;
  type bookingsResourcesV2Resource_universal_d_ImportResourceRequest = ImportResourceRequest;
  type bookingsResourcesV2Resource_universal_d_ImportResourceResponse = ImportResourceResponse;
  type bookingsResourcesV2Resource_universal_d_FixResourceSchedulesRequest = FixResourceSchedulesRequest;
  type bookingsResourcesV2Resource_universal_d_FixResourceSchedulesResponse = FixResourceSchedulesResponse;
  type bookingsResourcesV2Resource_universal_d_ReindexTenantRequest = ReindexTenantRequest;
  type bookingsResourcesV2Resource_universal_d_ReindexTenantResponse = ReindexTenantResponse;
  const bookingsResourcesV2Resource_universal_d_createResource: typeof createResource;
  const bookingsResourcesV2Resource_universal_d_bulkCreateResources: typeof bulkCreateResources;
  type bookingsResourcesV2Resource_universal_d_BulkCreateResourcesOptions = BulkCreateResourcesOptions;
  const bookingsResourcesV2Resource_universal_d_getResource: typeof getResource;
  const bookingsResourcesV2Resource_universal_d_getDeletedResource: typeof getDeletedResource;
  const bookingsResourcesV2Resource_universal_d_listDeletedResources: typeof listDeletedResources;
  type bookingsResourcesV2Resource_universal_d_ListDeletedResourcesOptions = ListDeletedResourcesOptions;
  const bookingsResourcesV2Resource_universal_d_removeResourceFromTrashBin: typeof removeResourceFromTrashBin;
  const bookingsResourcesV2Resource_universal_d_restoreResourceFromTrashBin: typeof restoreResourceFromTrashBin;
  const bookingsResourcesV2Resource_universal_d_updateResource: typeof updateResource;
  type bookingsResourcesV2Resource_universal_d_UpdateResource = UpdateResource;
  type bookingsResourcesV2Resource_universal_d_UpdateResourceOptions = UpdateResourceOptions;
  const bookingsResourcesV2Resource_universal_d_deleteResource: typeof deleteResource;
  const bookingsResourcesV2Resource_universal_d_bulkDeleteResources: typeof bulkDeleteResources;
  const bookingsResourcesV2Resource_universal_d_searchResources: typeof searchResources;
  type bookingsResourcesV2Resource_universal_d_SearchResourcesOptions = SearchResourcesOptions;
  const bookingsResourcesV2Resource_universal_d_queryResources: typeof queryResources;
  type bookingsResourcesV2Resource_universal_d_ResourcesQueryResult = ResourcesQueryResult;
  type bookingsResourcesV2Resource_universal_d_ResourcesQueryBuilder = ResourcesQueryBuilder;
  const bookingsResourcesV2Resource_universal_d_countResources: typeof countResources;
  type bookingsResourcesV2Resource_universal_d_CountResourcesOptions = CountResourcesOptions;
  namespace bookingsResourcesV2Resource_universal_d {
    export {
      Resource$2 as Resource,
      bookingsResourcesV2Resource_universal_d_ResourceCompositionDetailsOneOf as ResourceCompositionDetailsOneOf,
      WorkingHoursSchedule$1 as WorkingHoursSchedule,
      bookingsResourcesV2Resource_universal_d_SingleResource as SingleResource,
      bookingsResourcesV2Resource_universal_d_WorkingHoursSchedules as WorkingHoursSchedules,
      Schedule$2 as Schedule,
      LocationOptions$1 as LocationOptions,
      SpecificLocation$1 as SpecificLocation,
      BusinessLocation$2 as BusinessLocation,
      bookingsResourcesV2Resource_universal_d_ResourceWorkingHoursSchedules as ResourceWorkingHoursSchedules,
      bookingsResourcesV2Resource_universal_d_EventsSchedule as EventsSchedule,
      bookingsResourcesV2Resource_universal_d_ManagementType as ManagementType,
      ExtendedFields$6 as ExtendedFields,
      bookingsResourcesV2Resource_universal_d_CreateResourceRequest as CreateResourceRequest,
      bookingsResourcesV2Resource_universal_d_CreateResourceResponse as CreateResourceResponse,
      bookingsResourcesV2Resource_universal_d_BulkCreateResourcesRequest as BulkCreateResourcesRequest,
      bookingsResourcesV2Resource_universal_d_BulkCreateResourcesResponse as BulkCreateResourcesResponse,
      bookingsResourcesV2Resource_universal_d_BulkResourceResult as BulkResourceResult,
      ItemMetadata$3 as ItemMetadata,
      ApplicationError$3 as ApplicationError,
      BulkActionMetadata$3 as BulkActionMetadata,
      bookingsResourcesV2Resource_universal_d_GetResourceRequest as GetResourceRequest,
      bookingsResourcesV2Resource_universal_d_GetResourceResponse as GetResourceResponse,
      bookingsResourcesV2Resource_universal_d_GetDeletedResourceRequest as GetDeletedResourceRequest,
      bookingsResourcesV2Resource_universal_d_GetDeletedResourceResponse as GetDeletedResourceResponse,
      bookingsResourcesV2Resource_universal_d_ListDeletedResourcesRequest as ListDeletedResourcesRequest,
      CursorPaging$6 as CursorPaging,
      bookingsResourcesV2Resource_universal_d_ListDeletedResourcesResponse as ListDeletedResourcesResponse,
      CursorPagingMetadata$5 as CursorPagingMetadata,
      Cursors$6 as Cursors,
      bookingsResourcesV2Resource_universal_d_RemoveResourceFromTrashBinRequest as RemoveResourceFromTrashBinRequest,
      bookingsResourcesV2Resource_universal_d_RemoveResourceFromTrashBinResponse as RemoveResourceFromTrashBinResponse,
      bookingsResourcesV2Resource_universal_d_RestoreResourceFromTrashBinRequest as RestoreResourceFromTrashBinRequest,
      bookingsResourcesV2Resource_universal_d_RestoreResourceFromTrashBinResponse as RestoreResourceFromTrashBinResponse,
      bookingsResourcesV2Resource_universal_d_UpdateResourceRequest as UpdateResourceRequest,
      bookingsResourcesV2Resource_universal_d_UpdateResourceResponse as UpdateResourceResponse,
      bookingsResourcesV2Resource_universal_d_DeleteResourceRequest as DeleteResourceRequest,
      bookingsResourcesV2Resource_universal_d_DeleteResourceResponse as DeleteResourceResponse,
      bookingsResourcesV2Resource_universal_d_BulkDeleteResourcesRequest as BulkDeleteResourcesRequest,
      bookingsResourcesV2Resource_universal_d_BulkDeleteResourcesResponse as BulkDeleteResourcesResponse,
      bookingsResourcesV2Resource_universal_d_SearchResourcesRequest as SearchResourcesRequest,
      CursorSearch$2 as CursorSearch,
      CursorSearchPagingMethodOneOf$2 as CursorSearchPagingMethodOneOf,
      Sorting$6 as Sorting,
      SortOrder$6 as SortOrder,
      Aggregation$1 as Aggregation,
      AggregationKindOneOf$1 as AggregationKindOneOf,
      RangeBucket$1 as RangeBucket,
      SortType$1 as SortType,
      SortDirection$1 as SortDirection,
      MissingValues$1 as MissingValues,
      IncludeMissingValuesOptions$1 as IncludeMissingValuesOptions,
      ScalarType$2 as ScalarType,
      ValueAggregation$1 as ValueAggregation,
      ValueAggregationOptionsOneOf$1 as ValueAggregationOptionsOneOf,
      NestedAggregationType$1 as NestedAggregationType,
      RangeAggregation$1 as RangeAggregation,
      ScalarAggregation$1 as ScalarAggregation,
      DateHistogramAggregation$1 as DateHistogramAggregation,
      Interval$2 as Interval,
      NestedAggregationItem$1 as NestedAggregationItem,
      NestedAggregationItemKindOneOf$1 as NestedAggregationItemKindOneOf,
      AggregationType$2 as AggregationType,
      NestedAggregation$1 as NestedAggregation,
      GroupByAggregation$1 as GroupByAggregation,
      GroupByAggregationKindOneOf$1 as GroupByAggregationKindOneOf,
      SearchDetails$2 as SearchDetails,
      Mode$2 as Mode,
      bookingsResourcesV2Resource_universal_d_SearchResourcesResponse as SearchResourcesResponse,
      AggregationData$2 as AggregationData,
      ValueAggregationResult$2 as ValueAggregationResult,
      RangeAggregationResult$2 as RangeAggregationResult,
      NestedAggregationResults$2 as NestedAggregationResults,
      NestedAggregationResultsResultOneOf$2 as NestedAggregationResultsResultOneOf,
      ValueResults$2 as ValueResults,
      RangeResults$2 as RangeResults,
      bookingsResourcesV2Resource_universal_d_AggregationResultsScalarResult as AggregationResultsScalarResult,
      NestedValueAggregationResult$2 as NestedValueAggregationResult,
      ValueResult$1 as ValueResult,
      RangeResult$1 as RangeResult,
      ScalarResult$2 as ScalarResult,
      NestedResultValue$1 as NestedResultValue,
      NestedResultValueResultOneOf$1 as NestedResultValueResultOneOf,
      Results$1 as Results,
      DateHistogramResult$1 as DateHistogramResult,
      GroupByValueResults$2 as GroupByValueResults,
      DateHistogramResults$1 as DateHistogramResults,
      NestedResults$1 as NestedResults,
      AggregationResults$2 as AggregationResults,
      AggregationResultsResultOneOf$2 as AggregationResultsResultOneOf,
      bookingsResourcesV2Resource_universal_d_QueryResourcesRequest as QueryResourcesRequest,
      CursorQuery$4 as CursorQuery,
      CursorQueryPagingMethodOneOf$4 as CursorQueryPagingMethodOneOf,
      bookingsResourcesV2Resource_universal_d_QueryResourcesResponse as QueryResourcesResponse,
      bookingsResourcesV2Resource_universal_d_CountResourcesRequest as CountResourcesRequest,
      bookingsResourcesV2Resource_universal_d_CountResourcesResponse as CountResourcesResponse,
      bookingsResourcesV2Resource_universal_d_ImportResourceRequest as ImportResourceRequest,
      bookingsResourcesV2Resource_universal_d_ImportResourceResponse as ImportResourceResponse,
      bookingsResourcesV2Resource_universal_d_FixResourceSchedulesRequest as FixResourceSchedulesRequest,
      bookingsResourcesV2Resource_universal_d_FixResourceSchedulesResponse as FixResourceSchedulesResponse,
      bookingsResourcesV2Resource_universal_d_ReindexTenantRequest as ReindexTenantRequest,
      bookingsResourcesV2Resource_universal_d_ReindexTenantResponse as ReindexTenantResponse,
      MetaSiteSpecialEvent$1 as MetaSiteSpecialEvent,
      MetaSiteSpecialEventPayloadOneOf$1 as MetaSiteSpecialEventPayloadOneOf,
      Asset$1 as Asset,
      State$1 as State,
      SiteCreated$3 as SiteCreated,
      SiteCreatedContext$1 as SiteCreatedContext,
      Namespace$1 as Namespace,
      SiteTransferred$1 as SiteTransferred,
      SiteDeleted$1 as SiteDeleted,
      DeleteContext$1 as DeleteContext,
      DeleteStatus$1 as DeleteStatus,
      SiteUndeleted$1 as SiteUndeleted,
      SitePublished$1 as SitePublished,
      SiteUnpublished$1 as SiteUnpublished,
      SiteMarkedAsTemplate$1 as SiteMarkedAsTemplate,
      SiteMarkedAsWixSite$1 as SiteMarkedAsWixSite,
      ServiceProvisioned$1 as ServiceProvisioned,
      ServiceRemoved$1 as ServiceRemoved,
      SiteRenamed$1 as SiteRenamed,
      SiteHardDeleted$1 as SiteHardDeleted,
      NamespaceChanged$1 as NamespaceChanged,
      StudioAssigned$1 as StudioAssigned,
      StudioUnassigned$1 as StudioUnassigned,
      Empty$3 as Empty,
      DomainEvent$6 as DomainEvent,
      DomainEventBodyOneOf$6 as DomainEventBodyOneOf,
      EntityCreatedEvent$6 as EntityCreatedEvent,
      RestoreInfo$6 as RestoreInfo,
      EntityUpdatedEvent$6 as EntityUpdatedEvent,
      EntityDeletedEvent$6 as EntityDeletedEvent,
      ActionEvent$6 as ActionEvent,
      MessageEnvelope$6 as MessageEnvelope,
      IdentificationData$7 as IdentificationData,
      IdentificationDataIdOneOf$7 as IdentificationDataIdOneOf,
      WebhookIdentityType$6 as WebhookIdentityType,
      bookingsResourcesV2Resource_universal_d_createResource as createResource,
      bookingsResourcesV2Resource_universal_d_bulkCreateResources as bulkCreateResources,
      bookingsResourcesV2Resource_universal_d_BulkCreateResourcesOptions as BulkCreateResourcesOptions,
      bookingsResourcesV2Resource_universal_d_getResource as getResource,
      bookingsResourcesV2Resource_universal_d_getDeletedResource as getDeletedResource,
      bookingsResourcesV2Resource_universal_d_listDeletedResources as listDeletedResources,
      bookingsResourcesV2Resource_universal_d_ListDeletedResourcesOptions as ListDeletedResourcesOptions,
      bookingsResourcesV2Resource_universal_d_removeResourceFromTrashBin as removeResourceFromTrashBin,
      bookingsResourcesV2Resource_universal_d_restoreResourceFromTrashBin as restoreResourceFromTrashBin,
      bookingsResourcesV2Resource_universal_d_updateResource as updateResource,
      bookingsResourcesV2Resource_universal_d_UpdateResource as UpdateResource,
      bookingsResourcesV2Resource_universal_d_UpdateResourceOptions as UpdateResourceOptions,
      bookingsResourcesV2Resource_universal_d_deleteResource as deleteResource,
      bookingsResourcesV2Resource_universal_d_bulkDeleteResources as bulkDeleteResources,
      bookingsResourcesV2Resource_universal_d_searchResources as searchResources,
      bookingsResourcesV2Resource_universal_d_SearchResourcesOptions as SearchResourcesOptions,
      bookingsResourcesV2Resource_universal_d_queryResources as queryResources,
      bookingsResourcesV2Resource_universal_d_ResourcesQueryResult as ResourcesQueryResult,
      bookingsResourcesV2Resource_universal_d_ResourcesQueryBuilder as ResourcesQueryBuilder,
      bookingsResourcesV2Resource_universal_d_countResources as countResources,
      bookingsResourcesV2Resource_universal_d_CountResourcesOptions as CountResourcesOptions,
    };
  }
  
  /** A ResourceType is a classification of resources, e.g. room, equipment or vehicle. */
  interface ResourceType$1 {
      /**
       * ResourceType ID.
       * @readonly
       */
      _id?: string | null;
      /**
       * Represents the current state of this resource type.
       * Each time the resource type is modified, its `revision` changes by the server.
       * For an update operation to succeed, you MUST pass the latest revision.
       * @readonly
       */
      revision?: string | null;
      /**
       * Represents the time this resource type was created.
       * @readonly
       */
      _createdDate?: Date | null;
      /**
       * Represents the time this resource type was last updated.
       * @readonly
       */
      _updatedDate?: Date | null;
      /** The name of this resource type, for example `meeting room`. The name must be unique per site. */
      name?: string | null;
      /**
       * The ID of the app of which the resources of this type belong to. Default: Bookings App ID.
       * @internal
       */
      appId?: string | null;
      /**
       * Aggregation data about counts of resources that have this type.
       * @internal
       * @readonly
       */
      resourceCounts?: ResourceCounts;
      /** Extensions enabling users to save custom data related to the resource type. */
      extendedFields?: ExtendedFields$5;
  }
  interface ResourceCounts {
      /**
       * The number of resources that have this type.
       * @readonly
       */
      total?: number | null;
      /**
       * Whether a resource of this type exists that is available in all locations
       * @readonly
       */
      hasResourcesInAllLocations?: boolean | null;
      /**
       * Whether a resource of this type exists that is available in any customer location
       * @readonly
       */
      hasResourcesInCustomerLocations?: boolean | null;
      /**
       * Whether a resource of this type exists that is available in any custom location
       * @readonly
       */
      hasResourcesInCustomLocations?: boolean | null;
      /**
       * Number of distinct business locations of resources with this type.
       * @readonly
       */
      distinctBusinessLocationsCount?: number | null;
      /**
       * Distinct business location ids of resources with this type. Only first 50 are returned.
       * @readonly
       */
      distinctLocationIds?: DistinctLocationIds;
  }
  interface DistinctLocationIds {
      /** Locations ids of business locations */
      values?: string[];
  }
  interface ExtendedFields$5 {
      /**
       * Extended field data. Each key corresponds to the namespace of the app that created the extended fields.
       * The value of each key is structured according to the schema defined when the extended fields were configured.
       *
       * You can only access fields for which you have the appropriate permissions.
       *
       * Learn more about [extended fields](https://dev.wix.com/docs/rest/articles/getting-started/extended-fields).
       */
      namespaces?: Record<string, Record<string, any>>;
  }
  interface CreateResourceTypeRequest {
      /** Resource type to be created. */
      resourceType: ResourceType$1;
      /**
       * The number of resources that must be created initially for this type
       * @internal
       */
      quantity?: number;
      /**
       * Locations where created resources are available
       * @internal
       */
      locationOptions?: LocationOptions;
      /**
       * List of additional fields to be included in the response.
       * @internal
       */
      fields?: RequestedFields$2[];
  }
  interface LocationOptions {
      /**
       * `true` if the resource is available in all locations, `false` if the resource is available only in specific locations.
       * Default: `false`.
       */
      availableInAllLocations?: boolean | null;
      /**
       * Details of specific locations. It must be left empty if `available_in_all_locations` is `true`.
       * If supplied then the field `specific_location_options.available_in_business_locations` must be set to `true`.
       */
      specificLocationOptions?: SpecificLocation;
  }
  interface SpecificLocation {
      /**
       * `true` if the resource can be used at a customer selected location, `false` otherwise.
       * Read more about locations in this [article](https://dev.wix.com/docs/rest/business-solutions/bookings/services/services-v2/about-service-locations).
       * Default: `false`.
       * @internal
       */
      availableInCustomerLocations?: boolean | null;
      /**
       * `true` if the resource is available in custom locations, `false` otherwise.
       * Default: `false`.
       * @internal
       */
      availableInCustomLocations?: boolean | null;
      /**
       * `true` if the resource is available in some business locations, `false` otherwise.
       * Default: `false`.
       */
      availableInBusinessLocations?: boolean | null;
      /**
       * Information about business locations. Should be empty if `available_in_business_locations` is `false` or if no business location exists in Locations.
       * Currently a single business location can be set.
       * Read more about business locations in this [article](https://dev.wix.com/docs/rest/business-management/locations/introduction).
       */
      businessLocations?: BusinessLocation$1[];
  }
  interface BusinessLocation$1 {
      /** The ID of the business location. Must not be empty. */
      locationId?: string | null;
  }
  enum RequestedFields$2 {
      UNKNOWN_REQUESTED_FIELD = "UNKNOWN_REQUESTED_FIELD",
      TOTAL_RESOURCE_COUNT = "TOTAL_RESOURCE_COUNT",
      SPECIFIC_LOCATION_TYPE_RESOURCE_COUNTS = "SPECIFIC_LOCATION_TYPE_RESOURCE_COUNTS",
      DISTINCT_RESOURCE_LOCATIONS = "DISTINCT_RESOURCE_LOCATIONS"
  }
  interface CreateResourceTypeResponse {
      /** The created resource type. */
      resourceType?: ResourceType$1;
      /**
       * Partial errors. ResourceType entity was created but requested dependant entities were not.
       * @internal
       */
      partialErrors?: CreateResourceTypeErrors[];
  }
  enum CreateResourceTypeErrors {
      UNKNOWN_CREATE_RESOURCE_TYPE_ERROR = "UNKNOWN_CREATE_RESOURCE_TYPE_ERROR",
      /** Failed to create requested `quantity` of resources for the resource type */
      FAILED_TO_CREATE_RESOURCES = "FAILED_TO_CREATE_RESOURCES"
  }
  interface GetResourceTypeRequest {
      /** ID of the resource type to retrieve. */
      resourceTypeId: string;
      /**
       * List of additional fields to be included in the response.
       * @internal
       */
      fields?: RequestedFields$2[];
  }
  interface GetResourceTypeResponse {
      /** The requested resource type. */
      resourceType?: ResourceType$1;
  }
  interface UpdateResourceTypeRequest {
      /** Resource type to update. [Partial updates](https://dev.wix.com/api/rest/wix-bookings/bookings/patch-endpoints-and-field-masks-in-update-requests) are supported. */
      resourceType: ResourceType$1;
      /**
       * Set of fields to update.
       * Fields that aren't included in `fieldMask.paths` are ignored.
       * See [Field Masks in Update Requests][1] for details on working with field masks.
       * [1]: https://dev.wix.com/api/rest/contacts/contacts/field-masks-in-update-requests
       * @internal
       */
      mask?: string[];
      /**
       * List of additional fields to be included in the response.
       * @internal
       */
      fields?: RequestedFields$2[];
  }
  interface UpdateResourceTypeResponse {
      /** Updated resource type. */
      resourceType?: ResourceType$1;
  }
  interface DeleteResourceTypeRequest {
      /** ID of the resource type to delete. */
      resourceTypeId: string;
  }
  interface DeleteResourceTypeResponse {
  }
  interface QueryResourceTypesRequest {
      /** WQL expression. */
      query?: CursorQuery$3;
      /**
       * List of additional fields to be included in the response.
       * @internal
       */
      fields?: RequestedFields$2[];
  }
  interface CursorQuery$3 extends CursorQueryPagingMethodOneOf$3 {
      /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
      cursorPaging?: CursorPaging$5;
      /**
       * Filter object in the following format:
       * `"filter" : {
       * "fieldName1": "value1",
       * "fieldName2":{"$operator":"value2"}
       * }`
       * Example of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`, `$contains`
       */
      filter?: Record<string, any> | null;
      /**
       * Sort object in the following format:
       * `[{"fieldName":"sortField1","order":"ASC"},{"fieldName":"sortField2","order":"DESC"}]`
       */
      sort?: Sorting$5[];
  }
  /** @oneof */
  interface CursorQueryPagingMethodOneOf$3 {
      /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
      cursorPaging?: CursorPaging$5;
  }
  interface Sorting$5 {
      /** Name of the field to sort by. */
      fieldName?: string;
      /** Sort order. */
      order?: SortOrder$5;
  }
  enum SortOrder$5 {
      ASC = "ASC",
      DESC = "DESC"
  }
  interface CursorPaging$5 {
      /** Number of items to load. */
      limit?: number | null;
      /**
       * Pointer to the next or previous page in the list of results.
       *
       * You can get the relevant cursor token
       * from the `pagingMetadata` object in the previous call's response.
       * Not relevant for the first request.
       */
      cursor?: string | null;
  }
  interface QueryResourceTypesResponse {
      /** The retrieved resource types. */
      resourceTypes?: ResourceType$1[];
      /** Paging metadata, including offset and count. */
      pagingMetadata?: CursorPagingMetadata$4;
  }
  interface CursorPagingMetadata$4 {
      /** Number of items returned in the response. */
      count?: number | null;
      /** Offset that was requested. */
      cursors?: Cursors$5;
      /**
       * Indicates if there are more results after the current page.
       * If `true`, another page of results can be retrieved.
       * If `false`, this is the last page.
       */
      hasNext?: boolean | null;
  }
  interface Cursors$5 {
      /** Cursor pointing to next page in the list of results. */
      next?: string | null;
      /** Cursor pointing to previous page in the list of results. */
      prev?: string | null;
  }
  interface CountResourceTypesRequest {
      /** Filter to apply on resource types to count. */
      filter?: Record<string, any> | null;
  }
  interface CountResourceTypesResponse {
      /** The number of resource types matching the given filter. */
      count?: number;
  }
  interface DomainEvent$5 extends DomainEventBodyOneOf$5 {
      createdEvent?: EntityCreatedEvent$5;
      updatedEvent?: EntityUpdatedEvent$5;
      deletedEvent?: EntityDeletedEvent$5;
      actionEvent?: ActionEvent$5;
      /**
       * Unique event ID.
       * Allows clients to ignore duplicate webhooks.
       */
      _id?: string;
      /**
       * Assumes actions are also always typed to an entity_type
       * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
       */
      entityFqdn?: string;
      /**
       * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
       * This is although the created/updated/deleted notion is duplication of the oneof types
       * Example: created/updated/deleted/started/completed/email_opened
       */
      slug?: string;
      /** ID of the entity associated with the event. */
      entityId?: string;
      /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
      eventTime?: Date | null;
      /**
       * Whether the event was triggered as a result of a privacy regulation application
       * (for example, GDPR).
       */
      triggeredByAnonymizeRequest?: boolean | null;
      /** If present, indicates the action that triggered the event. */
      originatedFrom?: string | null;
      /**
       * A sequence number defining the order of updates to the underlying entity.
       * For example, given that some entity was updated at 16:00 and than again at 16:01,
       * it is guaranteed that the sequence number of the second update is strictly higher than the first.
       * As the consumer, you can use this value to ensure that you handle messages in the correct order.
       * To do so, you will need to persist this number on your end, and compare the sequence number from the
       * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
       */
      entityEventSequence?: string | null;
  }
  /** @oneof */
  interface DomainEventBodyOneOf$5 {
      createdEvent?: EntityCreatedEvent$5;
      updatedEvent?: EntityUpdatedEvent$5;
      deletedEvent?: EntityDeletedEvent$5;
      actionEvent?: ActionEvent$5;
  }
  interface EntityCreatedEvent$5 {
      entityAsJson?: string;
      /**
       * Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity
       * @internal
       */
      triggeredByUndelete?: boolean | null;
      /** Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity */
      restoreInfo?: RestoreInfo$5;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface RestoreInfo$5 {
      deletedDate?: Date | null;
  }
  interface EntityUpdatedEvent$5 {
      /**
       * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
       * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
       * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
       */
      currentEntityAsJson?: string;
      /**
       * This field is currently part of the of the EntityUpdatedEvent msg, but scala/node libraries which implements the domain events standard
       * wont populate it / have any reference to it in the API.
       * The main reason for it is that fetching the old entity from the DB will have a performance hit on an update operation so unless truly needed,
       * the developer should send only the new (current) entity.
       * An additional reason is not wanting to send this additional entity over the wire (kafka) since in some cases it can be really big
       * Developers that must reflect the old entity will have to implement their own domain event sender mechanism which will follow the DomainEvent proto message.
       * @internal
       * @deprecated
       */
      previousEntityAsJson?: string | null;
      /**
       * WIP - This property will hold both names and values of the updated fields of the entity.
       * For more details please see [adr](https://docs.google.com/document/d/1PdqsOM20Ph2HAkmx8zvUnzzk3Sekp3BR9h34wSvsRnI/edit#heading=h.phlw87mh2imx) or [issue](https://github.com/wix-private/nile-tracker/issues/363)
       * @internal
       */
      modifiedFields?: Record<string, any>;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface EntityDeletedEvent$5 {
      /**
       * Indicates if the entity is sent to trash-bin. only available when trash-bin is enabled
       * @internal
       */
      movedToTrash?: boolean | null;
      /** Entity that was deleted */
      deletedEntityAsJson?: string | null;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface ActionEvent$5 {
      bodyAsJson?: string;
  }
  interface MessageEnvelope$5 {
      /** App instance ID. */
      instanceId?: string | null;
      /** Event type. */
      eventType?: string;
      /** The identification type and identity data. */
      identity?: IdentificationData$6;
      /** Stringify payload. */
      data?: string;
  }
  interface IdentificationData$6 extends IdentificationDataIdOneOf$6 {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
      /** @readonly */
      identityType?: WebhookIdentityType$5;
  }
  /** @oneof */
  interface IdentificationDataIdOneOf$6 {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
  }
  enum WebhookIdentityType$5 {
      UNKNOWN = "UNKNOWN",
      ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
      MEMBER = "MEMBER",
      WIX_USER = "WIX_USER",
      APP = "APP"
  }
  /**
   * Creates a new ResourceType.
   *
   * By using the create API, you can create a resource type and set its name and the ID of the app it belongs to.
   * @param resourceType - Resource type to be created.
   * @public
   * @documentationMaturity preview
   * @requiredField resourceType
   * @requiredField resourceType.name
   * @permissionId BOOKINGS.RESOURCE_TYPE_CREATE
   * @adminMethod
   * @returns The created resource type.
   */
  function createResourceType(resourceType: ResourceType$1, options?: CreateResourceTypeOptions): Promise<ResourceType$1>;
  interface CreateResourceTypeOptions {
      /**
       * The number of resources that must be created initially for this type
       * @internal
       */
      quantity?: number;
      /**
       * Locations where created resources are available
       * @internal
       */
      locationOptions?: LocationOptions;
      /**
       * List of additional fields to be included in the response.
       * @internal
       */
      fields?: RequestedFields$2[];
  }
  /**
   * Retrieves a ResourceType by ID.
   * @param resourceTypeId - ID of the resource type to retrieve.
   * @public
   * @documentationMaturity preview
   * @requiredField resourceTypeId
   * @permissionId BOOKINGS.RESOURCE_TYPE_READ
   * @permissionId BOOKINGS.RESOURCES_READ
   * @returns The requested resource type.
   */
  function getResourceType(resourceTypeId: string, options?: GetResourceTypeOptions): Promise<ResourceType$1>;
  interface GetResourceTypeOptions {
      /**
       * List of additional fields to be included in the response.
       * @internal
       */
      fields?: RequestedFields$2[];
  }
  /**
   * Updates a ResourceType.
   *
   * [Partial updates](https://dev.wix.com/api/rest/wix-bookings/bookings/patch-endpoints-and-field-masks-in-update-requests) are supported.
   *
   * Each time the resource type is updated, `revision` increments by 1. You must include current revision of the resource type when updating it.
   * This ensures you're working with the latest service information and prevents unintended overwrites.
   * @param _id - ResourceType ID.
   * @public
   * @documentationMaturity preview
   * @requiredField _id
   * @requiredField resourceType
   * @requiredField resourceType.revision
   * @permissionId BOOKINGS.RESOURCE_TYPE_UPDATE
   * @adminMethod
   * @returns Updated resource type.
   */
  function updateResourceType(_id: string | null, resourceType: UpdateResourceType, options?: UpdateResourceTypeOptions): Promise<ResourceType$1>;
  interface UpdateResourceType {
      /**
       * ResourceType ID.
       * @readonly
       */
      _id?: string | null;
      /**
       * Represents the current state of this resource type.
       * Each time the resource type is modified, its `revision` changes by the server.
       * For an update operation to succeed, you MUST pass the latest revision.
       * @readonly
       */
      revision?: string | null;
      /**
       * Represents the time this resource type was created.
       * @readonly
       */
      _createdDate?: Date | null;
      /**
       * Represents the time this resource type was last updated.
       * @readonly
       */
      _updatedDate?: Date | null;
      /** The name of this resource type, for example `meeting room`. The name must be unique per site. */
      name?: string | null;
      /**
       * The ID of the app of which the resources of this type belong to. Default: Bookings App ID.
       * @internal
       */
      appId?: string | null;
      /**
       * Aggregation data about counts of resources that have this type.
       * @internal
       * @readonly
       */
      resourceCounts?: ResourceCounts;
      /** Extensions enabling users to save custom data related to the resource type. */
      extendedFields?: ExtendedFields$5;
  }
  interface UpdateResourceTypeOptions {
      /**
       * Set of fields to update.
       * Fields that aren't included in `fieldMask.paths` are ignored.
       * See [Field Masks in Update Requests][1] for details on working with field masks.
       * [1]: https://dev.wix.com/api/rest/contacts/contacts/field-masks-in-update-requests
       * @internal
       */
      mask?: string[];
      /**
       * List of additional fields to be included in the response.
       * @internal
       */
      fields?: RequestedFields$2[];
  }
  /**
   * Deletes a ResourceType.
   * @param resourceTypeId - ID of the resource type to delete.
   * @public
   * @documentationMaturity preview
   * @requiredField resourceTypeId
   * @permissionId BOOKINGS.RESOURCE_TYPE_DELETE
   * @adminMethod
   */
  function deleteResourceType(resourceTypeId: string): Promise<void>;
  /**
   * Queries resource types, given the provided [paging, filtering, and sorting][1].
   *
   * Up to 100 resource types can be returned per request.
   *
   * To learn how to query ResourceTypes, see [API Query Language][2].
   *
   * [1]: https://dev.wix.com/api/rest/getting-started/sorting-and-paging
   * [2]: https://dev.wix.com/api/rest/getting-started/api-query-language
   * @public
   * @documentationMaturity preview
   * @permissionId BOOKINGS.RESOURCE_TYPE_READ
   */
  function queryResourceTypes(options?: QueryResourceTypesOptions): ResourceTypesQueryBuilder;
  interface QueryResourceTypesOptions {
      /**
       * List of additional fields to be included in the response.
       * @internal
       */
      fields?: RequestedFields$2[] | undefined;
  }
  interface QueryCursorResult$3 {
      cursors: Cursors$5;
      hasNext: () => boolean;
      hasPrev: () => boolean;
      length: number;
      pageSize: number;
  }
  interface ResourceTypesQueryResult extends QueryCursorResult$3 {
      items: ResourceType$1[];
      query: ResourceTypesQueryBuilder;
      next: () => Promise<ResourceTypesQueryResult>;
      prev: () => Promise<ResourceTypesQueryResult>;
  }
  interface ResourceTypesQueryBuilder {
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       * @documentationMaturity preview
       */
      eq: (propertyName: 'name', value: any) => ResourceTypesQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       * @documentationMaturity preview
       */
      ne: (propertyName: 'name', value: any) => ResourceTypesQueryBuilder;
      /** @param propertyName - Property whose value is compared with `string`.
       * @param string - String to compare against. Case-insensitive.
       * @documentationMaturity preview
       */
      startsWith: (propertyName: 'name', value: string) => ResourceTypesQueryBuilder;
      /** @param propertyName - Property whose value is compared with `values`.
       * @param values - List of values to compare against.
       * @documentationMaturity preview
       */
      hasSome: (propertyName: 'name', value: any[]) => ResourceTypesQueryBuilder;
      /** @documentationMaturity preview */
      in: (propertyName: 'name', value: any) => ResourceTypesQueryBuilder;
      /** @documentationMaturity preview */
      exists: (propertyName: 'name', value: boolean) => ResourceTypesQueryBuilder;
      /** @param limit - Number of items to return, which is also the `pageSize` of the results object.
       * @documentationMaturity preview
       */
      limit: (limit: number) => ResourceTypesQueryBuilder;
      /** @param cursor - A pointer to specific record
       * @documentationMaturity preview
       */
      skipTo: (cursor: string) => ResourceTypesQueryBuilder;
      /** @documentationMaturity preview */
      find: () => Promise<ResourceTypesQueryResult>;
  }
  /**
   * Counts resource types according to given criteria.
   *
   * Use [WQL filter](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#the-filter-section) to define the criteria.
   * @public
   * @documentationMaturity preview
   * @permissionId BOOKINGS.RESOURCE_TYPE_READ
   */
  function countResourceTypes(options?: CountResourceTypesOptions): Promise<CountResourceTypesResponse>;
  interface CountResourceTypesOptions {
      /** Filter to apply on resource types to count. */
      filter?: Record<string, any> | null;
  }
  
  type bookingsResourcesV2ResourceType_universal_d_ResourceCounts = ResourceCounts;
  type bookingsResourcesV2ResourceType_universal_d_DistinctLocationIds = DistinctLocationIds;
  type bookingsResourcesV2ResourceType_universal_d_CreateResourceTypeRequest = CreateResourceTypeRequest;
  type bookingsResourcesV2ResourceType_universal_d_LocationOptions = LocationOptions;
  type bookingsResourcesV2ResourceType_universal_d_SpecificLocation = SpecificLocation;
  type bookingsResourcesV2ResourceType_universal_d_CreateResourceTypeResponse = CreateResourceTypeResponse;
  type bookingsResourcesV2ResourceType_universal_d_CreateResourceTypeErrors = CreateResourceTypeErrors;
  const bookingsResourcesV2ResourceType_universal_d_CreateResourceTypeErrors: typeof CreateResourceTypeErrors;
  type bookingsResourcesV2ResourceType_universal_d_GetResourceTypeRequest = GetResourceTypeRequest;
  type bookingsResourcesV2ResourceType_universal_d_GetResourceTypeResponse = GetResourceTypeResponse;
  type bookingsResourcesV2ResourceType_universal_d_UpdateResourceTypeRequest = UpdateResourceTypeRequest;
  type bookingsResourcesV2ResourceType_universal_d_UpdateResourceTypeResponse = UpdateResourceTypeResponse;
  type bookingsResourcesV2ResourceType_universal_d_DeleteResourceTypeRequest = DeleteResourceTypeRequest;
  type bookingsResourcesV2ResourceType_universal_d_DeleteResourceTypeResponse = DeleteResourceTypeResponse;
  type bookingsResourcesV2ResourceType_universal_d_QueryResourceTypesRequest = QueryResourceTypesRequest;
  type bookingsResourcesV2ResourceType_universal_d_QueryResourceTypesResponse = QueryResourceTypesResponse;
  type bookingsResourcesV2ResourceType_universal_d_CountResourceTypesRequest = CountResourceTypesRequest;
  type bookingsResourcesV2ResourceType_universal_d_CountResourceTypesResponse = CountResourceTypesResponse;
  const bookingsResourcesV2ResourceType_universal_d_createResourceType: typeof createResourceType;
  type bookingsResourcesV2ResourceType_universal_d_CreateResourceTypeOptions = CreateResourceTypeOptions;
  const bookingsResourcesV2ResourceType_universal_d_getResourceType: typeof getResourceType;
  type bookingsResourcesV2ResourceType_universal_d_GetResourceTypeOptions = GetResourceTypeOptions;
  const bookingsResourcesV2ResourceType_universal_d_updateResourceType: typeof updateResourceType;
  type bookingsResourcesV2ResourceType_universal_d_UpdateResourceType = UpdateResourceType;
  type bookingsResourcesV2ResourceType_universal_d_UpdateResourceTypeOptions = UpdateResourceTypeOptions;
  const bookingsResourcesV2ResourceType_universal_d_deleteResourceType: typeof deleteResourceType;
  const bookingsResourcesV2ResourceType_universal_d_queryResourceTypes: typeof queryResourceTypes;
  type bookingsResourcesV2ResourceType_universal_d_QueryResourceTypesOptions = QueryResourceTypesOptions;
  type bookingsResourcesV2ResourceType_universal_d_ResourceTypesQueryResult = ResourceTypesQueryResult;
  type bookingsResourcesV2ResourceType_universal_d_ResourceTypesQueryBuilder = ResourceTypesQueryBuilder;
  const bookingsResourcesV2ResourceType_universal_d_countResourceTypes: typeof countResourceTypes;
  type bookingsResourcesV2ResourceType_universal_d_CountResourceTypesOptions = CountResourceTypesOptions;
  namespace bookingsResourcesV2ResourceType_universal_d {
    export {
      ResourceType$1 as ResourceType,
      bookingsResourcesV2ResourceType_universal_d_ResourceCounts as ResourceCounts,
      bookingsResourcesV2ResourceType_universal_d_DistinctLocationIds as DistinctLocationIds,
      ExtendedFields$5 as ExtendedFields,
      bookingsResourcesV2ResourceType_universal_d_CreateResourceTypeRequest as CreateResourceTypeRequest,
      bookingsResourcesV2ResourceType_universal_d_LocationOptions as LocationOptions,
      bookingsResourcesV2ResourceType_universal_d_SpecificLocation as SpecificLocation,
      BusinessLocation$1 as BusinessLocation,
      RequestedFields$2 as RequestedFields,
      bookingsResourcesV2ResourceType_universal_d_CreateResourceTypeResponse as CreateResourceTypeResponse,
      bookingsResourcesV2ResourceType_universal_d_CreateResourceTypeErrors as CreateResourceTypeErrors,
      bookingsResourcesV2ResourceType_universal_d_GetResourceTypeRequest as GetResourceTypeRequest,
      bookingsResourcesV2ResourceType_universal_d_GetResourceTypeResponse as GetResourceTypeResponse,
      bookingsResourcesV2ResourceType_universal_d_UpdateResourceTypeRequest as UpdateResourceTypeRequest,
      bookingsResourcesV2ResourceType_universal_d_UpdateResourceTypeResponse as UpdateResourceTypeResponse,
      bookingsResourcesV2ResourceType_universal_d_DeleteResourceTypeRequest as DeleteResourceTypeRequest,
      bookingsResourcesV2ResourceType_universal_d_DeleteResourceTypeResponse as DeleteResourceTypeResponse,
      bookingsResourcesV2ResourceType_universal_d_QueryResourceTypesRequest as QueryResourceTypesRequest,
      CursorQuery$3 as CursorQuery,
      CursorQueryPagingMethodOneOf$3 as CursorQueryPagingMethodOneOf,
      Sorting$5 as Sorting,
      SortOrder$5 as SortOrder,
      CursorPaging$5 as CursorPaging,
      bookingsResourcesV2ResourceType_universal_d_QueryResourceTypesResponse as QueryResourceTypesResponse,
      CursorPagingMetadata$4 as CursorPagingMetadata,
      Cursors$5 as Cursors,
      bookingsResourcesV2ResourceType_universal_d_CountResourceTypesRequest as CountResourceTypesRequest,
      bookingsResourcesV2ResourceType_universal_d_CountResourceTypesResponse as CountResourceTypesResponse,
      DomainEvent$5 as DomainEvent,
      DomainEventBodyOneOf$5 as DomainEventBodyOneOf,
      EntityCreatedEvent$5 as EntityCreatedEvent,
      RestoreInfo$5 as RestoreInfo,
      EntityUpdatedEvent$5 as EntityUpdatedEvent,
      EntityDeletedEvent$5 as EntityDeletedEvent,
      ActionEvent$5 as ActionEvent,
      MessageEnvelope$5 as MessageEnvelope,
      IdentificationData$6 as IdentificationData,
      IdentificationDataIdOneOf$6 as IdentificationDataIdOneOf,
      WebhookIdentityType$5 as WebhookIdentityType,
      bookingsResourcesV2ResourceType_universal_d_createResourceType as createResourceType,
      bookingsResourcesV2ResourceType_universal_d_CreateResourceTypeOptions as CreateResourceTypeOptions,
      bookingsResourcesV2ResourceType_universal_d_getResourceType as getResourceType,
      bookingsResourcesV2ResourceType_universal_d_GetResourceTypeOptions as GetResourceTypeOptions,
      bookingsResourcesV2ResourceType_universal_d_updateResourceType as updateResourceType,
      bookingsResourcesV2ResourceType_universal_d_UpdateResourceType as UpdateResourceType,
      bookingsResourcesV2ResourceType_universal_d_UpdateResourceTypeOptions as UpdateResourceTypeOptions,
      bookingsResourcesV2ResourceType_universal_d_deleteResourceType as deleteResourceType,
      bookingsResourcesV2ResourceType_universal_d_queryResourceTypes as queryResourceTypes,
      bookingsResourcesV2ResourceType_universal_d_QueryResourceTypesOptions as QueryResourceTypesOptions,
      bookingsResourcesV2ResourceType_universal_d_ResourceTypesQueryResult as ResourceTypesQueryResult,
      bookingsResourcesV2ResourceType_universal_d_ResourceTypesQueryBuilder as ResourceTypesQueryBuilder,
      bookingsResourcesV2ResourceType_universal_d_countResourceTypes as countResourceTypes,
      bookingsResourcesV2ResourceType_universal_d_CountResourceTypesOptions as CountResourceTypesOptions,
    };
  }
  
  /** The `Service` object represents the business offering that a business provides to its customers. */
  interface Service {
      /**
       * Service ID.
       * @readonly
       */
      _id?: string | null;
      /** Service type. */
      type?: ServiceType;
      /** Order of a service within a category. */
      sortOrder?: number | null;
      name?: string | null;
      description?: string | null;
      tagLine?: string | null;
      /** Default maximum number of customers that can book the service. The service cannot be booked beyond this capacity. */
      defaultCapacity?: number | null;
      /** Media associated with the service. */
      media?: Media;
      /** Whether the service is hidden from the site. */
      hidden?: boolean | null;
      /** The category the service is associated with. */
      category?: V2Category;
      /** The form used when booking the service. */
      form?: Form;
      /** Payment options for booking the service. */
      payment?: Payment;
      /** Online booking settings. */
      onlineBooking?: OnlineBooking;
      /** Conferencing options for this service. */
      conferencing?: Conferencing;
      /**
       * The locations this service is offered at.
       * In case of multiple (more than 1) location, All locations must be of type `BUSINESS`.
       * For courses only: Currently, only 1 location is supported, for all location types.
       */
      locations?: Location$3[];
      /** Policy determining under what conditions this service can be booked. For example, whether the service can only be booked up to 30 minutes before it begins. */
      bookingPolicy?: BookingPolicy$1;
      /** The service's schedule, which can be used to manage the service's sessions. */
      schedule?: Schedule$1;
      /** IDs of the staff members providing the service. For appointments only. */
      staffMemberIds?: string[];
      /**
       * Staff members providing the service. For appointments only. Returned only if `STAFF_MEMBER_DETAILS` conditional field was passed.
       * @internal
       * @readonly
       * @deprecated Staff members providing the service. For appointments only. Returned only if `STAFF_MEMBER_DETAILS` conditional field was passed.
       * @replacedBy staff_member_details.staff_members
       * @targetRemovalDate 2025-01-01
       */
      staffMembers?: StaffMember$1[];
      /**
       * Staff members details. Returned only if `STAFF_MEMBER_DETAILS` conditional field was passed.
       * @internal
       */
      staffMemberDetails?: StaffMemberDetails;
      /**
       * Resource groups required to book the service. For example, to book this service, you must book a room out of the resource group named "rooms".
       * @internal
       * @deprecated Resource groups required to book the service. For example, to book this service, you must book a room out of the resource group named "rooms".
       * @replacedBy service_resources
       * @targetRemovalDate 2024-08-19
       */
      resourceGroups?: ResourceGroup[];
      /**
       * Details on resources that are required to book the service. For example, to book this service, you must book a room out of the resource type named "rooms".
       * @internal
       */
      serviceResources?: ServiceResource[];
      /**
       * A slug is the last part of the URL address that serves as a unique identifier of the service.
       * The list of supported slugs includes past service names for backwards compatibility, and a custom slug if one was set by the business owner.
       * @readonly
       */
      supportedSlugs?: Slug[];
      /**
       * The main slug for the service. `mainSlug` is either taken from the current service name or is a custom slug set by the business owner.
       * `mainSlug` is used to construct the service's URLs.
       * @readonly
       */
      mainSlug?: Slug;
      /**
       * URLs to various service-related pages, such as the calendar page and the booking page.
       * @readonly
       */
      urls?: URLs;
      /** Extensions enabling users to save custom data related to the service. */
      extendedFields?: ExtendedFields$4;
      /** Custom SEO data for the service. */
      seoData?: SeoSchema;
      /**
       * Date and time the service was created.
       * @readonly
       */
      _createdDate?: Date | null;
      /**
       * Date and time the service was updated.
       * @readonly
       */
      _updatedDate?: Date | null;
      /**
       * Revision number, which increments by 1 each time the service is updated. To prevent conflicting changes, the existing revision must be used when updating a service.
       * @readonly
       */
      revision?: string | null;
  }
  enum ServiceType {
      UNKNOWN_SERVICE_TYPE = "UNKNOWN_SERVICE_TYPE",
      /** Service is an appointment. */
      APPOINTMENT = "APPOINTMENT",
      /** Service is a class. */
      CLASS = "CLASS",
      /** Service is a course. */
      COURSE = "COURSE"
  }
  interface Media {
      /** Media items associated with the service. */
      items?: MediaItem$1[];
      /** Primary media associated with the service. */
      mainMedia?: MediaItem$1;
      /** Cover media associated with the service. */
      coverMedia?: MediaItem$1;
  }
  interface MediaItem$1 extends MediaItemItemOneOf {
      /** The image's Wix media URL in the following format: `'wix:image://v1/<uri>/<filename>#originWidth=<width>&originHeight=<height>[&watermark=<watermark_manifest_string>]'`. */
      image?: string;
  }
  /** @oneof */
  interface MediaItemItemOneOf {
      /** The image's Wix media URL in the following format: `'wix:image://v1/<uri>/<filename>#originWidth=<width>&originHeight=<height>[&watermark=<watermark_manifest_string>]'`. */
      image?: string;
  }
  interface V2Category {
      /** Category ID. */
      _id?: string;
      /**
       * Category name.
       * @readonly
       */
      name?: string | null;
      /**
       * Order of a category within a category list.
       * @readonly
       */
      sortOrder?: number | null;
  }
  interface Form {
      /**
       * ID of the form associated with the service.
       * Form information submitted when booking, including contact details, participants, and other form fields, set up for the service.
       */
      _id?: string;
      /**
       * Settings that apply to the service booking form on mobile clients.
       * @internal
       */
      mobileSettings?: FormSettings;
  }
  interface FormSettings {
      /** Whether the service booking form should be hidden from the site. */
      hidden?: boolean | null;
  }
  interface Payment extends PaymentRateOneOf {
      /**
       * The details for the fixed price of the service.
       *
       * Required when: `rateType` is `FIXED`
       */
      fixed?: FixedPayment;
      /**
       * The details for the custom price of the service.
       *
       * Required when: `rateType` is `CUSTOM`
       */
      custom?: CustomPayment;
      /**
       * The details for the varied pricing of the service.
       * Read more about [varied price options](https://support.wix.com/en/article/wix-bookings-about-getting-paid-online#offering-varied-price-options).
       *
       * Required when: `rateType` is `VARIED`
       */
      varied?: VariedPayment;
      /**
       * The rate the customer is expected to pay for the service.
       * Can be:
       * - `FIXED`: The service has a fixed price.
       * - `CUSTOM`: The service has a custom price, expressed as a price description.
       * - `VARIED`: This service is offered with a set of different prices based on different terms.
       * - `NO_FEE`: This service is offered free of charge.
       */
      rateType?: RateType;
      /** The payment options a customer can use to pay for the service. */
      options?: PaymentOptions;
      /**
       * IDs of pricing plans that can be used as payment for the service.
       * @readonly
       */
      pricingPlanIds?: string[];
  }
  /** @oneof */
  interface PaymentRateOneOf {
      /**
       * The details for the fixed price of the service.
       *
       * Required when: `rateType` is `FIXED`
       */
      fixed?: FixedPayment;
      /**
       * The details for the custom price of the service.
       *
       * Required when: `rateType` is `CUSTOM`
       */
      custom?: CustomPayment;
      /**
       * The details for the varied pricing of the service.
       * Read more about [varied price options](https://support.wix.com/en/article/wix-bookings-about-getting-paid-online#offering-varied-price-options).
       *
       * Required when: `rateType` is `VARIED`
       */
      varied?: VariedPayment;
  }
  enum RateType {
      UNKNOWN_RATE_TYPE = "UNKNOWN_RATE_TYPE",
      /** The service has a fixed price. */
      FIXED = "FIXED",
      /** The service has a custom price, expressed as a price description. */
      CUSTOM = "CUSTOM",
      /** This service is offered with a set of different prices based on different terms. */
      VARIED = "VARIED",
      /** This service is offered free of charge. */
      NO_FEE = "NO_FEE"
  }
  interface FixedPayment {
      /**
       * The fixed price required to book the service.
       *
       * Required when: `rateType` is `FIXED`
       */
      price?: CommonMoney;
      /**
       * The deposit price required to book the service.
       *
       * Required when: `rateType` is `FIXED` and `paymentOptions.deposit` is `true`
       */
      deposit?: CommonMoney;
  }
  /**
   * Money.
   * Default format to use. Sufficiently compliant with majority of standards: w3c, ISO 4217, ISO 20022, ISO 8583:2003.
   */
  interface CommonMoney {
      /** Monetary amount. Decimal string with a period as a decimal separator (e.g., 3.99). Optionally, a single (-), to indicate that the amount is negative. */
      value?: string;
      /**
       * Currency code. Must be valid ISO 4217 currency code (e.g., USD).
       * @readonly
       */
      currency?: string;
      /** Monetary amount. Decimal string in local format (e.g., 1 000,30). Optionally, a single (-), to indicate that the amount is negative. */
      formattedValue?: string | null;
  }
  interface CustomPayment {
      /** A custom description explaining to the customer how to pay for the service. */
      description?: string | null;
  }
  interface VariedPayment {
      /** The default price for the service without any variants. It will also be used as the default price for any new variant. */
      defaultPrice?: CommonMoney;
      /**
       * The deposit price required to book the service.
       *
       * Required when: `rateType` is `VARIED` and `paymentOptions.deposit` is `true`
       */
      deposit?: CommonMoney;
      /**
       * The minimal price a customer may pay for this service, based on its variants.
       * @readonly
       */
      minPrice?: CommonMoney;
      /**
       * The maximum price a customer may pay for this service, based on its variants.
       * @readonly
       */
      maxPrice?: CommonMoney;
  }
  interface PaymentOptions {
      /**
       * Customers can pay for the service online.
       * When `true`:
       * + `rateType` must be either `FIXED` or `VARIED`.
       * + `fixed.price` or `varied.default_price` must be specified respectively. Read more about [getting paid online](https://support.wix.com/en/article/wix-bookings-about-getting-paid-online).
       */
      online?: boolean | null;
      /** Customers can pay for the service in person. */
      inPerson?: boolean | null;
      /**
       * This service requires a deposit to be made online in order to book it.
       * When `true`:
       * + `rateType` must be `VARIED` or `FIXED`.
       * + A `deposit` must be specified.
       */
      deposit?: boolean | null;
      /** Customers can pay for the service using a pricing plan. */
      pricingPlan?: boolean | null;
  }
  interface OnlineBooking {
      /**
       * Whether this service can be booked online.
       * When set to `true`, customers can book the service online. Configuring the payment options is done via `service.payment` property.
       * When set to `false`, customers cannot book the service online, and the service can only be paid for in person.
       */
      enabled?: boolean | null;
      /** Booking the service requires approval by the business owner. */
      requireManualApproval?: boolean | null;
      /** Multiple customers can request to book the same time slot. Relevant when `requireManualApproval` is `true`. */
      allowMultipleRequests?: boolean | null;
  }
  interface Conferencing {
      /** Whether a conference link is generated for the service's sessions. */
      enabled?: boolean | null;
  }
  interface Location$3 extends LocationOptionsOneOf {
      /** The service is offered at the referenced business location, the location has to reference a location from the Business Info [Locations API](https://dev.wix.com/api/rest/business-info/locations). */
      business?: BusinessLocationOptions;
      /** The service is offered at a custom location. */
      custom?: CustomLocationOptions;
      /**
       * A reflection of the id of the location.
       * @readonly
       */
      _id?: string;
      /**
       * The type of location:
       * - `CUSTOM`: The location is specific to this service, and is not derived from the business location.
       * - `BUSINESS`: A business location, as defined for the by the Business Info [Locations API](https://www.wix.com/velo/reference/wix-business-tools-v2/locations).
       * - `CUSTOMER`: Will be determined by the customer. For appointments only.
       */
      type?: LocationType$3;
      /**
       * The location address, based on the location `type`. If `type` is `CUSTOMER`, this address is empty.
       * @readonly
       */
      calculatedAddress?: Address$4;
  }
  /** @oneof */
  interface LocationOptionsOneOf {
      /** The service is offered at the referenced business location, the location has to reference a location from the Business Info [Locations API](https://dev.wix.com/api/rest/business-info/locations). */
      business?: BusinessLocationOptions;
      /** The service is offered at a custom location. */
      custom?: CustomLocationOptions;
  }
  enum LocationType$3 {
      UNKNOWN_LOCATION_TYPE = "UNKNOWN_LOCATION_TYPE",
      /** The location is unique to this service and isn't defined as one of the business locations. `CUSTOM` is the equivalent of the `OWNER_CUSTOM` location type in [Schedules & Sessions API](https://dev.wix.com/api/rest/wix-bookings/schedules-and-sessions). */
      CUSTOM = "CUSTOM",
      /** The location is one of the business locations available using the Business Info [Locations API](https://dev.wix.com/api/rest/business-info/locations). */
      BUSINESS = "BUSINESS",
      /** The location can be determined by the customer and is not set up beforehand. This is applicable to services of type `APPOINTMENT` only. */
      CUSTOMER = "CUSTOMER"
  }
  interface Address$4 extends AddressStreetOneOf$3 {
      /** Street name and number. */
      streetAddress?: StreetAddress$3;
      addressLine1?: string | null;
      /** 2-letter country code in an [ISO-3166 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format. */
      country?: string | null;
      /** Code for a subdivision (such as state, prefecture, or province) in [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) format. */
      subdivision?: string | null;
      /** City name. */
      city?: string | null;
      /** Postal or zip code. */
      postalCode?: string | null;
      /** Full address of the location. */
      formatted?: string | null;
      /**
       * Coordinates of the physical address.
       * @internal
       */
      location?: AddressLocation$3;
  }
  /** @oneof */
  interface AddressStreetOneOf$3 {
      /** Street name and number. */
      streetAddress?: StreetAddress$3;
      addressLine?: string | null;
  }
  /** Street address. Includes street name, number, and apartment number in separate fields. */
  interface StreetAddress$3 {
      /** Street number. */
      number?: string;
      /** Street name. */
      name?: string;
      /** Apartment number. */
      apt?: string;
  }
  interface AddressLocation$3 {
      /** Address latitude. */
      latitude?: number | null;
      /** Address longitude. */
      longitude?: number | null;
  }
  interface BusinessLocationOptions {
      /** Business location ID. */
      _id?: string;
      /**
       * Business location name.
       * @readonly
       */
      name?: string;
      /**
       * Whether this is the default location. There can only be 1 default location per site. The default location can't be archived.
       * @readonly
       */
      default?: boolean | null;
      /**
       * Business location address. The address is derived from the business location and is read-only.
       * @readonly
       */
      address?: Address$4;
      /**
       * Business location email
       * @readonly
       */
      email?: string | null;
      /**
       * Business location phone
       * @readonly
       */
      phone?: string | null;
  }
  interface CustomLocationOptions {
      /**
       * A constant id for the custom location.
       * @readonly
       */
      _id?: string;
      /** A custom address for the location. */
      address?: Address$4;
  }
  /**
   * `BookingPolicy` is the main entity of `BookingPolicyService` and specifies a set of rules for booking a service
   * by visitors and members.
   *
   * Each `BookingPolicy` consists of a number of sub-policies. When the Bookings App is provisioned to a meta site then a
   * default `BookingPolicy` will be created with defaults for each of these sub-policies. This also applies when a request
   * is received to create a new `BookingPolicy` and one or more of these sub-policies are not provided.
   *
   * Sub-policies are defined in separate objects as specified below.
   *
   * - The `LimitEarlyBookingPolicy` object defines the policy for limiting early bookings.
   * - The `LimitLateBookingPolicy` object defines the policy for limiting late bookings.
   * - The `BookAfterStartPolicy` object defines the policy for booking after the start of the schedule.
   * - The `CancellationPolicy` object defines the policy for canceling a booked entity.
   * - The `ReschedulePolicy` object defines the policy for rescheduling booked entity.
   * - The `WaitlistPolicy` object defines the policy for a waitlist.
   * - The `ParticipantsPolicy` object defines the policy regarding the participants per booking.
   * - The `ResourcesPolicy` object defines the policy regarding the resources per booking.
   * - The `CancellationFeePolicy` object defines the policy regarding cancellation fees.
   * - The `SaveCreditCardPolicy` object defines the policy for saving credit card details.
   *
   * By default each sub-policy is disabled. A more detailed specification of the default settings of each sub-policy
   * can be found in the description of the corresponding object.
   *
   * Partial updates are supported on the main entity level, however in order to update a sub-policy the client needs to provide the whole sub-policy object.
   */
  interface BookingPolicy$1 {
      /** The ID to the policy for the booking. */
      _id?: string;
      /**
       * Revision number, which increments by 1 each time the policy is updated. To prevent conflicting changes, the existing revision must be used when updating a policy. Can be empty after the service was cloned as part of site clone.
       * @internal
       * @readonly
       */
      revision?: string | null;
      /**
       * Date and time the policy was created.
       * @readonly
       */
      _createdDate?: Date | null;
      /**
       * Date and time the policy was updated.
       * @readonly
       */
      _updatedDate?: Date | null;
      /**
       * Name of the policy.
       * @readonly
       */
      name?: string | null;
      /**
       * Custom description for the policy. This policy is displayed to the participant.
       * @readonly
       */
      customPolicyDescription?: PolicyDescription$1;
      /**
       * Whether the policy is the default for the meta site.
       * @readonly
       */
      default?: boolean | null;
      /**
       * Policy for limiting early bookings.
       * @readonly
       */
      limitEarlyBookingPolicy?: LimitEarlyBookingPolicy$1;
      /**
       * Policy for limiting late bookings.
       * @readonly
       */
      limitLateBookingPolicy?: LimitLateBookingPolicy$1;
      /**
       * Policy on booking an entity after the start of the schedule.
       * @readonly
       */
      bookAfterStartPolicy?: BookAfterStartPolicy$1;
      /**
       * Policy for canceling a booked entity.
       * @readonly
       */
      cancellationPolicy?: CancellationPolicy$1;
      /**
       * Policy for rescheduling a booked entity.
       * @readonly
       */
      reschedulePolicy?: ReschedulePolicy$1;
      /**
       * Waitlist policy for the service.
       * @readonly
       */
      waitlistPolicy?: WaitlistPolicy$1;
      /**
       * Policy regarding the participants per booking.
       * @readonly
       */
      participantsPolicy?: ParticipantsPolicy$1;
      /**
       * Policy for allocating resources.
       * @readonly
       */
      resourcesPolicy?: ResourcesPolicy$1;
      /**
       * Rules for cancellation fees.
       * @readonly
       */
      cancellationFeePolicy?: CancellationFeePolicy$1;
      /**
       * Rule for saving credit card.
       * @readonly
       */
      saveCreditCardPolicy?: SaveCreditCardPolicy$1;
  }
  /** A description of the policy to display to participants. */
  interface PolicyDescription$1 {
      /**
       * Whether the description should be displayed. If `true`, the description is displayed.
       *
       * Default: `false`
       */
      enabled?: boolean;
      /**
       * The description to display.
       *
       * Default: Empty
       * Max length: 2500 characters
       */
      description?: string;
  }
  /** The policy for limiting early bookings. */
  interface LimitEarlyBookingPolicy$1 {
      /**
       * Whether there is a limit on how early a customer
       * can book. When `false`, there is no limit on the earliest
       * booking time and customers can book in advance, as early as they like.
       *
       * Default: `false`
       */
      enabled?: boolean;
      /**
       * Maximum number of minutes before the start of the session that a booking can be made. This value must be greater
       * than `latest_booking_in_minutes` in the `LimitLateBookingPolicy` policy.
       *
       * Default: 10080 minutes (7 days)
       * Min: 1 minute
       */
      earliestBookingInMinutes?: number;
  }
  /**
   * The policy for limiting late bookings.
   *
   * This policy and the `BookAfterStartPolicy` policy cannot be enabled at the same time. So if this policy
   * is enabled, `BookAfterStartPolicy` must be disabled.
   */
  interface LimitLateBookingPolicy$1 {
      /**
       * Whether there is a limit on how late a customer
       * can book. When `false`, there is no limit on the latest
       * booking time and customers can book up to the last minute.
       *
       * Default: `false`
       */
      enabled?: boolean;
      /**
       * Minimum number of minutes before the start of the session that a booking can be made.
       * For a schedule, this is relative to the start time of the next booked session, excluding past-booked sessions.
       * This value must be less than `earliest_booking_in_minutes` in the `LimitEarlyBookingPolicy` policy.
       *
       * Default: 1440 minutes (1 day)
       * Min: 1 minute
       */
      latestBookingInMinutes?: number;
  }
  /**
   * The policy for whether a session can be booked after the start of the schedule.
   * This policy and `LimitLateBookingPolicy` cannot be enabled at the same time. So if this policy
   * is enabled, the `LimitLateBookingPolicy` policy must be disabled.
   */
  interface BookAfterStartPolicy$1 {
      /**
       * Whether booking is allowed after the start of the schedule. When `true`,
       * customers can book after the start of the schedule.
       *
       * Default: `false`
       */
      enabled?: boolean;
  }
  /** The policy for canceling a booked session. */
  interface CancellationPolicy$1 {
      /**
       * Whether canceling a booking is allowed. When `true`, customers
       * can cancel the booking.
       *
       * Default: `false`
       */
      enabled?: boolean;
      /**
       * Whether there is a limit on the latest cancellation time. When `true`,
       * a time limit is enforced.
       *
       * Default: `false`
       */
      limitLatestCancellation?: boolean;
      /**
       * Minimum number of minutes before the start of the booked session that the booking can be canceled.
       *
       * Default: 1440 minutes (1 day)
       * Min: 1 minute
       */
      latestCancellationInMinutes?: number;
  }
  /** The policy for rescheduling a booked session. */
  interface ReschedulePolicy$1 {
      /**
       * Whether rescheduling a booking is allowed. When `true`, customers
       * can reschedule the booking.
       *
       * Default: `false`
       */
      enabled?: boolean;
      /**
       * Whether there is a limit on the latest reschedule time. When `true`,
       * a time limit is enforced.
       *
       * Default: `false`
       */
      limitLatestReschedule?: boolean;
      /**
       * Minimum number of minutes before the start of the booked session that the booking can be rescheduled.
       *
       * Default: 1440 minutes (1 day)
       * Min: 1 minute
       */
      latestRescheduleInMinutes?: number;
  }
  /** The policy for the waitlist. */
  interface WaitlistPolicy$1 {
      /**
       * Whether the session has a waitlist. If `true`, there is a waitlist.
       *
       * Default: `false`
       */
      enabled?: boolean;
      /**
       * Number of spots available in the waitlist.
       *
       * Default: 10 spots
       * Min: 1 spot
       */
      capacity?: number;
      /**
       * Amount of time a participant is given to book, once notified that a spot is available.
       *
       * Default: 10 minutes
       * Min: 1 spot
       */
      reservationTimeInMinutes?: number;
  }
  /** The policy for the maximum number of participants per booking. */
  interface ParticipantsPolicy$1 {
      /**
       * Whether the maximum number of participants applies. When `false`, there is
       * no maximum.
       *
       * Default: `false`
       * Private because not limiting participants per booking is not supported by Bookings flows today
       * @internal
       */
      enabled?: boolean;
      /**
       * Maximum number of participants allowed.
       *
       * Default: 1 participant
       * Min: 1 participant
       */
      maxParticipantsPerBooking?: number;
  }
  /** The policy regarding the allocation of resources (e.g. staff members). */
  interface ResourcesPolicy$1 {
      /**
       * `true` if this policy is enabled, `false` otherwise.
       * When `false` then the client must always select a resource when booking an appointment.
       */
      enabled?: boolean;
      /**
       * `true`, if it is allowed to automatically assign a resource when booking an appointment,
       * `false`, if the client must always select a resource.
       *
       * Default: `false`
       */
      autoAssignAllowed?: boolean;
  }
  interface CancellationFeePolicy$1 {
      /**
       * Whether canceling a booking will result in a cancellation fee
       *
       * Default: `false`
       */
      enabled?: boolean;
      /** Cancellation windows describing the time of cancellation and the fee to charge. */
      cancellationWindows?: CancellationWindow$1[];
      /**
       * Whether the cancellation fee should not be automatically collected when customer cancels the booking.
       *
       * Default: `true`
       */
      autoCollectFeeEnabled?: boolean | null;
  }
  interface CancellationWindow$1 extends CancellationWindowFeeOneOf$1 {
      /** Amount to be charged as a cancellation fee. */
      amount?: CommonMoney;
      /** Percentage of the original price to be charged as a cancellation fee. */
      percentage?: string;
      /** The fee will be applied if the booked session starts within this start time in minutes. */
      startInMinutes?: number | null;
  }
  /** @oneof */
  interface CancellationWindowFeeOneOf$1 {
      /** Amount to be charged as a cancellation fee. */
      amount?: CommonMoney;
      /** Percentage of the original price to be charged as a cancellation fee. */
      percentage?: string;
  }
  interface SaveCreditCardPolicy$1 {
      /** Default: `false` */
      enabled?: boolean;
  }
  interface Schedule$1 {
      /**
       * Schedule ID, used to manage the service's sessions.
       * @readonly
       */
      _id?: string | null;
      /**
       * Start time of the first session in the schedule. For courses only.
       * @readonly
       */
      firstSessionStart?: Date | null;
      /**
       * End time of the last session in the schedule. For courses only.
       * @readonly
       */
      lastSessionEnd?: Date | null;
      /** Limitations dictating the way session availability is calculated. For appointments only. */
      availabilityConstraints?: AvailabilityConstraints$1;
  }
  interface AvailabilityConstraints$1 {
      /**
       * A list of duration options for sessions, in minutes.
       *
       * The availability calculation generates slots for sessions with these durations, unless there is a conflict with existing sessions or other availability constraints exist.
       * Required for services of type `APPOINTMENT` to allow the customer to book a session of the service. Not relevant for other service types.
       *
       *
       * Min: 1 minute, Max: 30 days, 23 hours, and 59 minutes
       */
      sessionDurations?: number[];
      /**
       * The number of minutes between the end of a session and the start of the next.
       *
       *
       * Min: 0 minutes
       * Max: 720 minutes
       */
      timeBetweenSessions?: number;
  }
  interface StaffMember$1 {
      /**
       * ID of the staff member providing the service, can be used to retrieve resource information using wix-bookings-backend resources API.
       * @readonly
       */
      staffMemberId?: string;
      /**
       * Name of the staff member
       * @readonly
       */
      name?: string | null;
      /**
       * Main media associated with the service.
       * @readonly
       */
      mainMedia?: StaffMediaItem;
  }
  interface StaffMediaItem extends StaffMediaItemItemOneOf {
      /** Details of the image associated with the staff, such as URL and size. */
      image?: string;
  }
  /** @oneof */
  interface StaffMediaItemItemOneOf {
      /** Details of the image associated with the staff, such as URL and size. */
      image?: string;
  }
  interface StaffMemberDetails {
      /** Staff members providing the service. For appointments only. */
      staffMembers?: StaffMember$1[];
  }
  interface ResourceGroup {
      /**
       * An optional resource group id, if provided it references a resource group in the resource groups API.
       * TODO - referenced_entity annotation
       */
      resourceGroupId?: string | null;
      /**
       * Resource ids, each referencing a resource in resources API. may be a subset of resources within a resource group.
       * TODO - referenced_entity annotation
       */
      resourceIds?: ResourceIds;
      /**
       * How many resources of the group / resource ids are required in order to book the service.
       * Defaults to 1.
       */
      requiredResourcesNumber?: number | null;
      /**
       * If set to `true`, the custom can select the specific resources while booking the service.
       * If set to `false`, the resources required for to book the service would be auto selected at the time of the booking.
       * Defaults to false.
       * @readonly
       */
      selectableResource?: boolean | null;
  }
  interface ResourceIds {
      /** Values of the resource ids. TODO - referenced_entity annotation */
      values?: string[];
  }
  interface ServiceResource extends ServiceResourceSelectionOneOf {
      /** Resource ids, each referencing a resource in resources API. Must be a subset of resources within the selected resource type. */
      resourceIds?: ResourceIds;
      /** The unique identifier for the service resource, if not provided, would default to the resource type id. */
      _id?: string | null;
      /** Service resource type data. */
      resourceType?: ResourceType;
      /**
       * How many resources of the are required in order to book the service.
       * Defaults to 1.
       */
      requiredResourcesNumber?: number | null;
      /**
       * If set to `true`, the customer can select the specific resources while booking the service.
       * If set to `false`, the resources required for to book the service would be auto selected at the time of the booking.
       * Defaults to false.
       * @readonly
       */
      selectableResource?: boolean | null;
  }
  /** @oneof */
  interface ServiceResourceSelectionOneOf {
      /** Resource ids, each referencing a resource in resources API. Must be a subset of resources within the selected resource type. */
      resourceIds?: ResourceIds;
  }
  interface ResourceType {
      /** The type of the resource. */
      _id?: string | null;
      /**
       * The name of the resource type.
       * @readonly
       */
      name?: string | null;
  }
  interface Slug {
      /** The unique part of service's URL that identifies the service's information page. For example, `service-1` in `https:/example.com/services/service-1`. */
      name?: string;
      /**
       * Whether the slug was generated or customized. If `true`, the slug was customized manually by the business owner. Otherwise, the slug was automatically generated from the service name.
       * @readonly
       */
      custom?: boolean | null;
      /**
       * Date and time the slug was created. This is a system field.
       * @readonly
       */
      _createdDate?: Date | null;
  }
  interface URLs {
      /**
       * The URL for the service page.
       * @readonly
       */
      servicePage?: string;
      /**
       * The URL for the booking entry point. It can be either to the calendar or to the service page.
       * @readonly
       */
      bookingPage?: string;
      /**
       * The URL for the calendar. Can be empty if no calendar exists.
       * @readonly
       */
      calendarPage?: string;
  }
  interface ExtendedFields$4 {
      /**
       * Extended field data. Each key corresponds to the namespace of the app that created the extended fields.
       * The value of each key is structured according to the schema defined when the extended fields were configured.
       *
       * You can only access fields for which you have the appropriate permissions.
       *
       * Learn more about [extended fields](https://dev.wix.com/docs/rest/articles/getting-started/extended-fields).
       */
      namespaces?: Record<string, Record<string, any>>;
  }
  /**
   * The SEO schema object contains data about different types of meta tags. It makes sure that the information about your page is presented properly to search engines.
   * The search engines use this information for ranking purposes, or to display snippets in the search results.
   * This data will override other sources of tags (for example patterns) and will be included in the <head> section of the HTML document, while not being displayed on the page itself.
   */
  interface SeoSchema {
      /** SEO tag information. */
      tags?: Tag[];
      /** SEO general settings. */
      settings?: Settings;
  }
  interface Keyword {
      /** Keyword value. */
      term?: string;
      /** Whether the keyword is the main focus keyword. */
      isMain?: boolean;
      /** The source that added the keyword terms to the SEO settings. */
      origin?: string | null;
  }
  interface Tag {
      /**
       * SEO tag type.
       *
       *
       * Supported values: `title`, `meta`, `script`, `link`.
       */
      type?: string;
      /**
       * A `{'key':'value'}` pair object where each SEO tag property (`'name'`, `'content'`, `'rel'`, `'href'`) contains a value.
       * For example: `{'name': 'description', 'content': 'the description itself'}`.
       */
      props?: Record<string, any> | null;
      /** SEO tag meta data. For example, `{height: 300, width: 240}`. */
      meta?: Record<string, any> | null;
      /** SEO tag inner content. For example, `<title> inner content </title>`. */
      children?: string;
      /** Whether the tag is a custom tag. */
      custom?: boolean;
      /** Whether the tag is disabled. */
      disabled?: boolean;
  }
  interface Settings {
      /**
       * Whether the Auto Redirect feature, which creates `301 redirects` on a slug change, is enabled.
       *
       *
       * Default: `false` (Auto Redirect is enabled.)
       */
      preventAutoRedirect?: boolean;
      /** User-selected keyword terms for a specific page. */
      keywords?: Keyword[];
  }
  /**
   * Message for reindexing search data to a given search schema. Support both upsert and delete flows as well as
   * performs context manipulation with adding tenant, provided in message to callscope.
   */
  interface ReindexMessage extends ReindexMessageActionOneOf {
      upsert?: Upsert;
      delete?: Delete;
      entityFqdn?: string;
      tenantId?: string;
      eventTime?: Date | null;
      entityEventSequence?: string | null;
      schema?: Schema;
  }
  /** @oneof */
  interface ReindexMessageActionOneOf {
      upsert?: Upsert;
      delete?: Delete;
  }
  interface Upsert {
      entityId?: string;
      entityAsJson?: string;
  }
  interface Delete {
      entityId?: string;
  }
  interface Schema {
      label?: string;
      clusterName?: string;
  }
  interface SetCustomSlugEvent {
      /** The main slug for the service after the update */
      mainSlug?: Slug;
  }
  interface ServicesUrlsChanged {
  }
  interface DomainEvent$4 extends DomainEventBodyOneOf$4 {
      createdEvent?: EntityCreatedEvent$4;
      updatedEvent?: EntityUpdatedEvent$4;
      deletedEvent?: EntityDeletedEvent$4;
      actionEvent?: ActionEvent$4;
      /**
       * Unique event ID.
       * Allows clients to ignore duplicate webhooks.
       */
      _id?: string;
      /**
       * Assumes actions are also always typed to an entity_type
       * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
       */
      entityFqdn?: string;
      /**
       * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
       * This is although the created/updated/deleted notion is duplication of the oneof types
       * Example: created/updated/deleted/started/completed/email_opened
       */
      slug?: string;
      /** ID of the entity associated with the event. */
      entityId?: string;
      /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
      eventTime?: Date | null;
      /**
       * Whether the event was triggered as a result of a privacy regulation application
       * (for example, GDPR).
       */
      triggeredByAnonymizeRequest?: boolean | null;
      /** If present, indicates the action that triggered the event. */
      originatedFrom?: string | null;
      /**
       * A sequence number defining the order of updates to the underlying entity.
       * For example, given that some entity was updated at 16:00 and than again at 16:01,
       * it is guaranteed that the sequence number of the second update is strictly higher than the first.
       * As the consumer, you can use this value to ensure that you handle messages in the correct order.
       * To do so, you will need to persist this number on your end, and compare the sequence number from the
       * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
       */
      entityEventSequence?: string | null;
  }
  /** @oneof */
  interface DomainEventBodyOneOf$4 {
      createdEvent?: EntityCreatedEvent$4;
      updatedEvent?: EntityUpdatedEvent$4;
      deletedEvent?: EntityDeletedEvent$4;
      actionEvent?: ActionEvent$4;
  }
  interface EntityCreatedEvent$4 {
      entityAsJson?: string;
      /**
       * Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity
       * @internal
       */
      triggeredByUndelete?: boolean | null;
      /** Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity */
      restoreInfo?: RestoreInfo$4;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface RestoreInfo$4 {
      deletedDate?: Date | null;
  }
  interface EntityUpdatedEvent$4 {
      /**
       * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
       * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
       * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
       */
      currentEntityAsJson?: string;
      /**
       * This field is currently part of the of the EntityUpdatedEvent msg, but scala/node libraries which implements the domain events standard
       * wont populate it / have any reference to it in the API.
       * The main reason for it is that fetching the old entity from the DB will have a performance hit on an update operation so unless truly needed,
       * the developer should send only the new (current) entity.
       * An additional reason is not wanting to send this additional entity over the wire (kafka) since in some cases it can be really big
       * Developers that must reflect the old entity will have to implement their own domain event sender mechanism which will follow the DomainEvent proto message.
       * @internal
       * @deprecated
       */
      previousEntityAsJson?: string | null;
      /**
       * WIP - This property will hold both names and values of the updated fields of the entity.
       * For more details please see [adr](https://docs.google.com/document/d/1PdqsOM20Ph2HAkmx8zvUnzzk3Sekp3BR9h34wSvsRnI/edit#heading=h.phlw87mh2imx) or [issue](https://github.com/wix-private/nile-tracker/issues/363)
       * @internal
       */
      modifiedFields?: Record<string, any>;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface EntityDeletedEvent$4 {
      /**
       * Indicates if the entity is sent to trash-bin. only available when trash-bin is enabled
       * @internal
       */
      movedToTrash?: boolean | null;
      /** Entity that was deleted */
      deletedEntityAsJson?: string | null;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface ActionEvent$4 {
      bodyAsJson?: string;
  }
  interface MessageEnvelope$4 {
      /** App instance ID. */
      instanceId?: string | null;
      /** Event type. */
      eventType?: string;
      /** The identification type and identity data. */
      identity?: IdentificationData$5;
      /** Stringify payload. */
      data?: string;
  }
  interface IdentificationData$5 extends IdentificationDataIdOneOf$5 {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
      /** @readonly */
      identityType?: WebhookIdentityType$4;
  }
  /** @oneof */
  interface IdentificationDataIdOneOf$5 {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
  }
  enum WebhookIdentityType$4 {
      UNKNOWN = "UNKNOWN",
      ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
      MEMBER = "MEMBER",
      WIX_USER = "WIX_USER",
      APP = "APP"
  }
  interface CreateServiceRequest {
      /** Service to be created. */
      service: Service;
  }
  interface CreateServiceResponse {
      /** The created service. */
      service?: Service;
  }
  interface BulkCreateServicesRequest {
      services: Service[];
      /** `true` if the created entities must be included in the response, */
      returnEntity?: boolean;
      /**
       * otherwise no entities are included in the response.
       * @internal
       */
      skipScheduleCreation?: boolean;
  }
  interface BulkCreateServicesResponse {
      /** The result of each service creation. */
      results?: BulkServiceResult[];
      /** Create statistics. */
      bulkActionMetadata?: BulkActionMetadata$2;
  }
  interface BulkServiceResult {
      /** Updated service metadata. */
      itemMetadata?: ItemMetadata$2;
      /** The updated service. */
      item?: Service;
  }
  interface ItemMetadata$2 {
      /** Item ID. Should always be available, unless it's impossible (for example, when failing to create an item). */
      _id?: string | null;
      /** Index of the item within the request array. Allows for correlation between request and response items. */
      originalIndex?: number;
      /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
      success?: boolean;
      /** Details about the error in case of failure. */
      error?: ApplicationError$2;
  }
  interface ApplicationError$2 {
      /** Error code. */
      code?: string;
      /** Description of the error. */
      description?: string;
      /** Data related to the error. */
      data?: Record<string, any> | null;
  }
  interface BulkActionMetadata$2 {
      /** Number of items that were successfully processed. */
      totalSuccesses?: number;
      /** Number of items that couldn't be processed. */
      totalFailures?: number;
      /** Number of failures without details because detailed failure threshold was exceeded. */
      undetailedFailures?: number;
  }
  interface GetServiceRequest {
      serviceId: string;
      /** @internal */
      conditionalFields?: RequestedFields$1[];
      /** @internal */
      eventuallyConsistent?: boolean | null;
  }
  enum RequestedFields$1 {
      UNKNOWN_REQUESTED_FIELD = "UNKNOWN_REQUESTED_FIELD",
      /** When passed, `service.staff_members` is returned */
      STAFF_MEMBER_DETAILS = "STAFF_MEMBER_DETAILS",
      /** When passed, `service.service_resources.resource_type.name` is */
      RESOURCE_TYPE_DETAILS = "RESOURCE_TYPE_DETAILS"
  }
  interface GetServiceResponse {
      /** The retrieved service. */
      service?: Service;
  }
  interface GetServiceAvailabilityConstraintsRequest {
      serviceId: string;
  }
  interface GetServiceAvailabilityConstraintsResponse {
      /** The retrieved availability constraints of the service. */
      constraints?: ServiceAvailabilityConstraints;
  }
  interface ServiceAvailabilityConstraints {
      /**
       * The booking policy.
       * @readonly
       */
      bookingPolicy?: BookingPolicy$1;
      /**
       * The service schedule, including the schedule id and availability constraints.
       * @readonly
       */
      schedule?: Schedule$1;
      /**
       * The locations this service is offered at.
       * Only multiple locations of type `BUSINESS` are supported. multiple locations of type `CUSTOM` or `CUSTOMER` are not supported.
       * For courses only: Currently, only 1 location is supported, for all location types.
       * Use `setServiceLocations` method to change the locations this service is offered at.
       * @readonly
       */
      locations?: Location$3[];
      /**
       * Resource groups required to book the service. For backwards compatibility only. Use `serviceResources` instead.
       * @readonly
       * @deprecated Resource groups required to book the service. For backwards compatibility only. Use `serviceResources` instead.
       * @replacedBy service_resources
       * @targetRemovalDate 2024-08-19
       */
      resourceGroups?: ResourceGroup[];
      /**
       * Resource groups required to book the service
       * @readonly
       */
      serviceResources?: ServiceResource[];
      /**
       * The time between available slots' start times.
       * For example, For 5 minute slots, 3:00, 3:05, 3:15 etc. For 1 hour slots, 3:00, 4:00, 5:00 etc.
       * Is applied to all schedules of the site.
       * For appointment only.
       * @readonly
       */
      slotsSplitInterval?: V1SplitInterval;
      /**
       * Online booking settings.
       * @readonly
       */
      onlineBooking?: OnlineBooking;
  }
  /** The time between available slots' start times. For example, For 5 minute slots, 3:00, 3:05, 3:15 etc. For 1 hour slots, 3:00, 4:00, 5:00 etc. */
  interface V1SplitInterval {
      /**
       * Whether the slot duration is used as the split interval value.
       * If `same_as_duration` is `true`, the `value_in_minutes` is the sum of the first duration in
       * `schedule.availabilityConstraints.SlotDurations` field, and `schedule.availabilityConstraints.TimeBetweenSlots` field.
       */
      sameAsDuration?: boolean | null;
      /** Number of minutes between available slots' start times when `same_as_duration` is `false`. */
      valueInMinutes?: number | null;
  }
  interface UpdateServiceRequest {
      /** Service to update. [Partial */
      service: Service;
      /**
       * updates](https://dev.wix.com/api/rest/wix-bookings/bookings/patch-endpoints-and-field-masks-in-update-requests)
       * are supported.
       * @internal
       */
      mask?: string[];
  }
  interface UpdateServiceResponse {
      /** The updated service. */
      service?: Service;
  }
  interface BulkUpdateServicesRequest {
      services?: MaskedService[];
      /** `true` if the updated entities must be included in the response, */
      returnEntity?: boolean;
  }
  interface MaskedService {
      /** Service to update. [Partial */
      service?: Service;
      /**
       * updates](https://dev.wix.com/api/rest/wix-bookings/bookings/patch-endpoints-and-field-masks-in-update-requests)
       * are supported.
       * @internal
       */
      mask?: string[];
  }
  interface BulkUpdateServicesResponse {
      /** The result of each service update. */
      results?: BulkServiceResult[];
      /** Update statistics. */
      bulkActionMetadata?: BulkActionMetadata$2;
  }
  interface BulkUpdateServicesByFilterRequest {
      /** Filter to identify the services that need to be updated. */
      filter: Record<string, any> | null;
      /**
       * Service to update. [Partial
       * updates](https://dev.wix.com/api/rest/wix-bookings/bookings/patch-endpoints-and-field-masks-in-update-requests)
       * are supported.
       */
      service: Service;
      /**
       * Explicit list of fields to update.
       * @internal
       */
      mask?: string[];
  }
  interface BulkUpdateServicesByFilterResponse {
      /** ID of the service update job. */
      jobId?: string;
  }
  interface DeleteServiceRequest {
      serviceId: string;
      /**
       * Whether to preserve future sessions with participants.
       *
       * Default: `false`
       */
      preserveFutureSessionsWithParticipants?: boolean;
      /** Whether to notify participants about the change and an optional */
      participantNotification?: ParticipantNotification$4;
  }
  interface ParticipantNotification$4 {
      /**
       * Whether to send the message about the changes to the customer.
       *
       * Default: `false`
       */
      notifyParticipants?: boolean | null;
      /** Custom message to send to the participants about the changes to the booking. */
      message?: string | null;
  }
  interface DeleteServiceResponse {
  }
  interface BulkDeleteServicesRequest {
      /** Ids of the services for deletion. */
      ids: string[];
      /**
       * Whether to preserve future sessions with participants.
       *
       * Default: `false`.
       */
      preserveFutureSessionsWithParticipants?: boolean;
      /** Whether to notify participants about the change and an optional */
      participantNotification?: ParticipantNotification$4;
  }
  interface BulkDeleteServicesResponse {
      /** The result of each service removal. */
      results?: BulkServiceResult[];
      /** Update statistics. */
      bulkActionMetadata?: BulkActionMetadata$2;
  }
  interface BulkDeleteServicesByFilterRequest {
      /** Filter to identify the services that need to be deleted. */
      filter: Record<string, any> | null;
      /**
       * Whether to preserve future sessions with participants.
       *
       * Default: `false`.
       */
      preserveFutureSessionsWithParticipants?: boolean;
      /** Whether to notify participants about the change and an optional custom message. */
      participantNotification?: ParticipantNotification$4;
  }
  interface BulkDeleteServicesByFilterResponse {
      /** ID of the service deletion job. */
      jobId?: string;
  }
  interface QueryServicesRequest {
      /** WQL expression. */
      query: QueryV2$2;
      /** @internal */
      conditionalFields?: RequestedFields$1[];
      /** @internal */
      eventuallyConsistent?: boolean | null;
  }
  interface QueryV2$2 extends QueryV2PagingMethodOneOf$2 {
      /** Paging options to limit and skip the number of items. */
      paging?: Paging$2;
      /**
       * Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`.
       * @internal
       */
      cursorPaging?: CursorPaging$4;
      /**
       * Filter object in the following format:
       *
       * `"filter" : {
       * "fieldName1": "value1",
       * "fieldName2":{"$operator":"value2"}
       * }`
       *
       * Example of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`
       *
       * Read more about [supported fields and operators](https://dev.wix.com/api/rest/wix-bookings/services-v2/filtering-and-sorting).
       */
      filter?: Record<string, any> | null;
      /**
       * Sort object in the following format:
       * `[ {"fieldName":"sortField1","order":"ASC"},
       * {"fieldName":"sortField2","order":"DESC"} ]`
       *
       * Read more about [sorting](https://dev.wix.com/api/rest/wix-bookings/services-v2/filtering-and-sorting#wix-bookings_services-v2_filtering-and-sorting_sorting).
       */
      sort?: Sorting$4[];
      /**
       * Array of projected fields. A list of specific field names to return. If `fieldsets` are also specified, the union of `fieldsets` and `fields` is returned.
       * @internal
       */
      fields?: string[];
      /**
       * Array of named, predefined sets of projected fields. A array of predefined named sets of fields to be returned. Specifying multiple `fieldsets` will return the union of fields from all sets. If `fields` are also specified, the union of `fieldsets` and `fields` is returned.
       * @internal
       */
      fieldsets?: string[];
  }
  /** @oneof */
  interface QueryV2PagingMethodOneOf$2 {
      /** Paging options to limit and skip the number of items. */
      paging?: Paging$2;
      /**
       * Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`.
       * @internal
       */
      cursorPaging?: CursorPaging$4;
  }
  interface Sorting$4 {
      /** Name of the field to sort by. */
      fieldName?: string;
      /** Sort order. */
      order?: SortOrder$4;
  }
  enum SortOrder$4 {
      ASC = "ASC",
      DESC = "DESC"
  }
  interface Paging$2 {
      /** Number of items to load. */
      limit?: number | null;
      /** Number of items to skip in the current sort order. */
      offset?: number | null;
  }
  interface CursorPaging$4 {
      /** Number of items to load. */
      limit?: number | null;
      /**
       * Pointer to the next or previous page in the list of results.
       *
       * You can get the relevant cursor token
       * from the `pagingMetadata` object in the previous call's response.
       * Not relevant for the first request.
       */
      cursor?: string | null;
  }
  interface QueryServicesResponse {
      /** The retrieved services. */
      services?: Service[];
      /** Paging metadata, including offset and count. */
      pagingMetadata?: PagingMetadataV2$1;
  }
  interface PagingMetadataV2$1 {
      /** Number of items returned in the response. */
      count?: number | null;
      /** Offset that was requested. */
      offset?: number | null;
      /** Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set. */
      total?: number | null;
      /** Flag that indicates the server failed to calculate the `total` field. */
      tooManyToCount?: boolean | null;
      /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
      cursors?: Cursors$4;
      /**
       * Indicates if there are more results after the current page.
       * If `true`, another page of results can be retrieved.
       * If `false`, this is the last page.
       * @internal
       */
      hasNext?: boolean | null;
  }
  interface Cursors$4 {
      /** Cursor pointing to next page in the list of results. */
      next?: string | null;
      /** Cursor pointing to previous page in the list of results. */
      prev?: string | null;
  }
  interface SearchServicesRequest {
      /** WQL, search or aggregation expression. */
      search: CursorSearch$1;
  }
  interface CursorSearch$1 extends CursorSearchPagingMethodOneOf$1 {
      /**
       * Cursor pointing to page of results.
       * When requesting 'cursor_paging.cursor', no `filter`, `sort` or `search` can be provided.
       */
      cursorPaging?: CursorPaging$4;
      /** A filter object. See documentation [here](https://bo.wix.com/wix-docs/rnd/platformization-guidelines/api-query-language#platformization-guidelines_api-query-language_defining-in-protobuf) */
      filter?: Record<string, any> | null;
      /** Sort object in the form [{"fieldName":"sortField1"},{"fieldName":"sortField2","direction":"DESC"}] */
      sort?: Sorting$4[];
      /** Aggregations | Faceted search: refers to a way to explore large amounts of data by displaying summaries about various partitions of the data and later allowing to narrow the navigation to a specific partition. */
      aggregations?: Aggregation[];
      /** Free text to match in searchable fields */
      search?: SearchDetails$1;
      /**
       * UTC offset or IANA time zone. Valid values are
       * ISO 8601 UTC offsets, such as +02:00 or -06:00,
       * and IANA time zone IDs, such as Europe/Rome
       *
       * Affects all filters and aggregations returned values.
       * You may override this behavior in a specific filter by providing
       * timestamps including time zone. e.g. `"2023-12-20T10:52:34.795Z"`
       */
      timeZone?: string | null;
  }
  /** @oneof */
  interface CursorSearchPagingMethodOneOf$1 {
      /**
       * Cursor pointing to page of results.
       * When requesting 'cursor_paging.cursor', no `filter`, `sort` or `search` can be provided.
       */
      cursorPaging?: CursorPaging$4;
  }
  interface Aggregation extends AggregationKindOneOf {
      /** Value aggregation */
      value?: ValueAggregation;
      /** Range aggregation */
      range?: RangeAggregation;
      /** Scalar aggregation */
      scalar?: ScalarAggregation;
      /** Date histogram aggregation */
      dateHistogram?: DateHistogramAggregation;
      /** Nested aggregation */
      nested?: NestedAggregation;
      /** User-defined name of aggregation, should be unique, will appear in aggregation results */
      name?: string | null;
      /** Type of aggregation, client must provide matching aggregation field below */
      type?: AggregationType$1;
      /** Field to aggregate by, use dot notation to specify json path */
      fieldPath?: string;
      /**
       * deprecated, use `nested` instead
       * @deprecated deprecated, use `nested` instead
       * @replacedBy kind.nested
       * @targetRemovalDate 2025-01-01
       */
      groupBy?: GroupByAggregation;
  }
  /** @oneof */
  interface AggregationKindOneOf {
      /** Value aggregation */
      value?: ValueAggregation;
      /** Range aggregation */
      range?: RangeAggregation;
      /** Scalar aggregation */
      scalar?: ScalarAggregation;
      /** Date histogram aggregation */
      dateHistogram?: DateHistogramAggregation;
      /** Nested aggregation */
      nested?: NestedAggregation;
  }
  interface RangeBucket {
      /** Inclusive lower bound of the range. Required if to is not given. */
      from?: number | null;
      /** Exclusive upper bound of the range. Required if from is not given. */
      to?: number | null;
  }
  enum SortType {
      COUNT = "COUNT",
      VALUE = "VALUE"
  }
  enum SortDirection {
      DESC = "DESC",
      ASC = "ASC"
  }
  enum MissingValues {
      EXCLUDE = "EXCLUDE",
      INCLUDE = "INCLUDE"
  }
  interface IncludeMissingValuesOptions {
      /** can specify custom bucket name. Defaults are [string -> "N/A"], [int -> "0"], [bool -> "false"] ... */
      addToBucket?: string;
  }
  enum ScalarType$1 {
      UNKNOWN_SCALAR_TYPE = "UNKNOWN_SCALAR_TYPE",
      COUNT_DISTINCT = "COUNT_DISTINCT",
      MIN = "MIN",
      MAX = "MAX",
      SUM = "SUM",
      AVG = "AVG"
  }
  interface ValueAggregation extends ValueAggregationOptionsOneOf {
      /** options for including missing values */
      includeOptions?: IncludeMissingValuesOptions;
      /** Should sort by number of matches or value of the field */
      sortType?: SortType;
      /** Should sort in ascending or descending order */
      sortDirection?: SortDirection;
      /** How many aggregations would you like to return? Can be between 1 and 250. 10 is the default. */
      limit?: number | null;
      /** should missing values be included or excluded from the aggregation results. Default is EXCLUDE */
      missingValues?: MissingValues;
  }
  /** @oneof */
  interface ValueAggregationOptionsOneOf {
      /** options for including missing values */
      includeOptions?: IncludeMissingValuesOptions;
  }
  enum NestedAggregationType {
      UNKNOWN_AGGREGATION_TYPE = "UNKNOWN_AGGREGATION_TYPE",
      VALUE = "VALUE",
      RANGE = "RANGE",
      SCALAR = "SCALAR",
      DATE_HISTOGRAM = "DATE_HISTOGRAM"
  }
  interface RangeAggregation {
      /** Range buckets */
      buckets?: RangeBucket[];
  }
  interface ScalarAggregation {
      /** Define the operator for the scalar aggregation */
      type?: ScalarType$1;
  }
  interface DateHistogramAggregation {
      /** Interval for date histogram aggregation */
      interval?: DateHistogramAggregationInterval;
  }
  enum DateHistogramAggregationInterval {
      UNKNOWN_INTERVAL = "UNKNOWN_INTERVAL",
      /** Yearly interval */
      YEAR = "YEAR",
      /** Monthly interval */
      MONTH = "MONTH",
      /** Weekly interval */
      WEEK = "WEEK",
      /** Daily interval */
      DAY = "DAY",
      /** Hourly interval */
      HOUR = "HOUR",
      /** Minute interval */
      MINUTE = "MINUTE",
      /** Second interval */
      SECOND = "SECOND"
  }
  interface NestedAggregationItem extends NestedAggregationItemKindOneOf {
      /** Value aggregation */
      value?: ValueAggregation;
      /** Range aggregation */
      range?: RangeAggregation;
      /** Scalar aggregation */
      scalar?: ScalarAggregation;
      /** Date histogram aggregation */
      dateHistogram?: DateHistogramAggregation;
      /** User-defined name of aggregation, should be unique, will appear in aggregation results */
      name?: string | null;
      /** Type of aggregation, client must provide matching aggregation field below */
      type?: NestedAggregationType;
      /** Field to aggregate by, use dont notation to specify json path */
      fieldPath?: string;
  }
  /** @oneof */
  interface NestedAggregationItemKindOneOf {
      /** Value aggregation */
      value?: ValueAggregation;
      /** Range aggregation */
      range?: RangeAggregation;
      /** Scalar aggregation */
      scalar?: ScalarAggregation;
      /** Date histogram aggregation */
      dateHistogram?: DateHistogramAggregation;
  }
  enum AggregationType$1 {
      UNKNOWN_AGGREGATION_TYPE = "UNKNOWN_AGGREGATION_TYPE",
      VALUE = "VALUE",
      RANGE = "RANGE",
      SCALAR = "SCALAR",
      DATE_HISTOGRAM = "DATE_HISTOGRAM",
      NESTED = "NESTED"
  }
  /** nested aggregation expressed through a list of aggregation where each next aggregation is nested within previous one */
  interface NestedAggregation {
      /** Flattened list of aggregations, where each next aggregation is nested within previous one */
      nestedAggregations?: NestedAggregationItem[];
  }
  interface GroupByAggregation extends GroupByAggregationKindOneOf {
      /** Value aggregation configuration */
      value?: ValueAggregation;
      /** User-defined name of aggregation, should be unique, will appear in aggregation results */
      name?: string | null;
      /** Field to aggregate by */
      fieldPath?: string;
  }
  /** @oneof */
  interface GroupByAggregationKindOneOf {
      /** Value aggregation configuration */
      value?: ValueAggregation;
  }
  interface SearchDetails$1 {
      /** Boolean search mode */
      mode?: Mode$1;
      /** Search term or expression */
      expression?: string | null;
      /** Fields to search in. If empty - server will search in own default fields */
      fields?: string[];
      /** Flag if should use auto fuzzy search (allowing typos by a managed proximity algorithm) */
      fuzzy?: boolean;
  }
  enum Mode$1 {
      /** Any */
      OR = "OR",
      /** All */
      AND = "AND"
  }
  interface SearchServicesResponse {
      /** The retrieved services. */
      services?: Service[];
      /** Cursor paging metadata */
      pagingMetadata?: CursorPagingMetadata$3;
      /** Response aggregation data */
      aggregationData?: AggregationData$1;
  }
  interface CursorPagingMetadata$3 {
      /** Number of items returned in the response. */
      count?: number | null;
      /** Use these cursor to paginate between results. [Read more](https://dev.wix.com/api/rest/getting-started/api-query-language#getting-started_api-query-language_cursor-paging). */
      cursors?: Cursors$4;
      /**
       * Indicates if there are more results after the current page.
       * If `true`, another page of results can be retrieved.
       * If `false`, this is the last page.
       */
      hasNext?: boolean | null;
  }
  interface AggregationData$1 {
      /** key = aggregation name (as derived from search request) */
      results?: AggregationResults$1[];
  }
  interface ValueAggregationResult$1 {
      /** Value of the field */
      value?: string;
      /** Count of entities with this value */
      count?: number;
  }
  interface RangeAggregationResult$1 {
      /** Inclusive lower bound of the range */
      from?: number | null;
      /** Exclusive upper bound of the range */
      to?: number | null;
      /** Count of entities in this range */
      count?: number;
  }
  interface NestedAggregationResults$1 extends NestedAggregationResultsResultOneOf$1 {
      /** Value aggregation results */
      values?: ValueResults$1;
      /** Range aggregation results */
      ranges?: RangeResults$1;
      /** Scalar aggregation results */
      scalar?: ScalarResult$1;
      /** User-defined name of aggregation, matches the one provided in request */
      name?: string;
      /** Type of aggregation that matches result */
      type?: AggregationType$1;
      /** Field to aggregate by, matches the one provided in request */
      fieldPath?: string;
  }
  /** @oneof */
  interface NestedAggregationResultsResultOneOf$1 {
      /** Value aggregation results */
      values?: ValueResults$1;
      /** Range aggregation results */
      ranges?: RangeResults$1;
      /** Scalar aggregation results */
      scalar?: ScalarResult$1;
  }
  interface ValueResults$1 {
      /** List of value aggregations */
      results?: ValueAggregationResult$1[];
  }
  interface RangeResults$1 {
      /** List of ranges returned in same order as requested */
      results?: RangeAggregationResult$1[];
  }
  interface ScalarResult$1 {
      /** Type of scalar aggregation */
      type?: ScalarType$1;
      /** Value of the scalar aggregation */
      value?: number;
  }
  interface NestedValueAggregationResult$1 {
      /** Value of the field */
      value?: string;
      /** Nested aggregations */
      nestedResults?: NestedAggregationResults$1;
  }
  interface ValueResult {
      /** Value of the field */
      value?: string;
      /** Count of entities with this value */
      count?: number | null;
  }
  interface RangeResult {
      /** Inclusive lower bound of the range */
      from?: number | null;
      /** Exclusive upper bound of the range */
      to?: number | null;
      /** Count of entities in this range */
      count?: number | null;
  }
  interface NestedResultsScalarResult {
      /** Value of the scalar aggregation */
      value?: number;
  }
  interface NestedResultValue extends NestedResultValueResultOneOf {
      /** Value aggregation result */
      value?: ValueResult;
      /** Range aggregation result */
      range?: RangeResult;
      /** Scalar aggregation result */
      scalar?: NestedResultsScalarResult;
      /** Date histogram aggregation result */
      dateHistogram?: ValueResult;
  }
  /** @oneof */
  interface NestedResultValueResultOneOf {
      /** Value aggregation result */
      value?: ValueResult;
      /** Range aggregation result */
      range?: RangeResult;
      /** Scalar aggregation result */
      scalar?: NestedResultsScalarResult;
      /** Date histogram aggregation result */
      dateHistogram?: ValueResult;
  }
  interface Results {
      /** List of nested aggregations */
      results?: Record<string, NestedResultValue>;
  }
  interface DateHistogramResult {
      /** Date in ISO 8601 format */
      value?: string;
      /** Count of documents in the bucket */
      count?: number;
  }
  interface GroupByValueResults$1 {
      /** List of value aggregations */
      results?: NestedValueAggregationResult$1[];
  }
  interface DateHistogramResults {
      /** List of date histogram aggregations */
      results?: DateHistogramResult[];
  }
  /**
   * results of `NESTED` aggregation type in a flattened form
   * aggregations in resulting array are keyed by requested aggregation `name`.
   */
  interface NestedResults {
      /** List of nested aggregations */
      results?: Results[];
  }
  interface AggregationResults$1 extends AggregationResultsResultOneOf$1 {
      /** Value aggregation results */
      values?: ValueResults$1;
      /** Range aggregation results */
      ranges?: RangeResults$1;
      /** Scalar aggregation results */
      scalar?: ScalarResult$1;
      /** Group by value aggregation results */
      groupedByValue?: GroupByValueResults$1;
      /** Date histogram aggregation results */
      dateHistogram?: DateHistogramResults;
      /** Nested aggregation results */
      nested?: NestedResults;
      /** User-defined name of aggregation as derived from search request */
      name?: string;
      /** Type of aggregation that must match provided kind as derived from search request */
      type?: AggregationType$1;
      /** Field to aggregate by as derived from search request */
      fieldPath?: string;
  }
  /** @oneof */
  interface AggregationResultsResultOneOf$1 {
      /** Value aggregation results */
      values?: ValueResults$1;
      /** Range aggregation results */
      ranges?: RangeResults$1;
      /** Scalar aggregation results */
      scalar?: ScalarResult$1;
      /** Group by value aggregation results */
      groupedByValue?: GroupByValueResults$1;
      /** Date histogram aggregation results */
      dateHistogram?: DateHistogramResults;
      /** Nested aggregation results */
      nested?: NestedResults;
  }
  interface QueryPoliciesRequest {
      /** WQL expression. */
      query: CursorQuery$2;
  }
  interface CursorQuery$2 extends CursorQueryPagingMethodOneOf$2 {
      /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
      cursorPaging?: CursorPaging$4;
      /**
       * Filter object in the following format:
       * `"filter" : {
       * "fieldName1": "value1",
       * "fieldName2":{"$operator":"value2"}
       * }`
       * Example of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`
       */
      filter?: Record<string, any> | null;
      /**
       * Sort object in the following format:
       * `[{"fieldName":"sortField1","order":"ASC"},{"fieldName":"sortField2","order":"DESC"}]`
       */
      sort?: Sorting$4[];
  }
  /** @oneof */
  interface CursorQueryPagingMethodOneOf$2 {
      /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
      cursorPaging?: CursorPaging$4;
  }
  interface QueryPoliciesResponse {
      /** The retrieved policies. */
      bookingPolicies?: BookingPolicyWithServices[];
      /** Paging metadata, including offset and count. */
      pagingMetadata?: CursorPagingMetadata$3;
  }
  interface BookingPolicyWithServices {
      /** The booking policy. */
      bookingPolicy?: BookingPolicy$1;
      services?: Service[];
      /** Whether there are more services associated with the booking policy. */
      hasMoreServices?: boolean | null;
      /** The number of services associated with the booking policy. */
      countOfServices?: number;
  }
  interface CountServicesRequest {
      /** The filters for performing the count. */
      filter?: Record<string, any> | null;
  }
  interface CountServicesResponse {
      /** The number of services matching the given filter. */
      count?: number;
  }
  interface QueryLocationsRequest {
      /** The filter for the query. */
      filter?: QueryLocationsFilter;
  }
  interface QueryLocationsFilter {
      /** The filter sent to search services. */
      services?: Record<string, any> | null;
      /** IDs of business locations to query. */
      businessLocationIds?: string[];
  }
  interface QueryLocationsResponse {
      /** business locations on non hidden services. */
      businessLocations?: BusinessLocations;
      /** custom locations on non hidden services. */
      customLocations?: CustomLocations;
      /** customer location on non hidden services. */
      customerLocations?: CustomerLocations;
  }
  interface BusinessLocations {
      /** Whether there are any services with business locations */
      exists?: boolean;
      /** The retrieved locations sorted according to the Sort in Query. */
      locations?: Location$3[];
  }
  interface CustomLocations {
      /** Whether there are any services with custom location */
      exists?: boolean;
  }
  interface CustomerLocations {
      /** Whether there are any services with customer location */
      exists?: boolean;
  }
  interface QueryCategoriesRequest {
      /** The filter for the query. */
      filter?: QueryCategoriesFilter;
  }
  interface QueryCategoriesFilter {
      /** The filter sent to search services. */
      services?: Record<string, any> | null;
      /** IDs of categories to query. */
      categoryIds?: string[];
  }
  interface QueryCategoriesResponse {
      /** The retrieved categories. */
      categories?: V2Category[];
  }
  interface QueryServicesMultiLanguageRequest {
      /** WQL expression. */
      query: QueryV2$2;
      /** @internal */
      conditionalFields?: RequestedFields$1[];
  }
  interface QueryServicesMultiLanguageResponse {
      /** The retrieved services in the main language */
      services?: Service[];
      /** the retrieved services in the requested language according to the */
      translatedServices?: Service[];
      /** Paging metadata, including offset and count. */
      pagingMetadata?: PagingMetadataV2$1;
  }
  interface SetServiceLocationsRequest {
      /** ID of the service. */
      serviceId: string;
      /** The locations you specify replace the existing service locations. */
      locations: Location$3[];
      /**
       * The action to perform on sessions currently set to a removed location. For
       * example, move existing sessions to a new specified location.
       */
      removedLocationSessionsAction?: RemovedLocationSessionsAction;
      /**
       * Whether to notify participants about the change of location, and an
       * optional custom message.
       */
      participantNotification?: ParticipantNotification$4;
  }
  interface RemovedLocationSessionsAction extends RemovedLocationSessionsActionActionOptionsOneOf {
      /** Options related to the action, such as a new location to move existing sessions to. */
      moveToLocationOptions?: MoveToNewLocationsOptions;
      /** The action to perform on sessions currently set to a removed location. For example, move existing sessions to a new specified location. */
      action?: Action;
  }
  /** @oneof */
  interface RemovedLocationSessionsActionActionOptionsOneOf {
      /** Options related to the action, such as a new location to move existing sessions to. */
      moveToLocationOptions?: MoveToNewLocationsOptions;
  }
  enum Action {
      UNKNOWN_ACTION_TYPE = "UNKNOWN_ACTION_TYPE",
      /**
       * Keep future sessions at their current location. This is the default.
       * Note: The location will be set directly on the session. i.e, if the location is currently inherited from the schedule, the inheritance will be overridden.
       */
      KEEP_AT_CURRENT_LOCATION = "KEEP_AT_CURRENT_LOCATION",
      /**
       * Move future sessions to a new location.
       * The new location must be specified in the availability locations to set ('SetAvailabilityLocationsRequest.locations').
       */
      MOVE_TO_LOCATION = "MOVE_TO_LOCATION",
      /**
       * Delete future sessions.
       * Currently not supported.
       */
      DELETE = "DELETE"
  }
  interface MoveToNewLocationsOptions {
      /** The new location to move existing sessions currently set to a removed location, used when `action` is `MOVE_TO_LOCATION`. */
      newLocation?: Location$3;
  }
  interface SetServiceLocationsResponse {
      /** The updated service with the newly set locations. */
      service?: Service;
  }
  interface EnablePricingPlansForServiceRequest {
      serviceId: string;
      pricingPlanIds: string[];
  }
  interface EnablePricingPlansForServiceResponse {
      pricingPlanIds?: string[];
      /** The service after the pricing plans update. */
      service?: Service;
  }
  interface InvalidPricingPlan {
      /** The invalid pricing plan id. */
      _id?: string;
      /** The reason for the pricing plan considered as invalid */
      message?: string;
  }
  interface DisablePricingPlansForServiceRequest {
      serviceId: string;
      pricingPlanIds?: string[];
  }
  interface DisablePricingPlansForServiceResponse {
      /** The service after the pricing plans update. */
      service?: Service;
  }
  interface SetCustomSlugRequest {
      serviceId: string;
      slugName: string;
  }
  interface SetCustomSlugResponse {
      /** The new slug set as the active slug for the service. */
      slug?: Slug;
      /** The service after the custom slug update. */
      service?: Service;
  }
  interface ValidateSlugRequest {
      serviceId: string;
      slugName: string;
  }
  interface ValidateSlugResponse {
      /** Whether the requested slug name is valid. */
      valid?: boolean;
      slugName?: string | null;
      /**
       * be set as a slug for the service and is populated with the requested
       * slug. Otherwise, `slugName` is empty.
       * If the slug is invalid, this field is populated with the reasons why the
       * slug is invalid. Validation errors may include `SLUG_IS_TOO_LONG`,
       * `SLUG_CONTAIN_ILLEGAL_CHARACTERS`, and `SLUG_ALREADY_EXISTS`.
       */
      errors?: InvalidSlugError[];
  }
  enum InvalidSlugError {
      UNKNOWN_SLUG_ERROR = "UNKNOWN_SLUG_ERROR",
      /** The provided slug name contains illegal characters. */
      SLUG_CONTAINS_ILLEGAL_CHARACTERS = "SLUG_CONTAINS_ILLEGAL_CHARACTERS",
      /** The provided slug name already exists for another service. */
      SLUG_ALREADY_EXISTS = "SLUG_ALREADY_EXISTS"
  }
  interface CloneServiceRequest {
      sourceServiceId: string;
      /** copy recurring sessions of an active service's schedule */
      copyRecurringSessions?: boolean;
      /** copy benefits with pricing plans that are connected to the source */
      copyPricingPlans?: boolean;
      /**
       * service. If the source service is connected to more than 120
       * benefits with pricing plans then they will not be copied. In that
       * case the field `error_types` in the response will include
       * `PRICING_PLANS`.
       */
      hideService?: boolean | null;
      /** copy this value from the source service without overriding it */
      cloneServiceName?: string | null;
  }
  interface CloneServiceResponse {
      /** Cloned service */
      service?: Service;
      /** List of entity types that we failed to clone */
      errors?: CloneErrors[];
  }
  enum CloneErrors {
      UNKNOWN_CLONE_ERROR = "UNKNOWN_CLONE_ERROR",
      /** Failed to clone sessions of active service's schedule */
      SESSIONS = "SESSIONS",
      /** Failed to clone service's options and variants even though source service have them */
      OPTIONS_AND_VARIANTS = "OPTIONS_AND_VARIANTS",
      /** Failed to clone service's form */
      FORM = "FORM",
      /** Failed to clone pricing plans connected to the source service */
      PRICING_PLANS = "PRICING_PLANS"
  }
  /** An event sent every time a category entity is changed. */
  interface CategoryNotification {
      category?: Category;
      event?: Event;
  }
  /** Categories are used to group multiple services together. A service must be associated with a category in order to be exposed in the Wix Bookings UI. */
  interface Category {
      /**
       * Category ID.
       * @readonly
       */
      _id?: string | null;
      /** Category name. */
      name?: string | null;
      /**
       * Custom properties that can be associated with the category.
       * @internal
       */
      customProperties?: Record<string, string>;
      /**
       * Category status.
       *
       * Supported values:
       * - `"CREATED"`: The category is created.
       * - `"DELETED"`: The category is deleted.
       *
       * Default: `"CREATED"`
       * @readonly
       */
      status?: Status$1;
      /** Sort order of the category in the Dashboard. */
      sortOrder?: number | null;
  }
  enum Status$1 {
      /** The category is created. */
      CREATED = "CREATED",
      /** The category is deleted. */
      DELETED = "DELETED"
  }
  enum Event {
      Updated = "Updated",
      Deleted = "Deleted",
      Created = "Created"
  }
  interface Empty$2 {
  }
  interface ScheduleNotification$1 extends ScheduleNotificationEventOneOf$1 {
      scheduleCreated?: ScheduleCreated$1;
      scheduleUpdated?: ScheduleUpdated$1;
      scheduleCancelled?: ScheduleCancelled$1;
      sessionCreated?: SessionCreated$1;
      sessionUpdated?: SessionUpdated$1;
      sessionCancelled?: SessionCancelled$1;
      availabilityPolicyUpdated?: AvailabilityPolicyUpdated$1;
      /** @deprecated */
      intervalSplit?: IntervalSplit$1;
      recurringSessionSplit?: RecurringSessionSplit$1;
      /**
       * Inspect `schedule.scheduleOwnerUserId` on `scheduleUpdated` instead.
       * @deprecated
       */
      scheduleUnassignedFromUser?: ScheduleUnassignedFromUser$1;
      /**
       * supported only for schedule migration apis.
       * @internal
       */
      multipleSessionsCreated?: MultipleSessionsCreated$1;
      /**
       * supported only for schedule migration apis.
       * @internal
       */
      migrationEvent?: MigrationEvent$1;
      preserveFutureSessionsWithParticipants?: boolean | null;
      /**
       * Whether to notify participants about changed sessions. deprecated, use participant_notification
       * @deprecated
       */
      notifyParticipants?: boolean;
      /** site properties. Optional. Given in create schedule notification. */
      siteProperties?: SitePropertiesOnScheduleCreation$1;
      instanceId?: string;
      /**
       * true when the schedule belongs to a site that is rolled out to calendar v3
       * @internal
       */
      rolledOut?: boolean | null;
  }
  /** @oneof */
  interface ScheduleNotificationEventOneOf$1 {
      scheduleCreated?: ScheduleCreated$1;
      scheduleUpdated?: ScheduleUpdated$1;
      scheduleCancelled?: ScheduleCancelled$1;
      sessionCreated?: SessionCreated$1;
      sessionUpdated?: SessionUpdated$1;
      sessionCancelled?: SessionCancelled$1;
      availabilityPolicyUpdated?: AvailabilityPolicyUpdated$1;
      /** @deprecated */
      intervalSplit?: IntervalSplit$1;
      recurringSessionSplit?: RecurringSessionSplit$1;
      /**
       * Inspect `schedule.scheduleOwnerUserId` on `scheduleUpdated` instead.
       * @deprecated
       */
      scheduleUnassignedFromUser?: ScheduleUnassignedFromUser$1;
      /**
       * supported only for schedule migration apis.
       * @internal
       */
      multipleSessionsCreated?: MultipleSessionsCreated$1;
      /**
       * supported only for schedule migration apis.
       * @internal
       */
      migrationEvent?: MigrationEvent$1;
  }
  interface ScheduleCreated$1 {
      schedule?: V1Schedule;
  }
  interface V1Schedule {
      /** Schedule ID. */
      _id?: string;
      /** ID of the schedule's owner entity. This may be a resource ID or a service ID. */
      scheduleOwnerId?: string | null;
      /**
       * Start time of the first session in the schedule.
       * @internal
       * @readonly
       */
      firstSessionStart?: Date | null;
      /**
       * End time of the last session in the schedule.
       * @internal
       * @readonly
       */
      lastSessionEnd?: Date | null;
      /**
       * Schedule's time zone in [Area/Location](https://en.wikipedia.org/wiki/Tz_database) format. Read-only.
       * Derived from the Wix Business time zone.
       * @readonly
       */
      timeZone?: string | null;
      /**
       * Deprecated. Please use the [Sessions API](https://dev.wix.com/api/rest/wix-bookings/schedules-and-sessions/session) instead.
       * @deprecated
       */
      intervals?: RecurringInterval$1[];
      /** Default title for the schedule's sessions. Maximum length: 6000 characters. */
      title?: string | null;
      /**
       * __Deprecated.__
       * Tags for grouping schedules. These tags are the default tags for the schedule's sessions.
       * The Wix Bookings app uses the following predefined tags to set schedule type: `"INDIVIDUAL"`, `"GROUP"`, and `"COURSE"`. Once the schedule type is set using these tags, you cannot update it. In addition to the app's tags, you can create and update your own tags.
       * @deprecated
       */
      tags?: string[] | null;
      /** Default location for the schedule's sessions. */
      location?: V1Location;
      /**
       * Maximum number of participants that can be added to the schedule's sessions.
       * Must be at most `1` for schedule whose availability is affected by another schedule. E.g, appointment schedules of the Wix Bookings app.
       */
      capacity?: number | null;
      /**
       * Deprecated. Please use the [Booking Services V2](https://dev.wix.com/api/rest/wix-bookings/services-v2) payment instead.
       * @deprecated
       */
      rate?: Rate$1;
      /**
       * __Deprecated.__
       * @deprecated
       */
      availability?: Availability$1;
      /**
       * Number of participants registered to sessions in this schedule, calculated as the sum of the party sizes.
       * @readonly
       */
      totalNumberOfParticipants?: number;
      /**
       * *Partial list** of participants which are registered to sessions in this schedule.
       * Participants who are registered in the schedule are automatically registered to any session that is created for the schedule.
       * To retrieve the full list of schedule participants please use the [Query Extended Bookings API](https://dev.wix.com/api/rest/wix-bookings/bookings-reader-v2/query-extended-bookings).
       * @readonly
       */
      participants?: Participant$1[];
      /**
       * __Deprecated.__
       * @deprecated
       */
      externalCalendarOverrides?: ExternalCalendarOverrides$1;
      /**
       * Schedule status.
       * @readonly
       */
      status?: ScheduleStatus$1;
      /**
       * Schedule creation date.
       * @readonly
       */
      created?: Date | null;
      /**
       * Schedule last update date.
       * @readonly
       */
      updated?: Date | null;
      /**
       * Schedule version number, updated each time the schedule is updated.
       * @readonly
       */
      version?: number;
      /**
       * The schedule version, updated each time the schedule or the schedule participants are updated.
       * @internal
       * @readonly
       */
      versions?: Version$1;
      /**
       * Fields which were inherited from the Business Info page under Settings in the Dashboard.
       * @readonly
       */
      inheritedFields?: string[];
      /**
       * __Deprecated.__
       * @deprecated
       */
      conferenceProvider?: ConferenceProvider$1;
      /**
       * A conference created for the schedule. This is used when a participant is added to a schedule.
       * **Partially deprecated.** Only `hostUrl` and `guestUrl` are to be supported.
       * @deprecated
       */
      calendarConference?: CalendarConference$1;
      /**
       * The name of the schedule owner. It may be a resource name or a service name. Optional.
       * @internal
       */
      scheduleOwnerName?: string | null;
      /**
       * The user id of the schedule owner. Optional.
       * Currently, in Bookings system, it would be present when the schedule is owned by a staff resource and the resource is connected to a user.
       * NOT IMPLEMENTED. YET.
       * @internal
       * @readonly
       */
      scheduleOwnerUserId?: string | null;
  }
  interface RecurringInterval$1 {
      /**
       * The recurring interval identifier.
       * @readonly
       */
      _id?: string;
      /** The start time of the recurring interval. Required. */
      start?: Date | null;
      /** The end time of the recurring interval. Optional. Empty value indicates that there is no end time. */
      end?: Date | null;
      /** The interval rules. The day, hour and minutes the interval is recurring. */
      interval?: Interval$1;
      /** The frequency of the interval. Optional. The default is frequency with the default repetition. */
      frequency?: Frequency$1;
      /** Specifies the list of linked schedules and the way this link affects the corresponding schedules' availability. Can be calculated from the schedule or overridden on the recurring interval. */
      affectedSchedules?: LinkedSchedule$1[];
      /** The type of recurring interval. */
      intervalType?: RecurringIntervalType$1;
  }
  interface Interval$1 {
      /** The day the interval accrue. Optional. The default is the day of the recurring interval's start time. */
      daysOfWeek?: Day$1;
      /** The hour of the day the interval accrue. must be consistent with the Interval start time. Options. The default is 0. minimum: 0, maximum: 23. */
      hourOfDay?: number | null;
      /** The minutes of hour the interval accrue. must be consistent with the Interval end time. Options. The default is 0. minimum: 0, maximum: 59. */
      minuteOfHour?: number | null;
      /** The duration of the interval in minutes. Required. Part of the session end time calculation. */
      duration?: number;
  }
  enum Day$1 {
      /** Undefined. */
      UNDEFINED = "UNDEFINED",
      /** Monday. */
      MON = "MON",
      /** Tuesday. */
      TUE = "TUE",
      /** Wednesday. */
      WED = "WED",
      /** Thursday. */
      THU = "THU",
      /** Friday. */
      FRI = "FRI",
      /** Saturday. */
      SAT = "SAT",
      /** Sunday. */
      SUN = "SUN"
  }
  interface Frequency$1 {
      /** The frequency of the recurrence in weeks. i.e. when this value is 4, the interval occurs every 4 weeks. Optional. The default is 1. minimum: 1, maximum: 52. */
      repetition?: number | null;
  }
  interface LinkedSchedule$1 {
      /** Schedule ID. */
      scheduleId?: string;
      /**
       * Sets this schedule's availability for the duration of the linked schedule's sessions.  Default is `"BUSY"`.
       * If set to `"BUSY"`, this schedule cannot have any available slots during the linked schedule's sessions.
       * If set to `"FREE"`, this schedule can have available slots during the linked schedule's sessions.
       */
      transparency?: Transparency$1;
      /**
       * Owner ID, of the linked schedule.
       * @readonly
       */
      scheduleOwnerId?: string;
      /**
       * The name of the linked schedule owner. It may be a resource name or a service name. Optional.
       * This field is inherited from the schedule identified by scheduleId above.
       * @internal
       * @readonly
       */
      scheduleOwnerName?: string | null;
      /**
       * The user id of the linked schedule owner. Optional.
       * This field is inherited from the schedule identified by scheduleId above.
       * NOT IMPLEMENTED. YET.
       * @internal
       * @readonly
       */
      scheduleOwnerUserId?: string | null;
  }
  enum Transparency$1 {
      UNDEFINED = "UNDEFINED",
      /** The schedule can have available slots during the session. */
      FREE = "FREE",
      /** The schedule cannot have available slots during the session. Default value. */
      BUSY = "BUSY"
  }
  enum RecurringIntervalType$1 {
      /** The default value. Sessions for this interval will be of type EVENT. */
      UNDEFINED = "UNDEFINED",
      /** A recurring interval of events */
      EVENT = "EVENT",
      /** Deprecated */
      TIME_AVAILABILITY = "TIME_AVAILABILITY",
      /** A recurring interval for availability */
      AVAILABILITY = "AVAILABILITY"
  }
  interface V1Location {
      /**
       * Location type.
       * One of:
       * - `"OWNER_BUSINESS"` The business address as set in the sites general settings.
       * - `"OWNER_CUSTOM"` The address as set when creating the service.
       * - `"CUSTOM"` The address set for the individual session.
       */
      locationType?: LocationLocationType$1;
      /**
       * Free text address used when locationType is `OWNER_CUSTOM`.
       * @deprecated
       */
      address?: string | null;
      /** Custom address, used when locationType is `"OWNER_CUSTOM"`. Might be used when locationType is `"CUSTOM"` in case the owner sets a custom address for the session which is different from the default. */
      customAddress?: CommonAddress;
      /**
       * The Wix Business location formatted address.
       * Valid when `locationType` is `OWNER_BUSINESS`. Defaults to the business's location.
       * To retrieve the full location data please use the [Locations API](https://dev.wix.com/api/rest/business-info/locations).
       * @internal
       */
      businessLocation?: LocationsLocation$1;
  }
  enum LocationLocationType$1 {
      UNDEFINED = "UNDEFINED",
      OWNER_BUSINESS = "OWNER_BUSINESS",
      OWNER_CUSTOM = "OWNER_CUSTOM",
      CUSTOM = "CUSTOM"
  }
  /** Physical address */
  interface CommonAddress extends CommonAddressStreetOneOf {
      /** Street name, number and apartment number. */
      streetAddress?: CommonStreetAddress;
      /** Main address line, usually street and number, as free text. */
      addressLine?: string | null;
      /** Country code. */
      country?: string | null;
      /** Subdivision. Usually state, region, prefecture or province code, according to [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). */
      subdivision?: string | null;
      /** City name. */
      city?: string | null;
      /** Zip/postal code. */
      postalCode?: string | null;
      /** Free text providing more detailed address info. Usually contains Apt, Suite, and Floor. */
      addressLine2?: string | null;
      /** A string containing the full address of this location. */
      formattedAddress?: string | null;
      /** Free text to help find the address. */
      hint?: string | null;
      /** Coordinates of the physical address. */
      geocode?: CommonAddressLocation;
      /** Country full name. */
      countryFullname?: string | null;
      /** Multi-level subdivisions from top to bottom. */
      subdivisions?: Subdivision$3[];
  }
  /** @oneof */
  interface CommonAddressStreetOneOf {
      /** Street name, number and apartment number. */
      streetAddress?: CommonStreetAddress;
      /** Main address line, usually street and number, as free text. */
      addressLine?: string | null;
  }
  interface CommonStreetAddress {
      /** Street number. */
      number?: string;
      /** Street name. */
      name?: string;
      /** Apartment number. */
      apt?: string;
  }
  interface CommonAddressLocation {
      /** Address latitude. */
      latitude?: number | null;
      /** Address longitude. */
      longitude?: number | null;
  }
  interface Subdivision$3 {
      /** Subdivision code. Usually state, region, prefecture or province code, according to [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). */
      code?: string;
      /** Subdivision full name. */
      name?: string;
  }
  interface LocationsLocation$1 {
      /**
       * Location ID.
       * @readonly
       */
      _id?: string | null;
      /** Location name. */
      name?: string;
      /** Location description. */
      description?: string | null;
      /**
       * Whether this is the default location. There can only be one default location per site. The default location can't be archived.
       * @readonly
       */
      default?: boolean;
      /**
       * Location status. Defaults to `ACTIVE`.
       * __Notes:__
       * - [Archiving a location](https://dev.wix.com/api/rest/business-info/locations/archive-location)
       * doesn't affect the location's status.
       * - `INACTIVE` status is currently not supported.
       */
      status?: LocationStatus$1;
      /**
       * Location type.
       *
       * **Note:** Currently not supported.
       * @deprecated
       */
      locationType?: LocationsLocationType$1;
      /** Fax number. */
      fax?: string | null;
      /** Timezone in `America/New_York` format. */
      timeZone?: string | null;
      /** Email address. */
      email?: string | null;
      /** Phone number. */
      phone?: string | null;
      /** Address. */
      address?: LocationsAddress$1;
      /**
       * Business schedule. Array of weekly recurring time periods when the location is open for business. Limited to 100 time periods.
       *
       * __Note:__ Not supported by Wix Bookings.
       */
      businessSchedule?: BusinessSchedule$2;
      /**
       * Revision number, which increments by 1 each time the location is updated.
       * To prevent conflicting changes, the existing revision must be used when updating a location.
       */
      revision?: string | null;
      /**
       * Whether the location is archived. Archived locations can't be updated.
       * __Note:__ [Archiving a location](https://dev.wix.com/api/rest/business-info/locations/archive-location)
       * doesn't affect its `status`.
       * @readonly
       */
      archived?: boolean;
      /** Location types. */
      locationTypes?: LocationsLocationType$1[];
  }
  /** For future use */
  enum LocationStatus$1 {
      ACTIVE = "ACTIVE",
      INACTIVE = "INACTIVE"
  }
  /** For future use */
  enum LocationsLocationType$1 {
      UNKNOWN = "UNKNOWN",
      BRANCH = "BRANCH",
      OFFICES = "OFFICES",
      RECEPTION = "RECEPTION",
      HEADQUARTERS = "HEADQUARTERS",
      INVENTORY = "INVENTORY"
  }
  interface LocationsAddress$1 {
      /** 2-letter country code in an [ISO-3166 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format. */
      country?: string | null;
      /** Code for a subdivision (such as state, prefecture, or province) in [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) format. */
      subdivision?: string | null;
      /** City name. */
      city?: string | null;
      /** Postal or zip code. */
      postalCode?: string | null;
      /** Street address. Includes street name, number, and apartment number in separate fields. */
      streetAddress?: LocationsStreetAddress$1;
      /** Full address of the location. */
      formatted?: string | null;
      /** Geographic coordinates of location. */
      location?: LocationsAddressLocation$1;
  }
  /** Street address. Includes street name, number, and apartment number in separate fields. */
  interface LocationsStreetAddress$1 {
      /** Street number. */
      number?: string;
      /** Street name. */
      name?: string;
      /** Apartment number. */
      apt?: string;
  }
  /** Address Geolocation */
  interface LocationsAddressLocation$1 {
      /** Latitude of the location. Must be between -90 and 90. */
      latitude?: number | null;
      /** Longitude of the location. Must be between -180 and 180. */
      longitude?: number | null;
  }
  /** Business schedule. Regular and exceptional time periods when the business is open or the service is available. */
  interface BusinessSchedule$2 {
      /** Weekly recurring time periods when the business is regularly open or the service is available. Limited to 100 time periods. */
      periods?: TimePeriod$2[];
      /** Exceptions to the business's regular hours. The business can be open or closed during the exception. */
      specialHourPeriod?: SpecialHourPeriod$2[];
  }
  /** Weekly recurring time periods when the business is regularly open or the service is available. */
  interface TimePeriod$2 {
      /** Day of the week the period starts on. */
      openDay?: DayOfWeek$2;
      /**
       * Time the period starts in 24-hour [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) extended format. Valid values are `00:00` to `24:00`, where `24:00` represents
       * midnight at the end of the specified day.
       */
      openTime?: string;
      /** Day of the week the period ends on. */
      closeDay?: DayOfWeek$2;
      /**
       * Time the period ends in 24-hour [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) extended format. Valid values are `00:00` to `24:00`, where `24:00` represents
       * midnight at the end of the specified day.
       *
       * __Note:__ If `openDay` and `closeDay` specify the same day of the week `closeTime` must be later than `openTime`.
       */
      closeTime?: string;
  }
  /** Enumerates the days of the week. */
  enum DayOfWeek$2 {
      MONDAY = "MONDAY",
      TUESDAY = "TUESDAY",
      WEDNESDAY = "WEDNESDAY",
      THURSDAY = "THURSDAY",
      FRIDAY = "FRIDAY",
      SATURDAY = "SATURDAY",
      SUNDAY = "SUNDAY"
  }
  /** Exception to the business's regular hours. The business can be open or closed during the exception. */
  interface SpecialHourPeriod$2 {
      /** Start date and time of the exception in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format and [Coordinated Universal Time (UTC)](https://en.wikipedia.org/wiki/Coordinated_Universal_Time). */
      startDate?: string;
      /** End date and time of the exception in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format and [Coordinated Universal Time (UTC)](https://en.wikipedia.org/wiki/Coordinated_Universal_Time). */
      endDate?: string;
      /**
       * Whether the business is closed (or the service is not available) during the exception.
       *
       * Default: `true`.
       */
      isClosed?: boolean;
      /** Additional info about the exception. For example, "We close earlier on New Year's Eve." */
      comment?: string;
  }
  interface Rate$1 {
      /**
       * Mapping between a named price option, for example, adult or child prices, and the price, currency, and down payment amount.
       * When present in an update request, the `default_varied_price` is ignored to support backward compatibility.
       */
      labeledPriceOptions?: Record<string, Price$1>;
      /**
       * Textual price information used when **Price Per Session** is set to **Custom Price** in the app's service details page.
       * When present in an update request, the `default_varied_price` is ignored to support backward compatibility.
       */
      priceText?: string | null;
      /**
       * Default service price. Always vailable when a service has
       * [variants](https://dev.wix.com/api/rest/wix-bookings/service-options-and-variants/introduction).
       * Sometimes also available for services without variants.
       * Ignored in [updates to a service](https://dev.wix.com/api/rest/wix-bookings/services/service/update-service),
       * when either `labeled_price_options` or `price_text` is also specified.
       * @internal
       */
      defaultVariedPrice?: Price$1;
  }
  interface Price$1 {
      /** Required payment amount. */
      amount?: string;
      /** Currency in which the amount is quoted. */
      currency?: string;
      /** Amount of a down payment or deposit as part of the transaction. */
      downPayAmount?: string;
  }
  /**
   * <!-- Needs updating when recurrence has been tested
   * Schedule's availability calculation is executed by the schedule's available intervals and this additional information.
   * Schedule's available intervals are recurring intervals (defined in the schedule) minus sessions that has no more spots for bookings (including time between_slots), or schedule's sessions with open spots for bookings.-->
   */
  interface Availability$1 {
      /** Date and time the schedule starts to be available for booking. */
      start?: Date | null;
      /** Date and time the schedule stops being available for booking. No value indicates no end time. */
      end?: Date | null;
      /** Other schedules that impact the availability calculation. Relevant only when there are availability constraints. */
      linkedSchedules?: LinkedSchedule$1[];
      /** Constraints for calculating the schedule's availability. */
      constraints?: V1AvailabilityConstraints;
      /**
       * Not supported yet.
       * A list of possible locations for the session when `use_default_location` is set to `false`. Slots are generated for each location. Only one of the possible locations can be chosen by the customer.
       *
       * **NOTE**: When using the `locations` parameter, the default location is not automatically included in the list.
       * @internal
       */
      locations?: V1Location[];
      /**
       * Not supported yet.
       * Whether the schedule's slots are only available at the schedule's default location, as set in `schedule.location`. If set to `false`, the `locations` array is used to set the possible locations of the schedule's sessions.
       * Default is `true`.
       * @internal
       */
      useDefaultLocation?: boolean | null;
  }
  /** Describes how to calculate the specific slots that are available for booking. */
  interface V1AvailabilityConstraints {
      /**
       * A list of duration options for slots, in minutes. Minimum value for a duration is 1.
       * The availability calculation generates slots with these durations, where there is no conflict with existing sessions or other availability constraints.
       */
      slotDurations?: number[];
      /**
       * The number of minutes between the `end` of one slot, and the `start` of the next.
       * Minimum value is 0, maximum value is 120.
       */
      timeBetweenSlots?: number;
      /**
       * Specify how to split the slots in intervals of minutes.
       * This value indicates the time between available slots' start time. e.g., from 5 minute slots (3:00, 3:05, 3:15) and 1 hour slots (3:00, 4:00, 5:00).
       * Optional. The default is the first duration in slot_durations field.
       * Deprecated. Use the `split_slots_interval.value_in_minutes`.
       * @deprecated
       */
      splitInterval?: number | null;
      /**
       * An object defining the time between available slots' start times.  For example, a slot with slots_split_interval=5 can start every 5 minutes. The default is the slot duration.
       * @readonly
       */
      slotsSplitInterval?: SplitInterval$1;
  }
  /** The time between available slots' start times. For example, For 5 minute slots, 3:00, 3:05, 3:15 etc. For 1 hour slots, 3:00, 4:00, 5:00 etc. */
  interface SplitInterval$1 {
      /**
       * Whether the slot duration is used as the split interval value.
       * If `same_as_duration` is `true`, the `value_in_minutes` is the sum of the first duration in
       * `schedule.availabilityConstraints.SlotDurations` field, and `schedule.availabilityConstraints.TimeBetweenSlots` field.
       */
      sameAsDuration?: boolean | null;
      /** Number of minutes between available slots' start times when `same_as_duration` is `false`. */
      valueInMinutes?: number | null;
  }
  interface Participant$1 {
      /** Participant ID. Currently represents the booking.id. */
      _id?: string;
      /** Contact ID. */
      contactId?: string | null;
      /** Participant's name. */
      name?: string | null;
      /** Participant's phone number. */
      phone?: string | null;
      /** Participant's email address. */
      email?: string | null;
      /** Group or party size. The number of people attending. Defaults to 0. Maximum is 250. */
      partySize?: number;
      /**
       * Approval status for the participant.
       * <!-- Commented out untill updateParticipant is exposed Generally the same status as the booking, unless updated using the `updateParticipant()` API. Defaults to `"UNDEFINED"`.-->
       */
      approvalStatus?: ApprovalStatus$1;
      /**
       * Whether the participant was inherited from the schedule, as opposed to being booked directly to the session.
       * @readonly
       */
      inherited?: boolean;
  }
  enum ApprovalStatus$1 {
      /** Default. */
      UNDEFINED = "UNDEFINED",
      /** Pending business approval. */
      PENDING = "PENDING",
      /** Approved by the business. */
      APPROVED = "APPROVED",
      /** Declined by the business. */
      DECLINED = "DECLINED"
  }
  interface ExternalCalendarOverrides$1 {
      /** Synced title of the external calendar event. */
      title?: string | null;
      /** Synced description of the external calendar event. */
      description?: string | null;
  }
  enum ScheduleStatus$1 {
      UNDEFINED = "UNDEFINED",
      /** The default value when the schedule is created. */
      CREATED = "CREATED",
      /** The schedule has been canceled. */
      CANCELLED = "CANCELLED"
  }
  interface Version$1 {
      /** Schedule version number, updated each time the schedule is updated. */
      scheduleVersion?: number | null;
      /** Participants version number, updated each time the schedule participants are updated. */
      participantsVersion?: number | null;
  }
  interface ConferenceProvider$1 {
      /** Conferencing provider ID */
      providerId?: string;
  }
  interface CalendarConference$1 {
      /** Wix Calendar conference ID. */
      _id?: string;
      /** Conference meeting ID in the provider's conferencing system. */
      externalId?: string;
      /**
       * A generated id for the conference entity - Base62($providerId$accountOwnerId$conferenceId)
       * @internal
       */
      conferenceId?: string | null;
      /** Conference provider ID. */
      providerId?: string;
      /** URL used by the host to start the conference. */
      hostUrl?: string;
      /** URL used by a guest to join the conference. */
      guestUrl?: string;
      /** Password to join the conference. */
      password?: string | null;
      /** Conference description. */
      description?: string | null;
      /** Conference type. */
      conferenceType?: ConferenceType$1;
      /** ID of the account owner in the video conferencing service. */
      accountOwnerId?: string | null;
  }
  enum ConferenceType$1 {
      UNDEFINED = "UNDEFINED",
      /** API-generated online meeting. */
      ONLINE_MEETING_PROVIDER = "ONLINE_MEETING_PROVIDER",
      /** User-defined meeting. */
      CUSTOM = "CUSTOM"
  }
  interface ScheduleUpdated$1 {
      /** The old schedule before the update. */
      oldSchedule?: V1Schedule;
      /** The new schedule after the update. */
      newSchedule?: V1Schedule;
      /**
       * Recurring sessions updated event. If this field is given, the reason for the schedule updated event was
       * updating at least one of the given schedule's recurring sessions.
       * This event is triggered by create/update/delete recurring session apis.
       */
      recurringSessions?: RecurringSessionsUpdated$1;
      /** Whether to notify participants about the change and an optional custom message */
      participantNotification?: V1ParticipantNotification;
      /**
       * Whether this notification was created as a result of an anonymization request, such as GDPR.
       * An anonymized participant will have the following details:
       * name = "deleted"
       * phone = "deleted"
       * email = "deleted@deleted.com"
       */
      triggeredByAnonymizeRequest?: boolean | null;
  }
  interface RecurringSessionsUpdated$1 {
      /** Old schedule's recurring session list. */
      oldRecurringSessions?: Session$1[];
      /** New schedule's recurring session list. */
      newRecurringSessions?: Session$1[];
  }
  interface Session$1 {
      /**
       * Session ID.
       * @readonly
       */
      _id?: string | null;
      /** ID of the schedule that the session belongs to. */
      scheduleId?: string;
      /**
       * ID of the resource or service that the session's schedule belongs to.
       * @readonly
       */
      scheduleOwnerId?: string | null;
      /** Original start date and time of the session in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Coordinated_Universal_Time_(UTC)) format. */
      originalStart?: Date | null;
      /** An object specifying the start date and time of the session. If the session is a recurring session, `start` must contain a `localDateTime`. */
      start?: CalendarDateTime$1;
      /**
       * An object specifying the end date and time of the session. The `end` time must be after the `start` time and be same type as `start`.
       * If the session is a recurring session, `end` must contain a `localDateTime`.
       */
      end?: CalendarDateTime$1;
      /**
       * An object specifying a list of schedules and the way each schedule's availability is affected by the session. For example, the schedule of an instructor is affected by sessions of the class that they instruct.
       * The array is inherited from the schedule and can be overridden even if the session is a recurring session.
       */
      affectedSchedules?: LinkedSchedule$1[];
      /**
       * Session title.
       * The value is inherited from the schedule and can be overridden unless the session is a recurring session.
       */
      title?: string | null;
      /**
       * __Deprecated.__
       * Tags for the session.
       * The value is inherited from the schedule and can be overridden unless the session is a recurring session.
       * @deprecated
       */
      tags?: string[] | null;
      /**
       * An object describing the location where the session takes place.
       * Defaults to the schedule location.
       * For single sessions, `session.location.businessLocation` can only be provided for locations that are defined in the schedule using `schedule.location` or `schedule.availability.locations`.
       */
      location?: V1Location;
      /**
       * Maximum number of participants that can be added to the session. Defaults to the schedule capacity.
       * The value is inherited from the schedule and can be overridden unless the session is a recurring session.
       */
      capacity?: number | null;
      /**
       * The remaining number of participants that can be added to the session. Read-only.
       * Can be negative, in case the session is over capacity.
       * @internal
       * @readonly
       */
      remainingCapacity?: number | null;
      /**
       * Deprecated. Please use the [Booking Services V2](https://dev.wix.com/api/rest/wix-bookings/services-v2) payment instead.
       * @deprecated
       */
      rate?: Rate$1;
      /**
       * Time reserved after the session end time, derived from the schedule availability constraints and the time between slots. Read-only.
       * If the session is a recurring session, this field must be empty.
       */
      timeReservedAfter?: number | null;
      /**
       * Additional information about the session.
       * Notes are not supported for recurring sessions.
       */
      notes?: string;
      /**
       * The number of participants booked for the session. Read-only.
       * Calculated as the sum of the party sizes.
       * @readonly
       */
      totalNumberOfParticipants?: number;
      /**
       * *Partial list** list of participants booked for the session.
       * The list includes participants who have registered for this specific session, and participants who have registered for a schedule that includes this session.
       * If the session is a recurring session, this field must be empty.
       * To retrieve the full list of session participants please use the [Query Extended Bookings API](https://dev.wix.com/api/rest/wix-bookings/bookings-reader-v2/query-extended-bookings).
       */
      participants?: Participant$1[];
      /**
       * A list of properties for which values were inherited from the schedule.
       * This does not include participants that were inherited from the schedule.
       * @readonly
       */
      inheritedFields?: string[];
      /**
       * Information about the external calendar, if the session originated in an external calendar.
       * @internal
       * @readonly
       */
      externalCalendarInfo?: ExternalCalendarInfo$1;
      /**
       * __Deprecated.__
       * @deprecated
       */
      externalCalendarOverrides?: ExternalCalendarOverrides$1;
      /**
       * Session status.
       * @readonly
       */
      status?: SessionStatus;
      /**
       * Recurring interval ID. Defined when a session will be a recurring session. read-only. Optional.
       * For exmaple, when creating a class service  with recurring sessions, you add a recurrence rule to create recurring sessions.
       * This field is omitted for single sessions or instances of recurring sessions.
       * Specified when the session was originally generated from a schedule recurring interval.
       * Deprecated. Use `recurringSessionId`.
       * @readonly
       * @deprecated
       */
      recurringIntervalId?: string | null;
      /**
       * The ID of the recurring session if this session is an instance of a recurrence. Use this ID to update the recurrence and all of the instances.
       * @readonly
       */
      recurringSessionId?: string | null;
      /** Session type. */
      type?: SessionType$1;
      /**
       * A conference created for the session according to the details set in the schedule's conference provider information.
       * If the session is a recurring session, this field is inherited from the schedule.
       * **Partially deprecated.** Only `hostUrl` and `guestUrl` are to be supported.
       * @deprecated
       */
      calendarConference?: CalendarConference$1;
      /**
       * A string representing a recurrence rule (RRULE) for a recurring session, as defined in [iCalendar RFC 5545](https://icalendar.org/iCalendar-RFC-5545/3-3-10-recurrence-rule.html).
       * If the session is an instance of a recurrence pattern, the `instanceOfRecurrence` property will be contain the recurrence rule and this property will be empty.
       * The RRULE defines a rule for repeating a session.
       * Supported parameters are:
       *
       * |Keyword|Description|Supported values|
       * |--|--|---|
       * |`FREQ`|The frequency at which the session is recurs. Required.|`WEEKLY`|
       * |`INTERVAL`|How often, in terms of `FREQ`, the session recurs. Default is 1. Optional.|
       * |`UNTIL`|The UTC end date and time of the recurrence. Optional.|
       * |`BYDAY`|Day of the week when the event should recur. Required.|One of: `MO`, `TU`, `WE`, `TH`, `FR`, `SA`, `SU`|
       *
       *
       * For example, a session that repeats every second week on a Monday until January 7, 2022 at 8 AM:
       * `"FREQ=WEEKLY;INTERVAL=2;BYDAY=MO;UNTIL=20220107T080000Z"`
       *
       * <!--ORIGINAL COMMENTS:
       * `FREQ`  The frequency with which the session should be repeated (such as DAILY or WEEKLY).
       * Supported `WEEKLY` value is supported.
       * INTERVAL  Works together with FREQ to specify how often the session should be repeated. For example, FREQ=WEEKLY;INTERVAL=2 means once every two weeks. Optional. Default value is 1.
       * COUNT  The number of times this event should be repeated. Not yet supported.
       * UNTIL  The UTC date & time until which the session should be repeated. This parameter is optional. When it is not specified, the event repeats forever.
       * The format is a short ISO date, followed by 'T' and a short time with seconds and without milliseconds, terminated by the UTC designator 'Z'. For example, until Jan. 19th 2018 at 7:00 AM: 'UNTIL=20180119T070000Z'.
       * BYDAY - The days of the week when the event should be repeated. Currently, only a single day is supported. This parameter is mandatory.
       * Possible values are: MO, TU, WE, TH, FR, SA, SU
       * Note that DTSTART and DTEND lines are not allowed in this field; session start and end times are specified in the start and end fields.
       * **Example**: FREQ=WEEKLY;INTERVAL=2;BYDAY=MO;UNTIL=20200427T070000Z
       * ORIGINAL COMMENTS-->
       */
      recurrence?: string | null;
      /**
       * A string representing a recurrence rule (RRULE) if the session is an instance of a recurrence pattern.
       * Empty when the session is not an instance of a recurrence rule, or if the session defines a recurrence pattern, and `recurrence` is not empty.
       * @readonly
       */
      instanceOfRecurrence?: string | null;
      /**
       * The name of the schedule owner. It may be a resource name or a service name. Optional.
       * @internal
       * @readonly
       */
      scheduleOwnerName?: string | null;
      /**
       * The user id of the schedule owner. Optional.
       * NOT IMPLEMENTED YET.
       * @internal
       * @readonly
       */
      scheduleOwnerUserId?: string | null;
      /**
       * The session version.
       * Composed by the schedule, session and participants versions.
       * @readonly
       */
      version?: SessionVersion$1;
      /**
       * The ID of the event in the new Calendar Events V3 API.
       * @internal
       * @readonly
       */
      eventId?: string | null;
  }
  interface CalendarDateTime$1 {
      /**
       * UTC date-time in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Coordinated_Universal_Time_(UTC)) format. If a time zone offset is specified, the time is converted to UTC. For example, if you specify  `new Date('2021-01-06T16:00:00.000-07:00')`, the stored value will be `"2021-01-06T23:00:00.000Z"`.
       * Required if `localDateTime` is not specified.
       * If `localDateTime` is specified, `timestamp` is calculated as `localDateTime`, using the business's time zone.
       */
      timestamp?: Date | null;
      /** An object containing the local date and time for the business's time zone. */
      localDateTime?: LocalDateTime$1;
      /**
       * The time zone. Optional. Derived from the schedule's time zone.
       * In case this field is associated with recurring session, this field is empty.
       * @readonly
       */
      timeZone?: string | null;
  }
  interface LocalDateTime$1 {
      /** Year. 4-digit format. */
      year?: number | null;
      /** Month number, from 1-12. */
      monthOfYear?: number | null;
      /** Day of the month, from 1-31. */
      dayOfMonth?: number | null;
      /** Hour of the day in 24-hour format, from 0-23. */
      hourOfDay?: number | null;
      /** Minute, from 0-59. */
      minutesOfHour?: number | null;
  }
  interface ExternalCalendarInfo$1 {
      /** The external calendar type (e.g. Google Calendar, iCal, etc). */
      calendarType?: CalendarType$1;
  }
  enum CalendarType$1 {
      UNDEFINED = "UNDEFINED",
      GOOGLE = "GOOGLE",
      I_CAL = "I_CAL",
      /** Use `MICROSOFT` instead. */
      OUTLOOK = "OUTLOOK",
      /** Use `MICROSOFT` instead. */
      OFFICE_365 = "OFFICE_365",
      MICROSOFT = "MICROSOFT",
      OTHER = "OTHER"
  }
  enum SessionStatus {
      UNDEFINED = "UNDEFINED",
      /** The session is confirmed. Default status. */
      CONFIRMED = "CONFIRMED",
      /**
       * The session is cancelled.
       * A cancelled session can be the cancellation of a recurring session that should no longer be displayed or a deleted single session.
       * The ListSessions returns cancelled sessions only if 'includeDelete' flag is set to true.
       */
      CANCELLED = "CANCELLED"
  }
  enum SessionType$1 {
      UNDEFINED = "UNDEFINED",
      /**
       * The session creates an event on the calendar for the owner of the schedule that the session belongs to.
       * Default type.
       */
      EVENT = "EVENT",
      /** The session represents a resource's available working hours. */
      WORKING_HOURS = "WORKING_HOURS",
      /** Deprecated. please use WORKING_HOURS */
      TIME_AVAILABILITY = "TIME_AVAILABILITY",
      /** Deprecated. The session represents a resource's available hours. please use WORKING_HOURS */
      AVAILABILITY = "AVAILABILITY"
  }
  interface SessionVersion$1 {
      /**
       * Schedule version number, updated each time the schedule is updated.
       * @internal
       */
      scheduleVersion?: number;
      /**
       * Session version number, updated each time the session is updated.
       * @internal
       */
      sessionVersion?: number;
      /**
       * Participants version number, updated each time the session participants are updated.
       * @internal
       */
      participantsVersion?: number | null;
      /** Incremental version number, which is updated on each change to the session or on changes affecting the session. */
      number?: string | null;
  }
  interface V1ParticipantNotification {
      /**
       * Whether to send the message about the changes to the customer.
       *
       * Default: `false`
       */
      notifyParticipants?: boolean;
      /** Custom message to send to the participants about the changes to the booking. */
      message?: string | null;
      /**
       * Optional additional metadata.
       * Supported only in V3 APIs.
       * @internal
       */
      metadata?: Record<string, string>;
  }
  interface ScheduleCancelled$1 {
      schedule?: V1Schedule;
      /** Whether to notify participants about the change and an optional custom message */
      participantNotification?: V1ParticipantNotification;
      oldSchedule?: V1Schedule;
  }
  interface SessionCreated$1 {
      session?: Session$1;
  }
  interface SessionUpdated$1 {
      oldSession?: Session$1;
      newSession?: Session$1;
      /** Whether to notify participants about the change and an optional custom message */
      participantNotification?: V1ParticipantNotification;
      /**
       * Whether this notification was created as a result of an anonymization request, such as GDPR.
       * An anonymized participant will have the following details:
       * name = "deleted"
       * phone = "deleted"
       * email = "deleted@deleted.com"
       */
      triggeredByAnonymizeRequest?: boolean | null;
  }
  interface SessionCancelled$1 {
      session?: Session$1;
      /** Whether to notify participants about the change and an optional custom message */
      participantNotification?: V1ParticipantNotification;
  }
  interface AvailabilityPolicyUpdated$1 {
      availabilityPolicy?: AvailabilityPolicy$1;
  }
  /** Availability policy applied to all site schedules. */
  interface AvailabilityPolicy$1 {
      /** Specify how to split the schedule slots in intervals of minutes. */
      splitInterval?: SplitInterval$1;
  }
  interface IntervalSplit$1 {
      scheduleId?: string;
      intervals?: RecurringInterval$1[];
      newScheduleVersion?: number | null;
      oldScheduleVersion?: number | null;
  }
  interface RecurringSessionSplit$1 {
      scheduleId?: string;
      recurringSessions?: Session$1[];
      newScheduleVersion?: number | null;
      oldScheduleVersion?: number | null;
  }
  /** Schedule unassigned from user. */
  interface ScheduleUnassignedFromUser$1 {
      /** The Wix user id. */
      userId?: string | null;
      /** The schedule that was unassigned from the user. */
      schedule?: V1Schedule;
  }
  interface MultipleSessionsCreated$1 {
      schedulesWithSessions?: ScheduleWithSessions$1[];
  }
  interface ScheduleWithSessions$1 {
      schedule?: V1Schedule;
      siteProperties?: SitePropertiesOnScheduleCreation$1;
      sessions?: Session$1[];
  }
  interface SitePropertiesOnScheduleCreation$1 {
      /** The global time zone value. */
      timeZone?: string | null;
  }
  interface MigrationEvent$1 {
      migrationData?: MigrationData$1;
  }
  interface MigrationData$1 {
      businessId?: string | null;
      staffs?: StaffData$1[];
  }
  interface StaffData$1 {
      resourceId?: string;
      syncRequestEmail?: string;
      refreshToken?: string;
  }
  interface ResourceNotification {
      /**
       * Updated resource entity.
       * 'resource.schedules' is deprecated and will not be returned. Please use 'resource.scheduleIds' instead.
       */
      resource?: Resource$1;
      /** Event type. */
      event?: ResourceNotificationEvent;
  }
  interface Resource$1 {
      /**
       * Resource ID.
       * @readonly
       */
      _id?: string | null;
      /** Resource name. */
      name?: string | null;
      /** Resource email address. */
      email?: string | null;
      /** Resource phone number. */
      phone?: string | null;
      /** Resource description. */
      description?: string | null;
      /**
       * Deprecated. Please use tags.
       * @deprecated
       */
      tag?: string | null;
      /** Resource tags. Tags are used to identify, group, and filter the different types of resources. For example, 'staff' or 'room'. */
      tags?: string[] | null;
      /** Resource images. */
      images?: string[];
      /**
       * Deprecated. Please use scheduleIds. List of the schedules owned by this resource. Min size 1.
       * @deprecated
       */
      schedules?: V1Schedule[];
      /**
       * List of IDs of schedules owned by this resource.
       * @readonly
       */
      scheduleIds?: string[] | null;
      /**
       * Resource status.
       * @readonly
       */
      status?: ResourceStatus;
      /**
       * Wix user ID, if the resource is associated with the Wix user.
       * A staff member resource can be associated with a Wix user via assignment of a permissions role in the business manager.
       * @readonly
       */
      wixUserId?: string | null;
      /**
       * The ID of the Resource Group that this resource belongs to. This is an optional field as not every resource is part of a group.
       * @internal
       */
      groupId?: string | null;
      /**
       * This field determines how to resolve the working hours of this resource. Defaults to `true` if was not set by the client.
       * When set to `true` then working hours (including location information) can be found in the sessions of a schedule that is connected to this resource.
       * If `false`, then the working hours are not specified as sessions of a connected schedule. Instead this resource is then by definition full-time available (7 x 24).
       * @internal
       */
      hasWorkingHoursSchedule?: boolean | null;
      /**
       * True if the resource is available in all locations, false if the resource is available only in a specific business location. Empty if `has_working_hours_schedule` is true.
       * Information on the location(s) can then be found in the sessions of one of the connected schedules.
       * @internal
       */
      availableInAllLocations?: boolean | null;
      /**
       * Information about business location connected to the resource. Should be empty if `available_in_all_locations` is true or if no business location exists in OS.
       * @internal
       */
      businessLocation?: BusinessLocation;
      /**
       * This schedule contains the sessions in which this resource is booked.
       * Equals to the first element of `schedules` array.
       * @internal
       * @readonly
       */
      eventsSchedule?: V1Schedule;
      /**
       * The type of of the resource. Currently this field is only filled for staff and will contain the ID as configured in the
       * BOOKINGS_RESOURCE_TYPES component of the Bookings app.
       * @internal
       * @readonly
       */
      type?: string | null;
  }
  enum ResourceStatus {
      UNDEFINED = "UNDEFINED",
      /** Default status. */
      CREATED = "CREATED",
      /** The resource was deleted. */
      DELETED = "DELETED",
      /** The resource was updated. */
      UPDATED = "UPDATED"
  }
  interface BusinessLocation {
      /** The ID of the business location. Has to be non-empty */
      locationId?: string;
  }
  enum ResourceNotificationEvent {
      UNDEFINED = "UNDEFINED",
      Updated = "Updated",
      Deleted = "Deleted",
      Created = "Created",
      Schedule_Updated = "Schedule_Updated"
  }
  interface BenefitNotification {
      /** Plan unique ID */
      planId?: string;
      /** App def ID */
      appDefId?: string;
      /** Current benefit details */
      benefit?: Benefit;
      /** Previous benefit */
      prevBenefit?: Benefit;
      /** Notification event */
      event?: BenefitNotificationEvent;
  }
  interface Benefit {
      /**
       * Benefit unique ID
       * @readonly
       */
      _id?: string | null;
      /** Benefit Type */
      benefitType?: BenefitType;
      /** Resource IDs that serves by this benefit */
      resourceIds?: string[];
      /** Amount of credits that provided by this benefit */
      creditAmount?: number | null;
      /** additional details related to benefit; limited to 20 entries, 20 symbols for key and 20 symbols for value */
      customFields?: Record<string, string>;
      /** return value only in case it required in the ListRequest, true means that benefit's type could be updated */
      editable?: boolean | null;
      /** Benefit behavior */
      behavior?: Behavior;
      /**
       * Id of the app associated with this benefit
       * @readonly
       */
      appDefId?: string | null;
  }
  interface EntryPass {
  }
  interface Discount extends DiscountDiscountOneOf {
      /** Fixed-rate percent off discount */
      percentOffRate?: string;
      /** Absolute amount discount */
      moneyOffAmount?: string;
  }
  /** @oneof */
  interface DiscountDiscountOneOf {
      /** Fixed-rate percent off discount */
      percentOffRate?: string;
      /** Absolute amount discount */
      moneyOffAmount?: string;
  }
  enum BenefitType {
      /** Should never be used */
      UNDEFINED = "UNDEFINED",
      /** Limited benefit type */
      LIMITED = "LIMITED",
      /** Unlimited benefit type */
      UNLIMITED = "UNLIMITED"
  }
  interface Behavior extends BehaviorBehaviorOneOf {
      /** Entry pass for resources, e.g. a ticket for Bookings service or a ticket for Events. */
      defaultBehavior?: EntryPass;
      /** Discount applied to paid resources */
      discount?: Discount;
  }
  /** @oneof */
  interface BehaviorBehaviorOneOf {
      /** Entry pass for resources, e.g. a ticket for Bookings service or a ticket for Events. */
      defaultBehavior?: EntryPass;
      /** Discount applied to paid resources */
      discount?: Discount;
  }
  enum BenefitNotificationEvent {
      Updated = "Updated",
      Deleted = "Deleted",
      Created = "Created"
  }
  interface UserDomainInfoChangedEvent {
      domainName?: string;
      crudType?: CrudType;
      metaSiteId?: string | null;
      changeTime?: Date | null;
  }
  enum CrudType {
      INVALID_CRUD_TYPE = "INVALID_CRUD_TYPE",
      CREATE = "CREATE",
      UPDATE = "UPDATE",
      DELETE = "DELETE",
      /** Unfortunately this action is used by hibernate save in wix-war */
      CREATE_OR_UPDATE = "CREATE_OR_UPDATE"
  }
  interface HtmlSitePublished {
      /** Application instance ID */
      appInstanceId?: string;
      /** Application type */
      appType?: string;
      /** Revision */
      revision?: string;
      /** MSID */
      metaSiteId?: string | null;
      /** optional branch id if publish is done from branch */
      branchId?: string | null;
      /** The site's last transactionId */
      lastTransactionId?: string | null;
      /** A list of the site's pages */
      pages?: Page[];
      /** Site's publish date */
      publishDate?: string;
  }
  interface Page {
      /** Page's Id */
      _id?: string;
  }
  /** Encapsulates all details written to the Greyhound topic when a site's properties are updated. */
  interface SitePropertiesNotification$1 {
      /** The site ID for which this update notification applies. */
      metasiteId?: string;
      /** The actual update event. */
      event?: SitePropertiesEvent$1;
      /** A convenience set of mappings from the MetaSite ID to its constituent services. */
      translations?: Translation$1[];
      /** Context of the notification */
      changeContext?: ChangeContext$1;
  }
  /** The actual update event for a particular notification. */
  interface SitePropertiesEvent$1 {
      /** Version of the site's properties represented by this update. */
      version?: number;
      /**
       * Set of properties that were updated - corresponds to the fields in "properties".
       * @internal
       */
      fields?: string[];
      /** Updated properties. */
      properties?: Properties$1;
  }
  interface Properties$1 {
      /** Site categories. */
      categories?: Categories$1;
      /** Site locale. */
      locale?: Locale$1;
      /**
       * Site language.
       *
       * Two-letter language code in [ISO 639-1 alpha-2](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format.
       */
      language?: string | null;
      /**
       * Site currency format used to bill customers.
       *
       * Three-letter currency code in [ISO-4217 alphabetic](https://en.wikipedia.org/wiki/ISO_4217#Active_codes) format.
       */
      paymentCurrency?: string | null;
      /** Timezone in `America/New_York` format. */
      timeZone?: string | null;
      /** Email address. */
      email?: string | null;
      /** Phone number. */
      phone?: string | null;
      /** Fax number. */
      fax?: string | null;
      /** Address. */
      address?: V4Address;
      /** Site display name. */
      siteDisplayName?: string | null;
      /** Business name. */
      businessName?: string | null;
      /** Path to the site's logo in Wix Media (without Wix Media base URL). */
      logo?: string | null;
      /** Site description. */
      description?: string | null;
      /**
       * Business schedule. Regular and exceptional time periods when the business is open or the service is available.
       *
       * __Note:__ Not supported by Wix Bookings.
       */
      businessSchedule?: BusinessSchedule$2;
      /** Supported languages of a site and the primary language. */
      multilingual?: Multilingual$1;
      /** Cookie policy the site owner defined for their site (before the users interacts with/limits it). */
      consentPolicy?: ConsentPolicy$1;
      /**
       * Supported values: `FITNESS SERVICE`, `RESTAURANT`, `BLOG`, `STORE`, `EVENT`, `UNKNOWN`.
       *
       * Site business type.
       */
      businessConfig?: string | null;
      /** External site url that uses Wix as its headless business solution */
      externalSiteUrl?: string | null;
      /** Track clicks analytics */
      trackClicksAnalytics?: boolean;
  }
  interface Categories$1 {
      /** Primary site category. */
      primary?: string;
      /** Secondary site category. */
      secondary?: string[];
      /** Business Term Id */
      businessTermId?: string | null;
  }
  interface Locale$1 {
      /** Two-letter language code in [ISO 639-1 alpha-2](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format. */
      languageCode?: string;
      /** Two-letter country code in [ISO-3166 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2#Officially_assigned_code_elements) format. */
      country?: string;
  }
  interface V4Address {
      /** Street name. */
      street?: string;
      /** City name. */
      city?: string;
      /** Two-letter country code in an [ISO-3166 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format. */
      country?: string;
      /** State. */
      state?: string;
      /** Zip or postal code. */
      zip?: string;
      /** Extra information to be displayed in the address. */
      hint?: AddressHint$1;
      /** Whether this address represents a physical location. */
      isPhysical?: boolean;
      /** Google-formatted version of this address. */
      googleFormattedAddress?: string;
      /** Street number. */
      streetNumber?: string;
      /** Apartment number. */
      apartmentNumber?: string;
      /** Geographic coordinates of location. */
      coordinates?: GeoCoordinates$1;
  }
  /**
   * Extra information on displayed addresses.
   * This is used for display purposes. Used to add additional data about the address, such as "In the passage".
   * Free text. In addition the user can state where he wants that additional description - before, after, or instead
   * the address string.
   */
  interface AddressHint$1 {
      /** Extra text displayed next to, or instead of, the actual address. */
      text?: string;
      /** Where the extra text should be displayed. */
      placement?: PlacementType$1;
  }
  /** Where the extra text should be displayed: before, after or instead of the actual address. */
  enum PlacementType$1 {
      BEFORE = "BEFORE",
      AFTER = "AFTER",
      REPLACE = "REPLACE"
  }
  /** Geocoordinates for a particular address. */
  interface GeoCoordinates$1 {
      /** Latitude of the location. Must be between -90 and 90. */
      latitude?: number;
      /** Longitude of the location. Must be between -180 and 180. */
      longitude?: number;
  }
  interface Multilingual$1 {
      /** Supported languages list. */
      supportedLanguages?: SupportedLanguage$1[];
      /** Whether to redirect to user language. */
      autoRedirect?: boolean;
  }
  interface SupportedLanguage$1 {
      /** Two-letter language code in [ISO 639-1 alpha-2](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format. */
      languageCode?: string;
      /** Locale. */
      locale?: Locale$1;
      /** Whether the supported language is the primary language for the site. */
      isPrimary?: boolean;
      /** Language icon. */
      countryCode?: string;
      /** How the language will be resolved. For internal use. */
      resolutionMethod?: ResolutionMethod$1;
  }
  enum ResolutionMethod$1 {
      QUERY_PARAM = "QUERY_PARAM",
      SUBDOMAIN = "SUBDOMAIN",
      SUBDIRECTORY = "SUBDIRECTORY"
  }
  interface ConsentPolicy$1 {
      /** Whether the site uses cookies that are essential to site operation. */
      essential?: boolean | null;
      /** Whether the site uses cookies that affect site performance and other functional measurements. */
      functional?: boolean | null;
      /** Whether the site uses cookies that collect analytics about how the site is used (in order to improve it). */
      analytics?: boolean | null;
      /** Whether the site uses cookies that collect information allowing better customization of the experience for a current visitor. */
      advertising?: boolean | null;
      /** CCPA compliance flag. */
      dataToThirdParty?: boolean | null;
  }
  /** A single mapping from the MetaSite ID to a particular service. */
  interface Translation$1 {
      /** The service type. */
      serviceType?: string;
      /** The application definition ID; this only applies to services of type ThirdPartyApps. */
      appDefId?: string;
      /** The instance ID of the service. */
      instanceId?: string;
  }
  interface ChangeContext$1 extends ChangeContextPayloadOneOf$1 {
      /** Properties were updated. */
      propertiesChange?: PropertiesChange$1;
      /** Default properties were created on site creation. */
      siteCreated?: SiteCreated$2;
      /** Properties were cloned on site cloning. */
      siteCloned?: SiteCloned$1;
  }
  /** @oneof */
  interface ChangeContextPayloadOneOf$1 {
      /** Properties were updated. */
      propertiesChange?: PropertiesChange$1;
      /** Default properties were created on site creation. */
      siteCreated?: SiteCreated$2;
      /** Properties were cloned on site cloning. */
      siteCloned?: SiteCloned$1;
  }
  interface PropertiesChange$1 {
  }
  interface SiteCreated$2 {
      /** Origin template site id. */
      originTemplateId?: string | null;
  }
  interface SiteCloned$1 {
      /** Origin site id. */
      originMetaSiteId?: string;
  }
  interface MultiServiceEnabledNotification {
  }
  /**
   * Creates a new service.
   * @param service - Service to be created.
   * @public
   * @documentationMaturity preview
   * @requiredField service
   * @permissionId BOOKINGS.SERVICES_CREATE
   * @adminMethod
   * @returns The created service.
   */
  function createService(service: Service): Promise<Service>;
  /**
   * Creates multiple new services.
   * @internal
   * @documentationMaturity preview
   * @requiredField services
   * @permissionId BOOKINGS.SERVICES_CREATE
   * @adminMethod
   */
  function bulkCreateServices(services: Service[], options?: BulkCreateServicesOptions): Promise<BulkCreateServicesResponse>;
  interface BulkCreateServicesOptions {
      /** `true` if the created entities must be included in the response, */
      returnEntity?: boolean;
      /**
       * otherwise no entities are included in the response.
       * @internal
       */
      skipScheduleCreation?: boolean;
  }
  /**
   * Retrieves a service.
   * @public
   * @documentationMaturity preview
   * @requiredField serviceId
   * @permissionId BOOKINGS.SERVICES_READ
   * @returns The retrieved service.
   */
  function getService(serviceId: string, options?: GetServiceOptions): Promise<Service>;
  interface GetServiceOptions {
      /** @internal */
      conditionalFields?: RequestedFields$1[];
      /** @internal */
      eventuallyConsistent?: boolean | null;
  }
  /**
   * Retrieves the service constraints for availability calculation
   * @internal
   * @documentationMaturity preview
   * @requiredField serviceId
   * @permissionId BOOKINGS.SERVICES_READ
   */
  function getServiceAvailabilityConstraints(serviceId: string): Promise<GetServiceAvailabilityConstraintsResponse>;
  /**
   * Updates a service.
   *
   * [Partial
   * updates](https://dev.wix.com/api/rest/wix-bookings/bookings/patch-endpoints-and-field-masks-in-update-requests)
   * are supported.
   *
   * Each time the service is updated, `revision` increments by 1. You must
   * include the number of the existing revision when updating the service.
   * This ensures you're working with the latest service information and
   * prevents unintended overwrites.
   * @param _id - Service ID.
   * @public
   * @documentationMaturity preview
   * @requiredField _id
   * @requiredField service
   * @requiredField service.revision
   * @permissionId BOOKINGS.SERVICES_UPDATE
   * @adminMethod
   * @returns The updated service.
   */
  function updateService(_id: string | null, service: UpdateService, options?: UpdateServiceOptions): Promise<Service>;
  interface UpdateService {
      /**
       * Service ID.
       * @readonly
       */
      _id?: string | null;
      /** Service type. */
      type?: ServiceType;
      /** Order of a service within a category. */
      sortOrder?: number | null;
      name?: string | null;
      description?: string | null;
      tagLine?: string | null;
      /** Default maximum number of customers that can book the service. The service cannot be booked beyond this capacity. */
      defaultCapacity?: number | null;
      /** Media associated with the service. */
      media?: Media;
      /** Whether the service is hidden from the site. */
      hidden?: boolean | null;
      /** The category the service is associated with. */
      category?: V2Category;
      /** The form used when booking the service. */
      form?: Form;
      /** Payment options for booking the service. */
      payment?: Payment;
      /** Online booking settings. */
      onlineBooking?: OnlineBooking;
      /** Conferencing options for this service. */
      conferencing?: Conferencing;
      /**
       * The locations this service is offered at.
       * In case of multiple (more than 1) location, All locations must be of type `BUSINESS`.
       * For courses only: Currently, only 1 location is supported, for all location types.
       */
      locations?: Location$3[];
      /** Policy determining under what conditions this service can be booked. For example, whether the service can only be booked up to 30 minutes before it begins. */
      bookingPolicy?: BookingPolicy$1;
      /** The service's schedule, which can be used to manage the service's sessions. */
      schedule?: Schedule$1;
      /** IDs of the staff members providing the service. For appointments only. */
      staffMemberIds?: string[];
      /**
       * Staff members providing the service. For appointments only. Returned only if `STAFF_MEMBER_DETAILS` conditional field was passed.
       * @internal
       * @readonly
       * @deprecated Staff members providing the service. For appointments only. Returned only if `STAFF_MEMBER_DETAILS` conditional field was passed.
       * @replacedBy staff_member_details.staff_members
       * @targetRemovalDate 2025-01-01
       */
      staffMembers?: StaffMember$1[];
      /**
       * Staff members details. Returned only if `STAFF_MEMBER_DETAILS` conditional field was passed.
       * @internal
       */
      staffMemberDetails?: StaffMemberDetails;
      /**
       * Resource groups required to book the service. For example, to book this service, you must book a room out of the resource group named "rooms".
       * @internal
       * @deprecated Resource groups required to book the service. For example, to book this service, you must book a room out of the resource group named "rooms".
       * @replacedBy service_resources
       * @targetRemovalDate 2024-08-19
       */
      resourceGroups?: ResourceGroup[];
      /**
       * Details on resources that are required to book the service. For example, to book this service, you must book a room out of the resource type named "rooms".
       * @internal
       */
      serviceResources?: ServiceResource[];
      /**
       * A slug is the last part of the URL address that serves as a unique identifier of the service.
       * The list of supported slugs includes past service names for backwards compatibility, and a custom slug if one was set by the business owner.
       * @readonly
       */
      supportedSlugs?: Slug[];
      /**
       * The main slug for the service. `mainSlug` is either taken from the current service name or is a custom slug set by the business owner.
       * `mainSlug` is used to construct the service's URLs.
       * @readonly
       */
      mainSlug?: Slug;
      /**
       * URLs to various service-related pages, such as the calendar page and the booking page.
       * @readonly
       */
      urls?: URLs;
      /** Extensions enabling users to save custom data related to the service. */
      extendedFields?: ExtendedFields$4;
      /** Custom SEO data for the service. */
      seoData?: SeoSchema;
      /**
       * Date and time the service was created.
       * @readonly
       */
      _createdDate?: Date | null;
      /**
       * Date and time the service was updated.
       * @readonly
       */
      _updatedDate?: Date | null;
      /**
       * Revision number, which increments by 1 each time the service is updated. To prevent conflicting changes, the existing revision must be used when updating a service.
       * @readonly
       */
      revision?: string | null;
  }
  interface UpdateServiceOptions {
      /**
       * updates](https://dev.wix.com/api/rest/wix-bookings/bookings/patch-endpoints-and-field-masks-in-update-requests)
       * are supported.
       * @internal
       */
      mask?: string[];
  }
  /**
   * Updates multiple services.
   *
   * [Partial
   * updates](https://dev.wix.com/api/rest/wix-bookings/bookings/patch-endpoints-and-field-masks-in-update-requests)
   * are supported.
   *
   * Each time a service is updated, `revision` increments by 1. You must
   * include the number of the existing revision for each service to update.
   * This ensures you're working with the latest service information and
   * prevents unintended overwrites.
   * @public
   * @documentationMaturity preview
   * @requiredField options.services.service
   * @requiredField options.services.service._id
   * @requiredField options.services.service.revision
   * @permissionId BOOKINGS.SERVICES_UPDATE
   * @adminMethod
   */
  function bulkUpdateServices(options?: BulkUpdateServicesOptions): Promise<BulkUpdateServicesResponse>;
  interface BulkUpdateServicesOptions {
      services?: MaskedService[];
      /** `true` if the updated entities must be included in the response, */
      returnEntity?: boolean;
  }
  /**
   * Updates multiple services by filter.
   *
   * [Partial
   * updates](https://dev.wix.com/api/rest/wix-bookings/bookings/patch-endpoints-and-field-masks-in-update-requests)
   * are supported.
   *
   * Each time a service is updated, `revision` increments by 1.
   * @param filter - Filter to identify the services that need to be updated.
   * @public
   * @documentationMaturity preview
   * @requiredField filter
   * @requiredField options.service
   * @permissionId BOOKINGS.SERVICES_UPDATE
   * @adminMethod
   */
  function bulkUpdateServicesByFilter(filter: Record<string, any> | null, options?: BulkUpdateServicesByFilterOptions): Promise<BulkUpdateServicesByFilterResponse>;
  interface BulkUpdateServicesByFilterOptions {
      /**
       * Service to update. [Partial
       * updates](https://dev.wix.com/api/rest/wix-bookings/bookings/patch-endpoints-and-field-masks-in-update-requests)
       * are supported.
       */
      service: Service;
      /**
       * Explicit list of fields to update.
       * @internal
       */
      mask?: string[];
  }
  /**
   * Deletes a service.
   * @public
   * @documentationMaturity preview
   * @requiredField serviceId
   * @param options - Allows you to configure how to handle the deleted service's future sessions and how to notify the sessions participants.
   * @permissionId BOOKINGS.SERVICES_DELETE
   * @adminMethod
   */
  function deleteService(serviceId: string, options?: DeleteServiceOptions): Promise<void>;
  interface DeleteServiceOptions {
      /**
       * Whether to preserve future sessions with participants.
       *
       * Default: `false`
       */
      preserveFutureSessionsWithParticipants?: boolean;
      /** Whether to notify participants about the change and an optional */
      participantNotification?: ParticipantNotification$4;
  }
  /**
   * Deletes multiple services.
   * @param ids - Ids of the services for deletion.
   * @public
   * @documentationMaturity preview
   * @requiredField ids
   * @permissionId BOOKINGS.SERVICES_DELETE
   * @adminMethod
   */
  function bulkDeleteServices(ids: string[], options?: BulkDeleteServicesOptions): Promise<BulkDeleteServicesResponse>;
  interface BulkDeleteServicesOptions {
      /**
       * Whether to preserve future sessions with participants.
       *
       * Default: `false`.
       */
      preserveFutureSessionsWithParticipants?: boolean;
      /** Whether to notify participants about the change and an optional */
      participantNotification?: ParticipantNotification$4;
  }
  /**
   * Deletes multiple services by filter.
   * @param filter - Filter to identify the services that need to be deleted.
   * @public
   * @documentationMaturity preview
   * @requiredField filter
   * @permissionId BOOKINGS.SERVICES_DELETE
   * @adminMethod
   */
  function bulkDeleteServicesByFilter(filter: Record<string, any> | null, options?: BulkDeleteServicesByFilterOptions): Promise<BulkDeleteServicesByFilterResponse>;
  interface BulkDeleteServicesByFilterOptions {
      /**
       * Whether to preserve future sessions with participants.
       *
       * Default: `false`.
       */
      preserveFutureSessionsWithParticipants?: boolean;
      /** Whether to notify participants about the change and an optional custom message. */
      participantNotification?: ParticipantNotification$4;
  }
  /**
   * Retrieves a list of up to 100 services, given the provided paging, filtering, and sorting.
   * `queryServices()` runs with these defaults, which you can override:
   * + `paging.limit` is `100`.
   * + `paging.offset` is `0`.
   *
   *
   * >**Notes:**
   * > + Use UTC format when filtering with dates.
   * > + Only 1 use of each filter in the same query is supported. If a filter is defined more than once in a query, only the first occurrence is processed.
   * @public
   * @documentationMaturity preview
   * @permissionId BOOKINGS.SERVICES_READ
   */
  function queryServices(options?: QueryServicesOptions): ServicesQueryBuilder;
  interface QueryServicesOptions {
      /** @internal */
      conditionalFields?: RequestedFields$1[] | undefined;
      /** @internal */
      eventuallyConsistent?: boolean | null | undefined;
  }
  interface QueryOffsetResult {
      currentPage: number | undefined;
      totalPages: number | undefined;
      totalCount: number | undefined;
      hasNext: () => boolean;
      hasPrev: () => boolean;
      length: number;
      pageSize: number;
  }
  interface ServicesQueryResult extends QueryOffsetResult {
      items: Service[];
      query: ServicesQueryBuilder;
      next: () => Promise<ServicesQueryResult>;
      prev: () => Promise<ServicesQueryResult>;
  }
  interface ServicesQueryBuilder {
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       * @documentationMaturity preview
       */
      eq: (propertyName: '_id' | 'type' | 'name' | 'description' | 'tagLine' | 'hidden' | 'category.id' | 'category.name' | 'form.id' | 'payment.options.online' | 'payment.options.inPerson' | 'payment.options.pricingPlan' | 'onlineBooking.enabled' | 'locations.business.id' | 'schedule.firstSessionStart' | 'schedule.lastSessionEnd' | 'staffMemberIds' | 'supportedSlugs.name' | 'mainSlug.name', value: any) => ServicesQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       * @documentationMaturity preview
       */
      ne: (propertyName: '_id' | 'type' | 'name' | 'description' | 'tagLine' | 'hidden' | 'category.id' | 'category.name' | 'form.id' | 'payment.options.online' | 'payment.options.inPerson' | 'payment.options.pricingPlan' | 'onlineBooking.enabled' | 'locations.business.id' | 'schedule.firstSessionStart' | 'schedule.lastSessionEnd' | 'staffMemberIds' | 'supportedSlugs.name' | 'mainSlug.name', value: any) => ServicesQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       * @documentationMaturity preview
       */
      ge: (propertyName: 'schedule.firstSessionStart' | 'schedule.lastSessionEnd', value: any) => ServicesQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       * @documentationMaturity preview
       */
      gt: (propertyName: 'schedule.firstSessionStart' | 'schedule.lastSessionEnd', value: any) => ServicesQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       * @documentationMaturity preview
       */
      le: (propertyName: 'schedule.firstSessionStart' | 'schedule.lastSessionEnd', value: any) => ServicesQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       * @documentationMaturity preview
       */
      lt: (propertyName: 'schedule.firstSessionStart' | 'schedule.lastSessionEnd', value: any) => ServicesQueryBuilder;
      /** @param propertyName - Property whose value is compared with `string`.
       * @param string - String to compare against. Case-insensitive.
       * @documentationMaturity preview
       */
      startsWith: (propertyName: '_id' | 'name' | 'description' | 'tagLine' | 'category.id' | 'category.name' | 'form.id' | 'locations.business.id' | 'supportedSlugs.name' | 'mainSlug.name', value: string) => ServicesQueryBuilder;
      /** @param propertyName - Property whose value is compared with `values`.
       * @param values - List of values to compare against.
       * @documentationMaturity preview
       */
      hasSome: (propertyName: '_id' | 'type' | 'name' | 'description' | 'tagLine' | 'hidden' | 'category.id' | 'category.name' | 'form.id' | 'payment.options.online' | 'payment.options.inPerson' | 'payment.options.pricingPlan' | 'onlineBooking.enabled' | 'locations.business.id' | 'schedule.firstSessionStart' | 'schedule.lastSessionEnd' | 'staffMemberIds' | 'supportedSlugs.name' | 'mainSlug.name', value: any[]) => ServicesQueryBuilder;
      /** @param propertyName - Property whose value is compared with `values`.
       * @param values - List of values to compare against.
       * @documentationMaturity preview
       */
      hasAll: (propertyName: 'staffMemberIds', value: any[]) => ServicesQueryBuilder;
      /** @documentationMaturity preview */
      in: (propertyName: '_id' | 'type' | 'name' | 'description' | 'tagLine' | 'hidden' | 'category.id' | 'category.name' | 'form.id' | 'payment.options.online' | 'payment.options.inPerson' | 'payment.options.pricingPlan' | 'onlineBooking.enabled' | 'locations.business.id' | 'schedule.firstSessionStart' | 'schedule.lastSessionEnd' | 'staffMemberIds' | 'supportedSlugs.name' | 'mainSlug.name', value: any) => ServicesQueryBuilder;
      /** @documentationMaturity preview */
      exists: (propertyName: '_id' | 'type' | 'name' | 'description' | 'tagLine' | 'hidden' | 'category.id' | 'category.name' | 'form.id' | 'payment.options.online' | 'payment.options.inPerson' | 'payment.options.pricingPlan' | 'onlineBooking.enabled' | 'locations.business.id' | 'schedule.firstSessionStart' | 'schedule.lastSessionEnd' | 'staffMemberIds' | 'supportedSlugs.name' | 'mainSlug.name', value: boolean) => ServicesQueryBuilder;
      /** @param limit - Number of items to return, which is also the `pageSize` of the results object.
       * @documentationMaturity preview
       */
      limit: (limit: number) => ServicesQueryBuilder;
      /** @param skip - Number of items to skip in the query results before returning the results.
       * @documentationMaturity preview
       */
      skip: (skip: number) => ServicesQueryBuilder;
      /** @documentationMaturity preview */
      find: () => Promise<ServicesQueryResult>;
  }
  /**
   * Retrieves a list of up to 100 services, given the provided query string,
   * and paging.
   * @param search - WQL, search or aggregation expression.
   * @public
   * @documentationMaturity preview
   * @requiredField search
   * @permissionId BOOKINGS.SERVICES_READ
   */
  function searchServices(search: CursorSearch$1): Promise<SearchServicesResponse>;
  /**
   * Retrieves a list of up to 100 policies, given the provided paging,
   * filtering, and sorting.
   *
   *
   * Define queries using [WQL - Wix Query
   * Language](https://dev.wix.com/api/rest/getting-started/api-query-language).
   * For field support for filters and sorting, see [Supported Filters and
   * Sorting](https://dev.wix.com/api/rest/wix-bookings/services-v2/supported-filters-and-sorting).
   *
   * To retrieve all policies use an empty query:
   *
   * ```javascript
   * {
   * "query": {}
   * }
   * ```
   * `Query Policies` runs with these defaults, which you can override:
   * + `paging.limit` is `100`.
   * + `paging.offset` is `0`.
   *
   *
   * >**Notes:**
   * > + Use UTC format when filtering with dates.
   * > + Only 1 use of each filter in the same query is supported. If a filter
   * is defined more than once in a query, only the first occurrence is
   * processed.
   * @param query - WQL expression.
   * @public
   * @documentationMaturity preview
   * @requiredField query
   * @permissionId BOOKINGS.BOOKING_POLICY_READ
   * @permissionId BOOKINGS.SERVICES_READ
   */
  function queryPolicies(query: CursorQuery$2): Promise<QueryPoliciesResponse>;
  /**
   * Retrieves the number of services that match the provided filters.
   * @public
   * @documentationMaturity preview
   * @permissionId BOOKINGS.SERVICES_COUNT
   */
  function countServices(options?: CountServicesOptions): Promise<CountServicesResponse>;
  interface CountServicesOptions {
      /** The filters for performing the count. */
      filter?: Record<string, any> | null;
  }
  /**
   * Query locations that exist on services.
   * @public
   * @documentationMaturity preview
   * @permissionId BOOKINGS.SERVICES_READ
   */
  function queryLocations(options?: QueryLocationsOptions): Promise<QueryLocationsResponse>;
  interface QueryLocationsOptions {
      /** The filter for the query. */
      filter?: QueryLocationsFilter;
  }
  /**
   * Query categories that exist on services.
   * @public
   * @documentationMaturity preview
   * @permissionId BOOKINGS.SERVICES_READ
   */
  function queryCategories(options?: QueryCategoriesOptions): Promise<QueryCategoriesResponse>;
  interface QueryCategoriesOptions {
      /** The filter for the query. */
      filter?: QueryCategoriesFilter;
  }
  /**
   * Query services in both the main language and the provided language according to the linguist aspect.
   * @param query - WQL expression.
   * @internal
   * @documentationMaturity preview
   * @requiredField query
   * @permissionId BOOKINGS.SERVICES_READ
   */
  function queryServicesMultiLanguage(query: QueryV2$2, options?: QueryServicesMultiLanguageOptions): Promise<QueryServicesMultiLanguageResponse>;
  interface QueryServicesMultiLanguageOptions {
      /** @internal */
      conditionalFields?: RequestedFields$1[];
  }
  /**
   * Change the locations this service is offered at.
   * Changing locations may have impact on existing sessions and their
   * participants. When removing locations from a service, this endpoint
   * requires stating what to do with existing sessions occurring at the removed
   * locations.
   * @param serviceId - ID of the service.
   * @param locations - The locations you specify replace the existing service locations.
   * @public
   * @documentationMaturity preview
   * @requiredField locations
   * @requiredField serviceId
   * @permissionId BOOKINGS.SERVICES_LOCATIONS_SET
   * @adminMethod
   */
  function setServiceLocations(serviceId: string, locations: Location$3[], options?: SetServiceLocationsOptions): Promise<SetServiceLocationsResponse>;
  interface SetServiceLocationsOptions {
      /**
       * The action to perform on sessions currently set to a removed location. For
       * example, move existing sessions to a new specified location.
       */
      removedLocationSessionsAction?: RemovedLocationSessionsAction;
      /**
       * Whether to notify participants about the change of location, and an
       * optional custom message.
       */
      participantNotification?: ParticipantNotification$4;
  }
  /**
   * Enables specific [pricing
   * plans](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/plans/plan-object)
   * as payment methods for a service. This API enables customers to pay for the
   * service using one of the specified pricing plans.
   * @public
   * @documentationMaturity preview
   * @requiredField pricingPlanIds
   * @requiredField serviceId
   * @permissionId BOOKINGS.SERVICES_PRICING_PLANS_ADD
   * @adminMethod
   */
  function enablePricingPlansForService(serviceId: string, pricingPlanIds: string[]): Promise<EnablePricingPlansForServiceResponse>;
  /**
   * Disables specific [pricing
   * plans](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/plans/plan-object)
   * as payment methods for a service. Customers can't pay for the service using
   * a removed pricing plan. Existing payments with a removed plan aren't
   * affected.
   * @public
   * @documentationMaturity preview
   * @requiredField serviceId
   * @permissionId BOOKINGS.SERVICES_PRICING_PLANS_REMOVE
   * @adminMethod
   */
  function disablePricingPlansForService(serviceId: string, options?: DisablePricingPlansForServiceOptions): Promise<DisablePricingPlansForServiceResponse>;
  interface DisablePricingPlansForServiceOptions {
      pricingPlanIds?: string[];
  }
  /**
   * Sets a custom (user-defined) slug for the various service pages.
   * The call may fail if there's another service with the same slug, either by
   * past name or by a custom slug.
   * @public
   * @documentationMaturity preview
   * @requiredField serviceId
   * @requiredField slugName
   * @permissionId BOOKINGS.SERVICES_CUSTOM_SLUGS_SET
   * @adminMethod
   */
  function setCustomSlug(serviceId: string, slugName: string): Promise<SetCustomSlugResponse>;
  /**
   * Validate a custom (user-defined) slug, making sure no other service uses
   * the same slug. The call may fail if there's another service with the same
   * slug, either by past name or by a custom set slug.
   * @public
   * @documentationMaturity preview
   * @requiredField options
   * @requiredField options.slugName
   * @requiredField serviceId
   * @permissionId BOOKINGS.SERVICES_CUSTOM_SLUGS_SET
   * @adminMethod
   */
  function validateSlug(serviceId: string, options: ValidateSlugOptions): Promise<ValidateSlugResponse>;
  interface ValidateSlugOptions {
      slugName: string;
  }
  /**
   * Clones a service.
   * @public
   * @documentationMaturity preview
   * @requiredField sourceServiceId
   * @permissionId BOOKINGS.SERVICE_CLONE
   * @adminMethod
   */
  function cloneService(sourceServiceId: string, options?: CloneServiceOptions): Promise<CloneServiceResponse>;
  interface CloneServiceOptions {
      /** copy recurring sessions of an active service's schedule */
      copyRecurringSessions?: boolean;
      /** copy benefits with pricing plans that are connected to the source */
      copyPricingPlans?: boolean;
      /**
       * service. If the source service is connected to more than 120
       * benefits with pricing plans then they will not be copied. In that
       * case the field `error_types` in the response will include
       * `PRICING_PLANS`.
       */
      hideService?: boolean | null;
      /** copy this value from the source service without overriding it */
      cloneServiceName?: string | null;
  }
  
  type bookingsServicesV2Service_universal_d_Service = Service;
  type bookingsServicesV2Service_universal_d_ServiceType = ServiceType;
  const bookingsServicesV2Service_universal_d_ServiceType: typeof ServiceType;
  type bookingsServicesV2Service_universal_d_Media = Media;
  type bookingsServicesV2Service_universal_d_MediaItemItemOneOf = MediaItemItemOneOf;
  type bookingsServicesV2Service_universal_d_V2Category = V2Category;
  type bookingsServicesV2Service_universal_d_Form = Form;
  type bookingsServicesV2Service_universal_d_FormSettings = FormSettings;
  type bookingsServicesV2Service_universal_d_Payment = Payment;
  type bookingsServicesV2Service_universal_d_PaymentRateOneOf = PaymentRateOneOf;
  type bookingsServicesV2Service_universal_d_RateType = RateType;
  const bookingsServicesV2Service_universal_d_RateType: typeof RateType;
  type bookingsServicesV2Service_universal_d_FixedPayment = FixedPayment;
  type bookingsServicesV2Service_universal_d_CommonMoney = CommonMoney;
  type bookingsServicesV2Service_universal_d_CustomPayment = CustomPayment;
  type bookingsServicesV2Service_universal_d_VariedPayment = VariedPayment;
  type bookingsServicesV2Service_universal_d_PaymentOptions = PaymentOptions;
  type bookingsServicesV2Service_universal_d_OnlineBooking = OnlineBooking;
  type bookingsServicesV2Service_universal_d_Conferencing = Conferencing;
  type bookingsServicesV2Service_universal_d_LocationOptionsOneOf = LocationOptionsOneOf;
  type bookingsServicesV2Service_universal_d_BusinessLocationOptions = BusinessLocationOptions;
  type bookingsServicesV2Service_universal_d_CustomLocationOptions = CustomLocationOptions;
  type bookingsServicesV2Service_universal_d_StaffMediaItem = StaffMediaItem;
  type bookingsServicesV2Service_universal_d_StaffMediaItemItemOneOf = StaffMediaItemItemOneOf;
  type bookingsServicesV2Service_universal_d_StaffMemberDetails = StaffMemberDetails;
  type bookingsServicesV2Service_universal_d_ResourceGroup = ResourceGroup;
  type bookingsServicesV2Service_universal_d_ResourceIds = ResourceIds;
  type bookingsServicesV2Service_universal_d_ServiceResource = ServiceResource;
  type bookingsServicesV2Service_universal_d_ServiceResourceSelectionOneOf = ServiceResourceSelectionOneOf;
  type bookingsServicesV2Service_universal_d_ResourceType = ResourceType;
  type bookingsServicesV2Service_universal_d_Slug = Slug;
  type bookingsServicesV2Service_universal_d_URLs = URLs;
  type bookingsServicesV2Service_universal_d_SeoSchema = SeoSchema;
  type bookingsServicesV2Service_universal_d_Keyword = Keyword;
  type bookingsServicesV2Service_universal_d_Tag = Tag;
  type bookingsServicesV2Service_universal_d_Settings = Settings;
  type bookingsServicesV2Service_universal_d_ReindexMessage = ReindexMessage;
  type bookingsServicesV2Service_universal_d_ReindexMessageActionOneOf = ReindexMessageActionOneOf;
  type bookingsServicesV2Service_universal_d_Upsert = Upsert;
  type bookingsServicesV2Service_universal_d_Delete = Delete;
  type bookingsServicesV2Service_universal_d_Schema = Schema;
  type bookingsServicesV2Service_universal_d_SetCustomSlugEvent = SetCustomSlugEvent;
  type bookingsServicesV2Service_universal_d_ServicesUrlsChanged = ServicesUrlsChanged;
  type bookingsServicesV2Service_universal_d_CreateServiceRequest = CreateServiceRequest;
  type bookingsServicesV2Service_universal_d_CreateServiceResponse = CreateServiceResponse;
  type bookingsServicesV2Service_universal_d_BulkCreateServicesRequest = BulkCreateServicesRequest;
  type bookingsServicesV2Service_universal_d_BulkCreateServicesResponse = BulkCreateServicesResponse;
  type bookingsServicesV2Service_universal_d_BulkServiceResult = BulkServiceResult;
  type bookingsServicesV2Service_universal_d_GetServiceRequest = GetServiceRequest;
  type bookingsServicesV2Service_universal_d_GetServiceResponse = GetServiceResponse;
  type bookingsServicesV2Service_universal_d_GetServiceAvailabilityConstraintsRequest = GetServiceAvailabilityConstraintsRequest;
  type bookingsServicesV2Service_universal_d_GetServiceAvailabilityConstraintsResponse = GetServiceAvailabilityConstraintsResponse;
  type bookingsServicesV2Service_universal_d_ServiceAvailabilityConstraints = ServiceAvailabilityConstraints;
  type bookingsServicesV2Service_universal_d_V1SplitInterval = V1SplitInterval;
  type bookingsServicesV2Service_universal_d_UpdateServiceRequest = UpdateServiceRequest;
  type bookingsServicesV2Service_universal_d_UpdateServiceResponse = UpdateServiceResponse;
  type bookingsServicesV2Service_universal_d_BulkUpdateServicesRequest = BulkUpdateServicesRequest;
  type bookingsServicesV2Service_universal_d_MaskedService = MaskedService;
  type bookingsServicesV2Service_universal_d_BulkUpdateServicesResponse = BulkUpdateServicesResponse;
  type bookingsServicesV2Service_universal_d_BulkUpdateServicesByFilterRequest = BulkUpdateServicesByFilterRequest;
  type bookingsServicesV2Service_universal_d_BulkUpdateServicesByFilterResponse = BulkUpdateServicesByFilterResponse;
  type bookingsServicesV2Service_universal_d_DeleteServiceRequest = DeleteServiceRequest;
  type bookingsServicesV2Service_universal_d_DeleteServiceResponse = DeleteServiceResponse;
  type bookingsServicesV2Service_universal_d_BulkDeleteServicesRequest = BulkDeleteServicesRequest;
  type bookingsServicesV2Service_universal_d_BulkDeleteServicesResponse = BulkDeleteServicesResponse;
  type bookingsServicesV2Service_universal_d_BulkDeleteServicesByFilterRequest = BulkDeleteServicesByFilterRequest;
  type bookingsServicesV2Service_universal_d_BulkDeleteServicesByFilterResponse = BulkDeleteServicesByFilterResponse;
  type bookingsServicesV2Service_universal_d_QueryServicesRequest = QueryServicesRequest;
  type bookingsServicesV2Service_universal_d_QueryServicesResponse = QueryServicesResponse;
  type bookingsServicesV2Service_universal_d_SearchServicesRequest = SearchServicesRequest;
  type bookingsServicesV2Service_universal_d_Aggregation = Aggregation;
  type bookingsServicesV2Service_universal_d_AggregationKindOneOf = AggregationKindOneOf;
  type bookingsServicesV2Service_universal_d_RangeBucket = RangeBucket;
  type bookingsServicesV2Service_universal_d_SortType = SortType;
  const bookingsServicesV2Service_universal_d_SortType: typeof SortType;
  type bookingsServicesV2Service_universal_d_SortDirection = SortDirection;
  const bookingsServicesV2Service_universal_d_SortDirection: typeof SortDirection;
  type bookingsServicesV2Service_universal_d_MissingValues = MissingValues;
  const bookingsServicesV2Service_universal_d_MissingValues: typeof MissingValues;
  type bookingsServicesV2Service_universal_d_IncludeMissingValuesOptions = IncludeMissingValuesOptions;
  type bookingsServicesV2Service_universal_d_ValueAggregation = ValueAggregation;
  type bookingsServicesV2Service_universal_d_ValueAggregationOptionsOneOf = ValueAggregationOptionsOneOf;
  type bookingsServicesV2Service_universal_d_NestedAggregationType = NestedAggregationType;
  const bookingsServicesV2Service_universal_d_NestedAggregationType: typeof NestedAggregationType;
  type bookingsServicesV2Service_universal_d_RangeAggregation = RangeAggregation;
  type bookingsServicesV2Service_universal_d_ScalarAggregation = ScalarAggregation;
  type bookingsServicesV2Service_universal_d_DateHistogramAggregation = DateHistogramAggregation;
  type bookingsServicesV2Service_universal_d_DateHistogramAggregationInterval = DateHistogramAggregationInterval;
  const bookingsServicesV2Service_universal_d_DateHistogramAggregationInterval: typeof DateHistogramAggregationInterval;
  type bookingsServicesV2Service_universal_d_NestedAggregationItem = NestedAggregationItem;
  type bookingsServicesV2Service_universal_d_NestedAggregationItemKindOneOf = NestedAggregationItemKindOneOf;
  type bookingsServicesV2Service_universal_d_NestedAggregation = NestedAggregation;
  type bookingsServicesV2Service_universal_d_GroupByAggregation = GroupByAggregation;
  type bookingsServicesV2Service_universal_d_GroupByAggregationKindOneOf = GroupByAggregationKindOneOf;
  type bookingsServicesV2Service_universal_d_SearchServicesResponse = SearchServicesResponse;
  type bookingsServicesV2Service_universal_d_ValueResult = ValueResult;
  type bookingsServicesV2Service_universal_d_RangeResult = RangeResult;
  type bookingsServicesV2Service_universal_d_NestedResultsScalarResult = NestedResultsScalarResult;
  type bookingsServicesV2Service_universal_d_NestedResultValue = NestedResultValue;
  type bookingsServicesV2Service_universal_d_NestedResultValueResultOneOf = NestedResultValueResultOneOf;
  type bookingsServicesV2Service_universal_d_Results = Results;
  type bookingsServicesV2Service_universal_d_DateHistogramResult = DateHistogramResult;
  type bookingsServicesV2Service_universal_d_DateHistogramResults = DateHistogramResults;
  type bookingsServicesV2Service_universal_d_NestedResults = NestedResults;
  type bookingsServicesV2Service_universal_d_QueryPoliciesRequest = QueryPoliciesRequest;
  type bookingsServicesV2Service_universal_d_QueryPoliciesResponse = QueryPoliciesResponse;
  type bookingsServicesV2Service_universal_d_BookingPolicyWithServices = BookingPolicyWithServices;
  type bookingsServicesV2Service_universal_d_CountServicesRequest = CountServicesRequest;
  type bookingsServicesV2Service_universal_d_CountServicesResponse = CountServicesResponse;
  type bookingsServicesV2Service_universal_d_QueryLocationsRequest = QueryLocationsRequest;
  type bookingsServicesV2Service_universal_d_QueryLocationsFilter = QueryLocationsFilter;
  type bookingsServicesV2Service_universal_d_QueryLocationsResponse = QueryLocationsResponse;
  type bookingsServicesV2Service_universal_d_BusinessLocations = BusinessLocations;
  type bookingsServicesV2Service_universal_d_CustomLocations = CustomLocations;
  type bookingsServicesV2Service_universal_d_CustomerLocations = CustomerLocations;
  type bookingsServicesV2Service_universal_d_QueryCategoriesRequest = QueryCategoriesRequest;
  type bookingsServicesV2Service_universal_d_QueryCategoriesFilter = QueryCategoriesFilter;
  type bookingsServicesV2Service_universal_d_QueryCategoriesResponse = QueryCategoriesResponse;
  type bookingsServicesV2Service_universal_d_QueryServicesMultiLanguageRequest = QueryServicesMultiLanguageRequest;
  type bookingsServicesV2Service_universal_d_QueryServicesMultiLanguageResponse = QueryServicesMultiLanguageResponse;
  type bookingsServicesV2Service_universal_d_SetServiceLocationsRequest = SetServiceLocationsRequest;
  type bookingsServicesV2Service_universal_d_RemovedLocationSessionsAction = RemovedLocationSessionsAction;
  type bookingsServicesV2Service_universal_d_RemovedLocationSessionsActionActionOptionsOneOf = RemovedLocationSessionsActionActionOptionsOneOf;
  type bookingsServicesV2Service_universal_d_Action = Action;
  const bookingsServicesV2Service_universal_d_Action: typeof Action;
  type bookingsServicesV2Service_universal_d_MoveToNewLocationsOptions = MoveToNewLocationsOptions;
  type bookingsServicesV2Service_universal_d_SetServiceLocationsResponse = SetServiceLocationsResponse;
  type bookingsServicesV2Service_universal_d_EnablePricingPlansForServiceRequest = EnablePricingPlansForServiceRequest;
  type bookingsServicesV2Service_universal_d_EnablePricingPlansForServiceResponse = EnablePricingPlansForServiceResponse;
  type bookingsServicesV2Service_universal_d_InvalidPricingPlan = InvalidPricingPlan;
  type bookingsServicesV2Service_universal_d_DisablePricingPlansForServiceRequest = DisablePricingPlansForServiceRequest;
  type bookingsServicesV2Service_universal_d_DisablePricingPlansForServiceResponse = DisablePricingPlansForServiceResponse;
  type bookingsServicesV2Service_universal_d_SetCustomSlugRequest = SetCustomSlugRequest;
  type bookingsServicesV2Service_universal_d_SetCustomSlugResponse = SetCustomSlugResponse;
  type bookingsServicesV2Service_universal_d_ValidateSlugRequest = ValidateSlugRequest;
  type bookingsServicesV2Service_universal_d_ValidateSlugResponse = ValidateSlugResponse;
  type bookingsServicesV2Service_universal_d_InvalidSlugError = InvalidSlugError;
  const bookingsServicesV2Service_universal_d_InvalidSlugError: typeof InvalidSlugError;
  type bookingsServicesV2Service_universal_d_CloneServiceRequest = CloneServiceRequest;
  type bookingsServicesV2Service_universal_d_CloneServiceResponse = CloneServiceResponse;
  type bookingsServicesV2Service_universal_d_CloneErrors = CloneErrors;
  const bookingsServicesV2Service_universal_d_CloneErrors: typeof CloneErrors;
  type bookingsServicesV2Service_universal_d_CategoryNotification = CategoryNotification;
  type bookingsServicesV2Service_universal_d_Category = Category;
  type bookingsServicesV2Service_universal_d_Event = Event;
  const bookingsServicesV2Service_universal_d_Event: typeof Event;
  type bookingsServicesV2Service_universal_d_V1Schedule = V1Schedule;
  type bookingsServicesV2Service_universal_d_V1Location = V1Location;
  type bookingsServicesV2Service_universal_d_CommonAddress = CommonAddress;
  type bookingsServicesV2Service_universal_d_CommonAddressStreetOneOf = CommonAddressStreetOneOf;
  type bookingsServicesV2Service_universal_d_CommonStreetAddress = CommonStreetAddress;
  type bookingsServicesV2Service_universal_d_CommonAddressLocation = CommonAddressLocation;
  type bookingsServicesV2Service_universal_d_V1AvailabilityConstraints = V1AvailabilityConstraints;
  type bookingsServicesV2Service_universal_d_SessionStatus = SessionStatus;
  const bookingsServicesV2Service_universal_d_SessionStatus: typeof SessionStatus;
  type bookingsServicesV2Service_universal_d_V1ParticipantNotification = V1ParticipantNotification;
  type bookingsServicesV2Service_universal_d_ResourceNotification = ResourceNotification;
  type bookingsServicesV2Service_universal_d_ResourceStatus = ResourceStatus;
  const bookingsServicesV2Service_universal_d_ResourceStatus: typeof ResourceStatus;
  type bookingsServicesV2Service_universal_d_BusinessLocation = BusinessLocation;
  type bookingsServicesV2Service_universal_d_ResourceNotificationEvent = ResourceNotificationEvent;
  const bookingsServicesV2Service_universal_d_ResourceNotificationEvent: typeof ResourceNotificationEvent;
  type bookingsServicesV2Service_universal_d_BenefitNotification = BenefitNotification;
  type bookingsServicesV2Service_universal_d_Benefit = Benefit;
  type bookingsServicesV2Service_universal_d_EntryPass = EntryPass;
  type bookingsServicesV2Service_universal_d_Discount = Discount;
  type bookingsServicesV2Service_universal_d_DiscountDiscountOneOf = DiscountDiscountOneOf;
  type bookingsServicesV2Service_universal_d_BenefitType = BenefitType;
  const bookingsServicesV2Service_universal_d_BenefitType: typeof BenefitType;
  type bookingsServicesV2Service_universal_d_Behavior = Behavior;
  type bookingsServicesV2Service_universal_d_BehaviorBehaviorOneOf = BehaviorBehaviorOneOf;
  type bookingsServicesV2Service_universal_d_BenefitNotificationEvent = BenefitNotificationEvent;
  const bookingsServicesV2Service_universal_d_BenefitNotificationEvent: typeof BenefitNotificationEvent;
  type bookingsServicesV2Service_universal_d_UserDomainInfoChangedEvent = UserDomainInfoChangedEvent;
  type bookingsServicesV2Service_universal_d_CrudType = CrudType;
  const bookingsServicesV2Service_universal_d_CrudType: typeof CrudType;
  type bookingsServicesV2Service_universal_d_HtmlSitePublished = HtmlSitePublished;
  type bookingsServicesV2Service_universal_d_Page = Page;
  type bookingsServicesV2Service_universal_d_V4Address = V4Address;
  type bookingsServicesV2Service_universal_d_MultiServiceEnabledNotification = MultiServiceEnabledNotification;
  const bookingsServicesV2Service_universal_d_createService: typeof createService;
  const bookingsServicesV2Service_universal_d_bulkCreateServices: typeof bulkCreateServices;
  type bookingsServicesV2Service_universal_d_BulkCreateServicesOptions = BulkCreateServicesOptions;
  const bookingsServicesV2Service_universal_d_getService: typeof getService;
  type bookingsServicesV2Service_universal_d_GetServiceOptions = GetServiceOptions;
  const bookingsServicesV2Service_universal_d_getServiceAvailabilityConstraints: typeof getServiceAvailabilityConstraints;
  const bookingsServicesV2Service_universal_d_updateService: typeof updateService;
  type bookingsServicesV2Service_universal_d_UpdateService = UpdateService;
  type bookingsServicesV2Service_universal_d_UpdateServiceOptions = UpdateServiceOptions;
  const bookingsServicesV2Service_universal_d_bulkUpdateServices: typeof bulkUpdateServices;
  type bookingsServicesV2Service_universal_d_BulkUpdateServicesOptions = BulkUpdateServicesOptions;
  const bookingsServicesV2Service_universal_d_bulkUpdateServicesByFilter: typeof bulkUpdateServicesByFilter;
  type bookingsServicesV2Service_universal_d_BulkUpdateServicesByFilterOptions = BulkUpdateServicesByFilterOptions;
  const bookingsServicesV2Service_universal_d_deleteService: typeof deleteService;
  type bookingsServicesV2Service_universal_d_DeleteServiceOptions = DeleteServiceOptions;
  const bookingsServicesV2Service_universal_d_bulkDeleteServices: typeof bulkDeleteServices;
  type bookingsServicesV2Service_universal_d_BulkDeleteServicesOptions = BulkDeleteServicesOptions;
  const bookingsServicesV2Service_universal_d_bulkDeleteServicesByFilter: typeof bulkDeleteServicesByFilter;
  type bookingsServicesV2Service_universal_d_BulkDeleteServicesByFilterOptions = BulkDeleteServicesByFilterOptions;
  const bookingsServicesV2Service_universal_d_queryServices: typeof queryServices;
  type bookingsServicesV2Service_universal_d_QueryServicesOptions = QueryServicesOptions;
  type bookingsServicesV2Service_universal_d_ServicesQueryResult = ServicesQueryResult;
  type bookingsServicesV2Service_universal_d_ServicesQueryBuilder = ServicesQueryBuilder;
  const bookingsServicesV2Service_universal_d_searchServices: typeof searchServices;
  const bookingsServicesV2Service_universal_d_queryPolicies: typeof queryPolicies;
  const bookingsServicesV2Service_universal_d_countServices: typeof countServices;
  type bookingsServicesV2Service_universal_d_CountServicesOptions = CountServicesOptions;
  const bookingsServicesV2Service_universal_d_queryLocations: typeof queryLocations;
  type bookingsServicesV2Service_universal_d_QueryLocationsOptions = QueryLocationsOptions;
  const bookingsServicesV2Service_universal_d_queryCategories: typeof queryCategories;
  type bookingsServicesV2Service_universal_d_QueryCategoriesOptions = QueryCategoriesOptions;
  const bookingsServicesV2Service_universal_d_queryServicesMultiLanguage: typeof queryServicesMultiLanguage;
  type bookingsServicesV2Service_universal_d_QueryServicesMultiLanguageOptions = QueryServicesMultiLanguageOptions;
  const bookingsServicesV2Service_universal_d_setServiceLocations: typeof setServiceLocations;
  type bookingsServicesV2Service_universal_d_SetServiceLocationsOptions = SetServiceLocationsOptions;
  const bookingsServicesV2Service_universal_d_enablePricingPlansForService: typeof enablePricingPlansForService;
  const bookingsServicesV2Service_universal_d_disablePricingPlansForService: typeof disablePricingPlansForService;
  type bookingsServicesV2Service_universal_d_DisablePricingPlansForServiceOptions = DisablePricingPlansForServiceOptions;
  const bookingsServicesV2Service_universal_d_setCustomSlug: typeof setCustomSlug;
  const bookingsServicesV2Service_universal_d_validateSlug: typeof validateSlug;
  type bookingsServicesV2Service_universal_d_ValidateSlugOptions = ValidateSlugOptions;
  const bookingsServicesV2Service_universal_d_cloneService: typeof cloneService;
  type bookingsServicesV2Service_universal_d_CloneServiceOptions = CloneServiceOptions;
  namespace bookingsServicesV2Service_universal_d {
    export {
      bookingsServicesV2Service_universal_d_Service as Service,
      bookingsServicesV2Service_universal_d_ServiceType as ServiceType,
      bookingsServicesV2Service_universal_d_Media as Media,
      MediaItem$1 as MediaItem,
      bookingsServicesV2Service_universal_d_MediaItemItemOneOf as MediaItemItemOneOf,
      bookingsServicesV2Service_universal_d_V2Category as V2Category,
      bookingsServicesV2Service_universal_d_Form as Form,
      bookingsServicesV2Service_universal_d_FormSettings as FormSettings,
      bookingsServicesV2Service_universal_d_Payment as Payment,
      bookingsServicesV2Service_universal_d_PaymentRateOneOf as PaymentRateOneOf,
      bookingsServicesV2Service_universal_d_RateType as RateType,
      bookingsServicesV2Service_universal_d_FixedPayment as FixedPayment,
      bookingsServicesV2Service_universal_d_CommonMoney as CommonMoney,
      bookingsServicesV2Service_universal_d_CustomPayment as CustomPayment,
      bookingsServicesV2Service_universal_d_VariedPayment as VariedPayment,
      bookingsServicesV2Service_universal_d_PaymentOptions as PaymentOptions,
      bookingsServicesV2Service_universal_d_OnlineBooking as OnlineBooking,
      bookingsServicesV2Service_universal_d_Conferencing as Conferencing,
      Location$3 as Location,
      bookingsServicesV2Service_universal_d_LocationOptionsOneOf as LocationOptionsOneOf,
      LocationType$3 as LocationType,
      Address$4 as Address,
      AddressStreetOneOf$3 as AddressStreetOneOf,
      StreetAddress$3 as StreetAddress,
      AddressLocation$3 as AddressLocation,
      bookingsServicesV2Service_universal_d_BusinessLocationOptions as BusinessLocationOptions,
      bookingsServicesV2Service_universal_d_CustomLocationOptions as CustomLocationOptions,
      BookingPolicy$1 as BookingPolicy,
      PolicyDescription$1 as PolicyDescription,
      LimitEarlyBookingPolicy$1 as LimitEarlyBookingPolicy,
      LimitLateBookingPolicy$1 as LimitLateBookingPolicy,
      BookAfterStartPolicy$1 as BookAfterStartPolicy,
      CancellationPolicy$1 as CancellationPolicy,
      ReschedulePolicy$1 as ReschedulePolicy,
      WaitlistPolicy$1 as WaitlistPolicy,
      ParticipantsPolicy$1 as ParticipantsPolicy,
      ResourcesPolicy$1 as ResourcesPolicy,
      CancellationFeePolicy$1 as CancellationFeePolicy,
      CancellationWindow$1 as CancellationWindow,
      CancellationWindowFeeOneOf$1 as CancellationWindowFeeOneOf,
      SaveCreditCardPolicy$1 as SaveCreditCardPolicy,
      Schedule$1 as Schedule,
      AvailabilityConstraints$1 as AvailabilityConstraints,
      StaffMember$1 as StaffMember,
      bookingsServicesV2Service_universal_d_StaffMediaItem as StaffMediaItem,
      bookingsServicesV2Service_universal_d_StaffMediaItemItemOneOf as StaffMediaItemItemOneOf,
      bookingsServicesV2Service_universal_d_StaffMemberDetails as StaffMemberDetails,
      bookingsServicesV2Service_universal_d_ResourceGroup as ResourceGroup,
      bookingsServicesV2Service_universal_d_ResourceIds as ResourceIds,
      bookingsServicesV2Service_universal_d_ServiceResource as ServiceResource,
      bookingsServicesV2Service_universal_d_ServiceResourceSelectionOneOf as ServiceResourceSelectionOneOf,
      bookingsServicesV2Service_universal_d_ResourceType as ResourceType,
      bookingsServicesV2Service_universal_d_Slug as Slug,
      bookingsServicesV2Service_universal_d_URLs as URLs,
      ExtendedFields$4 as ExtendedFields,
      bookingsServicesV2Service_universal_d_SeoSchema as SeoSchema,
      bookingsServicesV2Service_universal_d_Keyword as Keyword,
      bookingsServicesV2Service_universal_d_Tag as Tag,
      bookingsServicesV2Service_universal_d_Settings as Settings,
      bookingsServicesV2Service_universal_d_ReindexMessage as ReindexMessage,
      bookingsServicesV2Service_universal_d_ReindexMessageActionOneOf as ReindexMessageActionOneOf,
      bookingsServicesV2Service_universal_d_Upsert as Upsert,
      bookingsServicesV2Service_universal_d_Delete as Delete,
      bookingsServicesV2Service_universal_d_Schema as Schema,
      bookingsServicesV2Service_universal_d_SetCustomSlugEvent as SetCustomSlugEvent,
      bookingsServicesV2Service_universal_d_ServicesUrlsChanged as ServicesUrlsChanged,
      DomainEvent$4 as DomainEvent,
      DomainEventBodyOneOf$4 as DomainEventBodyOneOf,
      EntityCreatedEvent$4 as EntityCreatedEvent,
      RestoreInfo$4 as RestoreInfo,
      EntityUpdatedEvent$4 as EntityUpdatedEvent,
      EntityDeletedEvent$4 as EntityDeletedEvent,
      ActionEvent$4 as ActionEvent,
      MessageEnvelope$4 as MessageEnvelope,
      IdentificationData$5 as IdentificationData,
      IdentificationDataIdOneOf$5 as IdentificationDataIdOneOf,
      WebhookIdentityType$4 as WebhookIdentityType,
      bookingsServicesV2Service_universal_d_CreateServiceRequest as CreateServiceRequest,
      bookingsServicesV2Service_universal_d_CreateServiceResponse as CreateServiceResponse,
      bookingsServicesV2Service_universal_d_BulkCreateServicesRequest as BulkCreateServicesRequest,
      bookingsServicesV2Service_universal_d_BulkCreateServicesResponse as BulkCreateServicesResponse,
      bookingsServicesV2Service_universal_d_BulkServiceResult as BulkServiceResult,
      ItemMetadata$2 as ItemMetadata,
      ApplicationError$2 as ApplicationError,
      BulkActionMetadata$2 as BulkActionMetadata,
      bookingsServicesV2Service_universal_d_GetServiceRequest as GetServiceRequest,
      RequestedFields$1 as RequestedFields,
      bookingsServicesV2Service_universal_d_GetServiceResponse as GetServiceResponse,
      bookingsServicesV2Service_universal_d_GetServiceAvailabilityConstraintsRequest as GetServiceAvailabilityConstraintsRequest,
      bookingsServicesV2Service_universal_d_GetServiceAvailabilityConstraintsResponse as GetServiceAvailabilityConstraintsResponse,
      bookingsServicesV2Service_universal_d_ServiceAvailabilityConstraints as ServiceAvailabilityConstraints,
      bookingsServicesV2Service_universal_d_V1SplitInterval as V1SplitInterval,
      bookingsServicesV2Service_universal_d_UpdateServiceRequest as UpdateServiceRequest,
      bookingsServicesV2Service_universal_d_UpdateServiceResponse as UpdateServiceResponse,
      bookingsServicesV2Service_universal_d_BulkUpdateServicesRequest as BulkUpdateServicesRequest,
      bookingsServicesV2Service_universal_d_MaskedService as MaskedService,
      bookingsServicesV2Service_universal_d_BulkUpdateServicesResponse as BulkUpdateServicesResponse,
      bookingsServicesV2Service_universal_d_BulkUpdateServicesByFilterRequest as BulkUpdateServicesByFilterRequest,
      bookingsServicesV2Service_universal_d_BulkUpdateServicesByFilterResponse as BulkUpdateServicesByFilterResponse,
      bookingsServicesV2Service_universal_d_DeleteServiceRequest as DeleteServiceRequest,
      ParticipantNotification$4 as ParticipantNotification,
      bookingsServicesV2Service_universal_d_DeleteServiceResponse as DeleteServiceResponse,
      bookingsServicesV2Service_universal_d_BulkDeleteServicesRequest as BulkDeleteServicesRequest,
      bookingsServicesV2Service_universal_d_BulkDeleteServicesResponse as BulkDeleteServicesResponse,
      bookingsServicesV2Service_universal_d_BulkDeleteServicesByFilterRequest as BulkDeleteServicesByFilterRequest,
      bookingsServicesV2Service_universal_d_BulkDeleteServicesByFilterResponse as BulkDeleteServicesByFilterResponse,
      bookingsServicesV2Service_universal_d_QueryServicesRequest as QueryServicesRequest,
      QueryV2$2 as QueryV2,
      QueryV2PagingMethodOneOf$2 as QueryV2PagingMethodOneOf,
      Sorting$4 as Sorting,
      SortOrder$4 as SortOrder,
      Paging$2 as Paging,
      CursorPaging$4 as CursorPaging,
      bookingsServicesV2Service_universal_d_QueryServicesResponse as QueryServicesResponse,
      PagingMetadataV2$1 as PagingMetadataV2,
      Cursors$4 as Cursors,
      bookingsServicesV2Service_universal_d_SearchServicesRequest as SearchServicesRequest,
      CursorSearch$1 as CursorSearch,
      CursorSearchPagingMethodOneOf$1 as CursorSearchPagingMethodOneOf,
      bookingsServicesV2Service_universal_d_Aggregation as Aggregation,
      bookingsServicesV2Service_universal_d_AggregationKindOneOf as AggregationKindOneOf,
      bookingsServicesV2Service_universal_d_RangeBucket as RangeBucket,
      bookingsServicesV2Service_universal_d_SortType as SortType,
      bookingsServicesV2Service_universal_d_SortDirection as SortDirection,
      bookingsServicesV2Service_universal_d_MissingValues as MissingValues,
      bookingsServicesV2Service_universal_d_IncludeMissingValuesOptions as IncludeMissingValuesOptions,
      ScalarType$1 as ScalarType,
      bookingsServicesV2Service_universal_d_ValueAggregation as ValueAggregation,
      bookingsServicesV2Service_universal_d_ValueAggregationOptionsOneOf as ValueAggregationOptionsOneOf,
      bookingsServicesV2Service_universal_d_NestedAggregationType as NestedAggregationType,
      bookingsServicesV2Service_universal_d_RangeAggregation as RangeAggregation,
      bookingsServicesV2Service_universal_d_ScalarAggregation as ScalarAggregation,
      bookingsServicesV2Service_universal_d_DateHistogramAggregation as DateHistogramAggregation,
      bookingsServicesV2Service_universal_d_DateHistogramAggregationInterval as DateHistogramAggregationInterval,
      bookingsServicesV2Service_universal_d_NestedAggregationItem as NestedAggregationItem,
      bookingsServicesV2Service_universal_d_NestedAggregationItemKindOneOf as NestedAggregationItemKindOneOf,
      AggregationType$1 as AggregationType,
      bookingsServicesV2Service_universal_d_NestedAggregation as NestedAggregation,
      bookingsServicesV2Service_universal_d_GroupByAggregation as GroupByAggregation,
      bookingsServicesV2Service_universal_d_GroupByAggregationKindOneOf as GroupByAggregationKindOneOf,
      SearchDetails$1 as SearchDetails,
      Mode$1 as Mode,
      bookingsServicesV2Service_universal_d_SearchServicesResponse as SearchServicesResponse,
      CursorPagingMetadata$3 as CursorPagingMetadata,
      AggregationData$1 as AggregationData,
      ValueAggregationResult$1 as ValueAggregationResult,
      RangeAggregationResult$1 as RangeAggregationResult,
      NestedAggregationResults$1 as NestedAggregationResults,
      NestedAggregationResultsResultOneOf$1 as NestedAggregationResultsResultOneOf,
      ValueResults$1 as ValueResults,
      RangeResults$1 as RangeResults,
      ScalarResult$1 as ScalarResult,
      NestedValueAggregationResult$1 as NestedValueAggregationResult,
      bookingsServicesV2Service_universal_d_ValueResult as ValueResult,
      bookingsServicesV2Service_universal_d_RangeResult as RangeResult,
      bookingsServicesV2Service_universal_d_NestedResultsScalarResult as NestedResultsScalarResult,
      bookingsServicesV2Service_universal_d_NestedResultValue as NestedResultValue,
      bookingsServicesV2Service_universal_d_NestedResultValueResultOneOf as NestedResultValueResultOneOf,
      bookingsServicesV2Service_universal_d_Results as Results,
      bookingsServicesV2Service_universal_d_DateHistogramResult as DateHistogramResult,
      GroupByValueResults$1 as GroupByValueResults,
      bookingsServicesV2Service_universal_d_DateHistogramResults as DateHistogramResults,
      bookingsServicesV2Service_universal_d_NestedResults as NestedResults,
      AggregationResults$1 as AggregationResults,
      AggregationResultsResultOneOf$1 as AggregationResultsResultOneOf,
      bookingsServicesV2Service_universal_d_QueryPoliciesRequest as QueryPoliciesRequest,
      CursorQuery$2 as CursorQuery,
      CursorQueryPagingMethodOneOf$2 as CursorQueryPagingMethodOneOf,
      bookingsServicesV2Service_universal_d_QueryPoliciesResponse as QueryPoliciesResponse,
      bookingsServicesV2Service_universal_d_BookingPolicyWithServices as BookingPolicyWithServices,
      bookingsServicesV2Service_universal_d_CountServicesRequest as CountServicesRequest,
      bookingsServicesV2Service_universal_d_CountServicesResponse as CountServicesResponse,
      bookingsServicesV2Service_universal_d_QueryLocationsRequest as QueryLocationsRequest,
      bookingsServicesV2Service_universal_d_QueryLocationsFilter as QueryLocationsFilter,
      bookingsServicesV2Service_universal_d_QueryLocationsResponse as QueryLocationsResponse,
      bookingsServicesV2Service_universal_d_BusinessLocations as BusinessLocations,
      bookingsServicesV2Service_universal_d_CustomLocations as CustomLocations,
      bookingsServicesV2Service_universal_d_CustomerLocations as CustomerLocations,
      bookingsServicesV2Service_universal_d_QueryCategoriesRequest as QueryCategoriesRequest,
      bookingsServicesV2Service_universal_d_QueryCategoriesFilter as QueryCategoriesFilter,
      bookingsServicesV2Service_universal_d_QueryCategoriesResponse as QueryCategoriesResponse,
      bookingsServicesV2Service_universal_d_QueryServicesMultiLanguageRequest as QueryServicesMultiLanguageRequest,
      bookingsServicesV2Service_universal_d_QueryServicesMultiLanguageResponse as QueryServicesMultiLanguageResponse,
      bookingsServicesV2Service_universal_d_SetServiceLocationsRequest as SetServiceLocationsRequest,
      bookingsServicesV2Service_universal_d_RemovedLocationSessionsAction as RemovedLocationSessionsAction,
      bookingsServicesV2Service_universal_d_RemovedLocationSessionsActionActionOptionsOneOf as RemovedLocationSessionsActionActionOptionsOneOf,
      bookingsServicesV2Service_universal_d_Action as Action,
      bookingsServicesV2Service_universal_d_MoveToNewLocationsOptions as MoveToNewLocationsOptions,
      bookingsServicesV2Service_universal_d_SetServiceLocationsResponse as SetServiceLocationsResponse,
      bookingsServicesV2Service_universal_d_EnablePricingPlansForServiceRequest as EnablePricingPlansForServiceRequest,
      bookingsServicesV2Service_universal_d_EnablePricingPlansForServiceResponse as EnablePricingPlansForServiceResponse,
      bookingsServicesV2Service_universal_d_InvalidPricingPlan as InvalidPricingPlan,
      bookingsServicesV2Service_universal_d_DisablePricingPlansForServiceRequest as DisablePricingPlansForServiceRequest,
      bookingsServicesV2Service_universal_d_DisablePricingPlansForServiceResponse as DisablePricingPlansForServiceResponse,
      bookingsServicesV2Service_universal_d_SetCustomSlugRequest as SetCustomSlugRequest,
      bookingsServicesV2Service_universal_d_SetCustomSlugResponse as SetCustomSlugResponse,
      bookingsServicesV2Service_universal_d_ValidateSlugRequest as ValidateSlugRequest,
      bookingsServicesV2Service_universal_d_ValidateSlugResponse as ValidateSlugResponse,
      bookingsServicesV2Service_universal_d_InvalidSlugError as InvalidSlugError,
      bookingsServicesV2Service_universal_d_CloneServiceRequest as CloneServiceRequest,
      bookingsServicesV2Service_universal_d_CloneServiceResponse as CloneServiceResponse,
      bookingsServicesV2Service_universal_d_CloneErrors as CloneErrors,
      bookingsServicesV2Service_universal_d_CategoryNotification as CategoryNotification,
      bookingsServicesV2Service_universal_d_Category as Category,
      Status$1 as Status,
      bookingsServicesV2Service_universal_d_Event as Event,
      Empty$2 as Empty,
      ScheduleNotification$1 as ScheduleNotification,
      ScheduleNotificationEventOneOf$1 as ScheduleNotificationEventOneOf,
      ScheduleCreated$1 as ScheduleCreated,
      bookingsServicesV2Service_universal_d_V1Schedule as V1Schedule,
      RecurringInterval$1 as RecurringInterval,
      Interval$1 as Interval,
      Day$1 as Day,
      Frequency$1 as Frequency,
      LinkedSchedule$1 as LinkedSchedule,
      Transparency$1 as Transparency,
      RecurringIntervalType$1 as RecurringIntervalType,
      bookingsServicesV2Service_universal_d_V1Location as V1Location,
      LocationLocationType$1 as LocationLocationType,
      bookingsServicesV2Service_universal_d_CommonAddress as CommonAddress,
      bookingsServicesV2Service_universal_d_CommonAddressStreetOneOf as CommonAddressStreetOneOf,
      bookingsServicesV2Service_universal_d_CommonStreetAddress as CommonStreetAddress,
      bookingsServicesV2Service_universal_d_CommonAddressLocation as CommonAddressLocation,
      Subdivision$3 as Subdivision,
      LocationsLocation$1 as LocationsLocation,
      LocationStatus$1 as LocationStatus,
      LocationsLocationType$1 as LocationsLocationType,
      LocationsAddress$1 as LocationsAddress,
      LocationsStreetAddress$1 as LocationsStreetAddress,
      LocationsAddressLocation$1 as LocationsAddressLocation,
      BusinessSchedule$2 as BusinessSchedule,
      TimePeriod$2 as TimePeriod,
      DayOfWeek$2 as DayOfWeek,
      SpecialHourPeriod$2 as SpecialHourPeriod,
      Rate$1 as Rate,
      Price$1 as Price,
      Availability$1 as Availability,
      bookingsServicesV2Service_universal_d_V1AvailabilityConstraints as V1AvailabilityConstraints,
      SplitInterval$1 as SplitInterval,
      Participant$1 as Participant,
      ApprovalStatus$1 as ApprovalStatus,
      ExternalCalendarOverrides$1 as ExternalCalendarOverrides,
      ScheduleStatus$1 as ScheduleStatus,
      Version$1 as Version,
      ConferenceProvider$1 as ConferenceProvider,
      CalendarConference$1 as CalendarConference,
      ConferenceType$1 as ConferenceType,
      ScheduleUpdated$1 as ScheduleUpdated,
      RecurringSessionsUpdated$1 as RecurringSessionsUpdated,
      Session$1 as Session,
      CalendarDateTime$1 as CalendarDateTime,
      LocalDateTime$1 as LocalDateTime,
      ExternalCalendarInfo$1 as ExternalCalendarInfo,
      CalendarType$1 as CalendarType,
      bookingsServicesV2Service_universal_d_SessionStatus as SessionStatus,
      SessionType$1 as SessionType,
      SessionVersion$1 as SessionVersion,
      bookingsServicesV2Service_universal_d_V1ParticipantNotification as V1ParticipantNotification,
      ScheduleCancelled$1 as ScheduleCancelled,
      SessionCreated$1 as SessionCreated,
      SessionUpdated$1 as SessionUpdated,
      SessionCancelled$1 as SessionCancelled,
      AvailabilityPolicyUpdated$1 as AvailabilityPolicyUpdated,
      AvailabilityPolicy$1 as AvailabilityPolicy,
      IntervalSplit$1 as IntervalSplit,
      RecurringSessionSplit$1 as RecurringSessionSplit,
      ScheduleUnassignedFromUser$1 as ScheduleUnassignedFromUser,
      MultipleSessionsCreated$1 as MultipleSessionsCreated,
      ScheduleWithSessions$1 as ScheduleWithSessions,
      SitePropertiesOnScheduleCreation$1 as SitePropertiesOnScheduleCreation,
      MigrationEvent$1 as MigrationEvent,
      MigrationData$1 as MigrationData,
      StaffData$1 as StaffData,
      bookingsServicesV2Service_universal_d_ResourceNotification as ResourceNotification,
      Resource$1 as Resource,
      bookingsServicesV2Service_universal_d_ResourceStatus as ResourceStatus,
      bookingsServicesV2Service_universal_d_BusinessLocation as BusinessLocation,
      bookingsServicesV2Service_universal_d_ResourceNotificationEvent as ResourceNotificationEvent,
      bookingsServicesV2Service_universal_d_BenefitNotification as BenefitNotification,
      bookingsServicesV2Service_universal_d_Benefit as Benefit,
      bookingsServicesV2Service_universal_d_EntryPass as EntryPass,
      bookingsServicesV2Service_universal_d_Discount as Discount,
      bookingsServicesV2Service_universal_d_DiscountDiscountOneOf as DiscountDiscountOneOf,
      bookingsServicesV2Service_universal_d_BenefitType as BenefitType,
      bookingsServicesV2Service_universal_d_Behavior as Behavior,
      bookingsServicesV2Service_universal_d_BehaviorBehaviorOneOf as BehaviorBehaviorOneOf,
      bookingsServicesV2Service_universal_d_BenefitNotificationEvent as BenefitNotificationEvent,
      bookingsServicesV2Service_universal_d_UserDomainInfoChangedEvent as UserDomainInfoChangedEvent,
      bookingsServicesV2Service_universal_d_CrudType as CrudType,
      bookingsServicesV2Service_universal_d_HtmlSitePublished as HtmlSitePublished,
      bookingsServicesV2Service_universal_d_Page as Page,
      SitePropertiesNotification$1 as SitePropertiesNotification,
      SitePropertiesEvent$1 as SitePropertiesEvent,
      Properties$1 as Properties,
      Categories$1 as Categories,
      Locale$1 as Locale,
      bookingsServicesV2Service_universal_d_V4Address as V4Address,
      AddressHint$1 as AddressHint,
      PlacementType$1 as PlacementType,
      GeoCoordinates$1 as GeoCoordinates,
      Multilingual$1 as Multilingual,
      SupportedLanguage$1 as SupportedLanguage,
      ResolutionMethod$1 as ResolutionMethod,
      ConsentPolicy$1 as ConsentPolicy,
      Translation$1 as Translation,
      ChangeContext$1 as ChangeContext,
      ChangeContextPayloadOneOf$1 as ChangeContextPayloadOneOf,
      PropertiesChange$1 as PropertiesChange,
      SiteCreated$2 as SiteCreated,
      SiteCloned$1 as SiteCloned,
      bookingsServicesV2Service_universal_d_MultiServiceEnabledNotification as MultiServiceEnabledNotification,
      bookingsServicesV2Service_universal_d_createService as createService,
      bookingsServicesV2Service_universal_d_bulkCreateServices as bulkCreateServices,
      bookingsServicesV2Service_universal_d_BulkCreateServicesOptions as BulkCreateServicesOptions,
      bookingsServicesV2Service_universal_d_getService as getService,
      bookingsServicesV2Service_universal_d_GetServiceOptions as GetServiceOptions,
      bookingsServicesV2Service_universal_d_getServiceAvailabilityConstraints as getServiceAvailabilityConstraints,
      bookingsServicesV2Service_universal_d_updateService as updateService,
      bookingsServicesV2Service_universal_d_UpdateService as UpdateService,
      bookingsServicesV2Service_universal_d_UpdateServiceOptions as UpdateServiceOptions,
      bookingsServicesV2Service_universal_d_bulkUpdateServices as bulkUpdateServices,
      bookingsServicesV2Service_universal_d_BulkUpdateServicesOptions as BulkUpdateServicesOptions,
      bookingsServicesV2Service_universal_d_bulkUpdateServicesByFilter as bulkUpdateServicesByFilter,
      bookingsServicesV2Service_universal_d_BulkUpdateServicesByFilterOptions as BulkUpdateServicesByFilterOptions,
      bookingsServicesV2Service_universal_d_deleteService as deleteService,
      bookingsServicesV2Service_universal_d_DeleteServiceOptions as DeleteServiceOptions,
      bookingsServicesV2Service_universal_d_bulkDeleteServices as bulkDeleteServices,
      bookingsServicesV2Service_universal_d_BulkDeleteServicesOptions as BulkDeleteServicesOptions,
      bookingsServicesV2Service_universal_d_bulkDeleteServicesByFilter as bulkDeleteServicesByFilter,
      bookingsServicesV2Service_universal_d_BulkDeleteServicesByFilterOptions as BulkDeleteServicesByFilterOptions,
      bookingsServicesV2Service_universal_d_queryServices as queryServices,
      bookingsServicesV2Service_universal_d_QueryServicesOptions as QueryServicesOptions,
      bookingsServicesV2Service_universal_d_ServicesQueryResult as ServicesQueryResult,
      bookingsServicesV2Service_universal_d_ServicesQueryBuilder as ServicesQueryBuilder,
      bookingsServicesV2Service_universal_d_searchServices as searchServices,
      bookingsServicesV2Service_universal_d_queryPolicies as queryPolicies,
      bookingsServicesV2Service_universal_d_countServices as countServices,
      bookingsServicesV2Service_universal_d_CountServicesOptions as CountServicesOptions,
      bookingsServicesV2Service_universal_d_queryLocations as queryLocations,
      bookingsServicesV2Service_universal_d_QueryLocationsOptions as QueryLocationsOptions,
      bookingsServicesV2Service_universal_d_queryCategories as queryCategories,
      bookingsServicesV2Service_universal_d_QueryCategoriesOptions as QueryCategoriesOptions,
      bookingsServicesV2Service_universal_d_queryServicesMultiLanguage as queryServicesMultiLanguage,
      bookingsServicesV2Service_universal_d_QueryServicesMultiLanguageOptions as QueryServicesMultiLanguageOptions,
      bookingsServicesV2Service_universal_d_setServiceLocations as setServiceLocations,
      bookingsServicesV2Service_universal_d_SetServiceLocationsOptions as SetServiceLocationsOptions,
      bookingsServicesV2Service_universal_d_enablePricingPlansForService as enablePricingPlansForService,
      bookingsServicesV2Service_universal_d_disablePricingPlansForService as disablePricingPlansForService,
      bookingsServicesV2Service_universal_d_DisablePricingPlansForServiceOptions as DisablePricingPlansForServiceOptions,
      bookingsServicesV2Service_universal_d_setCustomSlug as setCustomSlug,
      bookingsServicesV2Service_universal_d_validateSlug as validateSlug,
      bookingsServicesV2Service_universal_d_ValidateSlugOptions as ValidateSlugOptions,
      bookingsServicesV2Service_universal_d_cloneService as cloneService,
      bookingsServicesV2Service_universal_d_CloneServiceOptions as CloneServiceOptions,
    };
  }
  
  /** StaffMember is the main entity of Bookings StaffMembers. used to manage staff providing services */
  interface StaffMember {
      /**
       * Staff member's ID
       * @readonly
       */
      _id?: string | null;
      /** Staff member's name. */
      name?: string | null;
      /** Staff member's email address. */
      email?: string | null;
      /** Staff member's phone number. */
      phone?: string | null;
      /** Description, For example: "The best masseuse in all of the land" */
      description?: string | null;
      /** The media of the staff. */
      mainMedia?: MediaItem;
      /**
       * The related calendar resource id, same as `resource.id`
       * @readonly
       */
      resourceId?: string | null;
      /**
       * The related calendar resource
       * @readonly
       */
      resource?: Resource;
      /**
       * The identity of the Wix user associated with the staff member.
       *
       * To connect a staff member to a Wix user, use `ConnectStaffMemberToUser`.
       * To disconnect a staff member from a Wix user, use `DisconnectStaffMemberFromUser`.
       * @readonly
       */
      associatedWixIdentity?: AssociatedWixIdentity;
      /**
       * A staff member conferencing providers.
       * Field is deprecated, use associated_conferencing_accounts instead.
       * @internal
       * @readonly
       * @deprecated
       * @replacedBy associated_conferencing_accounts
       * @targetRemovalDate 2024-10-01
       */
      associatedConferencingProviders?: AssociatedConferencingProviders;
      /**
       * Conferencing accounts used to create meetings links with this staff member.
       * @internal
       * @readonly
       */
      associatedConferencingAccounts?: AssociatedConferencingAccounts;
      /**
       * `true` - if staff was auto created default staff.
       * @internal
       * @readonly
       */
      default?: boolean;
      /**
       * Revision number, which increments by 1 each time the staff member is updated.
       * To prevent conflicting changes,
       * the current revision must be passed when updating the staff member.
       * @readonly
       */
      revision?: string | null;
      /**
       * Represents the time this staff member was created.
       * @readonly
       */
      _createdDate?: Date | null;
      /**
       * Represents the time this staff member was last updated
       * @readonly
       */
      _updatedDate?: Date | null;
      /** Extensions enabling users to save custom data related to the staff member. */
      extendedFields?: ExtendedFields$3;
  }
  interface MediaItem extends MediaItemMediaOneOf {
      /** Staff members main image. */
      image?: string;
  }
  /** @oneof */
  interface MediaItemMediaOneOf {
      /** Staff members main image. */
      image?: string;
  }
  interface Resource {
      /** The related calendar resource Id, same as `resourceId`. */
      _id?: string | null;
      /** The working hours schedules of the staff member, used to determine the availability of the staff member. Currently only one is supported. */
      workingHoursSchedules?: WorkingHoursSchedule[];
      /** The schedule containing the sessions in which this resource is booked. */
      eventsSchedule?: EventSchedule;
      /** `true` if the staff member uses the default business working hours schedule. Returns `false` otherwise. */
      usesDefaultWorkingHours?: boolean;
  }
  interface WorkingHoursSchedule {
      /** The related schedule ID */
      _id?: string | null;
      /** `true` if it is a shared schedule (For example, the default business working hours schedule), `false` or empty if this is a custom schedule specific to the resource. */
      shared?: boolean;
  }
  interface EventSchedule {
      /** The related schedule ID */
      _id?: string | null;
  }
  /** A staff member resource can be associated with a Wix user via assignment of a permissions role in the business manager. */
  interface AssociatedWixIdentity {
      /** Users identification data, returned only when the staff member is connected to a Wix user */
      identificationData?: IdentificationData$4;
      /**
       * Staff members connection status to the user.
       * @readonly
       * @deprecated Staff members connection status to the user.
       * @replacedBy connection_state
       * @targetRemovalDate 2024-12-01
       */
      connectionStatus?: AssociatedWixIdentityConnectionStatusEnumConnectionStatus;
      /**
       * The connection state between a staff member and a Wix user.
       * Returned only when `ASSOCIATED_IDENTITY_STATUS` is provided in the `fields` parameter.
       * @readonly
       */
      connectionState?: ConnectionState;
  }
  interface IdentificationData$4 extends IdentificationDataIdOneOf$4 {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
      /** ID of of a contact in the site's [CRM by Ascend](https://www.wix.com/ascend/crm) system. */
      contactId?: string | null;
      /**
       * @internal
       * @readonly
       */
      identityType?: IdentityType$2;
  }
  /** @oneof */
  interface IdentificationDataIdOneOf$4 {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
  }
  enum IdentityType$2 {
      UNKNOWN = "UNKNOWN",
      ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
      MEMBER = "MEMBER",
      WIX_USER = "WIX_USER",
      APP = "APP"
  }
  enum AssociatedWixIdentityConnectionStatusEnumConnectionStatus {
      /** User connection status is unknown. */
      UNKNOWN = "UNKNOWN",
      /** User is connected to the staff member. */
      CONNECTED = "CONNECTED",
      /** User connection is pending. */
      PENDING = "PENDING",
      /** Pending connections invite has expired. */
      EXPIRED = "EXPIRED",
      /** User is disconnected from the staff member. */
      DISCONNECTED = "DISCONNECTED"
  }
  interface ConnectionState {
      /** @readonly */
      status?: ConnectionStateConnectionState;
  }
  enum ConnectionStateConnectionState {
      /** User connection status is unknown. Only returned when conditional field for status is not selected. */
      UNKNOWN = "UNKNOWN",
      /** User is connected to the staff member. */
      CONNECTED = "CONNECTED",
      /** User connection is pending. */
      PENDING = "PENDING",
      /** Pending connections invite has expired. */
      EXPIRED = "EXPIRED",
      /** User is disconnected from the staff member. */
      DISCONNECTED = "DISCONNECTED"
  }
  interface AssociatedConferencingProviders {
      /** Conferencing accounts that are connected to this staff. */
      items?: AssociatedConferencingProvider[];
  }
  interface AssociatedConferencingProvider {
      /** Conferencing provider id, e.g. Zoom integration identifier. */
      _id?: string;
      /** Provider name, e.g. Zoom. */
      name?: string;
      /** Connection status. */
      connectionStatus?: ConnectionStatus;
      /** Conferencing account email. Might not match staff email. */
      accountEmail?: string | null;
  }
  enum ConnectionStatus {
      UNKNOWN = "UNKNOWN",
      /** Provider is connected to site and user is authenticated. */
      CONNECTED = "CONNECTED",
      /** Provider is not connected to site or user is not authenticated. */
      DISCONNECTED = "DISCONNECTED"
  }
  interface AssociatedConferencingAccounts {
      /** Conferencing accounts that are connected to this staff. */
      items?: AssociatedConferencingAccount[];
  }
  interface AssociatedConferencingAccount extends AssociatedConferencingAccountAccountOneOf {
      /**
       * Conferencing for this staff member is configured via an external provider.
       * For example, Zoom integration generating a link for sessions with the staff member.
       */
      providerAccount?: AssociatedConferencingProvider;
      /**
       * Conferencing for this staff member is configured via a custom conference link.
       * Custom conference link details.
       */
      customAccount?: CustomConferenceAccount;
  }
  /** @oneof */
  interface AssociatedConferencingAccountAccountOneOf {
      /**
       * Conferencing for this staff member is configured via an external provider.
       * For example, Zoom integration generating a link for sessions with the staff member.
       */
      providerAccount?: AssociatedConferencingProvider;
      /**
       * Conferencing for this staff member is configured via a custom conference link.
       * Custom conference link details.
       */
      customAccount?: CustomConferenceAccount;
  }
  interface CustomConferenceAccount {
      /** Conferencing url. For example, a Google meet link. */
      url?: string | null;
      /** Optional password that protects the conferencing link. */
      password?: string | null;
      /** Optional description of the conference link. */
      description?: string | null;
  }
  interface ExtendedFields$3 {
      /**
       * Extended field data. Each key corresponds to the namespace of the app that created the extended fields.
       * The value of each key is structured according to the schema defined when the extended fields were configured.
       *
       * You can only access fields for which you have the appropriate permissions.
       *
       * Learn more about [extended fields](https://dev.wix.com/docs/rest/articles/getting-started/extended-fields).
       */
      namespaces?: Record<string, Record<string, any>>;
  }
  interface CreateStaffMemberRequest {
      /** Staff Member to be created. */
      staffMember: StaffMember;
      /** Conditional fields to return. */
      fields?: RequestedFields[];
  }
  enum RequestedFields {
      UNKNOWN_REQUESTED_FIELD = "UNKNOWN_REQUESTED_FIELD",
      /**
       * Stating this value in the `fields` parameter would
       * return the resource details, including the resource's schedule ids in the `resource` field.
       */
      RESOURCE_DETAILS = "RESOURCE_DETAILS",
      /**
       * Stating this value in the `fields` parameter would
       * return the conference accounts used to create conference links, in the `associatedConferencingProviders` property.
       */
      ASSOCIATED_CONFERENCING_PROVIDERS = "ASSOCIATED_CONFERENCING_PROVIDERS",
      /**
       * Stating this value in the `fields` parameter would
       * return `associatedWixIdentity.connectionState` which contains the connection status of a staff member to a Wix user.
       */
      ASSOCIATED_IDENTITY_STATUS = "ASSOCIATED_IDENTITY_STATUS",
      /**
       * Stating this value in the `fields` parameter would
       * return the conference accounts used to create conference links, in the `associatedConferencingAccounts` property.
       */
      ASSOCIATED_CONFERENCING_ACCOUNTS = "ASSOCIATED_CONFERENCING_ACCOUNTS"
  }
  interface CreateStaffMemberResponse {
      /** The created staff member. */
      staffMember?: StaffMember;
  }
  /**
   * This message is used to notify that a staff member has been fully created. For now it is only needed for
   * producing the correct Resources V1 events. A decision will be made later whether to keep it or not.
   */
  interface StaffMemberFullyCreated {
      /** the staff member that */
      staffMember?: StaffMember;
  }
  interface GetStaffMemberRequest {
      /** ID of the staff member to retrieve. */
      staffMemberId: string;
      /** Conditional fields to return. */
      fields?: RequestedFields[];
  }
  interface GetStaffMemberResponse {
      /** The retrieved StaffMember. */
      staffMember?: StaffMember;
  }
  interface GetDeletedStaffMemberRequest {
      /** Id of the staff member to retrieve */
      staffMemberId: string;
      /** Conditional fields to return. */
      fields?: RequestedFields[];
  }
  interface GetDeletedStaffMemberResponse {
      /** The retrieved staff member. */
      staffMember?: StaffMember;
  }
  interface ListDeletedStaffMembersRequest {
      /** The Ids of the staff members to retrieve. If omitted all deleted staff members will be retrieved paginated. */
      staffMemberIds?: string[];
      /** Paging parameter, enabling to pass a limit and a cursor. */
      paging?: CursorPaging$3;
      /** Conditional fields to return. */
      fields?: RequestedFields[];
  }
  interface CursorPaging$3 {
      /** Number of items to load. */
      limit?: number | null;
      /**
       * Pointer to the next or previous page in the list of results.
       *
       * You can get the relevant cursor token
       * from the `pagingMetadata` object in the previous call's response.
       * Not relevant for the first request.
       */
      cursor?: string | null;
  }
  interface ListDeletedStaffMembersResponse {
      /** The retrieved staff members. */
      staffMembers?: StaffMember[];
      /** Paging metadata */
      pagingMetadata?: CursorPagingMetadata$2;
  }
  interface CursorPagingMetadata$2 {
      /** Number of items returned in the response. */
      count?: number | null;
      /** Offset that was requested. */
      cursors?: Cursors$3;
      /**
       * Indicates if there are more results after the current page.
       * If `true`, another page of results can be retrieved.
       * If `false`, this is the last page.
       */
      hasNext?: boolean | null;
  }
  interface Cursors$3 {
      /** Cursor pointing to next page in the list of results. */
      next?: string | null;
      /** Cursor pointing to previous page in the list of results. */
      prev?: string | null;
  }
  interface RemoveStaffMemberFromTrashBinRequest {
      /** Id of the staff member to remove from the trash bin */
      staffMemberId: string;
  }
  interface RemoveStaffMemberFromTrashBinResponse {
  }
  interface RestoreStaffMemberFromTrashBinRequest {
      /** Id of the staff member to restore from the trash bin */
      staffMemberId: string;
      /** Conditional fields to return. */
      fields?: RequestedFields[];
  }
  interface RestoreStaffMemberFromTrashBinResponse {
      /** The restored staff member. */
      staffMember?: StaffMember;
  }
  interface UpdateStaffMemberRequest {
      /** Staff member to update. [Partial */
      staffMember: StaffMember;
      /**
       * updates](https://dev.wix.com/api/rest/wix-bookings/bookings/patch-endpoints-and-field-masks-in-update-requests)
       * are supported.
       * @internal
       */
      fieldMask?: string[];
      /** Conditional fields to return. */
      fields?: RequestedFields[];
  }
  interface UpdateStaffMemberResponse {
      /** The updated staff member. */
      staffMember?: StaffMember;
  }
  interface DeleteStaffMemberRequest {
      /** Id of the staff member to delete. */
      staffMemberId: string;
  }
  interface DeleteStaffMemberResponse {
  }
  interface StaffMemberDisconnectedFromUser {
      /** The staff member entity after disconnecting it from a user. */
      staffMember?: StaffMember;
  }
  interface QueryStaffMembersRequest {
      /** WQL expression. */
      query?: CursorQuery$1;
      /** Conditional fields to return. */
      fields?: RequestedFields[];
  }
  interface CursorQuery$1 extends CursorQueryPagingMethodOneOf$1 {
      /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
      cursorPaging?: CursorPaging$3;
      /**
       * Filter object in the following format:
       * `"filter" : {
       * "fieldName1": "value1",
       * "fieldName2":{"$operator":"value2"}
       * }`
       * Example of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`, `$contains`
       */
      filter?: Record<string, any> | null;
      /**
       * Sort object in the following format:
       * `[{"fieldName":"sortField1","order":"ASC"},{"fieldName":"sortField2","order":"DESC"}]`
       */
      sort?: Sorting$3[];
  }
  /** @oneof */
  interface CursorQueryPagingMethodOneOf$1 {
      /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
      cursorPaging?: CursorPaging$3;
  }
  interface Sorting$3 {
      /** Name of the field to sort by. */
      fieldName?: string;
      /** Sort order. */
      order?: SortOrder$3;
  }
  enum SortOrder$3 {
      ASC = "ASC",
      DESC = "DESC"
  }
  interface QueryStaffMembersResponse {
      /** The retrieved staff members. */
      staffMembers?: StaffMember[];
      /** Paging metadata */
      pagingMetadata?: CursorPagingMetadata$2;
  }
  interface QueryStaffMembersMultiLanguageRequest {
      /** WQL expression. */
      query: CursorQuery$1;
      /** Conditional fields to return. */
      fields?: RequestedFields[];
  }
  interface QueryStaffMembersMultiLanguageResponse {
      /** The retrieved staff members. */
      staffMembers?: StaffMember[];
      /** The retrieved staff members in the requested language according to the provided linguist aspect. */
      translatedStaffMembers?: StaffMember[];
      /** Paging metadata, including offset and count. */
      pagingMetadata?: CursorPagingMetadata$2;
  }
  interface CountStaffMembersRequest {
      /** The filters for performing the count. */
      filter?: Record<string, any> | null;
  }
  interface CountStaffMembersResponse {
      /** The number of staff members matching the given filter. */
      count?: number;
  }
  interface ConnectStaffMemberToUserRequest {
      /** Id of the staff member. The staff member to connect to a user. */
      staffMemberId: string;
      /** Email of the user to send invitation to. The staff existing email would be used if not provided. */
      email?: string | null;
      /** Conditional fields to return. */
      fields?: RequestedFields[];
  }
  interface ConnectStaffMemberToUserResponse {
      /** The updated staff member. After connecting to the user. */
      staffMember?: StaffMember;
  }
  interface StaffMemberConnectedToUser {
      /** The staff member entity after connecting it to a user. */
      staffMember?: StaffMember;
  }
  interface SearchStaffMembersRequest {
      /** WQL expression. */
      search: CursorSearch;
      /** Conditional fields to return. */
      fields?: RequestedFields[];
  }
  interface CursorSearch extends CursorSearchPagingMethodOneOf {
      /** Cursor pointing to page of results. Can't be used together with 'paging'. 'cursor_paging.cursor' can not be used together with 'filter' or 'sort' */
      cursorPaging?: CursorPaging$3;
      /** A filter object. See documentation [here](https://bo.wix.com/wix-docs/rnd/platformization-guidelines/api-query-language#platformization-guidelines_api-query-language_defining-in-protobuf) */
      filter?: Record<string, any> | null;
      /** Sort object in the form [{"fieldName":"sortField1"},{"fieldName":"sortField2","direction":"DESC"}] */
      sort?: Sorting$3[];
      /** Free text to match in searchable fields */
      search?: SearchDetails;
  }
  /** @oneof */
  interface CursorSearchPagingMethodOneOf {
      /** Cursor pointing to page of results. Can't be used together with 'paging'. 'cursor_paging.cursor' can not be used together with 'filter' or 'sort' */
      cursorPaging?: CursorPaging$3;
  }
  interface SearchDetails {
      /** Defines how separate search terms in `expression` are combined */
      mode?: Mode;
      /** Search term or expression */
      expression?: string | null;
      /** Fields to search in. If empty - will search in all searchable fields. Use dot notation to specify json path */
      fields?: string[];
      /** Flag if should use auto fuzzy search (allowing typos by a managed proximity algorithm) */
      fuzzy?: boolean;
  }
  enum Mode {
      /** Any of the search terms must be present */
      OR = "OR",
      /** All search terms must be present */
      AND = "AND"
  }
  interface SearchStaffMembersResponse {
      /** The retrieved staff members matching the search criteria. */
      staffMembers?: StaffMember[];
      /** Paging metadata. including paging, offset and cursor. */
      pagingMetadata?: CursorPagingMetadata$2;
      /** Aggregation data results, resulting from the aggregations stated in the request. */
      aggregationData?: AggregationData;
  }
  interface AggregationData {
      /** key = aggregation name (as derived from search request) */
      results?: AggregationResults[];
  }
  interface ValueAggregationResult {
      value?: string;
      count?: number;
  }
  interface RangeAggregationResult {
      from?: number | null;
      to?: number | null;
      count?: number;
  }
  enum ScalarType {
      UNKNOWN_SCALAR_TYPE = "UNKNOWN_SCALAR_TYPE",
      COUNT_DISTINCT = "COUNT_DISTINCT",
      MIN = "MIN",
      MAX = "MAX",
      SUM = "SUM",
      AVG = "AVG"
  }
  interface NestedAggregationResults extends NestedAggregationResultsResultOneOf {
      values?: ValueResults;
      ranges?: RangeResults;
      scalar?: ScalarResult;
      name?: string;
      type?: AggregationType;
      fieldPath?: string;
  }
  /** @oneof */
  interface NestedAggregationResultsResultOneOf {
      values?: ValueResults;
      ranges?: RangeResults;
      scalar?: ScalarResult;
  }
  enum AggregationType {
      UNKNOWN_AGGREGATION_TYPE = "UNKNOWN_AGGREGATION_TYPE",
      VALUE = "VALUE",
      RANGE = "RANGE",
      SCALAR = "SCALAR"
  }
  interface ValueResults {
      results?: ValueAggregationResult[];
  }
  interface RangeResults {
      results?: RangeAggregationResult[];
  }
  interface ScalarResult {
      type?: ScalarType;
      value?: number;
  }
  interface NestedValueAggregationResult {
      value?: string;
      nestedResults?: NestedAggregationResults;
  }
  interface GroupByValueResults {
      results?: NestedValueAggregationResult[];
  }
  interface AggregationResults extends AggregationResultsResultOneOf {
      values?: ValueResults;
      ranges?: RangeResults;
      scalar?: ScalarResult;
      groupedByValue?: GroupByValueResults;
      name?: string;
      type?: AggregationType;
      fieldPath?: string;
  }
  /** @oneof */
  interface AggregationResultsResultOneOf {
      values?: ValueResults;
      ranges?: RangeResults;
      scalar?: ScalarResult;
      groupedByValue?: GroupByValueResults;
  }
  interface DisconnectStaffMemberFromUserRequest {
      /** Id of the StaffMember to disconnect. The staff member to disconnect from a user. */
      staffMemberId: string;
      /** Conditional fields to return. */
      fields?: RequestedFields[];
  }
  interface DisconnectStaffMemberFromUserResponse {
      /** The updated staff member. After disconnecting from the user. */
      staffMember?: StaffMember;
  }
  interface AssignWorkingHoursScheduleRequest {
      /** Id of the staff member to assign the schedule to. */
      staffMemberId: string;
      /** Id of a schedule to assign to the staff's working hours schedule. */
      scheduleId: string;
      /** Conditional fields to return. */
      fields?: RequestedFields[];
  }
  interface AssignWorkingHoursScheduleResponse {
      /** The updated staff member. After assigning the custom schedule. */
      staffMember?: StaffMember;
  }
  interface AssignCustomScheduleRequest {
      /** Id of the staff member to assign the schedule to. */
      staffMemberId: string;
      /** Id of a schedule to assign to the staff's working hours schedule. */
      scheduleId: string;
      /** Conditional fields to return. */
      fields?: RequestedFields[];
  }
  interface AssignCustomScheduleResponse {
      /** The updated staff member. After assigning the custom schedule. */
      staffMember?: StaffMember;
  }
  interface RestoreStaffRequest {
      /** Id of the staff member to restore. */
      staffMemberId?: string;
      /** Conditional fields to return. */
      fields?: RequestedFields[];
  }
  interface RestoreStaffResponse {
      /** The restored staff member. */
      staffMember?: StaffMember;
  }
  interface ImportStaffMemberRequest {
      /** StaffMember to be created. */
      staffMember?: StaffMember;
      /** Conditional fields to return. */
      fields?: RequestedFields[];
  }
  interface ImportStaffMemberResponse {
      /** The imported StaffMember. */
      staffMember?: StaffMember;
  }
  interface Empty$1 {
  }
  interface PolicyRemovedFromContributor {
      accountId?: string;
      metaSiteId?: string;
      policyIds?: string[];
  }
  interface PolicyUpdatedForContributor {
      accountId?: string;
      metaSiteId?: string;
      oldPolicyIds?: string[];
      newPolicyIds?: string[];
  }
  interface DomainEvent$3 extends DomainEventBodyOneOf$3 {
      createdEvent?: EntityCreatedEvent$3;
      updatedEvent?: EntityUpdatedEvent$3;
      deletedEvent?: EntityDeletedEvent$3;
      actionEvent?: ActionEvent$3;
      /**
       * Unique event ID.
       * Allows clients to ignore duplicate webhooks.
       */
      _id?: string;
      /**
       * Assumes actions are also always typed to an entity_type
       * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
       */
      entityFqdn?: string;
      /**
       * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
       * This is although the created/updated/deleted notion is duplication of the oneof types
       * Example: created/updated/deleted/started/completed/email_opened
       */
      slug?: string;
      /** ID of the entity associated with the event. */
      entityId?: string;
      /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
      eventTime?: Date | null;
      /**
       * Whether the event was triggered as a result of a privacy regulation application
       * (for example, GDPR).
       */
      triggeredByAnonymizeRequest?: boolean | null;
      /** If present, indicates the action that triggered the event. */
      originatedFrom?: string | null;
      /**
       * A sequence number defining the order of updates to the underlying entity.
       * For example, given that some entity was updated at 16:00 and than again at 16:01,
       * it is guaranteed that the sequence number of the second update is strictly higher than the first.
       * As the consumer, you can use this value to ensure that you handle messages in the correct order.
       * To do so, you will need to persist this number on your end, and compare the sequence number from the
       * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
       */
      entityEventSequence?: string | null;
  }
  /** @oneof */
  interface DomainEventBodyOneOf$3 {
      createdEvent?: EntityCreatedEvent$3;
      updatedEvent?: EntityUpdatedEvent$3;
      deletedEvent?: EntityDeletedEvent$3;
      actionEvent?: ActionEvent$3;
  }
  interface EntityCreatedEvent$3 {
      entityAsJson?: string;
      /**
       * Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity
       * @internal
       */
      triggeredByUndelete?: boolean | null;
      /** Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity */
      restoreInfo?: RestoreInfo$3;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface RestoreInfo$3 {
      deletedDate?: Date | null;
  }
  interface EntityUpdatedEvent$3 {
      /**
       * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
       * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
       * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
       */
      currentEntityAsJson?: string;
      /**
       * This field is currently part of the of the EntityUpdatedEvent msg, but scala/node libraries which implements the domain events standard
       * wont populate it / have any reference to it in the API.
       * The main reason for it is that fetching the old entity from the DB will have a performance hit on an update operation so unless truly needed,
       * the developer should send only the new (current) entity.
       * An additional reason is not wanting to send this additional entity over the wire (kafka) since in some cases it can be really big
       * Developers that must reflect the old entity will have to implement their own domain event sender mechanism which will follow the DomainEvent proto message.
       * @internal
       * @deprecated
       */
      previousEntityAsJson?: string | null;
      /**
       * WIP - This property will hold both names and values of the updated fields of the entity.
       * For more details please see [adr](https://docs.google.com/document/d/1PdqsOM20Ph2HAkmx8zvUnzzk3Sekp3BR9h34wSvsRnI/edit#heading=h.phlw87mh2imx) or [issue](https://github.com/wix-private/nile-tracker/issues/363)
       * @internal
       */
      modifiedFields?: Record<string, any>;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface EntityDeletedEvent$3 {
      /**
       * Indicates if the entity is sent to trash-bin. only available when trash-bin is enabled
       * @internal
       */
      movedToTrash?: boolean | null;
      /** Entity that was deleted */
      deletedEntityAsJson?: string | null;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface ActionEvent$3 {
      bodyAsJson?: string;
  }
  interface ScheduleNotification extends ScheduleNotificationEventOneOf {
      scheduleCreated?: ScheduleCreated;
      scheduleUpdated?: ScheduleUpdated;
      scheduleCancelled?: ScheduleCancelled;
      sessionCreated?: SessionCreated;
      sessionUpdated?: SessionUpdated;
      sessionCancelled?: SessionCancelled;
      availabilityPolicyUpdated?: AvailabilityPolicyUpdated;
      /** @deprecated */
      intervalSplit?: IntervalSplit;
      recurringSessionSplit?: RecurringSessionSplit;
      /**
       * Inspect `schedule.scheduleOwnerUserId` on `scheduleUpdated` instead.
       * @deprecated
       */
      scheduleUnassignedFromUser?: ScheduleUnassignedFromUser;
      /**
       * supported only for schedule migration apis.
       * @internal
       */
      multipleSessionsCreated?: MultipleSessionsCreated;
      /**
       * supported only for schedule migration apis.
       * @internal
       */
      migrationEvent?: MigrationEvent;
      preserveFutureSessionsWithParticipants?: boolean | null;
      /**
       * Whether to notify participants about changed sessions. deprecated, use participant_notification
       * @deprecated
       */
      notifyParticipants?: boolean;
      /** site properties. Optional. Given in create schedule notification. */
      siteProperties?: SitePropertiesOnScheduleCreation;
      instanceId?: string;
      /**
       * true when the schedule belongs to a site that is rolled out to calendar v3
       * @internal
       */
      rolledOut?: boolean | null;
  }
  /** @oneof */
  interface ScheduleNotificationEventOneOf {
      scheduleCreated?: ScheduleCreated;
      scheduleUpdated?: ScheduleUpdated;
      scheduleCancelled?: ScheduleCancelled;
      sessionCreated?: SessionCreated;
      sessionUpdated?: SessionUpdated;
      sessionCancelled?: SessionCancelled;
      availabilityPolicyUpdated?: AvailabilityPolicyUpdated;
      /** @deprecated */
      intervalSplit?: IntervalSplit;
      recurringSessionSplit?: RecurringSessionSplit;
      /**
       * Inspect `schedule.scheduleOwnerUserId` on `scheduleUpdated` instead.
       * @deprecated
       */
      scheduleUnassignedFromUser?: ScheduleUnassignedFromUser;
      /**
       * supported only for schedule migration apis.
       * @internal
       */
      multipleSessionsCreated?: MultipleSessionsCreated;
      /**
       * supported only for schedule migration apis.
       * @internal
       */
      migrationEvent?: MigrationEvent;
  }
  interface ScheduleCreated {
      schedule?: Schedule;
  }
  interface Schedule {
      /** Schedule ID. */
      _id?: string;
      /** ID of the schedule's owner entity. This may be a resource ID or a service ID. */
      scheduleOwnerId?: string | null;
      /**
       * Start time of the first session in the schedule.
       * @internal
       * @readonly
       */
      firstSessionStart?: Date | null;
      /**
       * End time of the last session in the schedule.
       * @internal
       * @readonly
       */
      lastSessionEnd?: Date | null;
      /**
       * Schedule's time zone in [Area/Location](https://en.wikipedia.org/wiki/Tz_database) format. Read-only.
       * Derived from the Wix Business time zone.
       * @readonly
       */
      timeZone?: string | null;
      /**
       * Deprecated. Please use the [Sessions API](https://dev.wix.com/api/rest/wix-bookings/schedules-and-sessions/session) instead.
       * @deprecated
       */
      intervals?: RecurringInterval[];
      /** Default title for the schedule's sessions. Maximum length: 6000 characters. */
      title?: string | null;
      /**
       * __Deprecated.__
       * Tags for grouping schedules. These tags are the default tags for the schedule's sessions.
       * The Wix Bookings app uses the following predefined tags to set schedule type: `"INDIVIDUAL"`, `"GROUP"`, and `"COURSE"`. Once the schedule type is set using these tags, you cannot update it. In addition to the app's tags, you can create and update your own tags.
       * @deprecated
       */
      tags?: string[] | null;
      /** Default location for the schedule's sessions. */
      location?: Location$2;
      /**
       * Maximum number of participants that can be added to the schedule's sessions.
       * Must be at most `1` for schedule whose availability is affected by another schedule. E.g, appointment schedules of the Wix Bookings app.
       */
      capacity?: number | null;
      /**
       * Deprecated. Please use the [Booking Services V2](https://dev.wix.com/api/rest/wix-bookings/services-v2) payment instead.
       * @deprecated
       */
      rate?: Rate;
      /**
       * __Deprecated.__
       * @deprecated
       */
      availability?: Availability;
      /**
       * Number of participants registered to sessions in this schedule, calculated as the sum of the party sizes.
       * @readonly
       */
      totalNumberOfParticipants?: number;
      /**
       * *Partial list** of participants which are registered to sessions in this schedule.
       * Participants who are registered in the schedule are automatically registered to any session that is created for the schedule.
       * To retrieve the full list of schedule participants please use the [Query Extended Bookings API](https://dev.wix.com/api/rest/wix-bookings/bookings-reader-v2/query-extended-bookings).
       * @readonly
       */
      participants?: Participant[];
      /**
       * __Deprecated.__
       * @deprecated
       */
      externalCalendarOverrides?: ExternalCalendarOverrides;
      /**
       * Schedule status.
       * @readonly
       */
      status?: ScheduleStatus;
      /**
       * Schedule creation date.
       * @readonly
       */
      created?: Date | null;
      /**
       * Schedule last update date.
       * @readonly
       */
      updated?: Date | null;
      /**
       * Schedule version number, updated each time the schedule is updated.
       * @readonly
       */
      version?: number;
      /**
       * The schedule version, updated each time the schedule or the schedule participants are updated.
       * @internal
       * @readonly
       */
      versions?: Version;
      /**
       * Fields which were inherited from the Business Info page under Settings in the Dashboard.
       * @readonly
       */
      inheritedFields?: string[];
      /**
       * __Deprecated.__
       * @deprecated
       */
      conferenceProvider?: ConferenceProvider;
      /**
       * A conference created for the schedule. This is used when a participant is added to a schedule.
       * **Partially deprecated.** Only `hostUrl` and `guestUrl` are to be supported.
       * @deprecated
       */
      calendarConference?: CalendarConference;
      /**
       * The name of the schedule owner. It may be a resource name or a service name. Optional.
       * @internal
       */
      scheduleOwnerName?: string | null;
      /**
       * The user id of the schedule owner. Optional.
       * Currently, in Bookings system, it would be present when the schedule is owned by a staff resource and the resource is connected to a user.
       * NOT IMPLEMENTED. YET.
       * @internal
       * @readonly
       */
      scheduleOwnerUserId?: string | null;
  }
  interface RecurringInterval {
      /**
       * The recurring interval identifier.
       * @readonly
       */
      _id?: string;
      /** The start time of the recurring interval. Required. */
      start?: Date | null;
      /** The end time of the recurring interval. Optional. Empty value indicates that there is no end time. */
      end?: Date | null;
      /** The interval rules. The day, hour and minutes the interval is recurring. */
      interval?: Interval;
      /** The frequency of the interval. Optional. The default is frequency with the default repetition. */
      frequency?: Frequency;
      /** Specifies the list of linked schedules and the way this link affects the corresponding schedules' availability. Can be calculated from the schedule or overridden on the recurring interval. */
      affectedSchedules?: LinkedSchedule[];
      /** The type of recurring interval. */
      intervalType?: RecurringIntervalType;
  }
  interface Interval {
      /** The day the interval accrue. Optional. The default is the day of the recurring interval's start time. */
      daysOfWeek?: Day;
      /** The hour of the day the interval accrue. must be consistent with the Interval start time. Options. The default is 0. minimum: 0, maximum: 23. */
      hourOfDay?: number | null;
      /** The minutes of hour the interval accrue. must be consistent with the Interval end time. Options. The default is 0. minimum: 0, maximum: 59. */
      minuteOfHour?: number | null;
      /** The duration of the interval in minutes. Required. Part of the session end time calculation. */
      duration?: number;
  }
  enum Day {
      /** Undefined. */
      UNDEFINED = "UNDEFINED",
      /** Monday. */
      MON = "MON",
      /** Tuesday. */
      TUE = "TUE",
      /** Wednesday. */
      WED = "WED",
      /** Thursday. */
      THU = "THU",
      /** Friday. */
      FRI = "FRI",
      /** Saturday. */
      SAT = "SAT",
      /** Sunday. */
      SUN = "SUN"
  }
  interface Frequency {
      /** The frequency of the recurrence in weeks. i.e. when this value is 4, the interval occurs every 4 weeks. Optional. The default is 1. minimum: 1, maximum: 52. */
      repetition?: number | null;
  }
  interface LinkedSchedule {
      /** Schedule ID. */
      scheduleId?: string;
      /**
       * Sets this schedule's availability for the duration of the linked schedule's sessions.  Default is `"BUSY"`.
       * If set to `"BUSY"`, this schedule cannot have any available slots during the linked schedule's sessions.
       * If set to `"FREE"`, this schedule can have available slots during the linked schedule's sessions.
       */
      transparency?: Transparency;
      /**
       * Owner ID, of the linked schedule.
       * @readonly
       */
      scheduleOwnerId?: string;
      /**
       * The name of the linked schedule owner. It may be a resource name or a service name. Optional.
       * This field is inherited from the schedule identified by scheduleId above.
       * @internal
       * @readonly
       */
      scheduleOwnerName?: string | null;
      /**
       * The user id of the linked schedule owner. Optional.
       * This field is inherited from the schedule identified by scheduleId above.
       * NOT IMPLEMENTED. YET.
       * @internal
       * @readonly
       */
      scheduleOwnerUserId?: string | null;
  }
  enum Transparency {
      UNDEFINED = "UNDEFINED",
      /** The schedule can have available slots during the session. */
      FREE = "FREE",
      /** The schedule cannot have available slots during the session. Default value. */
      BUSY = "BUSY"
  }
  enum RecurringIntervalType {
      /** The default value. Sessions for this interval will be of type EVENT. */
      UNDEFINED = "UNDEFINED",
      /** A recurring interval of events */
      EVENT = "EVENT",
      /** Deprecated */
      TIME_AVAILABILITY = "TIME_AVAILABILITY",
      /** A recurring interval for availability */
      AVAILABILITY = "AVAILABILITY"
  }
  interface Location$2 {
      /**
       * Location type.
       * One of:
       * - `"OWNER_BUSINESS"` The business address as set in the sites general settings.
       * - `"OWNER_CUSTOM"` The address as set when creating the service.
       * - `"CUSTOM"` The address set for the individual session.
       */
      locationType?: LocationType$2;
      /**
       * Free text address used when locationType is `OWNER_CUSTOM`.
       * @deprecated
       */
      address?: string | null;
      /** Custom address, used when locationType is `"OWNER_CUSTOM"`. Might be used when locationType is `"CUSTOM"` in case the owner sets a custom address for the session which is different from the default. */
      customAddress?: Address$3;
      /**
       * The Wix Business location formatted address.
       * Valid when `locationType` is `OWNER_BUSINESS`. Defaults to the business's location.
       * To retrieve the full location data please use the [Locations API](https://dev.wix.com/api/rest/business-info/locations).
       * @internal
       */
      businessLocation?: LocationsLocation;
  }
  enum LocationType$2 {
      UNDEFINED = "UNDEFINED",
      OWNER_BUSINESS = "OWNER_BUSINESS",
      OWNER_CUSTOM = "OWNER_CUSTOM",
      CUSTOM = "CUSTOM"
  }
  /** Physical address */
  interface Address$3 extends AddressStreetOneOf$2 {
      /** Street name, number and apartment number. */
      streetAddress?: StreetAddress$2;
      /** Main address line, usually street and number, as free text. */
      addressLine?: string | null;
      /** Country code. */
      country?: string | null;
      /** Subdivision. Usually state, region, prefecture or province code, according to [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). */
      subdivision?: string | null;
      /** City name. */
      city?: string | null;
      /** Zip/postal code. */
      postalCode?: string | null;
      /** Free text providing more detailed address info. Usually contains Apt, Suite, and Floor. */
      addressLine2?: string | null;
      /** A string containing the full address of this location. */
      formattedAddress?: string | null;
      /** Free text to help find the address. */
      hint?: string | null;
      /** Coordinates of the physical address. */
      geocode?: AddressLocation$2;
      /** Country full name. */
      countryFullname?: string | null;
      /** Multi-level subdivisions from top to bottom. */
      subdivisions?: Subdivision$2[];
  }
  /** @oneof */
  interface AddressStreetOneOf$2 {
      /** Street name, number and apartment number. */
      streetAddress?: StreetAddress$2;
      /** Main address line, usually street and number, as free text. */
      addressLine?: string | null;
  }
  interface StreetAddress$2 {
      /** Street number. */
      number?: string;
      /** Street name. */
      name?: string;
      /** Apartment number. */
      apt?: string;
  }
  interface AddressLocation$2 {
      /** Address latitude. */
      latitude?: number | null;
      /** Address longitude. */
      longitude?: number | null;
  }
  interface Subdivision$2 {
      /** Subdivision code. Usually state, region, prefecture or province code, according to [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). */
      code?: string;
      /** Subdivision full name. */
      name?: string;
  }
  interface LocationsLocation {
      /**
       * Location ID.
       * @readonly
       */
      _id?: string | null;
      /** Location name. */
      name?: string;
      /** Location description. */
      description?: string | null;
      /**
       * Whether this is the default location. There can only be one default location per site. The default location can't be archived.
       * @readonly
       */
      default?: boolean;
      /**
       * Location status. Defaults to `ACTIVE`.
       * __Notes:__
       * - [Archiving a location](https://dev.wix.com/api/rest/business-info/locations/archive-location)
       * doesn't affect the location's status.
       * - `INACTIVE` status is currently not supported.
       */
      status?: LocationStatus;
      /**
       * Location type.
       *
       * **Note:** Currently not supported.
       * @deprecated
       */
      locationType?: LocationsLocationType;
      /** Fax number. */
      fax?: string | null;
      /** Timezone in `America/New_York` format. */
      timeZone?: string | null;
      /** Email address. */
      email?: string | null;
      /** Phone number. */
      phone?: string | null;
      /** Address. */
      address?: LocationsAddress;
      /**
       * Business schedule. Array of weekly recurring time periods when the location is open for business. Limited to 100 time periods.
       *
       * __Note:__ Not supported by Wix Bookings.
       */
      businessSchedule?: BusinessSchedule$1;
      /**
       * Revision number, which increments by 1 each time the location is updated.
       * To prevent conflicting changes, the existing revision must be used when updating a location.
       */
      revision?: string | null;
      /**
       * Whether the location is archived. Archived locations can't be updated.
       * __Note:__ [Archiving a location](https://dev.wix.com/api/rest/business-info/locations/archive-location)
       * doesn't affect its `status`.
       * @readonly
       */
      archived?: boolean;
      /** Location types. */
      locationTypes?: LocationsLocationType[];
  }
  /** For future use */
  enum LocationStatus {
      ACTIVE = "ACTIVE",
      INACTIVE = "INACTIVE"
  }
  /** For future use */
  enum LocationsLocationType {
      UNKNOWN = "UNKNOWN",
      BRANCH = "BRANCH",
      OFFICES = "OFFICES",
      RECEPTION = "RECEPTION",
      HEADQUARTERS = "HEADQUARTERS",
      INVENTORY = "INVENTORY"
  }
  interface LocationsAddress {
      /** 2-letter country code in an [ISO-3166 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format. */
      country?: string | null;
      /** Code for a subdivision (such as state, prefecture, or province) in [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) format. */
      subdivision?: string | null;
      /** City name. */
      city?: string | null;
      /** Postal or zip code. */
      postalCode?: string | null;
      /** Street address. Includes street name, number, and apartment number in separate fields. */
      streetAddress?: LocationsStreetAddress;
      /** Full address of the location. */
      formatted?: string | null;
      /** Geographic coordinates of location. */
      location?: LocationsAddressLocation;
  }
  /** Street address. Includes street name, number, and apartment number in separate fields. */
  interface LocationsStreetAddress {
      /** Street number. */
      number?: string;
      /** Street name. */
      name?: string;
      /** Apartment number. */
      apt?: string;
  }
  /** Address Geolocation */
  interface LocationsAddressLocation {
      /** Latitude of the location. Must be between -90 and 90. */
      latitude?: number | null;
      /** Longitude of the location. Must be between -180 and 180. */
      longitude?: number | null;
  }
  /** Business schedule. Regular and exceptional time periods when the business is open or the service is available. */
  interface BusinessSchedule$1 {
      /** Weekly recurring time periods when the business is regularly open or the service is available. Limited to 100 time periods. */
      periods?: TimePeriod$1[];
      /** Exceptions to the business's regular hours. The business can be open or closed during the exception. */
      specialHourPeriod?: SpecialHourPeriod$1[];
  }
  /** Weekly recurring time periods when the business is regularly open or the service is available. */
  interface TimePeriod$1 {
      /** Day of the week the period starts on. */
      openDay?: DayOfWeek$1;
      /**
       * Time the period starts in 24-hour [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) extended format. Valid values are `00:00` to `24:00`, where `24:00` represents
       * midnight at the end of the specified day.
       */
      openTime?: string;
      /** Day of the week the period ends on. */
      closeDay?: DayOfWeek$1;
      /**
       * Time the period ends in 24-hour [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) extended format. Valid values are `00:00` to `24:00`, where `24:00` represents
       * midnight at the end of the specified day.
       *
       * __Note:__ If `openDay` and `closeDay` specify the same day of the week `closeTime` must be later than `openTime`.
       */
      closeTime?: string;
  }
  /** Enumerates the days of the week. */
  enum DayOfWeek$1 {
      MONDAY = "MONDAY",
      TUESDAY = "TUESDAY",
      WEDNESDAY = "WEDNESDAY",
      THURSDAY = "THURSDAY",
      FRIDAY = "FRIDAY",
      SATURDAY = "SATURDAY",
      SUNDAY = "SUNDAY"
  }
  /** Exception to the business's regular hours. The business can be open or closed during the exception. */
  interface SpecialHourPeriod$1 {
      /** Start date and time of the exception in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format and [Coordinated Universal Time (UTC)](https://en.wikipedia.org/wiki/Coordinated_Universal_Time). */
      startDate?: string;
      /** End date and time of the exception in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format and [Coordinated Universal Time (UTC)](https://en.wikipedia.org/wiki/Coordinated_Universal_Time). */
      endDate?: string;
      /**
       * Whether the business is closed (or the service is not available) during the exception.
       *
       * Default: `true`.
       */
      isClosed?: boolean;
      /** Additional info about the exception. For example, "We close earlier on New Year's Eve." */
      comment?: string;
  }
  interface Rate {
      /**
       * Mapping between a named price option, for example, adult or child prices, and the price, currency, and down payment amount.
       * When present in an update request, the `default_varied_price` is ignored to support backward compatibility.
       */
      labeledPriceOptions?: Record<string, Price>;
      /**
       * Textual price information used when **Price Per Session** is set to **Custom Price** in the app's service details page.
       * When present in an update request, the `default_varied_price` is ignored to support backward compatibility.
       */
      priceText?: string | null;
      /**
       * Default service price. Always vailable when a service has
       * [variants](https://dev.wix.com/api/rest/wix-bookings/service-options-and-variants/introduction).
       * Sometimes also available for services without variants.
       * Ignored in [updates to a service](https://dev.wix.com/api/rest/wix-bookings/services/service/update-service),
       * when either `labeled_price_options` or `price_text` is also specified.
       * @internal
       */
      defaultVariedPrice?: Price;
  }
  interface Price {
      /** Required payment amount. */
      amount?: string;
      /** Currency in which the amount is quoted. */
      currency?: string;
      /** Amount of a down payment or deposit as part of the transaction. */
      downPayAmount?: string;
  }
  /**
   * <!-- Needs updating when recurrence has been tested
   * Schedule's availability calculation is executed by the schedule's available intervals and this additional information.
   * Schedule's available intervals are recurring intervals (defined in the schedule) minus sessions that has no more spots for bookings (including time between_slots), or schedule's sessions with open spots for bookings.-->
   */
  interface Availability {
      /** Date and time the schedule starts to be available for booking. */
      start?: Date | null;
      /** Date and time the schedule stops being available for booking. No value indicates no end time. */
      end?: Date | null;
      /** Other schedules that impact the availability calculation. Relevant only when there are availability constraints. */
      linkedSchedules?: LinkedSchedule[];
      /** Constraints for calculating the schedule's availability. */
      constraints?: AvailabilityConstraints;
      /**
       * Not supported yet.
       * A list of possible locations for the session when `use_default_location` is set to `false`. Slots are generated for each location. Only one of the possible locations can be chosen by the customer.
       *
       * **NOTE**: When using the `locations` parameter, the default location is not automatically included in the list.
       * @internal
       */
      locations?: Location$2[];
      /**
       * Not supported yet.
       * Whether the schedule's slots are only available at the schedule's default location, as set in `schedule.location`. If set to `false`, the `locations` array is used to set the possible locations of the schedule's sessions.
       * Default is `true`.
       * @internal
       */
      useDefaultLocation?: boolean | null;
  }
  /** Describes how to calculate the specific slots that are available for booking. */
  interface AvailabilityConstraints {
      /**
       * A list of duration options for slots, in minutes. Minimum value for a duration is 1.
       * The availability calculation generates slots with these durations, where there is no conflict with existing sessions or other availability constraints.
       */
      slotDurations?: number[];
      /**
       * The number of minutes between the `end` of one slot, and the `start` of the next.
       * Minimum value is 0, maximum value is 120.
       */
      timeBetweenSlots?: number;
      /**
       * Specify how to split the slots in intervals of minutes.
       * This value indicates the time between available slots' start time. e.g., from 5 minute slots (3:00, 3:05, 3:15) and 1 hour slots (3:00, 4:00, 5:00).
       * Optional. The default is the first duration in slot_durations field.
       * Deprecated. Use the `split_slots_interval.value_in_minutes`.
       * @deprecated
       */
      splitInterval?: number | null;
      /**
       * An object defining the time between available slots' start times.  For example, a slot with slots_split_interval=5 can start every 5 minutes. The default is the slot duration.
       * @readonly
       */
      slotsSplitInterval?: SplitInterval;
  }
  /** The time between available slots' start times. For example, For 5 minute slots, 3:00, 3:05, 3:15 etc. For 1 hour slots, 3:00, 4:00, 5:00 etc. */
  interface SplitInterval {
      /**
       * Whether the slot duration is used as the split interval value.
       * If `same_as_duration` is `true`, the `value_in_minutes` is the sum of the first duration in
       * `schedule.availabilityConstraints.SlotDurations` field, and `schedule.availabilityConstraints.TimeBetweenSlots` field.
       */
      sameAsDuration?: boolean | null;
      /** Number of minutes between available slots' start times when `same_as_duration` is `false`. */
      valueInMinutes?: number | null;
  }
  interface Participant {
      /** Participant ID. Currently represents the booking.id. */
      _id?: string;
      /** Contact ID. */
      contactId?: string | null;
      /** Participant's name. */
      name?: string | null;
      /** Participant's phone number. */
      phone?: string | null;
      /** Participant's email address. */
      email?: string | null;
      /** Group or party size. The number of people attending. Defaults to 0. Maximum is 250. */
      partySize?: number;
      /**
       * Approval status for the participant.
       * <!-- Commented out untill updateParticipant is exposed Generally the same status as the booking, unless updated using the `updateParticipant()` API. Defaults to `"UNDEFINED"`.-->
       */
      approvalStatus?: ApprovalStatus;
      /**
       * Whether the participant was inherited from the schedule, as opposed to being booked directly to the session.
       * @readonly
       */
      inherited?: boolean;
  }
  enum ApprovalStatus {
      /** Default. */
      UNDEFINED = "UNDEFINED",
      /** Pending business approval. */
      PENDING = "PENDING",
      /** Approved by the business. */
      APPROVED = "APPROVED",
      /** Declined by the business. */
      DECLINED = "DECLINED"
  }
  interface ExternalCalendarOverrides {
      /** Synced title of the external calendar event. */
      title?: string | null;
      /** Synced description of the external calendar event. */
      description?: string | null;
  }
  enum ScheduleStatus {
      UNDEFINED = "UNDEFINED",
      /** The default value when the schedule is created. */
      CREATED = "CREATED",
      /** The schedule has been canceled. */
      CANCELLED = "CANCELLED"
  }
  interface Version {
      /** Schedule version number, updated each time the schedule is updated. */
      scheduleVersion?: number | null;
      /** Participants version number, updated each time the schedule participants are updated. */
      participantsVersion?: number | null;
  }
  interface ConferenceProvider {
      /** Conferencing provider ID */
      providerId?: string;
  }
  interface CalendarConference {
      /** Wix Calendar conference ID. */
      _id?: string;
      /** Conference meeting ID in the provider's conferencing system. */
      externalId?: string;
      /**
       * A generated id for the conference entity - Base62($providerId$accountOwnerId$conferenceId)
       * @internal
       */
      conferenceId?: string | null;
      /** Conference provider ID. */
      providerId?: string;
      /** URL used by the host to start the conference. */
      hostUrl?: string;
      /** URL used by a guest to join the conference. */
      guestUrl?: string;
      /** Password to join the conference. */
      password?: string | null;
      /** Conference description. */
      description?: string | null;
      /** Conference type. */
      conferenceType?: ConferenceType;
      /** ID of the account owner in the video conferencing service. */
      accountOwnerId?: string | null;
  }
  enum ConferenceType {
      UNDEFINED = "UNDEFINED",
      /** API-generated online meeting. */
      ONLINE_MEETING_PROVIDER = "ONLINE_MEETING_PROVIDER",
      /** User-defined meeting. */
      CUSTOM = "CUSTOM"
  }
  interface ScheduleUpdated {
      /** The old schedule before the update. */
      oldSchedule?: Schedule;
      /** The new schedule after the update. */
      newSchedule?: Schedule;
      /**
       * Recurring sessions updated event. If this field is given, the reason for the schedule updated event was
       * updating at least one of the given schedule's recurring sessions.
       * This event is triggered by create/update/delete recurring session apis.
       */
      recurringSessions?: RecurringSessionsUpdated;
      /** Whether to notify participants about the change and an optional custom message */
      participantNotification?: ParticipantNotification$3;
      /**
       * Whether this notification was created as a result of an anonymization request, such as GDPR.
       * An anonymized participant will have the following details:
       * name = "deleted"
       * phone = "deleted"
       * email = "deleted@deleted.com"
       */
      triggeredByAnonymizeRequest?: boolean | null;
  }
  interface RecurringSessionsUpdated {
      /** Old schedule's recurring session list. */
      oldRecurringSessions?: Session[];
      /** New schedule's recurring session list. */
      newRecurringSessions?: Session[];
  }
  interface Session {
      /**
       * Session ID.
       * @readonly
       */
      _id?: string | null;
      /** ID of the schedule that the session belongs to. */
      scheduleId?: string;
      /**
       * ID of the resource or service that the session's schedule belongs to.
       * @readonly
       */
      scheduleOwnerId?: string | null;
      /** Original start date and time of the session in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Coordinated_Universal_Time_(UTC)) format. */
      originalStart?: Date | null;
      /** An object specifying the start date and time of the session. If the session is a recurring session, `start` must contain a `localDateTime`. */
      start?: CalendarDateTime;
      /**
       * An object specifying the end date and time of the session. The `end` time must be after the `start` time and be same type as `start`.
       * If the session is a recurring session, `end` must contain a `localDateTime`.
       */
      end?: CalendarDateTime;
      /**
       * An object specifying a list of schedules and the way each schedule's availability is affected by the session. For example, the schedule of an instructor is affected by sessions of the class that they instruct.
       * The array is inherited from the schedule and can be overridden even if the session is a recurring session.
       */
      affectedSchedules?: LinkedSchedule[];
      /**
       * Session title.
       * The value is inherited from the schedule and can be overridden unless the session is a recurring session.
       */
      title?: string | null;
      /**
       * __Deprecated.__
       * Tags for the session.
       * The value is inherited from the schedule and can be overridden unless the session is a recurring session.
       * @deprecated
       */
      tags?: string[] | null;
      /**
       * An object describing the location where the session takes place.
       * Defaults to the schedule location.
       * For single sessions, `session.location.businessLocation` can only be provided for locations that are defined in the schedule using `schedule.location` or `schedule.availability.locations`.
       */
      location?: Location$2;
      /**
       * Maximum number of participants that can be added to the session. Defaults to the schedule capacity.
       * The value is inherited from the schedule and can be overridden unless the session is a recurring session.
       */
      capacity?: number | null;
      /**
       * The remaining number of participants that can be added to the session. Read-only.
       * Can be negative, in case the session is over capacity.
       * @internal
       * @readonly
       */
      remainingCapacity?: number | null;
      /**
       * Deprecated. Please use the [Booking Services V2](https://dev.wix.com/api/rest/wix-bookings/services-v2) payment instead.
       * @deprecated
       */
      rate?: Rate;
      /**
       * Time reserved after the session end time, derived from the schedule availability constraints and the time between slots. Read-only.
       * If the session is a recurring session, this field must be empty.
       */
      timeReservedAfter?: number | null;
      /**
       * Additional information about the session.
       * Notes are not supported for recurring sessions.
       */
      notes?: string;
      /**
       * The number of participants booked for the session. Read-only.
       * Calculated as the sum of the party sizes.
       * @readonly
       */
      totalNumberOfParticipants?: number;
      /**
       * *Partial list** list of participants booked for the session.
       * The list includes participants who have registered for this specific session, and participants who have registered for a schedule that includes this session.
       * If the session is a recurring session, this field must be empty.
       * To retrieve the full list of session participants please use the [Query Extended Bookings API](https://dev.wix.com/api/rest/wix-bookings/bookings-reader-v2/query-extended-bookings).
       */
      participants?: Participant[];
      /**
       * A list of properties for which values were inherited from the schedule.
       * This does not include participants that were inherited from the schedule.
       * @readonly
       */
      inheritedFields?: string[];
      /**
       * Information about the external calendar, if the session originated in an external calendar.
       * @internal
       * @readonly
       */
      externalCalendarInfo?: ExternalCalendarInfo;
      /**
       * __Deprecated.__
       * @deprecated
       */
      externalCalendarOverrides?: ExternalCalendarOverrides;
      /**
       * Session status.
       * @readonly
       */
      status?: Status;
      /**
       * Recurring interval ID. Defined when a session will be a recurring session. read-only. Optional.
       * For exmaple, when creating a class service  with recurring sessions, you add a recurrence rule to create recurring sessions.
       * This field is omitted for single sessions or instances of recurring sessions.
       * Specified when the session was originally generated from a schedule recurring interval.
       * Deprecated. Use `recurringSessionId`.
       * @readonly
       * @deprecated
       */
      recurringIntervalId?: string | null;
      /**
       * The ID of the recurring session if this session is an instance of a recurrence. Use this ID to update the recurrence and all of the instances.
       * @readonly
       */
      recurringSessionId?: string | null;
      /** Session type. */
      type?: SessionType;
      /**
       * A conference created for the session according to the details set in the schedule's conference provider information.
       * If the session is a recurring session, this field is inherited from the schedule.
       * **Partially deprecated.** Only `hostUrl` and `guestUrl` are to be supported.
       * @deprecated
       */
      calendarConference?: CalendarConference;
      /**
       * A string representing a recurrence rule (RRULE) for a recurring session, as defined in [iCalendar RFC 5545](https://icalendar.org/iCalendar-RFC-5545/3-3-10-recurrence-rule.html).
       * If the session is an instance of a recurrence pattern, the `instanceOfRecurrence` property will be contain the recurrence rule and this property will be empty.
       * The RRULE defines a rule for repeating a session.
       * Supported parameters are:
       *
       * |Keyword|Description|Supported values|
       * |--|--|---|
       * |`FREQ`|The frequency at which the session is recurs. Required.|`WEEKLY`|
       * |`INTERVAL`|How often, in terms of `FREQ`, the session recurs. Default is 1. Optional.|
       * |`UNTIL`|The UTC end date and time of the recurrence. Optional.|
       * |`BYDAY`|Day of the week when the event should recur. Required.|One of: `MO`, `TU`, `WE`, `TH`, `FR`, `SA`, `SU`|
       *
       *
       * For example, a session that repeats every second week on a Monday until January 7, 2022 at 8 AM:
       * `"FREQ=WEEKLY;INTERVAL=2;BYDAY=MO;UNTIL=20220107T080000Z"`
       *
       * <!--ORIGINAL COMMENTS:
       * `FREQ`  The frequency with which the session should be repeated (such as DAILY or WEEKLY).
       * Supported `WEEKLY` value is supported.
       * INTERVAL  Works together with FREQ to specify how often the session should be repeated. For example, FREQ=WEEKLY;INTERVAL=2 means once every two weeks. Optional. Default value is 1.
       * COUNT  The number of times this event should be repeated. Not yet supported.
       * UNTIL  The UTC date & time until which the session should be repeated. This parameter is optional. When it is not specified, the event repeats forever.
       * The format is a short ISO date, followed by 'T' and a short time with seconds and without milliseconds, terminated by the UTC designator 'Z'. For example, until Jan. 19th 2018 at 7:00 AM: 'UNTIL=20180119T070000Z'.
       * BYDAY - The days of the week when the event should be repeated. Currently, only a single day is supported. This parameter is mandatory.
       * Possible values are: MO, TU, WE, TH, FR, SA, SU
       * Note that DTSTART and DTEND lines are not allowed in this field; session start and end times are specified in the start and end fields.
       * **Example**: FREQ=WEEKLY;INTERVAL=2;BYDAY=MO;UNTIL=20200427T070000Z
       * ORIGINAL COMMENTS-->
       */
      recurrence?: string | null;
      /**
       * A string representing a recurrence rule (RRULE) if the session is an instance of a recurrence pattern.
       * Empty when the session is not an instance of a recurrence rule, or if the session defines a recurrence pattern, and `recurrence` is not empty.
       * @readonly
       */
      instanceOfRecurrence?: string | null;
      /**
       * The name of the schedule owner. It may be a resource name or a service name. Optional.
       * @internal
       * @readonly
       */
      scheduleOwnerName?: string | null;
      /**
       * The user id of the schedule owner. Optional.
       * NOT IMPLEMENTED YET.
       * @internal
       * @readonly
       */
      scheduleOwnerUserId?: string | null;
      /**
       * The session version.
       * Composed by the schedule, session and participants versions.
       * @readonly
       */
      version?: SessionVersion;
      /**
       * The ID of the event in the new Calendar Events V3 API.
       * @internal
       * @readonly
       */
      eventId?: string | null;
  }
  interface CalendarDateTime {
      /**
       * UTC date-time in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Coordinated_Universal_Time_(UTC)) format. If a time zone offset is specified, the time is converted to UTC. For example, if you specify  `new Date('2021-01-06T16:00:00.000-07:00')`, the stored value will be `"2021-01-06T23:00:00.000Z"`.
       * Required if `localDateTime` is not specified.
       * If `localDateTime` is specified, `timestamp` is calculated as `localDateTime`, using the business's time zone.
       */
      timestamp?: Date | null;
      /** An object containing the local date and time for the business's time zone. */
      localDateTime?: LocalDateTime;
      /**
       * The time zone. Optional. Derived from the schedule's time zone.
       * In case this field is associated with recurring session, this field is empty.
       * @readonly
       */
      timeZone?: string | null;
  }
  interface LocalDateTime {
      /** Year. 4-digit format. */
      year?: number | null;
      /** Month number, from 1-12. */
      monthOfYear?: number | null;
      /** Day of the month, from 1-31. */
      dayOfMonth?: number | null;
      /** Hour of the day in 24-hour format, from 0-23. */
      hourOfDay?: number | null;
      /** Minute, from 0-59. */
      minutesOfHour?: number | null;
  }
  interface ExternalCalendarInfo {
      /** The external calendar type (e.g. Google Calendar, iCal, etc). */
      calendarType?: CalendarType;
  }
  enum CalendarType {
      UNDEFINED = "UNDEFINED",
      GOOGLE = "GOOGLE",
      I_CAL = "I_CAL",
      /** Use `MICROSOFT` instead. */
      OUTLOOK = "OUTLOOK",
      /** Use `MICROSOFT` instead. */
      OFFICE_365 = "OFFICE_365",
      MICROSOFT = "MICROSOFT",
      OTHER = "OTHER"
  }
  enum Status {
      UNDEFINED = "UNDEFINED",
      /** The session is confirmed. Default status. */
      CONFIRMED = "CONFIRMED",
      /**
       * The session is cancelled.
       * A cancelled session can be the cancellation of a recurring session that should no longer be displayed or a deleted single session.
       * The ListSessions returns cancelled sessions only if 'includeDelete' flag is set to true.
       */
      CANCELLED = "CANCELLED"
  }
  enum SessionType {
      UNDEFINED = "UNDEFINED",
      /**
       * The session creates an event on the calendar for the owner of the schedule that the session belongs to.
       * Default type.
       */
      EVENT = "EVENT",
      /** The session represents a resource's available working hours. */
      WORKING_HOURS = "WORKING_HOURS",
      /** Deprecated. please use WORKING_HOURS */
      TIME_AVAILABILITY = "TIME_AVAILABILITY",
      /** Deprecated. The session represents a resource's available hours. please use WORKING_HOURS */
      AVAILABILITY = "AVAILABILITY"
  }
  interface SessionVersion {
      /**
       * Schedule version number, updated each time the schedule is updated.
       * @internal
       */
      scheduleVersion?: number;
      /**
       * Session version number, updated each time the session is updated.
       * @internal
       */
      sessionVersion?: number;
      /**
       * Participants version number, updated each time the session participants are updated.
       * @internal
       */
      participantsVersion?: number | null;
      /** Incremental version number, which is updated on each change to the session or on changes affecting the session. */
      number?: string | null;
  }
  interface ParticipantNotification$3 {
      /**
       * Whether to send the message about the changes to the customer.
       *
       * Default: `false`
       */
      notifyParticipants?: boolean;
      /** Custom message to send to the participants about the changes to the booking. */
      message?: string | null;
      /**
       * Optional additional metadata.
       * Supported only in V3 APIs.
       * @internal
       */
      metadata?: Record<string, string>;
  }
  interface ScheduleCancelled {
      schedule?: Schedule;
      /** Whether to notify participants about the change and an optional custom message */
      participantNotification?: ParticipantNotification$3;
      oldSchedule?: Schedule;
  }
  interface SessionCreated {
      session?: Session;
  }
  interface SessionUpdated {
      oldSession?: Session;
      newSession?: Session;
      /** Whether to notify participants about the change and an optional custom message */
      participantNotification?: ParticipantNotification$3;
      /**
       * Whether this notification was created as a result of an anonymization request, such as GDPR.
       * An anonymized participant will have the following details:
       * name = "deleted"
       * phone = "deleted"
       * email = "deleted@deleted.com"
       */
      triggeredByAnonymizeRequest?: boolean | null;
  }
  interface SessionCancelled {
      session?: Session;
      /** Whether to notify participants about the change and an optional custom message */
      participantNotification?: ParticipantNotification$3;
  }
  interface AvailabilityPolicyUpdated {
      availabilityPolicy?: AvailabilityPolicy;
  }
  /** Availability policy applied to all site schedules. */
  interface AvailabilityPolicy {
      /** Specify how to split the schedule slots in intervals of minutes. */
      splitInterval?: SplitInterval;
  }
  interface IntervalSplit {
      scheduleId?: string;
      intervals?: RecurringInterval[];
      newScheduleVersion?: number | null;
      oldScheduleVersion?: number | null;
  }
  interface RecurringSessionSplit {
      scheduleId?: string;
      recurringSessions?: Session[];
      newScheduleVersion?: number | null;
      oldScheduleVersion?: number | null;
  }
  /** Schedule unassigned from user. */
  interface ScheduleUnassignedFromUser {
      /** The Wix user id. */
      userId?: string | null;
      /** The schedule that was unassigned from the user. */
      schedule?: Schedule;
  }
  interface MultipleSessionsCreated {
      schedulesWithSessions?: ScheduleWithSessions[];
  }
  interface ScheduleWithSessions {
      schedule?: Schedule;
      siteProperties?: SitePropertiesOnScheduleCreation;
      sessions?: Session[];
  }
  interface SitePropertiesOnScheduleCreation {
      /** The global time zone value. */
      timeZone?: string | null;
  }
  interface MigrationEvent {
      migrationData?: MigrationData;
  }
  interface MigrationData {
      businessId?: string | null;
      staffs?: StaffData[];
  }
  interface StaffData {
      resourceId?: string;
      syncRequestEmail?: string;
      refreshToken?: string;
  }
  interface MetaSiteSpecialEvent extends MetaSiteSpecialEventPayloadOneOf {
      /** Emitted on a meta site creation. */
      siteCreated?: SiteCreated$1;
      /** Emitted on a meta site transfer completion. */
      siteTransferred?: SiteTransferred;
      /** Emitted on a meta site deletion. */
      siteDeleted?: SiteDeleted;
      /** Emitted on a meta site restoration. */
      siteUndeleted?: SiteUndeleted;
      /** Emitted on the first* publish of the meta site (* switching from unpublished to published state). */
      sitePublished?: SitePublished;
      /** Emitted on a meta site unpublish. */
      siteUnpublished?: SiteUnpublished;
      /** Emitted when meta site is marked as template. */
      siteMarkedAsTemplate?: SiteMarkedAsTemplate;
      /** Emitted when meta site is marked as a WixSite. */
      siteMarkedAsWixSite?: SiteMarkedAsWixSite;
      /** Emitted when an application is provisioned (installed). */
      serviceProvisioned?: ServiceProvisioned;
      /** Emitted when an application is removed (uninstalled). */
      serviceRemoved?: ServiceRemoved;
      /** Emitted when meta site name (URL slug) is changed. */
      siteRenamedPayload?: SiteRenamed;
      /** Emitted when meta site was permanently deleted. */
      hardDeleted?: SiteHardDeleted;
      /** Emitted on a namespace change. */
      namespaceChanged?: NamespaceChanged;
      /** Emitted when Studio is attached. */
      studioAssigned?: StudioAssigned;
      /** Emitted when Studio is detached. */
      studioUnassigned?: StudioUnassigned;
      /** A meta site id. */
      metaSiteId?: string;
      /** A meta site version. Monotonically increasing. */
      version?: string;
      /** A timestamp of the event. */
      timestamp?: string;
      /**
       * TODO(meta-site): Change validation once validations are disabled for consumers
       * More context: https://wix.slack.com/archives/C0UHEBPFT/p1720957844413149 and https://wix.slack.com/archives/CFWKX325T/p1728892152855659
       */
      assets?: Asset[];
  }
  /** @oneof */
  interface MetaSiteSpecialEventPayloadOneOf {
      /** Emitted on a meta site creation. */
      siteCreated?: SiteCreated$1;
      /** Emitted on a meta site transfer completion. */
      siteTransferred?: SiteTransferred;
      /** Emitted on a meta site deletion. */
      siteDeleted?: SiteDeleted;
      /** Emitted on a meta site restoration. */
      siteUndeleted?: SiteUndeleted;
      /** Emitted on the first* publish of the meta site (* switching from unpublished to published state). */
      sitePublished?: SitePublished;
      /** Emitted on a meta site unpublish. */
      siteUnpublished?: SiteUnpublished;
      /** Emitted when meta site is marked as template. */
      siteMarkedAsTemplate?: SiteMarkedAsTemplate;
      /** Emitted when meta site is marked as a WixSite. */
      siteMarkedAsWixSite?: SiteMarkedAsWixSite;
      /** Emitted when an application is provisioned (installed). */
      serviceProvisioned?: ServiceProvisioned;
      /** Emitted when an application is removed (uninstalled). */
      serviceRemoved?: ServiceRemoved;
      /** Emitted when meta site name (URL slug) is changed. */
      siteRenamedPayload?: SiteRenamed;
      /** Emitted when meta site was permanently deleted. */
      hardDeleted?: SiteHardDeleted;
      /** Emitted on a namespace change. */
      namespaceChanged?: NamespaceChanged;
      /** Emitted when Studio is attached. */
      studioAssigned?: StudioAssigned;
      /** Emitted when Studio is detached. */
      studioUnassigned?: StudioUnassigned;
  }
  interface Asset {
      /** An application definition id (app_id in dev-center). For legacy reasons may be UUID or a string (from Java Enum). */
      appDefId?: string;
      /** An instance id. For legacy reasons may be UUID or a string. */
      instanceId?: string;
      /** An application state. */
      state?: State;
  }
  enum State {
      UNKNOWN = "UNKNOWN",
      ENABLED = "ENABLED",
      DISABLED = "DISABLED",
      PENDING = "PENDING",
      DEMO = "DEMO"
  }
  interface SiteCreated$1 {
      /** A template identifier (empty if not created from a template). */
      originTemplateId?: string;
      /** An account id of the owner. */
      ownerId?: string;
      /** A context in which meta site was created. */
      context?: SiteCreatedContext;
      /**
       * A meta site id from which this site was created.
       *
       * In case of a creation from a template it's a template id.
       * In case of a site duplication ("Save As" in dashboard or duplicate in UM) it's an id of a source site.
       */
      originMetaSiteId?: string | null;
      /** A meta site name (URL slug). */
      siteName?: string;
      /** A namespace. */
      namespace?: Namespace;
  }
  enum SiteCreatedContext {
      /** A valid option, we don't expose all reasons why site might be created. */
      OTHER = "OTHER",
      /** A meta site was created from template. */
      FROM_TEMPLATE = "FROM_TEMPLATE",
      /** A meta site was created by copying of the transfferred meta site. */
      DUPLICATE_BY_SITE_TRANSFER = "DUPLICATE_BY_SITE_TRANSFER",
      /** A copy of existing meta site. */
      DUPLICATE = "DUPLICATE",
      /** A meta site was created as a transfferred site (copy of the original), old flow, should die soon. */
      OLD_SITE_TRANSFER = "OLD_SITE_TRANSFER",
      /** deprecated A meta site was created for Flash editor. */
      FLASH = "FLASH"
  }
  enum Namespace {
      UNKNOWN_NAMESPACE = "UNKNOWN_NAMESPACE",
      /** Default namespace for UGC sites. MetaSites with this namespace will be shown in a user's site list by default. */
      WIX = "WIX",
      /** ShoutOut stand alone product. These are siteless (no actual Wix site, no HtmlWeb). MetaSites with this namespace will *not* be shown in a user's site list by default. */
      SHOUT_OUT = "SHOUT_OUT",
      /** MetaSites created by the Albums product, they appear as part of the Albums app. MetaSites with this namespace will *not* be shown in a user's site list by default. */
      ALBUMS = "ALBUMS",
      /** Part of the WixStores migration flow, a user tries to migrate and gets this site to view and if the user likes it then stores removes this namespace and deletes the old site with the old stores. MetaSites with this namespace will *not* be shown in a user's site list by default. */
      WIX_STORES_TEST_DRIVE = "WIX_STORES_TEST_DRIVE",
      /** Hotels standalone (siteless). MetaSites with this namespace will *not* be shown in a user's site list by default. */
      HOTELS = "HOTELS",
      /** Clubs siteless MetaSites, a club without a wix website. MetaSites with this namespace will *not* be shown in a user's site list by default. */
      CLUBS = "CLUBS",
      /** A partially created ADI website. MetaSites with this namespace will *not* be shown in a user's site list by default. */
      ONBOARDING_DRAFT = "ONBOARDING_DRAFT",
      /** AppBuilder for AppStudio / shmite (c). MetaSites with this namespace will *not* be shown in a user's site list by default. */
      DEV_SITE = "DEV_SITE",
      /** LogoMaker websites offered to the user after logo purchase. MetaSites with this namespace will *not* be shown in a user's site list by default. */
      LOGOS = "LOGOS",
      /** VideoMaker websites offered to the user after video purchase. MetaSites with this namespace will *not* be shown in a user's site list by default. */
      VIDEO_MAKER = "VIDEO_MAKER",
      /** MetaSites with this namespace will *not* be shown in a user's site list by default. */
      PARTNER_DASHBOARD = "PARTNER_DASHBOARD",
      /** MetaSites with this namespace will *not* be shown in a user's site list by default. */
      DEV_CENTER_COMPANY = "DEV_CENTER_COMPANY",
      /**
       * A draft created by HTML editor on open. Upon "first save" it will be moved to be of WIX domain.
       *
       * Meta site with this namespace will *not* be shown in a user's site list by default.
       */
      HTML_DRAFT = "HTML_DRAFT",
      /**
       * the user-journey for Fitness users who want to start from managing their business instead of designing their website.
       * Will be accessible from Site List and will not have a website app.
       * Once the user attaches a site, the site will become a regular wixsite.
       */
      SITELESS_BUSINESS = "SITELESS_BUSINESS",
      /** Belongs to "strategic products" company. Supports new product in the creator's economy space. */
      CREATOR_ECONOMY = "CREATOR_ECONOMY",
      /** It is to be used in the Business First efforts. */
      DASHBOARD_FIRST = "DASHBOARD_FIRST",
      /** Bookings business flow with no site. */
      ANYWHERE = "ANYWHERE",
      /** Namespace for Headless Backoffice with no editor */
      HEADLESS = "HEADLESS",
      /**
       * Namespace for master site that will exist in parent account that will be referenced by subaccounts
       * The site will be used for account level CSM feature for enterprise
       */
      ACCOUNT_MASTER_CMS = "ACCOUNT_MASTER_CMS",
      /** Rise.ai Siteless account management for Gift Cards and Store Credit. */
      RISE = "RISE",
      /**
       * As part of the branded app new funnel, users now can create a meta site that will be branded app first.
       * There's a blank site behind the scene but it's blank).
       * The Mobile company will be the owner of this namespace.
       */
      BRANDED_FIRST = "BRANDED_FIRST",
      /** Nownia.com Siteless account management for Ai Scheduling Assistant. */
      NOWNIA = "NOWNIA",
      /**
       * UGC Templates are templates that are created by users for personal use and to sale to other users.
       * The Partners company owns this namespace.
       */
      UGC_TEMPLATE = "UGC_TEMPLATE",
      /** Codux Headless Sites */
      CODUX = "CODUX"
  }
  /** Site transferred to another user. */
  interface SiteTransferred {
      /** A previous owner id (user that transfers meta site). */
      oldOwnerId?: string;
      /** A new owner id (user that accepts meta site). */
      newOwnerId?: string;
  }
  /** Soft deletion of the meta site. Could be restored. */
  interface SiteDeleted {
      /** A deletion context. */
      deleteContext?: DeleteContext;
  }
  interface DeleteContext {
      /** When the meta site was deleted. */
      dateDeleted?: Date | null;
      /** A status. */
      deleteStatus?: DeleteStatus;
      /** A reason (flow). */
      deleteOrigin?: string;
      /** A service that deleted it. */
      initiatorId?: string | null;
  }
  enum DeleteStatus {
      UNKNOWN = "UNKNOWN",
      TRASH = "TRASH",
      DELETED = "DELETED",
      PENDING_PURGE = "PENDING_PURGE"
  }
  /** Restoration of the meta site. */
  interface SiteUndeleted {
  }
  /** First publish of a meta site. Or subsequent publish after unpublish. */
  interface SitePublished {
  }
  interface SiteUnpublished {
      /** A list of URLs previously associated with the meta site. */
      urls?: string[];
  }
  interface SiteMarkedAsTemplate {
  }
  interface SiteMarkedAsWixSite {
  }
  interface ServiceProvisioned {
      /** Either UUID or EmbeddedServiceType. */
      appDefId?: string;
      /** Not only UUID. Something here could be something weird. */
      instanceId?: string;
      /** An instance id from which this instance is originated. */
      originInstanceId?: string;
      /** A version. */
      version?: string | null;
      /** The origin meta site id */
      originMetaSiteId?: string | null;
  }
  interface ServiceRemoved {
      /** Either UUID or EmbeddedServiceType. */
      appDefId?: string;
      /** Not only UUID. Something here could be something weird. */
      instanceId?: string;
      /** A version. */
      version?: string | null;
  }
  /** Rename of the site. Meaning, free public url has been changed as well. */
  interface SiteRenamed {
      /** A new meta site name (URL slug). */
      newSiteName?: string;
      /** A previous meta site name (URL slug). */
      oldSiteName?: string;
  }
  /**
   * Hard deletion of the meta site.
   *
   * Could not be restored. Therefore it's desirable to cleanup data.
   */
  interface SiteHardDeleted {
      /** A deletion context. */
      deleteContext?: DeleteContext;
  }
  interface NamespaceChanged {
      /** A previous namespace. */
      oldNamespace?: Namespace;
      /** A new namespace. */
      newNamespace?: Namespace;
  }
  /** Assigned Studio editor */
  interface StudioAssigned {
  }
  /** Unassigned Studio editor */
  interface StudioUnassigned {
  }
  interface MessageEnvelope$3 {
      /** App instance ID. */
      instanceId?: string | null;
      /** Event type. */
      eventType?: string;
      /** The identification type and identity data. */
      identity?: WebhooksIdentificationData$1;
      /** Stringify payload. */
      data?: string;
  }
  interface WebhooksIdentificationData$1 extends WebhooksIdentificationDataIdOneOf$1 {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
      /** @readonly */
      identityType?: WebhookIdentityType$3;
  }
  /** @oneof */
  interface WebhooksIdentificationDataIdOneOf$1 {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
  }
  enum WebhookIdentityType$3 {
      UNKNOWN = "UNKNOWN",
      ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
      MEMBER = "MEMBER",
      WIX_USER = "WIX_USER",
      APP = "APP"
  }
  /**
   * Creates a staff member.
   *
   *
   * By using the create API, you can create a staff member and set its name, email, phone, description and media.
   * By default any staff member that is created will be linked to the business working hours, allowing customers to book appointments with the staff
   * based on the business working hours.
   * @param staffMember - Staff Member to be created.
   * @public
   * @documentationMaturity preview
   * @requiredField staffMember
   * @requiredField staffMember.name
   * @permissionId BOOKINGS.STAFF_MEMBER_CREATE
   * @adminMethod
   * @returns The created staff member.
   */
  function createStaffMember(staffMember: StaffMember, options?: CreateStaffMemberOptions): Promise<StaffMember>;
  interface CreateStaffMemberOptions {
      /** Conditional fields to return. */
      fields?: RequestedFields[];
  }
  /**
   * Retrieves a staff member by id.
   * @param staffMemberId - ID of the staff member to retrieve.
   * @public
   * @documentationMaturity preview
   * @requiredField staffMemberId
   * @permissionId BOOKINGS.STAFF_MEMBER_READ
   * @adminMethod
   * @returns The retrieved StaffMember.
   */
  function getStaffMember(staffMemberId: string, options?: GetStaffMemberOptions): Promise<StaffMember>;
  interface GetStaffMemberOptions {
      /** Conditional fields to return. */
      fields?: RequestedFields[];
  }
  /**
   * Retrieves a deleted staff member from the trash-bin.
   * @param staffMemberId - Id of the staff member to retrieve
   * @internal
   * @documentationMaturity preview
   * @requiredField staffMemberId
   * @permissionId BOOKINGS.STAFF_MEMBER_READ
   */
  function getDeletedStaffMember(staffMemberId: string, options?: GetDeletedStaffMemberOptions): Promise<GetDeletedStaffMemberResponse>;
  interface GetDeletedStaffMemberOptions {
      /** Conditional fields to return. */
      fields?: RequestedFields[];
  }
  /**
   * Retrieves a list of deleted staff members from the trash-bin.
   * List runs with these defaults, which you can override:
   * - `paging.limit` is `50`.
   * @internal
   * @documentationMaturity preview
   * @permissionId BOOKINGS.STAFF_MEMBER_READ
   */
  function listDeletedStaffMembers(options?: ListDeletedStaffMembersOptions): Promise<ListDeletedStaffMembersResponse>;
  interface ListDeletedStaffMembersOptions {
      /** The Ids of the staff members to retrieve. If omitted all deleted staff members will be retrieved paginated. */
      staffMemberIds?: string[];
      /** Paging parameter, enabling to pass a limit and a cursor. */
      paging?: CursorPaging$3;
      /** Conditional fields to return. */
      fields?: RequestedFields[];
  }
  /**
   * Remove a staff member from the trash bin, permanently deleting it.
   * This action is irreversible.
   * @param staffMemberId - Id of the staff member to remove from the trash bin
   * @internal
   * @documentationMaturity preview
   * @requiredField staffMemberId
   * @permissionId BOOKINGS.STAFF_MEMBER_REMOVE_FROM_TRASH_BIN
   * @adminMethod
   */
  function removeStaffMemberFromTrashBin(staffMemberId: string): Promise<void>;
  /**
   * Restore a staff member from the trash bin.
   * This action also restores the staff member's resource.
   * @param staffMemberId - Id of the staff member to restore from the trash bin
   * @internal
   * @documentationMaturity preview
   * @requiredField staffMemberId
   * @permissionId BOOKINGS.STAFF_MEMBER_RESTORE_FROM_TRASH_BIN
   * @adminMethod
   */
  function restoreStaffMemberFromTrashBin(staffMemberId: string, options?: RestoreStaffMemberFromTrashBinOptions): Promise<RestoreStaffMemberFromTrashBinResponse>;
  interface RestoreStaffMemberFromTrashBinOptions {
      /** Conditional fields to return. */
      fields?: RequestedFields[];
  }
  /**
   * Updates a StaffMember.
   *
   * [Partial updates](https://dev.wix.com/api/rest/wix-bookings/bookings/patch-endpoints-and-field-masks-in-update-requests) are supported.
   *
   * Each time the staff member is updated, `revision` increments by 1. You must include current revision of the staff member when updating it.
   * This ensures you're working with the latest service information and prevents unintended overwrites.
   * @param _id - Staff member's ID
   * @public
   * @documentationMaturity preview
   * @requiredField _id
   * @requiredField staffMember
   * @requiredField staffMember.revision
   * @permissionId BOOKINGS.STAFF_MEMBER_UPDATE
   * @adminMethod
   * @returns The updated staff member.
   */
  function updateStaffMember(_id: string | null, staffMember: UpdateStaffMember, options?: UpdateStaffMemberOptions): Promise<StaffMember>;
  interface UpdateStaffMember {
      /**
       * Staff member's ID
       * @readonly
       */
      _id?: string | null;
      /** Staff member's name. */
      name?: string | null;
      /** Staff member's email address. */
      email?: string | null;
      /** Staff member's phone number. */
      phone?: string | null;
      /** Description, For example: "The best masseuse in all of the land" */
      description?: string | null;
      /** The media of the staff. */
      mainMedia?: MediaItem;
      /**
       * The related calendar resource id, same as `resource.id`
       * @readonly
       */
      resourceId?: string | null;
      /**
       * The related calendar resource
       * @readonly
       */
      resource?: Resource;
      /**
       * The identity of the Wix user associated with the staff member.
       *
       * To connect a staff member to a Wix user, use `ConnectStaffMemberToUser`.
       * To disconnect a staff member from a Wix user, use `DisconnectStaffMemberFromUser`.
       * @readonly
       */
      associatedWixIdentity?: AssociatedWixIdentity;
      /**
       * A staff member conferencing providers.
       * Field is deprecated, use associated_conferencing_accounts instead.
       * @internal
       * @readonly
       * @deprecated
       * @replacedBy associated_conferencing_accounts
       * @targetRemovalDate 2024-10-01
       */
      associatedConferencingProviders?: AssociatedConferencingProviders;
      /**
       * Conferencing accounts used to create meetings links with this staff member.
       * @internal
       * @readonly
       */
      associatedConferencingAccounts?: AssociatedConferencingAccounts;
      /**
       * `true` - if staff was auto created default staff.
       * @internal
       * @readonly
       */
      default?: boolean;
      /**
       * Revision number, which increments by 1 each time the staff member is updated.
       * To prevent conflicting changes,
       * the current revision must be passed when updating the staff member.
       * @readonly
       */
      revision?: string | null;
      /**
       * Represents the time this staff member was created.
       * @readonly
       */
      _createdDate?: Date | null;
      /**
       * Represents the time this staff member was last updated
       * @readonly
       */
      _updatedDate?: Date | null;
      /** Extensions enabling users to save custom data related to the staff member. */
      extendedFields?: ExtendedFields$3;
  }
  interface UpdateStaffMemberOptions {
      /**
       * updates](https://dev.wix.com/api/rest/wix-bookings/bookings/patch-endpoints-and-field-masks-in-update-requests)
       * are supported.
       * @internal
       */
      fieldMask?: string[];
      /** Conditional fields to return. */
      fields?: RequestedFields[];
  }
  /**
   * Deletes a StaffMember.
   * @param staffMemberId - Id of the staff member to delete.
   * @public
   * @documentationMaturity preview
   * @requiredField staffMemberId
   * @permissionId BOOKINGS.STAFF_MEMBER_DELETE
   * @adminMethod
   */
  function deleteStaffMember(staffMemberId: string): Promise<void>;
  /**
   * Query StaffMembers using [WQL - Wix Query Language](https://dev.wix.com/api/rest/getting-started/api-query-language)
   * @public
   * @documentationMaturity preview
   * @permissionId BOOKINGS.STAFF_MEMBER_READ
   * @adminMethod
   */
  function queryStaffMembers(options?: QueryStaffMembersOptions): StaffMembersQueryBuilder;
  interface QueryStaffMembersOptions {
      /** Conditional fields to return. */
      fields?: RequestedFields[] | undefined;
  }
  interface QueryCursorResult$2 {
      cursors: Cursors$3;
      hasNext: () => boolean;
      hasPrev: () => boolean;
      length: number;
      pageSize: number;
  }
  interface StaffMembersQueryResult extends QueryCursorResult$2 {
      items: StaffMember[];
      query: StaffMembersQueryBuilder;
      next: () => Promise<StaffMembersQueryResult>;
      prev: () => Promise<StaffMembersQueryResult>;
  }
  interface StaffMembersQueryBuilder {
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       * @documentationMaturity preview
       */
      eq: (propertyName: '_id' | 'name' | 'email' | 'phone' | 'description' | 'resourceId' | 'resource.id' | 'associatedWixIdentity.identificationData.wixUserId' | 'associatedWixIdentity.identificationData.contactId' | '_createdDate' | '_updatedDate', value: any) => StaffMembersQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       * @documentationMaturity preview
       */
      ne: (propertyName: '_id' | 'name' | 'email' | 'phone' | 'description' | 'resourceId' | 'resource.id' | 'associatedWixIdentity.identificationData.wixUserId' | 'associatedWixIdentity.identificationData.contactId' | '_createdDate' | '_updatedDate', value: any) => StaffMembersQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       * @documentationMaturity preview
       */
      ge: (propertyName: '_createdDate' | '_updatedDate', value: any) => StaffMembersQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       * @documentationMaturity preview
       */
      gt: (propertyName: '_createdDate' | '_updatedDate', value: any) => StaffMembersQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       * @documentationMaturity preview
       */
      le: (propertyName: '_createdDate' | '_updatedDate', value: any) => StaffMembersQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       * @documentationMaturity preview
       */
      lt: (propertyName: '_createdDate' | '_updatedDate', value: any) => StaffMembersQueryBuilder;
      /** @param propertyName - Property whose value is compared with `string`.
       * @param string - String to compare against. Case-insensitive.
       * @documentationMaturity preview
       */
      startsWith: (propertyName: '_id' | 'description' | 'resourceId' | 'resource.id' | 'associatedWixIdentity.identificationData.wixUserId' | 'associatedWixIdentity.identificationData.contactId', value: string) => StaffMembersQueryBuilder;
      /** @param propertyName - Property whose value is compared with `values`.
       * @param values - List of values to compare against.
       * @documentationMaturity preview
       */
      hasSome: (propertyName: '_id' | 'description' | 'resourceId' | 'resource.id' | 'associatedWixIdentity.identificationData.wixUserId' | 'associatedWixIdentity.identificationData.contactId' | '_createdDate' | '_updatedDate', value: any[]) => StaffMembersQueryBuilder;
      /** @documentationMaturity preview */
      in: (propertyName: '_id' | 'name' | 'email' | 'phone' | 'description' | 'resourceId' | 'resource.id' | 'associatedWixIdentity.identificationData.wixUserId' | 'associatedWixIdentity.identificationData.contactId' | '_createdDate' | '_updatedDate', value: any) => StaffMembersQueryBuilder;
      /** @documentationMaturity preview */
      exists: (propertyName: '_id' | 'name' | 'email' | 'phone' | 'description' | 'resourceId' | 'resource.id' | 'associatedWixIdentity.identificationData.wixUserId' | 'associatedWixIdentity.identificationData.contactId' | '_createdDate' | '_updatedDate', value: boolean) => StaffMembersQueryBuilder;
      /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments.
       * @documentationMaturity preview
       */
      ascending: (...propertyNames: Array<'_id' | 'description' | 'resourceId' | 'resource.id' | 'associatedWixIdentity.identificationData.wixUserId' | 'associatedWixIdentity.identificationData.contactId' | 'associatedWixIdentity.identificationData.identityType' | 'default' | '_createdDate' | '_updatedDate'>) => StaffMembersQueryBuilder;
      /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments.
       * @documentationMaturity preview
       */
      descending: (...propertyNames: Array<'_id' | 'description' | 'resourceId' | 'resource.id' | 'associatedWixIdentity.identificationData.wixUserId' | 'associatedWixIdentity.identificationData.contactId' | 'associatedWixIdentity.identificationData.identityType' | 'default' | '_createdDate' | '_updatedDate'>) => StaffMembersQueryBuilder;
      /** @param limit - Number of items to return, which is also the `pageSize` of the results object.
       * @documentationMaturity preview
       */
      limit: (limit: number) => StaffMembersQueryBuilder;
      /** @param cursor - A pointer to specific record
       * @documentationMaturity preview
       */
      skipTo: (cursor: string) => StaffMembersQueryBuilder;
      /** @documentationMaturity preview */
      find: () => Promise<StaffMembersQueryResult>;
  }
  /**
   * Query staff members in multiple languages.
   *
   * Supports responses with text values (such as translated description) in different languages.
   * @param query - WQL expression.
   * @internal
   * @documentationMaturity preview
   * @requiredField query
   * @permissionId BOOKINGS.STAFF_MEMBER_READ
   */
  function queryStaffMembersMultiLanguage(query: CursorQuery$1, options?: QueryStaffMembersMultiLanguageOptions): Promise<QueryStaffMembersMultiLanguageResponse>;
  interface QueryStaffMembersMultiLanguageOptions {
      /** Conditional fields to return. */
      fields?: RequestedFields[];
  }
  /**
   * Counts staff members according to given criteria.
   *
   *
   * Use [WQL filter](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#the-filter-section) to define the criteria.
   * @public
   * @documentationMaturity preview
   * @permissionId BOOKINGS.STAFF_MEMBER_READ
   * @adminMethod
   */
  function countStaffMembers(options?: CountStaffMembersOptions): Promise<CountStaffMembersResponse>;
  interface CountStaffMembersOptions {
      /** The filters for performing the count. */
      filter?: Record<string, any> | null;
  }
  /**
   * Connects staff member to a Wix user.
   *
   *
   * By default the staff member's email is used to connect to the user.
   * If the email is already associated with a wix user with roles and permissions to access the site, the staff member is connected to that user.
   * If the email is not associated with a wix user, an invitation is sent to the email to join the site.
   *
   * *Connecting a staff member to a user gives access to the user to manage the staff's schedule via the Wix backoffice.**
   *
   * The status of a staff member's connection is stored in the `associatedWixIdentity` field, and can be fetched using the requested field `ASSOCIATED_IDENTITY_STATUS`.
   * @param staffMemberId - Id of the staff member. The staff member to connect to a user.
   * @public
   * @documentationMaturity preview
   * @requiredField staffMemberId
   * @permissionId BOOKINGS.STAFF_MEMBER_UPDATE
   * @adminMethod
   */
  function connectStaffMemberToUser(staffMemberId: string, options?: ConnectStaffMemberToUserOptions): Promise<ConnectStaffMemberToUserResponse>;
  interface ConnectStaffMemberToUserOptions {
      /** Email of the user to send invitation to. The staff existing email would be used if not provided. */
      email?: string | null;
      /** Conditional fields to return. */
      fields?: RequestedFields[];
  }
  /**
   * Retrieves a list of staff members matching the provided search criteria.
   *
   * The search endpoints allow to perform advance search including partial text search, exact match, and more.
   * The endpoint also allows to aggregate staff members by their name, email, phone, description, or resource id.
   * @param search - WQL expression.
   * @public
   * @documentationMaturity preview
   * @requiredField search
   * @permissionId BOOKINGS.STAFF_MEMBER_READ
   * @adminMethod
   */
  function searchStaffMembers(search: CursorSearch, options?: SearchStaffMembersOptions): Promise<SearchStaffMembersResponse>;
  interface SearchStaffMembersOptions {
      /** Conditional fields to return. */
      fields?: RequestedFields[];
  }
  /**
   * Disconnects a staff member from the Wix user.
   *
   * If the staff member is connected to a user, this API disconnects the staff member from the user, removing the `associatedWixIdentity` field.
   * The action removes the user's access to manage the staff member's schedule via the Wix backoffice.
   * @param staffMemberId - Id of the StaffMember to disconnect. The staff member to disconnect from a user.
   * @public
   * @documentationMaturity preview
   * @requiredField staffMemberId
   * @permissionId BOOKINGS.STAFF_MEMBER_UPDATE
   * @adminMethod
   */
  function disconnectStaffMemberFromUser(staffMemberId: string, options?: DisconnectStaffMemberFromUserOptions): Promise<DisconnectStaffMemberFromUserResponse>;
  interface DisconnectStaffMemberFromUserOptions {
      /** Conditional fields to return. */
      fields?: RequestedFields[];
  }
  /**
   * Assigns a custom working hours schedule to the staff member
   *
   *
   * The working hours schedule is a schedule that defines the working hours of a staff member,
   * and dictate when the staff member is available for bookings.
   *
   * By default staff members use the shared business working hours schedule. By assigning a custom working hours schedule to a staff member,
   * you can define specific working hours for that staff member.
   *
   * To create and manage schedules and working hours sessions, use [Schedules and Sessions API](https://dev.wix.com/docs/rest/business-solutions/bookings/calendar/schedules-and-sessions/introduction).
   * @param staffMemberId - Id of the staff member to assign the schedule to.
   * @param scheduleId - Id of a schedule to assign to the staff's working hours schedule.
   * @public
   * @documentationMaturity preview
   * @requiredField scheduleId
   * @requiredField staffMemberId
   * @permissionId BOOKINGS.STAFF_MEMBER_UPDATE
   * @adminMethod
   */
  function assignWorkingHoursSchedule(staffMemberId: string, scheduleId: string, options?: AssignWorkingHoursScheduleOptions): Promise<AssignWorkingHoursScheduleResponse>;
  interface AssignWorkingHoursScheduleOptions {
      /** Conditional fields to return. */
      fields?: RequestedFields[];
  }
  /**
   * Assigns a custom working hours schedule to the staff member
   *
   *
   * The working hours schedule is a schedule that defines the working hours of a staff member,
   * and dictate when the staff member is available for bookings.
   *
   * By default staff members use the shared business working hours schedule. By assigning a custom working hours schedule to a staff member,
   * you can define specific working hours for that staff member.
   *
   * To create and manage schedules and working hours sessions, use [Schedules and Sessions API](https://dev.wix.com/docs/rest/business-solutions/bookings/calendar/schedules-and-sessions/introduction).
   * @param staffMemberId - Id of the staff member to assign the schedule to.
   * @param scheduleId - Id of a schedule to assign to the staff's working hours schedule.
   * @public
   * @documentationMaturity preview
   * @requiredField scheduleId
   * @requiredField staffMemberId
   * @permissionId BOOKINGS.STAFF_MEMBER_UPDATE
   * @adminMethod
   * @deprecated
   * @replacedBy AssignWorkingHoursSchedule
   * @targetRemovalDate 2024-12-31
   */
  function assignCustomSchedule(staffMemberId: string, scheduleId: string, options?: AssignCustomScheduleOptions): Promise<AssignCustomScheduleResponse>;
  interface AssignCustomScheduleOptions {
      /** Conditional fields to return. */
      fields?: RequestedFields[];
  }
  
  type bookingsStaffV1StaffMember_universal_d_StaffMember = StaffMember;
  type bookingsStaffV1StaffMember_universal_d_MediaItem = MediaItem;
  type bookingsStaffV1StaffMember_universal_d_MediaItemMediaOneOf = MediaItemMediaOneOf;
  type bookingsStaffV1StaffMember_universal_d_Resource = Resource;
  type bookingsStaffV1StaffMember_universal_d_WorkingHoursSchedule = WorkingHoursSchedule;
  type bookingsStaffV1StaffMember_universal_d_EventSchedule = EventSchedule;
  type bookingsStaffV1StaffMember_universal_d_AssociatedWixIdentity = AssociatedWixIdentity;
  type bookingsStaffV1StaffMember_universal_d_AssociatedWixIdentityConnectionStatusEnumConnectionStatus = AssociatedWixIdentityConnectionStatusEnumConnectionStatus;
  const bookingsStaffV1StaffMember_universal_d_AssociatedWixIdentityConnectionStatusEnumConnectionStatus: typeof AssociatedWixIdentityConnectionStatusEnumConnectionStatus;
  type bookingsStaffV1StaffMember_universal_d_ConnectionState = ConnectionState;
  type bookingsStaffV1StaffMember_universal_d_ConnectionStateConnectionState = ConnectionStateConnectionState;
  const bookingsStaffV1StaffMember_universal_d_ConnectionStateConnectionState: typeof ConnectionStateConnectionState;
  type bookingsStaffV1StaffMember_universal_d_AssociatedConferencingProviders = AssociatedConferencingProviders;
  type bookingsStaffV1StaffMember_universal_d_AssociatedConferencingProvider = AssociatedConferencingProvider;
  type bookingsStaffV1StaffMember_universal_d_ConnectionStatus = ConnectionStatus;
  const bookingsStaffV1StaffMember_universal_d_ConnectionStatus: typeof ConnectionStatus;
  type bookingsStaffV1StaffMember_universal_d_AssociatedConferencingAccounts = AssociatedConferencingAccounts;
  type bookingsStaffV1StaffMember_universal_d_AssociatedConferencingAccount = AssociatedConferencingAccount;
  type bookingsStaffV1StaffMember_universal_d_AssociatedConferencingAccountAccountOneOf = AssociatedConferencingAccountAccountOneOf;
  type bookingsStaffV1StaffMember_universal_d_CustomConferenceAccount = CustomConferenceAccount;
  type bookingsStaffV1StaffMember_universal_d_CreateStaffMemberRequest = CreateStaffMemberRequest;
  type bookingsStaffV1StaffMember_universal_d_RequestedFields = RequestedFields;
  const bookingsStaffV1StaffMember_universal_d_RequestedFields: typeof RequestedFields;
  type bookingsStaffV1StaffMember_universal_d_CreateStaffMemberResponse = CreateStaffMemberResponse;
  type bookingsStaffV1StaffMember_universal_d_StaffMemberFullyCreated = StaffMemberFullyCreated;
  type bookingsStaffV1StaffMember_universal_d_GetStaffMemberRequest = GetStaffMemberRequest;
  type bookingsStaffV1StaffMember_universal_d_GetStaffMemberResponse = GetStaffMemberResponse;
  type bookingsStaffV1StaffMember_universal_d_GetDeletedStaffMemberRequest = GetDeletedStaffMemberRequest;
  type bookingsStaffV1StaffMember_universal_d_GetDeletedStaffMemberResponse = GetDeletedStaffMemberResponse;
  type bookingsStaffV1StaffMember_universal_d_ListDeletedStaffMembersRequest = ListDeletedStaffMembersRequest;
  type bookingsStaffV1StaffMember_universal_d_ListDeletedStaffMembersResponse = ListDeletedStaffMembersResponse;
  type bookingsStaffV1StaffMember_universal_d_RemoveStaffMemberFromTrashBinRequest = RemoveStaffMemberFromTrashBinRequest;
  type bookingsStaffV1StaffMember_universal_d_RemoveStaffMemberFromTrashBinResponse = RemoveStaffMemberFromTrashBinResponse;
  type bookingsStaffV1StaffMember_universal_d_RestoreStaffMemberFromTrashBinRequest = RestoreStaffMemberFromTrashBinRequest;
  type bookingsStaffV1StaffMember_universal_d_RestoreStaffMemberFromTrashBinResponse = RestoreStaffMemberFromTrashBinResponse;
  type bookingsStaffV1StaffMember_universal_d_UpdateStaffMemberRequest = UpdateStaffMemberRequest;
  type bookingsStaffV1StaffMember_universal_d_UpdateStaffMemberResponse = UpdateStaffMemberResponse;
  type bookingsStaffV1StaffMember_universal_d_DeleteStaffMemberRequest = DeleteStaffMemberRequest;
  type bookingsStaffV1StaffMember_universal_d_DeleteStaffMemberResponse = DeleteStaffMemberResponse;
  type bookingsStaffV1StaffMember_universal_d_StaffMemberDisconnectedFromUser = StaffMemberDisconnectedFromUser;
  type bookingsStaffV1StaffMember_universal_d_QueryStaffMembersRequest = QueryStaffMembersRequest;
  type bookingsStaffV1StaffMember_universal_d_QueryStaffMembersResponse = QueryStaffMembersResponse;
  type bookingsStaffV1StaffMember_universal_d_QueryStaffMembersMultiLanguageRequest = QueryStaffMembersMultiLanguageRequest;
  type bookingsStaffV1StaffMember_universal_d_QueryStaffMembersMultiLanguageResponse = QueryStaffMembersMultiLanguageResponse;
  type bookingsStaffV1StaffMember_universal_d_CountStaffMembersRequest = CountStaffMembersRequest;
  type bookingsStaffV1StaffMember_universal_d_CountStaffMembersResponse = CountStaffMembersResponse;
  type bookingsStaffV1StaffMember_universal_d_ConnectStaffMemberToUserRequest = ConnectStaffMemberToUserRequest;
  type bookingsStaffV1StaffMember_universal_d_ConnectStaffMemberToUserResponse = ConnectStaffMemberToUserResponse;
  type bookingsStaffV1StaffMember_universal_d_StaffMemberConnectedToUser = StaffMemberConnectedToUser;
  type bookingsStaffV1StaffMember_universal_d_SearchStaffMembersRequest = SearchStaffMembersRequest;
  type bookingsStaffV1StaffMember_universal_d_CursorSearch = CursorSearch;
  type bookingsStaffV1StaffMember_universal_d_CursorSearchPagingMethodOneOf = CursorSearchPagingMethodOneOf;
  type bookingsStaffV1StaffMember_universal_d_SearchDetails = SearchDetails;
  type bookingsStaffV1StaffMember_universal_d_Mode = Mode;
  const bookingsStaffV1StaffMember_universal_d_Mode: typeof Mode;
  type bookingsStaffV1StaffMember_universal_d_SearchStaffMembersResponse = SearchStaffMembersResponse;
  type bookingsStaffV1StaffMember_universal_d_AggregationData = AggregationData;
  type bookingsStaffV1StaffMember_universal_d_ValueAggregationResult = ValueAggregationResult;
  type bookingsStaffV1StaffMember_universal_d_RangeAggregationResult = RangeAggregationResult;
  type bookingsStaffV1StaffMember_universal_d_ScalarType = ScalarType;
  const bookingsStaffV1StaffMember_universal_d_ScalarType: typeof ScalarType;
  type bookingsStaffV1StaffMember_universal_d_NestedAggregationResults = NestedAggregationResults;
  type bookingsStaffV1StaffMember_universal_d_NestedAggregationResultsResultOneOf = NestedAggregationResultsResultOneOf;
  type bookingsStaffV1StaffMember_universal_d_AggregationType = AggregationType;
  const bookingsStaffV1StaffMember_universal_d_AggregationType: typeof AggregationType;
  type bookingsStaffV1StaffMember_universal_d_ValueResults = ValueResults;
  type bookingsStaffV1StaffMember_universal_d_RangeResults = RangeResults;
  type bookingsStaffV1StaffMember_universal_d_ScalarResult = ScalarResult;
  type bookingsStaffV1StaffMember_universal_d_NestedValueAggregationResult = NestedValueAggregationResult;
  type bookingsStaffV1StaffMember_universal_d_GroupByValueResults = GroupByValueResults;
  type bookingsStaffV1StaffMember_universal_d_AggregationResults = AggregationResults;
  type bookingsStaffV1StaffMember_universal_d_AggregationResultsResultOneOf = AggregationResultsResultOneOf;
  type bookingsStaffV1StaffMember_universal_d_DisconnectStaffMemberFromUserRequest = DisconnectStaffMemberFromUserRequest;
  type bookingsStaffV1StaffMember_universal_d_DisconnectStaffMemberFromUserResponse = DisconnectStaffMemberFromUserResponse;
  type bookingsStaffV1StaffMember_universal_d_AssignWorkingHoursScheduleRequest = AssignWorkingHoursScheduleRequest;
  type bookingsStaffV1StaffMember_universal_d_AssignWorkingHoursScheduleResponse = AssignWorkingHoursScheduleResponse;
  type bookingsStaffV1StaffMember_universal_d_AssignCustomScheduleRequest = AssignCustomScheduleRequest;
  type bookingsStaffV1StaffMember_universal_d_AssignCustomScheduleResponse = AssignCustomScheduleResponse;
  type bookingsStaffV1StaffMember_universal_d_RestoreStaffRequest = RestoreStaffRequest;
  type bookingsStaffV1StaffMember_universal_d_RestoreStaffResponse = RestoreStaffResponse;
  type bookingsStaffV1StaffMember_universal_d_ImportStaffMemberRequest = ImportStaffMemberRequest;
  type bookingsStaffV1StaffMember_universal_d_ImportStaffMemberResponse = ImportStaffMemberResponse;
  type bookingsStaffV1StaffMember_universal_d_PolicyRemovedFromContributor = PolicyRemovedFromContributor;
  type bookingsStaffV1StaffMember_universal_d_PolicyUpdatedForContributor = PolicyUpdatedForContributor;
  type bookingsStaffV1StaffMember_universal_d_ScheduleNotification = ScheduleNotification;
  type bookingsStaffV1StaffMember_universal_d_ScheduleNotificationEventOneOf = ScheduleNotificationEventOneOf;
  type bookingsStaffV1StaffMember_universal_d_ScheduleCreated = ScheduleCreated;
  type bookingsStaffV1StaffMember_universal_d_Schedule = Schedule;
  type bookingsStaffV1StaffMember_universal_d_RecurringInterval = RecurringInterval;
  type bookingsStaffV1StaffMember_universal_d_Interval = Interval;
  type bookingsStaffV1StaffMember_universal_d_Day = Day;
  const bookingsStaffV1StaffMember_universal_d_Day: typeof Day;
  type bookingsStaffV1StaffMember_universal_d_Frequency = Frequency;
  type bookingsStaffV1StaffMember_universal_d_LinkedSchedule = LinkedSchedule;
  type bookingsStaffV1StaffMember_universal_d_Transparency = Transparency;
  const bookingsStaffV1StaffMember_universal_d_Transparency: typeof Transparency;
  type bookingsStaffV1StaffMember_universal_d_RecurringIntervalType = RecurringIntervalType;
  const bookingsStaffV1StaffMember_universal_d_RecurringIntervalType: typeof RecurringIntervalType;
  type bookingsStaffV1StaffMember_universal_d_LocationsLocation = LocationsLocation;
  type bookingsStaffV1StaffMember_universal_d_LocationStatus = LocationStatus;
  const bookingsStaffV1StaffMember_universal_d_LocationStatus: typeof LocationStatus;
  type bookingsStaffV1StaffMember_universal_d_LocationsLocationType = LocationsLocationType;
  const bookingsStaffV1StaffMember_universal_d_LocationsLocationType: typeof LocationsLocationType;
  type bookingsStaffV1StaffMember_universal_d_LocationsAddress = LocationsAddress;
  type bookingsStaffV1StaffMember_universal_d_LocationsStreetAddress = LocationsStreetAddress;
  type bookingsStaffV1StaffMember_universal_d_LocationsAddressLocation = LocationsAddressLocation;
  type bookingsStaffV1StaffMember_universal_d_Rate = Rate;
  type bookingsStaffV1StaffMember_universal_d_Price = Price;
  type bookingsStaffV1StaffMember_universal_d_Availability = Availability;
  type bookingsStaffV1StaffMember_universal_d_AvailabilityConstraints = AvailabilityConstraints;
  type bookingsStaffV1StaffMember_universal_d_SplitInterval = SplitInterval;
  type bookingsStaffV1StaffMember_universal_d_Participant = Participant;
  type bookingsStaffV1StaffMember_universal_d_ApprovalStatus = ApprovalStatus;
  const bookingsStaffV1StaffMember_universal_d_ApprovalStatus: typeof ApprovalStatus;
  type bookingsStaffV1StaffMember_universal_d_ExternalCalendarOverrides = ExternalCalendarOverrides;
  type bookingsStaffV1StaffMember_universal_d_ScheduleStatus = ScheduleStatus;
  const bookingsStaffV1StaffMember_universal_d_ScheduleStatus: typeof ScheduleStatus;
  type bookingsStaffV1StaffMember_universal_d_Version = Version;
  type bookingsStaffV1StaffMember_universal_d_ConferenceProvider = ConferenceProvider;
  type bookingsStaffV1StaffMember_universal_d_CalendarConference = CalendarConference;
  type bookingsStaffV1StaffMember_universal_d_ConferenceType = ConferenceType;
  const bookingsStaffV1StaffMember_universal_d_ConferenceType: typeof ConferenceType;
  type bookingsStaffV1StaffMember_universal_d_ScheduleUpdated = ScheduleUpdated;
  type bookingsStaffV1StaffMember_universal_d_RecurringSessionsUpdated = RecurringSessionsUpdated;
  type bookingsStaffV1StaffMember_universal_d_Session = Session;
  type bookingsStaffV1StaffMember_universal_d_CalendarDateTime = CalendarDateTime;
  type bookingsStaffV1StaffMember_universal_d_LocalDateTime = LocalDateTime;
  type bookingsStaffV1StaffMember_universal_d_ExternalCalendarInfo = ExternalCalendarInfo;
  type bookingsStaffV1StaffMember_universal_d_CalendarType = CalendarType;
  const bookingsStaffV1StaffMember_universal_d_CalendarType: typeof CalendarType;
  type bookingsStaffV1StaffMember_universal_d_Status = Status;
  const bookingsStaffV1StaffMember_universal_d_Status: typeof Status;
  type bookingsStaffV1StaffMember_universal_d_SessionType = SessionType;
  const bookingsStaffV1StaffMember_universal_d_SessionType: typeof SessionType;
  type bookingsStaffV1StaffMember_universal_d_SessionVersion = SessionVersion;
  type bookingsStaffV1StaffMember_universal_d_ScheduleCancelled = ScheduleCancelled;
  type bookingsStaffV1StaffMember_universal_d_SessionCreated = SessionCreated;
  type bookingsStaffV1StaffMember_universal_d_SessionUpdated = SessionUpdated;
  type bookingsStaffV1StaffMember_universal_d_SessionCancelled = SessionCancelled;
  type bookingsStaffV1StaffMember_universal_d_AvailabilityPolicyUpdated = AvailabilityPolicyUpdated;
  type bookingsStaffV1StaffMember_universal_d_AvailabilityPolicy = AvailabilityPolicy;
  type bookingsStaffV1StaffMember_universal_d_IntervalSplit = IntervalSplit;
  type bookingsStaffV1StaffMember_universal_d_RecurringSessionSplit = RecurringSessionSplit;
  type bookingsStaffV1StaffMember_universal_d_ScheduleUnassignedFromUser = ScheduleUnassignedFromUser;
  type bookingsStaffV1StaffMember_universal_d_MultipleSessionsCreated = MultipleSessionsCreated;
  type bookingsStaffV1StaffMember_universal_d_ScheduleWithSessions = ScheduleWithSessions;
  type bookingsStaffV1StaffMember_universal_d_SitePropertiesOnScheduleCreation = SitePropertiesOnScheduleCreation;
  type bookingsStaffV1StaffMember_universal_d_MigrationEvent = MigrationEvent;
  type bookingsStaffV1StaffMember_universal_d_MigrationData = MigrationData;
  type bookingsStaffV1StaffMember_universal_d_StaffData = StaffData;
  type bookingsStaffV1StaffMember_universal_d_MetaSiteSpecialEvent = MetaSiteSpecialEvent;
  type bookingsStaffV1StaffMember_universal_d_MetaSiteSpecialEventPayloadOneOf = MetaSiteSpecialEventPayloadOneOf;
  type bookingsStaffV1StaffMember_universal_d_Asset = Asset;
  type bookingsStaffV1StaffMember_universal_d_State = State;
  const bookingsStaffV1StaffMember_universal_d_State: typeof State;
  type bookingsStaffV1StaffMember_universal_d_SiteCreatedContext = SiteCreatedContext;
  const bookingsStaffV1StaffMember_universal_d_SiteCreatedContext: typeof SiteCreatedContext;
  type bookingsStaffV1StaffMember_universal_d_Namespace = Namespace;
  const bookingsStaffV1StaffMember_universal_d_Namespace: typeof Namespace;
  type bookingsStaffV1StaffMember_universal_d_SiteTransferred = SiteTransferred;
  type bookingsStaffV1StaffMember_universal_d_SiteDeleted = SiteDeleted;
  type bookingsStaffV1StaffMember_universal_d_DeleteContext = DeleteContext;
  type bookingsStaffV1StaffMember_universal_d_DeleteStatus = DeleteStatus;
  const bookingsStaffV1StaffMember_universal_d_DeleteStatus: typeof DeleteStatus;
  type bookingsStaffV1StaffMember_universal_d_SiteUndeleted = SiteUndeleted;
  type bookingsStaffV1StaffMember_universal_d_SitePublished = SitePublished;
  type bookingsStaffV1StaffMember_universal_d_SiteUnpublished = SiteUnpublished;
  type bookingsStaffV1StaffMember_universal_d_SiteMarkedAsTemplate = SiteMarkedAsTemplate;
  type bookingsStaffV1StaffMember_universal_d_SiteMarkedAsWixSite = SiteMarkedAsWixSite;
  type bookingsStaffV1StaffMember_universal_d_ServiceProvisioned = ServiceProvisioned;
  type bookingsStaffV1StaffMember_universal_d_ServiceRemoved = ServiceRemoved;
  type bookingsStaffV1StaffMember_universal_d_SiteRenamed = SiteRenamed;
  type bookingsStaffV1StaffMember_universal_d_SiteHardDeleted = SiteHardDeleted;
  type bookingsStaffV1StaffMember_universal_d_NamespaceChanged = NamespaceChanged;
  type bookingsStaffV1StaffMember_universal_d_StudioAssigned = StudioAssigned;
  type bookingsStaffV1StaffMember_universal_d_StudioUnassigned = StudioUnassigned;
  const bookingsStaffV1StaffMember_universal_d_createStaffMember: typeof createStaffMember;
  type bookingsStaffV1StaffMember_universal_d_CreateStaffMemberOptions = CreateStaffMemberOptions;
  const bookingsStaffV1StaffMember_universal_d_getStaffMember: typeof getStaffMember;
  type bookingsStaffV1StaffMember_universal_d_GetStaffMemberOptions = GetStaffMemberOptions;
  const bookingsStaffV1StaffMember_universal_d_getDeletedStaffMember: typeof getDeletedStaffMember;
  type bookingsStaffV1StaffMember_universal_d_GetDeletedStaffMemberOptions = GetDeletedStaffMemberOptions;
  const bookingsStaffV1StaffMember_universal_d_listDeletedStaffMembers: typeof listDeletedStaffMembers;
  type bookingsStaffV1StaffMember_universal_d_ListDeletedStaffMembersOptions = ListDeletedStaffMembersOptions;
  const bookingsStaffV1StaffMember_universal_d_removeStaffMemberFromTrashBin: typeof removeStaffMemberFromTrashBin;
  const bookingsStaffV1StaffMember_universal_d_restoreStaffMemberFromTrashBin: typeof restoreStaffMemberFromTrashBin;
  type bookingsStaffV1StaffMember_universal_d_RestoreStaffMemberFromTrashBinOptions = RestoreStaffMemberFromTrashBinOptions;
  const bookingsStaffV1StaffMember_universal_d_updateStaffMember: typeof updateStaffMember;
  type bookingsStaffV1StaffMember_universal_d_UpdateStaffMember = UpdateStaffMember;
  type bookingsStaffV1StaffMember_universal_d_UpdateStaffMemberOptions = UpdateStaffMemberOptions;
  const bookingsStaffV1StaffMember_universal_d_deleteStaffMember: typeof deleteStaffMember;
  const bookingsStaffV1StaffMember_universal_d_queryStaffMembers: typeof queryStaffMembers;
  type bookingsStaffV1StaffMember_universal_d_QueryStaffMembersOptions = QueryStaffMembersOptions;
  type bookingsStaffV1StaffMember_universal_d_StaffMembersQueryResult = StaffMembersQueryResult;
  type bookingsStaffV1StaffMember_universal_d_StaffMembersQueryBuilder = StaffMembersQueryBuilder;
  const bookingsStaffV1StaffMember_universal_d_queryStaffMembersMultiLanguage: typeof queryStaffMembersMultiLanguage;
  type bookingsStaffV1StaffMember_universal_d_QueryStaffMembersMultiLanguageOptions = QueryStaffMembersMultiLanguageOptions;
  const bookingsStaffV1StaffMember_universal_d_countStaffMembers: typeof countStaffMembers;
  type bookingsStaffV1StaffMember_universal_d_CountStaffMembersOptions = CountStaffMembersOptions;
  const bookingsStaffV1StaffMember_universal_d_connectStaffMemberToUser: typeof connectStaffMemberToUser;
  type bookingsStaffV1StaffMember_universal_d_ConnectStaffMemberToUserOptions = ConnectStaffMemberToUserOptions;
  const bookingsStaffV1StaffMember_universal_d_searchStaffMembers: typeof searchStaffMembers;
  type bookingsStaffV1StaffMember_universal_d_SearchStaffMembersOptions = SearchStaffMembersOptions;
  const bookingsStaffV1StaffMember_universal_d_disconnectStaffMemberFromUser: typeof disconnectStaffMemberFromUser;
  type bookingsStaffV1StaffMember_universal_d_DisconnectStaffMemberFromUserOptions = DisconnectStaffMemberFromUserOptions;
  const bookingsStaffV1StaffMember_universal_d_assignWorkingHoursSchedule: typeof assignWorkingHoursSchedule;
  type bookingsStaffV1StaffMember_universal_d_AssignWorkingHoursScheduleOptions = AssignWorkingHoursScheduleOptions;
  const bookingsStaffV1StaffMember_universal_d_assignCustomSchedule: typeof assignCustomSchedule;
  type bookingsStaffV1StaffMember_universal_d_AssignCustomScheduleOptions = AssignCustomScheduleOptions;
  namespace bookingsStaffV1StaffMember_universal_d {
    export {
      bookingsStaffV1StaffMember_universal_d_StaffMember as StaffMember,
      bookingsStaffV1StaffMember_universal_d_MediaItem as MediaItem,
      bookingsStaffV1StaffMember_universal_d_MediaItemMediaOneOf as MediaItemMediaOneOf,
      bookingsStaffV1StaffMember_universal_d_Resource as Resource,
      bookingsStaffV1StaffMember_universal_d_WorkingHoursSchedule as WorkingHoursSchedule,
      bookingsStaffV1StaffMember_universal_d_EventSchedule as EventSchedule,
      bookingsStaffV1StaffMember_universal_d_AssociatedWixIdentity as AssociatedWixIdentity,
      IdentificationData$4 as IdentificationData,
      IdentificationDataIdOneOf$4 as IdentificationDataIdOneOf,
      IdentityType$2 as IdentityType,
      bookingsStaffV1StaffMember_universal_d_AssociatedWixIdentityConnectionStatusEnumConnectionStatus as AssociatedWixIdentityConnectionStatusEnumConnectionStatus,
      bookingsStaffV1StaffMember_universal_d_ConnectionState as ConnectionState,
      bookingsStaffV1StaffMember_universal_d_ConnectionStateConnectionState as ConnectionStateConnectionState,
      bookingsStaffV1StaffMember_universal_d_AssociatedConferencingProviders as AssociatedConferencingProviders,
      bookingsStaffV1StaffMember_universal_d_AssociatedConferencingProvider as AssociatedConferencingProvider,
      bookingsStaffV1StaffMember_universal_d_ConnectionStatus as ConnectionStatus,
      bookingsStaffV1StaffMember_universal_d_AssociatedConferencingAccounts as AssociatedConferencingAccounts,
      bookingsStaffV1StaffMember_universal_d_AssociatedConferencingAccount as AssociatedConferencingAccount,
      bookingsStaffV1StaffMember_universal_d_AssociatedConferencingAccountAccountOneOf as AssociatedConferencingAccountAccountOneOf,
      bookingsStaffV1StaffMember_universal_d_CustomConferenceAccount as CustomConferenceAccount,
      ExtendedFields$3 as ExtendedFields,
      bookingsStaffV1StaffMember_universal_d_CreateStaffMemberRequest as CreateStaffMemberRequest,
      bookingsStaffV1StaffMember_universal_d_RequestedFields as RequestedFields,
      bookingsStaffV1StaffMember_universal_d_CreateStaffMemberResponse as CreateStaffMemberResponse,
      bookingsStaffV1StaffMember_universal_d_StaffMemberFullyCreated as StaffMemberFullyCreated,
      bookingsStaffV1StaffMember_universal_d_GetStaffMemberRequest as GetStaffMemberRequest,
      bookingsStaffV1StaffMember_universal_d_GetStaffMemberResponse as GetStaffMemberResponse,
      bookingsStaffV1StaffMember_universal_d_GetDeletedStaffMemberRequest as GetDeletedStaffMemberRequest,
      bookingsStaffV1StaffMember_universal_d_GetDeletedStaffMemberResponse as GetDeletedStaffMemberResponse,
      bookingsStaffV1StaffMember_universal_d_ListDeletedStaffMembersRequest as ListDeletedStaffMembersRequest,
      CursorPaging$3 as CursorPaging,
      bookingsStaffV1StaffMember_universal_d_ListDeletedStaffMembersResponse as ListDeletedStaffMembersResponse,
      CursorPagingMetadata$2 as CursorPagingMetadata,
      Cursors$3 as Cursors,
      bookingsStaffV1StaffMember_universal_d_RemoveStaffMemberFromTrashBinRequest as RemoveStaffMemberFromTrashBinRequest,
      bookingsStaffV1StaffMember_universal_d_RemoveStaffMemberFromTrashBinResponse as RemoveStaffMemberFromTrashBinResponse,
      bookingsStaffV1StaffMember_universal_d_RestoreStaffMemberFromTrashBinRequest as RestoreStaffMemberFromTrashBinRequest,
      bookingsStaffV1StaffMember_universal_d_RestoreStaffMemberFromTrashBinResponse as RestoreStaffMemberFromTrashBinResponse,
      bookingsStaffV1StaffMember_universal_d_UpdateStaffMemberRequest as UpdateStaffMemberRequest,
      bookingsStaffV1StaffMember_universal_d_UpdateStaffMemberResponse as UpdateStaffMemberResponse,
      bookingsStaffV1StaffMember_universal_d_DeleteStaffMemberRequest as DeleteStaffMemberRequest,
      bookingsStaffV1StaffMember_universal_d_DeleteStaffMemberResponse as DeleteStaffMemberResponse,
      bookingsStaffV1StaffMember_universal_d_StaffMemberDisconnectedFromUser as StaffMemberDisconnectedFromUser,
      bookingsStaffV1StaffMember_universal_d_QueryStaffMembersRequest as QueryStaffMembersRequest,
      CursorQuery$1 as CursorQuery,
      CursorQueryPagingMethodOneOf$1 as CursorQueryPagingMethodOneOf,
      Sorting$3 as Sorting,
      SortOrder$3 as SortOrder,
      bookingsStaffV1StaffMember_universal_d_QueryStaffMembersResponse as QueryStaffMembersResponse,
      bookingsStaffV1StaffMember_universal_d_QueryStaffMembersMultiLanguageRequest as QueryStaffMembersMultiLanguageRequest,
      bookingsStaffV1StaffMember_universal_d_QueryStaffMembersMultiLanguageResponse as QueryStaffMembersMultiLanguageResponse,
      bookingsStaffV1StaffMember_universal_d_CountStaffMembersRequest as CountStaffMembersRequest,
      bookingsStaffV1StaffMember_universal_d_CountStaffMembersResponse as CountStaffMembersResponse,
      bookingsStaffV1StaffMember_universal_d_ConnectStaffMemberToUserRequest as ConnectStaffMemberToUserRequest,
      bookingsStaffV1StaffMember_universal_d_ConnectStaffMemberToUserResponse as ConnectStaffMemberToUserResponse,
      bookingsStaffV1StaffMember_universal_d_StaffMemberConnectedToUser as StaffMemberConnectedToUser,
      bookingsStaffV1StaffMember_universal_d_SearchStaffMembersRequest as SearchStaffMembersRequest,
      bookingsStaffV1StaffMember_universal_d_CursorSearch as CursorSearch,
      bookingsStaffV1StaffMember_universal_d_CursorSearchPagingMethodOneOf as CursorSearchPagingMethodOneOf,
      bookingsStaffV1StaffMember_universal_d_SearchDetails as SearchDetails,
      bookingsStaffV1StaffMember_universal_d_Mode as Mode,
      bookingsStaffV1StaffMember_universal_d_SearchStaffMembersResponse as SearchStaffMembersResponse,
      bookingsStaffV1StaffMember_universal_d_AggregationData as AggregationData,
      bookingsStaffV1StaffMember_universal_d_ValueAggregationResult as ValueAggregationResult,
      bookingsStaffV1StaffMember_universal_d_RangeAggregationResult as RangeAggregationResult,
      bookingsStaffV1StaffMember_universal_d_ScalarType as ScalarType,
      bookingsStaffV1StaffMember_universal_d_NestedAggregationResults as NestedAggregationResults,
      bookingsStaffV1StaffMember_universal_d_NestedAggregationResultsResultOneOf as NestedAggregationResultsResultOneOf,
      bookingsStaffV1StaffMember_universal_d_AggregationType as AggregationType,
      bookingsStaffV1StaffMember_universal_d_ValueResults as ValueResults,
      bookingsStaffV1StaffMember_universal_d_RangeResults as RangeResults,
      bookingsStaffV1StaffMember_universal_d_ScalarResult as ScalarResult,
      bookingsStaffV1StaffMember_universal_d_NestedValueAggregationResult as NestedValueAggregationResult,
      bookingsStaffV1StaffMember_universal_d_GroupByValueResults as GroupByValueResults,
      bookingsStaffV1StaffMember_universal_d_AggregationResults as AggregationResults,
      bookingsStaffV1StaffMember_universal_d_AggregationResultsResultOneOf as AggregationResultsResultOneOf,
      bookingsStaffV1StaffMember_universal_d_DisconnectStaffMemberFromUserRequest as DisconnectStaffMemberFromUserRequest,
      bookingsStaffV1StaffMember_universal_d_DisconnectStaffMemberFromUserResponse as DisconnectStaffMemberFromUserResponse,
      bookingsStaffV1StaffMember_universal_d_AssignWorkingHoursScheduleRequest as AssignWorkingHoursScheduleRequest,
      bookingsStaffV1StaffMember_universal_d_AssignWorkingHoursScheduleResponse as AssignWorkingHoursScheduleResponse,
      bookingsStaffV1StaffMember_universal_d_AssignCustomScheduleRequest as AssignCustomScheduleRequest,
      bookingsStaffV1StaffMember_universal_d_AssignCustomScheduleResponse as AssignCustomScheduleResponse,
      bookingsStaffV1StaffMember_universal_d_RestoreStaffRequest as RestoreStaffRequest,
      bookingsStaffV1StaffMember_universal_d_RestoreStaffResponse as RestoreStaffResponse,
      bookingsStaffV1StaffMember_universal_d_ImportStaffMemberRequest as ImportStaffMemberRequest,
      bookingsStaffV1StaffMember_universal_d_ImportStaffMemberResponse as ImportStaffMemberResponse,
      Empty$1 as Empty,
      bookingsStaffV1StaffMember_universal_d_PolicyRemovedFromContributor as PolicyRemovedFromContributor,
      bookingsStaffV1StaffMember_universal_d_PolicyUpdatedForContributor as PolicyUpdatedForContributor,
      DomainEvent$3 as DomainEvent,
      DomainEventBodyOneOf$3 as DomainEventBodyOneOf,
      EntityCreatedEvent$3 as EntityCreatedEvent,
      RestoreInfo$3 as RestoreInfo,
      EntityUpdatedEvent$3 as EntityUpdatedEvent,
      EntityDeletedEvent$3 as EntityDeletedEvent,
      ActionEvent$3 as ActionEvent,
      bookingsStaffV1StaffMember_universal_d_ScheduleNotification as ScheduleNotification,
      bookingsStaffV1StaffMember_universal_d_ScheduleNotificationEventOneOf as ScheduleNotificationEventOneOf,
      bookingsStaffV1StaffMember_universal_d_ScheduleCreated as ScheduleCreated,
      bookingsStaffV1StaffMember_universal_d_Schedule as Schedule,
      bookingsStaffV1StaffMember_universal_d_RecurringInterval as RecurringInterval,
      bookingsStaffV1StaffMember_universal_d_Interval as Interval,
      bookingsStaffV1StaffMember_universal_d_Day as Day,
      bookingsStaffV1StaffMember_universal_d_Frequency as Frequency,
      bookingsStaffV1StaffMember_universal_d_LinkedSchedule as LinkedSchedule,
      bookingsStaffV1StaffMember_universal_d_Transparency as Transparency,
      bookingsStaffV1StaffMember_universal_d_RecurringIntervalType as RecurringIntervalType,
      Location$2 as Location,
      LocationType$2 as LocationType,
      Address$3 as Address,
      AddressStreetOneOf$2 as AddressStreetOneOf,
      StreetAddress$2 as StreetAddress,
      AddressLocation$2 as AddressLocation,
      Subdivision$2 as Subdivision,
      bookingsStaffV1StaffMember_universal_d_LocationsLocation as LocationsLocation,
      bookingsStaffV1StaffMember_universal_d_LocationStatus as LocationStatus,
      bookingsStaffV1StaffMember_universal_d_LocationsLocationType as LocationsLocationType,
      bookingsStaffV1StaffMember_universal_d_LocationsAddress as LocationsAddress,
      bookingsStaffV1StaffMember_universal_d_LocationsStreetAddress as LocationsStreetAddress,
      bookingsStaffV1StaffMember_universal_d_LocationsAddressLocation as LocationsAddressLocation,
      BusinessSchedule$1 as BusinessSchedule,
      TimePeriod$1 as TimePeriod,
      DayOfWeek$1 as DayOfWeek,
      SpecialHourPeriod$1 as SpecialHourPeriod,
      bookingsStaffV1StaffMember_universal_d_Rate as Rate,
      bookingsStaffV1StaffMember_universal_d_Price as Price,
      bookingsStaffV1StaffMember_universal_d_Availability as Availability,
      bookingsStaffV1StaffMember_universal_d_AvailabilityConstraints as AvailabilityConstraints,
      bookingsStaffV1StaffMember_universal_d_SplitInterval as SplitInterval,
      bookingsStaffV1StaffMember_universal_d_Participant as Participant,
      bookingsStaffV1StaffMember_universal_d_ApprovalStatus as ApprovalStatus,
      bookingsStaffV1StaffMember_universal_d_ExternalCalendarOverrides as ExternalCalendarOverrides,
      bookingsStaffV1StaffMember_universal_d_ScheduleStatus as ScheduleStatus,
      bookingsStaffV1StaffMember_universal_d_Version as Version,
      bookingsStaffV1StaffMember_universal_d_ConferenceProvider as ConferenceProvider,
      bookingsStaffV1StaffMember_universal_d_CalendarConference as CalendarConference,
      bookingsStaffV1StaffMember_universal_d_ConferenceType as ConferenceType,
      bookingsStaffV1StaffMember_universal_d_ScheduleUpdated as ScheduleUpdated,
      bookingsStaffV1StaffMember_universal_d_RecurringSessionsUpdated as RecurringSessionsUpdated,
      bookingsStaffV1StaffMember_universal_d_Session as Session,
      bookingsStaffV1StaffMember_universal_d_CalendarDateTime as CalendarDateTime,
      bookingsStaffV1StaffMember_universal_d_LocalDateTime as LocalDateTime,
      bookingsStaffV1StaffMember_universal_d_ExternalCalendarInfo as ExternalCalendarInfo,
      bookingsStaffV1StaffMember_universal_d_CalendarType as CalendarType,
      bookingsStaffV1StaffMember_universal_d_Status as Status,
      bookingsStaffV1StaffMember_universal_d_SessionType as SessionType,
      bookingsStaffV1StaffMember_universal_d_SessionVersion as SessionVersion,
      ParticipantNotification$3 as ParticipantNotification,
      bookingsStaffV1StaffMember_universal_d_ScheduleCancelled as ScheduleCancelled,
      bookingsStaffV1StaffMember_universal_d_SessionCreated as SessionCreated,
      bookingsStaffV1StaffMember_universal_d_SessionUpdated as SessionUpdated,
      bookingsStaffV1StaffMember_universal_d_SessionCancelled as SessionCancelled,
      bookingsStaffV1StaffMember_universal_d_AvailabilityPolicyUpdated as AvailabilityPolicyUpdated,
      bookingsStaffV1StaffMember_universal_d_AvailabilityPolicy as AvailabilityPolicy,
      bookingsStaffV1StaffMember_universal_d_IntervalSplit as IntervalSplit,
      bookingsStaffV1StaffMember_universal_d_RecurringSessionSplit as RecurringSessionSplit,
      bookingsStaffV1StaffMember_universal_d_ScheduleUnassignedFromUser as ScheduleUnassignedFromUser,
      bookingsStaffV1StaffMember_universal_d_MultipleSessionsCreated as MultipleSessionsCreated,
      bookingsStaffV1StaffMember_universal_d_ScheduleWithSessions as ScheduleWithSessions,
      bookingsStaffV1StaffMember_universal_d_SitePropertiesOnScheduleCreation as SitePropertiesOnScheduleCreation,
      bookingsStaffV1StaffMember_universal_d_MigrationEvent as MigrationEvent,
      bookingsStaffV1StaffMember_universal_d_MigrationData as MigrationData,
      bookingsStaffV1StaffMember_universal_d_StaffData as StaffData,
      bookingsStaffV1StaffMember_universal_d_MetaSiteSpecialEvent as MetaSiteSpecialEvent,
      bookingsStaffV1StaffMember_universal_d_MetaSiteSpecialEventPayloadOneOf as MetaSiteSpecialEventPayloadOneOf,
      bookingsStaffV1StaffMember_universal_d_Asset as Asset,
      bookingsStaffV1StaffMember_universal_d_State as State,
      SiteCreated$1 as SiteCreated,
      bookingsStaffV1StaffMember_universal_d_SiteCreatedContext as SiteCreatedContext,
      bookingsStaffV1StaffMember_universal_d_Namespace as Namespace,
      bookingsStaffV1StaffMember_universal_d_SiteTransferred as SiteTransferred,
      bookingsStaffV1StaffMember_universal_d_SiteDeleted as SiteDeleted,
      bookingsStaffV1StaffMember_universal_d_DeleteContext as DeleteContext,
      bookingsStaffV1StaffMember_universal_d_DeleteStatus as DeleteStatus,
      bookingsStaffV1StaffMember_universal_d_SiteUndeleted as SiteUndeleted,
      bookingsStaffV1StaffMember_universal_d_SitePublished as SitePublished,
      bookingsStaffV1StaffMember_universal_d_SiteUnpublished as SiteUnpublished,
      bookingsStaffV1StaffMember_universal_d_SiteMarkedAsTemplate as SiteMarkedAsTemplate,
      bookingsStaffV1StaffMember_universal_d_SiteMarkedAsWixSite as SiteMarkedAsWixSite,
      bookingsStaffV1StaffMember_universal_d_ServiceProvisioned as ServiceProvisioned,
      bookingsStaffV1StaffMember_universal_d_ServiceRemoved as ServiceRemoved,
      bookingsStaffV1StaffMember_universal_d_SiteRenamed as SiteRenamed,
      bookingsStaffV1StaffMember_universal_d_SiteHardDeleted as SiteHardDeleted,
      bookingsStaffV1StaffMember_universal_d_NamespaceChanged as NamespaceChanged,
      bookingsStaffV1StaffMember_universal_d_StudioAssigned as StudioAssigned,
      bookingsStaffV1StaffMember_universal_d_StudioUnassigned as StudioUnassigned,
      MessageEnvelope$3 as MessageEnvelope,
      WebhooksIdentificationData$1 as WebhooksIdentificationData,
      WebhooksIdentificationDataIdOneOf$1 as WebhooksIdentificationDataIdOneOf,
      WebhookIdentityType$3 as WebhookIdentityType,
      bookingsStaffV1StaffMember_universal_d_createStaffMember as createStaffMember,
      bookingsStaffV1StaffMember_universal_d_CreateStaffMemberOptions as CreateStaffMemberOptions,
      bookingsStaffV1StaffMember_universal_d_getStaffMember as getStaffMember,
      bookingsStaffV1StaffMember_universal_d_GetStaffMemberOptions as GetStaffMemberOptions,
      bookingsStaffV1StaffMember_universal_d_getDeletedStaffMember as getDeletedStaffMember,
      bookingsStaffV1StaffMember_universal_d_GetDeletedStaffMemberOptions as GetDeletedStaffMemberOptions,
      bookingsStaffV1StaffMember_universal_d_listDeletedStaffMembers as listDeletedStaffMembers,
      bookingsStaffV1StaffMember_universal_d_ListDeletedStaffMembersOptions as ListDeletedStaffMembersOptions,
      bookingsStaffV1StaffMember_universal_d_removeStaffMemberFromTrashBin as removeStaffMemberFromTrashBin,
      bookingsStaffV1StaffMember_universal_d_restoreStaffMemberFromTrashBin as restoreStaffMemberFromTrashBin,
      bookingsStaffV1StaffMember_universal_d_RestoreStaffMemberFromTrashBinOptions as RestoreStaffMemberFromTrashBinOptions,
      bookingsStaffV1StaffMember_universal_d_updateStaffMember as updateStaffMember,
      bookingsStaffV1StaffMember_universal_d_UpdateStaffMember as UpdateStaffMember,
      bookingsStaffV1StaffMember_universal_d_UpdateStaffMemberOptions as UpdateStaffMemberOptions,
      bookingsStaffV1StaffMember_universal_d_deleteStaffMember as deleteStaffMember,
      bookingsStaffV1StaffMember_universal_d_queryStaffMembers as queryStaffMembers,
      bookingsStaffV1StaffMember_universal_d_QueryStaffMembersOptions as QueryStaffMembersOptions,
      bookingsStaffV1StaffMember_universal_d_StaffMembersQueryResult as StaffMembersQueryResult,
      bookingsStaffV1StaffMember_universal_d_StaffMembersQueryBuilder as StaffMembersQueryBuilder,
      bookingsStaffV1StaffMember_universal_d_queryStaffMembersMultiLanguage as queryStaffMembersMultiLanguage,
      bookingsStaffV1StaffMember_universal_d_QueryStaffMembersMultiLanguageOptions as QueryStaffMembersMultiLanguageOptions,
      bookingsStaffV1StaffMember_universal_d_countStaffMembers as countStaffMembers,
      bookingsStaffV1StaffMember_universal_d_CountStaffMembersOptions as CountStaffMembersOptions,
      bookingsStaffV1StaffMember_universal_d_connectStaffMemberToUser as connectStaffMemberToUser,
      bookingsStaffV1StaffMember_universal_d_ConnectStaffMemberToUserOptions as ConnectStaffMemberToUserOptions,
      bookingsStaffV1StaffMember_universal_d_searchStaffMembers as searchStaffMembers,
      bookingsStaffV1StaffMember_universal_d_SearchStaffMembersOptions as SearchStaffMembersOptions,
      bookingsStaffV1StaffMember_universal_d_disconnectStaffMemberFromUser as disconnectStaffMemberFromUser,
      bookingsStaffV1StaffMember_universal_d_DisconnectStaffMemberFromUserOptions as DisconnectStaffMemberFromUserOptions,
      bookingsStaffV1StaffMember_universal_d_assignWorkingHoursSchedule as assignWorkingHoursSchedule,
      bookingsStaffV1StaffMember_universal_d_AssignWorkingHoursScheduleOptions as AssignWorkingHoursScheduleOptions,
      bookingsStaffV1StaffMember_universal_d_assignCustomSchedule as assignCustomSchedule,
      bookingsStaffV1StaffMember_universal_d_AssignCustomScheduleOptions as AssignCustomScheduleOptions,
    };
  }
  
  /**
   * A booking policy is a set of rules that determine how customers can book a
   * service, including timeframes for booking, canceling, or rescheduling.
   */
  interface BookingPolicy {
      /**
       * ID of the booking policy.
       * @readonly
       */
      _id?: string | null;
      /**
       * Revision number, which increments by 1 each time the booking policy is updated.
       * To prevent conflicting changes, the current `revision` must be passed when
       * updating the booking policy.
       * @readonly
       */
      revision?: string | null;
      /**
       * Date and time the booking policy was created in `YYYY-MM-DDThh:mm:ss.sssZ` format.
       * @readonly
       */
      _createdDate?: Date | null;
      /**
       * Date and time the booking policy was updated in `YYYY-MM-DDThh:mm:ss.sssZ` format.
       * @readonly
       */
      _updatedDate?: Date | null;
      /** Name of the booking policy. */
      name?: string | null;
      /**
       * Custom description for the booking policy and whether it's displayed to the
       * participant.
       */
      customPolicyDescription?: PolicyDescription;
      /**
       * Whether the booking policy is the default.
       * @readonly
       */
      default?: boolean | null;
      /** Rule for limiting early bookings. */
      limitEarlyBookingPolicy?: LimitEarlyBookingPolicy;
      /**
       * Rule for limiting late bookings. This rule and `bookAfterStartPolicy` can't
       * be both enabled at the same time.
       */
      limitLateBookingPolicy?: LimitLateBookingPolicy;
      /**
       * Rule for booking after the start of a session or course. This rule and
       * `limitLateBookingPolicy` can't be both enabled at the same time.
       */
      bookAfterStartPolicy?: BookAfterStartPolicy;
      /** Rule for canceling a booking. */
      cancellationPolicy?: CancellationPolicy;
      /** Rule for rescheduling a booking. */
      reschedulePolicy?: ReschedulePolicy;
      /** Waitlist rule for the service. */
      waitlistPolicy?: WaitlistPolicy;
      /** Rule for participants per booking. */
      participantsPolicy?: ParticipantsPolicy;
      /**
       * Rule for allocating resources.
       * @internal
       */
      resourcesPolicy?: ResourcesPolicy;
      /** Rules for cancellation fees. */
      cancellationFeePolicy?: CancellationFeePolicy;
      /** Rule for saving credit card details. */
      saveCreditCardPolicy?: SaveCreditCardPolicy;
      /** Extensions enabling users to save custom data related to the booking policies. */
      extendedFields?: ExtendedFields$2;
  }
  /** A description of the booking policy to display to participants. */
  interface PolicyDescription {
      /**
       * Whether the description is displayed to the participant. `true` means the
       * description is displayed.
       *
       * Default: `false`
       */
      enabled?: boolean;
      /**
       * Description of the booking policy.
       *
       * Default: Empty
       * Max length: 2500 characters
       */
      description?: string;
  }
  /** The rule for limiting early bookings. */
  interface LimitEarlyBookingPolicy {
      /**
       * Whether there's a limit about how early a customer can book. `false` means there's
       * no limit to the earliest supported booking time.
       *
       * Default: `false`
       */
      enabled?: boolean;
      /**
       * Maximum number of minutes before the start of a session or course customers can book.
       * Must be greater than `limitLateBookingPolicy.latestBookingInMinutes`.
       *
       * Default: `10080` minutes (7 days)
       * Min: `1` minute
       */
      earliestBookingInMinutes?: number;
  }
  /**
   * Rule limiting late bookings.
   *
   * This rule and `bookAfterStartPolicy` can't be both enabled at the same time.
   */
  interface LimitLateBookingPolicy {
      /**
       * Whether there's a limit about how late customers can book. `false` means
       * customers can book up to the last minute. If set to `true`,
       * `bookAfterStartPolicy.enabled` must be set to `false`.
       *
       * Default: `false`
       */
      enabled?: boolean;
      /**
       * Minimum number of minutes before the start of the session customers can book.
       * For courses, this is relative to the start time of the next session and doesn't
       * consider course sessions in the past. This value must be less than
       * `limitEarlyBookingPolicy.earliestBookingInMinutes`.
       *
       * Default: `1440` minutes (1 day)
       * Min: `1` minute
       */
      latestBookingInMinutes?: number;
  }
  /**
   * The rule for whether a session can be booked after the start of the schedule.
   * This rule and `LimitLateBookingPolicy` cannot be enabled at the same time. So if this rule
   * is enabled, the `LimitLateBookingPolicy` rule must be disabled.
   */
  interface BookAfterStartPolicy {
      /**
       * Whether customers can book after the session has started. `true` means
       * customers can book after the session has started. For courses, this refers to
       * the start of the last course session. If set to `true`,
       * `limitLateBookingPolicy.enabled` must be set to `false`.
       *
       * Default: `false`
       */
      enabled?: boolean;
  }
  /** The rule for canceling a booked session. */
  interface CancellationPolicy {
      /**
       * Whether customers can cancel the booking. `true` means customers can cancel
       * the booking.
       *
       * Default: `false`
       */
      enabled?: boolean;
      /**
       * Whether there's a limit on the latest cancellation time. `false` means customers
       * can cancel the booking until the last minute before the course or session starts.
       *
       * Default: `false`
       */
      limitLatestCancellation?: boolean;
      /**
       * Minimum number of minutes before the start of the session customers can cancel.
       * For courses, this refers to the start of the first course session.
       *
       * Default: `1440` minutes (1 day)
       * Min: `1` minute
       */
      latestCancellationInMinutes?: number;
  }
  /** The rule for rescheduling a booked session. */
  interface ReschedulePolicy {
      /**
       * Whether customers can reschedule a booking for an appointment-based service.
       * `true` means customers can reschedule.
       *
       * Default: `false`
       */
      enabled?: boolean;
      /**
       * Whether there's a limit on the latest supported rescheduling time. `false`
       * means customers can reschedule until the last minute before the session start.
       *
       * Default: `false`
       */
      limitLatestReschedule?: boolean;
      /**
       * Minimum number of minutes before the session start session customers can
       * reschedule their booking.
       *
       * Default: `1440` minutes (1 day)
       * Min: `1` minute
       */
      latestRescheduleInMinutes?: number;
  }
  /** The rule for the waitlist. */
  interface WaitlistPolicy {
      /**
       * Whether the service has a waitlist. `true` means there's a waitlist.
       *
       * Default: `false`
       */
      enabled?: boolean;
      /**
       * Number of spots in the waitlist.
       *
       * Default: `10` spots
       * Min: `1` spot
       */
      capacity?: number;
      /**
       * Time in minutes the potential customer is given to book after they've been
       * notified that a spot has opened up for them. If they don't respond in time,
       * the open spot is offered to the next potential customer on the waitlist.
       *
       * Default: `10` minutes
       * Min: `1` minute
       */
      reservationTimeInMinutes?: number;
  }
  /** The rule for the maximum number of participants per booking. */
  interface ParticipantsPolicy {
      /**
       * Whether there's a maximum number of participants per booking. `false` means
       * there is no maximum.
       *
       * Default: `false`
       * Private because not limiting participants per booking is not supported by Bookings flows today
       * @internal
       */
      enabled?: boolean;
      /**
       * Maximum number of participants per booking.
       *
       * Default: `1` participant
       * Min: `1` participant
       */
      maxParticipantsPerBooking?: number;
  }
  /** The rule regarding the allocation of resources (e.g. staff members). */
  interface ResourcesPolicy {
      /**
       * Whether the customer must select a resource, for example a staff member, when
       * booking. `false` means the customer can book without selecting a resource.
       *
       * Default: `false`
       */
      enabled?: boolean;
      /**
       * Whether Wix Bookings automatically assigns a resource, for example a staff
       * member, to the booking. `false` means the customer must select the resource
       * themselves and Wix Bookings doesn't assign it automatically.
       *
       * Default: `false`
       */
      autoAssignAllowed?: boolean;
  }
  interface CancellationFeePolicy {
      /**
       * Whether customers must pay a cancellation fee when canceling a booking.
       *
       * Default: `false`
       */
      enabled?: boolean;
      /**
       * Time windows relative to the session start during which customers can cancel
       * their booking. Each window includes details about the fee for canceling within it.
       */
      cancellationWindows?: CancellationWindow[];
      /**
       * Whether Wix automatically charges the cancellation fee from the customer once
       * they cancel their booking.
       *
       * Default: `true`
       */
      autoCollectFeeEnabled?: boolean | null;
  }
  /**
   * Money.
   * Default format to use. Sufficiently compliant with majority of standards: w3c, ISO 4217, ISO 20022, ISO 8583:2003.
   */
  interface Money {
      /** Monetary amount. Decimal string with a period as a decimal separator (e.g., 3.99). Optionally, a single (-), to indicate that the amount is negative. */
      value?: string;
      /**
       * Currency code. Must be valid ISO 4217 currency code (e.g., USD).
       * @readonly
       */
      currency?: string;
      /** Monetary amount. Decimal string in local format (e.g., 1 000,30). Optionally, a single (-), to indicate that the amount is negative. */
      formattedValue?: string | null;
  }
  interface CancellationWindow extends CancellationWindowFeeOneOf {
      /** Fixed amount customers must pay when canceling the booking within this window. */
      amount?: Money;
      /**
       * Percentage of the booking price customers must pay when canceling within
       * this window.
       *
       * Min: `0.01` percent
       * Max: `100` percent
       */
      percentage?: string;
      /**
       * Start of the cancellation window in minutes before the session start. For
       * courses, this refers to the start of the first course session.
       */
      startInMinutes?: number | null;
  }
  /** @oneof */
  interface CancellationWindowFeeOneOf {
      /** Fixed amount customers must pay when canceling the booking within this window. */
      amount?: Money;
      /**
       * Percentage of the booking price customers must pay when canceling within
       * this window.
       *
       * Min: `0.01` percent
       * Max: `100` percent
       */
      percentage?: string;
  }
  interface SaveCreditCardPolicy {
      /**
       * Whether Wix stores credit card details of the customer. Storing the details
       * allows Wix to prefill the [checkout](https://dev.wix.com/docs/rest/business-solutions/e-commerce/checkout/introduction)
       * and thus increases the likelyhood that the customer completes the booking
       * process.
       *
       * Default: `false`
       */
      enabled?: boolean;
  }
  interface ExtendedFields$2 {
      /**
       * Extended field data. Each key corresponds to the namespace of the app that created the extended fields.
       * The value of each key is structured according to the schema defined when the extended fields were configured.
       *
       * You can only access fields for which you have the appropriate permissions.
       *
       * Learn more about [extended fields](https://dev.wix.com/docs/rest/articles/getting-started/extended-fields).
       */
      namespaces?: Record<string, Record<string, any>>;
  }
  /** This event is triggered when a different booking policy has been set as the default policy. */
  interface DefaultBookingPolicySet {
      /** The new default booking policy. */
      currentDefaultBookingPolicy?: BookingPolicy;
      /**
       * The booking policy that was the default before this endpoint was called.
       * This field will be empty if there was no default booking policy before this method was called.
       */
      previousDefaultBookingPolicy?: BookingPolicy;
  }
  interface CreateBookingPolicyRequest {
      /** Booking policy to create. */
      bookingPolicy: BookingPolicy;
  }
  interface CreateBookingPolicyResponse {
      /** Created booking policy. */
      bookingPolicy?: BookingPolicy;
  }
  interface GetBookingPolicyRequest {
      /** ID of the booking policy to retrieve. */
      bookingPolicyId: string;
  }
  interface GetBookingPolicyResponse {
      /** Retrieved booking policy. */
      bookingPolicy?: BookingPolicy;
  }
  interface GetStrictestBookingPolicyRequest {
      /** IDs of the booking policies for which to retrieve the strictest rules for. */
      bookingPolicyIds: string[];
  }
  interface GetStrictestBookingPolicyResponse {
      /**
       * Hypothetical `bookingPolicy` object that combines the strictest version of
       * each rule. `bookingPolicy.id` is `null` and the returned object isn't actually
       * created. To create a new policy, you can use
       * [Create Booking Policy](https://dev.wix.com/docs/rest/business-solutions/bookings/services/booking-policy/create-booking-policy).
       */
      bookingPolicy?: BookingPolicy;
  }
  interface UpdateBookingPolicyRequest {
      /** Booking policy to update. */
      bookingPolicy: BookingPolicy;
      /**
       * Explicit list of fields to update
       * @internal
       */
      mask?: string[];
  }
  interface UpdateBookingPolicyResponse {
      /** Updated booking policy. */
      bookingPolicy?: BookingPolicy;
  }
  interface SetDefaultBookingPolicyRequest {
      /** ID of the booking policy that's set as default. */
      bookingPolicyId: string;
  }
  interface SetDefaultBookingPolicyResponse {
      /** New default booking policy. */
      currentDefaultBookingPolicy?: BookingPolicy;
      /**
       * Previous default booking policy. Not available if the provided booking policy
       * was already the default.
       */
      previousDefaultBookingPolicy?: BookingPolicy;
  }
  interface DeleteBookingPolicyRequest {
      /** ID of the booking policy to delete. */
      bookingPolicyId: string;
  }
  interface DeleteBookingPolicyResponse {
  }
  interface QueryBookingPoliciesRequest {
      /**
       * The query by which to select booking policies. See
       * [the supported filters article](https://dev.wix.com/docs/rest/business-solutions/bookings/services/booking-policy/supported-filters)
       * for details.
       */
      query: CursorQuery;
  }
  interface CursorQuery extends CursorQueryPagingMethodOneOf {
      /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
      cursorPaging?: CursorPaging$2;
      /**
       * Filter object in the following format:
       * `"filter" : {
       * "fieldName1": "value1",
       * "fieldName2":{"$operator":"value2"}
       * }`
       * Example of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`, `$contains`
       */
      filter?: Record<string, any> | null;
      /**
       * Sort object in the following format:
       * `[{"fieldName":"sortField1","order":"ASC"},{"fieldName":"sortField2","order":"DESC"}]`
       */
      sort?: Sorting$2[];
  }
  /** @oneof */
  interface CursorQueryPagingMethodOneOf {
      /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
      cursorPaging?: CursorPaging$2;
  }
  interface Sorting$2 {
      /** Name of the field to sort by. */
      fieldName?: string;
      /** Sort order. */
      order?: SortOrder$2;
  }
  enum SortOrder$2 {
      ASC = "ASC",
      DESC = "DESC"
  }
  interface CursorPaging$2 {
      /** Number of items to load. */
      limit?: number | null;
      /**
       * Pointer to the next or previous page in the list of results.
       *
       * You can get the relevant cursor token
       * from the `pagingMetadata` object in the previous call's response.
       * Not relevant for the first request.
       */
      cursor?: string | null;
  }
  interface QueryBookingPoliciesResponse {
      /** Retrieved booking policies. */
      bookingPolicies?: BookingPolicy[];
      /** Paging metadata. */
      pagingMetadata?: CursorPagingMetadata$1;
  }
  interface CursorPagingMetadata$1 {
      /** Number of items returned in the response. */
      count?: number | null;
      /** Offset that was requested. */
      cursors?: Cursors$2;
      /**
       * Indicates if there are more results after the current page.
       * If `true`, another page of results can be retrieved.
       * If `false`, this is the last page.
       */
      hasNext?: boolean | null;
  }
  interface Cursors$2 {
      /** Cursor pointing to next page in the list of results. */
      next?: string | null;
      /** Cursor pointing to previous page in the list of results. */
      prev?: string | null;
  }
  interface CountBookingPoliciesRequest {
      /**
       * Filter to base the count on. See
       * [the supported filters article](https://dev.wix.com/docs/rest/business-solutions/bookings/services/booking-policy/supported-filters)
       * for details.
       */
      filter?: Record<string, any> | null;
  }
  interface CountBookingPoliciesResponse {
      /** Number of booking policies matching the provided filter. */
      count?: number;
  }
  interface UpdateAllPoliciesRequest {
      /** Fields to set to all booking policies. */
      bookingPolicy?: BookingPolicy;
      /**
       * List of fields to update
       * @internal
       */
      mask?: string[];
  }
  interface UpdateAllPoliciesResponse {
  }
  interface CreateMissingDefaultPolicyRequest {
  }
  interface CreateMissingDefaultPolicyResponse {
      /** The default booking policy. */
      defaultBookingPolicy?: BookingPolicy;
      /** Whether a new default policy was created. */
      wasANewPolicyCreated?: boolean;
  }
  interface DomainEvent$2 extends DomainEventBodyOneOf$2 {
      createdEvent?: EntityCreatedEvent$2;
      updatedEvent?: EntityUpdatedEvent$2;
      deletedEvent?: EntityDeletedEvent$2;
      actionEvent?: ActionEvent$2;
      /**
       * Unique event ID.
       * Allows clients to ignore duplicate webhooks.
       */
      _id?: string;
      /**
       * Assumes actions are also always typed to an entity_type
       * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
       */
      entityFqdn?: string;
      /**
       * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
       * This is although the created/updated/deleted notion is duplication of the oneof types
       * Example: created/updated/deleted/started/completed/email_opened
       */
      slug?: string;
      /** ID of the entity associated with the event. */
      entityId?: string;
      /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
      eventTime?: Date | null;
      /**
       * Whether the event was triggered as a result of a privacy regulation application
       * (for example, GDPR).
       */
      triggeredByAnonymizeRequest?: boolean | null;
      /** If present, indicates the action that triggered the event. */
      originatedFrom?: string | null;
      /**
       * A sequence number defining the order of updates to the underlying entity.
       * For example, given that some entity was updated at 16:00 and than again at 16:01,
       * it is guaranteed that the sequence number of the second update is strictly higher than the first.
       * As the consumer, you can use this value to ensure that you handle messages in the correct order.
       * To do so, you will need to persist this number on your end, and compare the sequence number from the
       * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
       */
      entityEventSequence?: string | null;
  }
  /** @oneof */
  interface DomainEventBodyOneOf$2 {
      createdEvent?: EntityCreatedEvent$2;
      updatedEvent?: EntityUpdatedEvent$2;
      deletedEvent?: EntityDeletedEvent$2;
      actionEvent?: ActionEvent$2;
  }
  interface EntityCreatedEvent$2 {
      entityAsJson?: string;
      /**
       * Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity
       * @internal
       */
      triggeredByUndelete?: boolean | null;
      /** Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity */
      restoreInfo?: RestoreInfo$2;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface RestoreInfo$2 {
      deletedDate?: Date | null;
  }
  interface EntityUpdatedEvent$2 {
      /**
       * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
       * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
       * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
       */
      currentEntityAsJson?: string;
      /**
       * This field is currently part of the of the EntityUpdatedEvent msg, but scala/node libraries which implements the domain events standard
       * wont populate it / have any reference to it in the API.
       * The main reason for it is that fetching the old entity from the DB will have a performance hit on an update operation so unless truly needed,
       * the developer should send only the new (current) entity.
       * An additional reason is not wanting to send this additional entity over the wire (kafka) since in some cases it can be really big
       * Developers that must reflect the old entity will have to implement their own domain event sender mechanism which will follow the DomainEvent proto message.
       * @internal
       * @deprecated
       */
      previousEntityAsJson?: string | null;
      /**
       * WIP - This property will hold both names and values of the updated fields of the entity.
       * For more details please see [adr](https://docs.google.com/document/d/1PdqsOM20Ph2HAkmx8zvUnzzk3Sekp3BR9h34wSvsRnI/edit#heading=h.phlw87mh2imx) or [issue](https://github.com/wix-private/nile-tracker/issues/363)
       * @internal
       */
      modifiedFields?: Record<string, any>;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface EntityDeletedEvent$2 {
      /**
       * Indicates if the entity is sent to trash-bin. only available when trash-bin is enabled
       * @internal
       */
      movedToTrash?: boolean | null;
      /** Entity that was deleted */
      deletedEntityAsJson?: string | null;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface ActionEvent$2 {
      bodyAsJson?: string;
  }
  interface Empty {
  }
  /** Encapsulates all details written to the Greyhound topic when a site's properties are updated. */
  interface SitePropertiesNotification {
      /** The site ID for which this update notification applies. */
      metasiteId?: string;
      /** The actual update event. */
      event?: SitePropertiesEvent;
      /** A convenience set of mappings from the MetaSite ID to its constituent services. */
      translations?: Translation[];
      /** Context of the notification */
      changeContext?: ChangeContext;
  }
  /** The actual update event for a particular notification. */
  interface SitePropertiesEvent {
      /** Version of the site's properties represented by this update. */
      version?: number;
      /**
       * Set of properties that were updated - corresponds to the fields in "properties".
       * @internal
       */
      fields?: string[];
      /** Updated properties. */
      properties?: Properties;
  }
  interface Properties {
      /** Site categories. */
      categories?: Categories;
      /** Site locale. */
      locale?: Locale;
      /**
       * Site language.
       *
       * Two-letter language code in [ISO 639-1 alpha-2](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format.
       */
      language?: string | null;
      /**
       * Site currency format used to bill customers.
       *
       * Three-letter currency code in [ISO-4217 alphabetic](https://en.wikipedia.org/wiki/ISO_4217#Active_codes) format.
       */
      paymentCurrency?: string | null;
      /** Timezone in `America/New_York` format. */
      timeZone?: string | null;
      /** Email address. */
      email?: string | null;
      /** Phone number. */
      phone?: string | null;
      /** Fax number. */
      fax?: string | null;
      /** Address. */
      address?: Address$2;
      /** Site display name. */
      siteDisplayName?: string | null;
      /** Business name. */
      businessName?: string | null;
      /** Path to the site's logo in Wix Media (without Wix Media base URL). */
      logo?: string | null;
      /** Site description. */
      description?: string | null;
      /**
       * Business schedule. Regular and exceptional time periods when the business is open or the service is available.
       *
       * __Note:__ Not supported by Wix Bookings.
       */
      businessSchedule?: BusinessSchedule;
      /** Supported languages of a site and the primary language. */
      multilingual?: Multilingual;
      /** Cookie policy the site owner defined for their site (before the users interacts with/limits it). */
      consentPolicy?: ConsentPolicy;
      /**
       * Supported values: `FITNESS SERVICE`, `RESTAURANT`, `BLOG`, `STORE`, `EVENT`, `UNKNOWN`.
       *
       * Site business type.
       */
      businessConfig?: string | null;
      /** External site url that uses Wix as its headless business solution */
      externalSiteUrl?: string | null;
      /** Track clicks analytics */
      trackClicksAnalytics?: boolean;
  }
  interface Categories {
      /** Primary site category. */
      primary?: string;
      /** Secondary site category. */
      secondary?: string[];
      /** Business Term Id */
      businessTermId?: string | null;
  }
  interface Locale {
      /** Two-letter language code in [ISO 639-1 alpha-2](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format. */
      languageCode?: string;
      /** Two-letter country code in [ISO-3166 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2#Officially_assigned_code_elements) format. */
      country?: string;
  }
  interface Address$2 {
      /** Street name. */
      street?: string;
      /** City name. */
      city?: string;
      /** Two-letter country code in an [ISO-3166 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format. */
      country?: string;
      /** State. */
      state?: string;
      /** Zip or postal code. */
      zip?: string;
      /** Extra information to be displayed in the address. */
      hint?: AddressHint;
      /** Whether this address represents a physical location. */
      isPhysical?: boolean;
      /** Google-formatted version of this address. */
      googleFormattedAddress?: string;
      /** Street number. */
      streetNumber?: string;
      /** Apartment number. */
      apartmentNumber?: string;
      /** Geographic coordinates of location. */
      coordinates?: GeoCoordinates;
  }
  /**
   * Extra information on displayed addresses.
   * This is used for display purposes. Used to add additional data about the address, such as "In the passage".
   * Free text. In addition the user can state where he wants that additional description - before, after, or instead
   * the address string.
   */
  interface AddressHint {
      /** Extra text displayed next to, or instead of, the actual address. */
      text?: string;
      /** Where the extra text should be displayed. */
      placement?: PlacementType;
  }
  /** Where the extra text should be displayed: before, after or instead of the actual address. */
  enum PlacementType {
      BEFORE = "BEFORE",
      AFTER = "AFTER",
      REPLACE = "REPLACE"
  }
  /** Geocoordinates for a particular address. */
  interface GeoCoordinates {
      /** Latitude of the location. Must be between -90 and 90. */
      latitude?: number;
      /** Longitude of the location. Must be between -180 and 180. */
      longitude?: number;
  }
  /** Business schedule. Regular and exceptional time periods when the business is open or the service is available. */
  interface BusinessSchedule {
      /** Weekly recurring time periods when the business is regularly open or the service is available. Limited to 100 time periods. */
      periods?: TimePeriod[];
      /** Exceptions to the business's regular hours. The business can be open or closed during the exception. */
      specialHourPeriod?: SpecialHourPeriod[];
  }
  /** Weekly recurring time periods when the business is regularly open or the service is available. */
  interface TimePeriod {
      /** Day of the week the period starts on. */
      openDay?: DayOfWeek;
      /**
       * Time the period starts in 24-hour [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) extended format. Valid values are `00:00` to `24:00`, where `24:00` represents
       * midnight at the end of the specified day.
       */
      openTime?: string;
      /** Day of the week the period ends on. */
      closeDay?: DayOfWeek;
      /**
       * Time the period ends in 24-hour [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) extended format. Valid values are `00:00` to `24:00`, where `24:00` represents
       * midnight at the end of the specified day.
       *
       * __Note:__ If `openDay` and `closeDay` specify the same day of the week `closeTime` must be later than `openTime`.
       */
      closeTime?: string;
  }
  /** Enumerates the days of the week. */
  enum DayOfWeek {
      MONDAY = "MONDAY",
      TUESDAY = "TUESDAY",
      WEDNESDAY = "WEDNESDAY",
      THURSDAY = "THURSDAY",
      FRIDAY = "FRIDAY",
      SATURDAY = "SATURDAY",
      SUNDAY = "SUNDAY"
  }
  /** Exception to the business's regular hours. The business can be open or closed during the exception. */
  interface SpecialHourPeriod {
      /** Start date and time of the exception in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format and [Coordinated Universal Time (UTC)](https://en.wikipedia.org/wiki/Coordinated_Universal_Time). */
      startDate?: string;
      /** End date and time of the exception in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format and [Coordinated Universal Time (UTC)](https://en.wikipedia.org/wiki/Coordinated_Universal_Time). */
      endDate?: string;
      /**
       * Whether the business is closed (or the service is not available) during the exception.
       *
       * Default: `true`.
       */
      isClosed?: boolean;
      /** Additional info about the exception. For example, "We close earlier on New Year's Eve." */
      comment?: string;
  }
  interface Multilingual {
      /** Supported languages list. */
      supportedLanguages?: SupportedLanguage[];
      /** Whether to redirect to user language. */
      autoRedirect?: boolean;
  }
  interface SupportedLanguage {
      /** Two-letter language code in [ISO 639-1 alpha-2](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format. */
      languageCode?: string;
      /** Locale. */
      locale?: Locale;
      /** Whether the supported language is the primary language for the site. */
      isPrimary?: boolean;
      /** Language icon. */
      countryCode?: string;
      /** How the language will be resolved. For internal use. */
      resolutionMethod?: ResolutionMethod;
  }
  enum ResolutionMethod {
      QUERY_PARAM = "QUERY_PARAM",
      SUBDOMAIN = "SUBDOMAIN",
      SUBDIRECTORY = "SUBDIRECTORY"
  }
  interface ConsentPolicy {
      /** Whether the site uses cookies that are essential to site operation. */
      essential?: boolean | null;
      /** Whether the site uses cookies that affect site performance and other functional measurements. */
      functional?: boolean | null;
      /** Whether the site uses cookies that collect analytics about how the site is used (in order to improve it). */
      analytics?: boolean | null;
      /** Whether the site uses cookies that collect information allowing better customization of the experience for a current visitor. */
      advertising?: boolean | null;
      /** CCPA compliance flag. */
      dataToThirdParty?: boolean | null;
  }
  /** A single mapping from the MetaSite ID to a particular service. */
  interface Translation {
      /** The service type. */
      serviceType?: string;
      /** The application definition ID; this only applies to services of type ThirdPartyApps. */
      appDefId?: string;
      /** The instance ID of the service. */
      instanceId?: string;
  }
  interface ChangeContext extends ChangeContextPayloadOneOf {
      /** Properties were updated. */
      propertiesChange?: PropertiesChange;
      /** Default properties were created on site creation. */
      siteCreated?: SiteCreated;
      /** Properties were cloned on site cloning. */
      siteCloned?: SiteCloned;
  }
  /** @oneof */
  interface ChangeContextPayloadOneOf {
      /** Properties were updated. */
      propertiesChange?: PropertiesChange;
      /** Default properties were created on site creation. */
      siteCreated?: SiteCreated;
      /** Properties were cloned on site cloning. */
      siteCloned?: SiteCloned;
  }
  interface PropertiesChange {
  }
  interface SiteCreated {
      /** Origin template site id. */
      originTemplateId?: string | null;
  }
  interface SiteCloned {
      /** Origin site id. */
      originMetaSiteId?: string;
  }
  interface MessageEnvelope$2 {
      /** App instance ID. */
      instanceId?: string | null;
      /** Event type. */
      eventType?: string;
      /** The identification type and identity data. */
      identity?: IdentificationData$3;
      /** Stringify payload. */
      data?: string;
  }
  interface IdentificationData$3 extends IdentificationDataIdOneOf$3 {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
      /** @readonly */
      identityType?: WebhookIdentityType$2;
  }
  /** @oneof */
  interface IdentificationDataIdOneOf$3 {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
  }
  enum WebhookIdentityType$2 {
      UNKNOWN = "UNKNOWN",
      ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
      MEMBER = "MEMBER",
      WIX_USER = "WIX_USER",
      APP = "APP"
  }
  /**
   * Creates a booking policy.
   * @param bookingPolicy - Booking policy to create.
   * @public
   * @documentationMaturity preview
   * @requiredField bookingPolicy
   * @permissionId BOOKINGS.BOOKING_POLICY_CREATE
   * @adminMethod
   * @returns Created booking policy.
   */
  function createBookingPolicy(bookingPolicy: BookingPolicy): Promise<BookingPolicy>;
  /**
   * Retrieves a booking policy.
   * @param bookingPolicyId - ID of the booking policy to retrieve.
   * @public
   * @documentationMaturity preview
   * @requiredField bookingPolicyId
   * @permissionId BOOKINGS.BOOKING_POLICY_READ
   * @returns Retrieved booking policy.
   */
  function getBookingPolicy(bookingPolicyId: string): Promise<BookingPolicy>;
  /**
   * Retrieves the strictest version of each policy rule from a list of booking
   * policies.
   *
   *
   * Returns a hypothetical `bookingPolicy` object that combines the strictest
   * version of each rule. The `id` of the returned policy is `null` and no
   * corresponding `bookingPolicy` object is created. To create a new policy, you
   * can use [Create Booking Policy](https://dev.wix.com/docs/rest/business-solutions/bookings/services/booking-policy/create-booking-policy).
   * @param bookingPolicyIds - IDs of the booking policies for which to retrieve the strictest rules for.
   * @public
   * @documentationMaturity preview
   * @requiredField bookingPolicyIds
   * @permissionId BOOKINGS.BOOKING_POLICY_READ
   */
  function getStrictestBookingPolicy(bookingPolicyIds: string[]): Promise<GetStrictestBookingPolicyResponse>;
  /**
   * Updates a booking policy.
   *
   *
   * Each time the booking policy is updated, `revision` increments by 1.
   * The current `revision` must be passed when updating the booking policy.
   * This ensures you're working with the latest booking policy and prevents unintended overwrites.
   * @param _id - ID of the booking policy.
   * @public
   * @documentationMaturity preview
   * @requiredField _id
   * @requiredField bookingPolicy
   * @requiredField bookingPolicy.revision
   * @permissionId BOOKINGS.BOOKING_POLICY_UPDATE
   * @adminMethod
   * @returns Updated booking policy.
   */
  function updateBookingPolicy(_id: string | null, bookingPolicy: UpdateBookingPolicy, options?: UpdateBookingPolicyOptions): Promise<BookingPolicy>;
  interface UpdateBookingPolicy {
      /**
       * ID of the booking policy.
       * @readonly
       */
      _id?: string | null;
      /**
       * Revision number, which increments by 1 each time the booking policy is updated.
       * To prevent conflicting changes, the current `revision` must be passed when
       * updating the booking policy.
       * @readonly
       */
      revision?: string | null;
      /**
       * Date and time the booking policy was created in `YYYY-MM-DDThh:mm:ss.sssZ` format.
       * @readonly
       */
      _createdDate?: Date | null;
      /**
       * Date and time the booking policy was updated in `YYYY-MM-DDThh:mm:ss.sssZ` format.
       * @readonly
       */
      _updatedDate?: Date | null;
      /** Name of the booking policy. */
      name?: string | null;
      /**
       * Custom description for the booking policy and whether it's displayed to the
       * participant.
       */
      customPolicyDescription?: PolicyDescription;
      /**
       * Whether the booking policy is the default.
       * @readonly
       */
      default?: boolean | null;
      /** Rule for limiting early bookings. */
      limitEarlyBookingPolicy?: LimitEarlyBookingPolicy;
      /**
       * Rule for limiting late bookings. This rule and `bookAfterStartPolicy` can't
       * be both enabled at the same time.
       */
      limitLateBookingPolicy?: LimitLateBookingPolicy;
      /**
       * Rule for booking after the start of a session or course. This rule and
       * `limitLateBookingPolicy` can't be both enabled at the same time.
       */
      bookAfterStartPolicy?: BookAfterStartPolicy;
      /** Rule for canceling a booking. */
      cancellationPolicy?: CancellationPolicy;
      /** Rule for rescheduling a booking. */
      reschedulePolicy?: ReschedulePolicy;
      /** Waitlist rule for the service. */
      waitlistPolicy?: WaitlistPolicy;
      /** Rule for participants per booking. */
      participantsPolicy?: ParticipantsPolicy;
      /**
       * Rule for allocating resources.
       * @internal
       */
      resourcesPolicy?: ResourcesPolicy;
      /** Rules for cancellation fees. */
      cancellationFeePolicy?: CancellationFeePolicy;
      /** Rule for saving credit card details. */
      saveCreditCardPolicy?: SaveCreditCardPolicy;
      /** Extensions enabling users to save custom data related to the booking policies. */
      extendedFields?: ExtendedFields$2;
  }
  interface UpdateBookingPolicyOptions {
      /**
       * Explicit list of fields to update
       * @internal
       */
      mask?: string[];
  }
  /**
   * Sets a booking policy as the default.
   *
   *
   * Also updates the site's current default policy by setting its `default`
   * attribute to `false`. If the provided policy is already the site's
   * default, the call succeeds without changing any `bookingPolicy` object.
   * @param bookingPolicyId - ID of the booking policy that's set as default.
   * @public
   * @documentationMaturity preview
   * @requiredField bookingPolicyId
   * @permissionId BOOKINGS.BOOKING_POLICY_SET_DEFAULT
   * @adminMethod
   */
  function setDefaultBookingPolicy(bookingPolicyId: string): Promise<SetDefaultBookingPolicyResponse>;
  /**
   * Deletes a booking policy.
   *
   *
   * You can't delete the default policy without
   * [setting a different policy as default](https://dev.wix.com/docs/rest/business-solutions/bookings/services/booking-policy/set-default-booking-policy)
   * first.
   * @param bookingPolicyId - ID of the booking policy to delete.
   * @public
   * @documentationMaturity preview
   * @requiredField bookingPolicyId
   * @permissionId BOOKINGS.BOOKING_POLICY_DELETE
   * @adminMethod
   */
  function deleteBookingPolicy(bookingPolicyId: string): Promise<void>;
  /**
   * Retrieves a list of booking policies, given the provided paging, filtering, and sorting.
   *
   *
   * Query Booking Policies runs with these defaults, which you can override:
   *
   * - Sorted by `createdDate` in ascending order.
   * - `cursorPaging.limit` set to `100`.
   *
   * For details about all supported filters and sorting options, see
   * [the supported filters article](https://dev.wix.com/docs/rest/business-solutions/bookings/services/booking-policy/supported-filters).
   *
   * To learn about working with _Query_ endpoints, see
   * [API Query Language](https://dev.wix.com/api/rest/getting-started/api-query-language),
   * [Sorting and Paging](https://dev.wix.com/api/rest/getting-started/pagination),
   * and [Field Projection](https://dev.wix.com/api/rest/getting-started/field-projection).
   * @public
   * @documentationMaturity preview
   * @permissionId BOOKINGS.BOOKING_POLICY_READ
   */
  function queryBookingPolicies(): BookingPoliciesQueryBuilder;
  interface QueryCursorResult$1 {
      cursors: Cursors$2;
      hasNext: () => boolean;
      hasPrev: () => boolean;
      length: number;
      pageSize: number;
  }
  interface BookingPoliciesQueryResult extends QueryCursorResult$1 {
      items: BookingPolicy[];
      query: BookingPoliciesQueryBuilder;
      next: () => Promise<BookingPoliciesQueryResult>;
      prev: () => Promise<BookingPoliciesQueryResult>;
  }
  interface BookingPoliciesQueryBuilder {
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       * @documentationMaturity preview
       */
      eq: (propertyName: '_id' | 'name' | 'customPolicyDescription.enabled' | 'customPolicyDescription.description' | 'default' | 'limitEarlyBookingPolicy.enabled' | 'limitEarlyBookingPolicy.earliestBookingInMinutes' | 'limitLateBookingPolicy.enabled' | 'limitLateBookingPolicy.latestBookingInMinutes' | 'bookAfterStartPolicy.enabled' | 'cancellationPolicy.enabled' | 'cancellationPolicy.limitLatestCancellation' | 'cancellationPolicy.latestCancellationInMinutes' | 'reschedulePolicy.enabled' | 'reschedulePolicy.limitLatestReschedule' | 'reschedulePolicy.latestRescheduleInMinutes' | 'waitlistPolicy.enabled' | 'waitlistPolicy.capacity' | 'waitlistPolicy.reservationTimeInMinutes' | 'participantsPolicy.maxParticipantsPerBooking' | 'resourcesPolicy.enabled' | 'resourcesPolicy.autoAssignAllowed', value: any) => BookingPoliciesQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       * @documentationMaturity preview
       */
      ne: (propertyName: '_id' | 'name' | 'customPolicyDescription.enabled' | 'customPolicyDescription.description' | 'default' | 'limitEarlyBookingPolicy.enabled' | 'limitEarlyBookingPolicy.earliestBookingInMinutes' | 'limitLateBookingPolicy.enabled' | 'limitLateBookingPolicy.latestBookingInMinutes' | 'bookAfterStartPolicy.enabled' | 'cancellationPolicy.enabled' | 'cancellationPolicy.limitLatestCancellation' | 'cancellationPolicy.latestCancellationInMinutes' | 'reschedulePolicy.enabled' | 'reschedulePolicy.limitLatestReschedule' | 'reschedulePolicy.latestRescheduleInMinutes' | 'waitlistPolicy.enabled' | 'waitlistPolicy.capacity' | 'waitlistPolicy.reservationTimeInMinutes' | 'participantsPolicy.maxParticipantsPerBooking' | 'resourcesPolicy.enabled' | 'resourcesPolicy.autoAssignAllowed', value: any) => BookingPoliciesQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       * @documentationMaturity preview
       */
      ge: (propertyName: 'limitEarlyBookingPolicy.earliestBookingInMinutes' | 'limitLateBookingPolicy.latestBookingInMinutes' | 'cancellationPolicy.latestCancellationInMinutes' | 'reschedulePolicy.latestRescheduleInMinutes' | 'waitlistPolicy.capacity' | 'waitlistPolicy.reservationTimeInMinutes' | 'participantsPolicy.maxParticipantsPerBooking', value: any) => BookingPoliciesQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       * @documentationMaturity preview
       */
      gt: (propertyName: 'limitEarlyBookingPolicy.earliestBookingInMinutes' | 'limitLateBookingPolicy.latestBookingInMinutes' | 'cancellationPolicy.latestCancellationInMinutes' | 'reschedulePolicy.latestRescheduleInMinutes' | 'waitlistPolicy.capacity' | 'waitlistPolicy.reservationTimeInMinutes' | 'participantsPolicy.maxParticipantsPerBooking', value: any) => BookingPoliciesQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       * @documentationMaturity preview
       */
      le: (propertyName: 'limitEarlyBookingPolicy.earliestBookingInMinutes' | 'limitLateBookingPolicy.latestBookingInMinutes' | 'cancellationPolicy.latestCancellationInMinutes' | 'reschedulePolicy.latestRescheduleInMinutes' | 'waitlistPolicy.capacity' | 'waitlistPolicy.reservationTimeInMinutes' | 'participantsPolicy.maxParticipantsPerBooking', value: any) => BookingPoliciesQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       * @documentationMaturity preview
       */
      lt: (propertyName: 'limitEarlyBookingPolicy.earliestBookingInMinutes' | 'limitLateBookingPolicy.latestBookingInMinutes' | 'cancellationPolicy.latestCancellationInMinutes' | 'reschedulePolicy.latestRescheduleInMinutes' | 'waitlistPolicy.capacity' | 'waitlistPolicy.reservationTimeInMinutes' | 'participantsPolicy.maxParticipantsPerBooking', value: any) => BookingPoliciesQueryBuilder;
      /** @param propertyName - Property whose value is compared with `string`.
       * @param string - String to compare against. Case-insensitive.
       * @documentationMaturity preview
       */
      startsWith: (propertyName: 'name' | 'customPolicyDescription.description', value: string) => BookingPoliciesQueryBuilder;
      /** @documentationMaturity preview */
      in: (propertyName: '_id' | 'limitEarlyBookingPolicy.earliestBookingInMinutes' | 'limitLateBookingPolicy.latestBookingInMinutes' | 'cancellationPolicy.latestCancellationInMinutes' | 'reschedulePolicy.latestRescheduleInMinutes' | 'waitlistPolicy.capacity' | 'waitlistPolicy.reservationTimeInMinutes' | 'participantsPolicy.maxParticipantsPerBooking', value: any) => BookingPoliciesQueryBuilder;
      /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments.
       * @documentationMaturity preview
       */
      ascending: (...propertyNames: Array<'_id' | 'name' | 'customPolicyDescription.enabled' | 'customPolicyDescription.description' | 'default' | 'limitEarlyBookingPolicy.enabled' | 'limitEarlyBookingPolicy.earliestBookingInMinutes' | 'limitLateBookingPolicy.enabled' | 'limitLateBookingPolicy.latestBookingInMinutes' | 'bookAfterStartPolicy.enabled' | 'cancellationPolicy.enabled' | 'cancellationPolicy.limitLatestCancellation' | 'cancellationPolicy.latestCancellationInMinutes' | 'reschedulePolicy.enabled' | 'reschedulePolicy.limitLatestReschedule' | 'reschedulePolicy.latestRescheduleInMinutes' | 'waitlistPolicy.enabled' | 'waitlistPolicy.capacity' | 'waitlistPolicy.reservationTimeInMinutes' | 'participantsPolicy.enabled' | 'participantsPolicy.maxParticipantsPerBooking' | 'resourcesPolicy.enabled' | 'resourcesPolicy.autoAssignAllowed'>) => BookingPoliciesQueryBuilder;
      /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments.
       * @documentationMaturity preview
       */
      descending: (...propertyNames: Array<'_id' | 'name' | 'customPolicyDescription.enabled' | 'customPolicyDescription.description' | 'default' | 'limitEarlyBookingPolicy.enabled' | 'limitEarlyBookingPolicy.earliestBookingInMinutes' | 'limitLateBookingPolicy.enabled' | 'limitLateBookingPolicy.latestBookingInMinutes' | 'bookAfterStartPolicy.enabled' | 'cancellationPolicy.enabled' | 'cancellationPolicy.limitLatestCancellation' | 'cancellationPolicy.latestCancellationInMinutes' | 'reschedulePolicy.enabled' | 'reschedulePolicy.limitLatestReschedule' | 'reschedulePolicy.latestRescheduleInMinutes' | 'waitlistPolicy.enabled' | 'waitlistPolicy.capacity' | 'waitlistPolicy.reservationTimeInMinutes' | 'participantsPolicy.enabled' | 'participantsPolicy.maxParticipantsPerBooking' | 'resourcesPolicy.enabled' | 'resourcesPolicy.autoAssignAllowed'>) => BookingPoliciesQueryBuilder;
      /** @param limit - Number of items to return, which is also the `pageSize` of the results object.
       * @documentationMaturity preview
       */
      limit: (limit: number) => BookingPoliciesQueryBuilder;
      /** @param cursor - A pointer to specific record
       * @documentationMaturity preview
       */
      skipTo: (cursor: string) => BookingPoliciesQueryBuilder;
      /** @documentationMaturity preview */
      find: () => Promise<BookingPoliciesQueryResult>;
  }
  /**
   * Counts booking policies, given the provided filtering.
   *
   *
   * See [the supported filters article](https://dev.wix.com/docs/rest/business-solutions/bookings/services/booking-policy/supported-filters)
   * for details.
   * @public
   * @documentationMaturity preview
   * @permissionId BOOKINGS.BOOKING_POLICY_READ
   */
  function countBookingPolicies(options?: CountBookingPoliciesOptions): Promise<CountBookingPoliciesResponse>;
  interface CountBookingPoliciesOptions {
      /**
       * Filter to base the count on. See
       * [the supported filters article](https://dev.wix.com/docs/rest/business-solutions/bookings/services/booking-policy/supported-filters)
       * for details.
       */
      filter?: Record<string, any> | null;
  }
  
  type bookingsV1BookingPolicy_universal_d_BookingPolicy = BookingPolicy;
  type bookingsV1BookingPolicy_universal_d_PolicyDescription = PolicyDescription;
  type bookingsV1BookingPolicy_universal_d_LimitEarlyBookingPolicy = LimitEarlyBookingPolicy;
  type bookingsV1BookingPolicy_universal_d_LimitLateBookingPolicy = LimitLateBookingPolicy;
  type bookingsV1BookingPolicy_universal_d_BookAfterStartPolicy = BookAfterStartPolicy;
  type bookingsV1BookingPolicy_universal_d_CancellationPolicy = CancellationPolicy;
  type bookingsV1BookingPolicy_universal_d_ReschedulePolicy = ReschedulePolicy;
  type bookingsV1BookingPolicy_universal_d_WaitlistPolicy = WaitlistPolicy;
  type bookingsV1BookingPolicy_universal_d_ParticipantsPolicy = ParticipantsPolicy;
  type bookingsV1BookingPolicy_universal_d_ResourcesPolicy = ResourcesPolicy;
  type bookingsV1BookingPolicy_universal_d_CancellationFeePolicy = CancellationFeePolicy;
  type bookingsV1BookingPolicy_universal_d_Money = Money;
  type bookingsV1BookingPolicy_universal_d_CancellationWindow = CancellationWindow;
  type bookingsV1BookingPolicy_universal_d_CancellationWindowFeeOneOf = CancellationWindowFeeOneOf;
  type bookingsV1BookingPolicy_universal_d_SaveCreditCardPolicy = SaveCreditCardPolicy;
  type bookingsV1BookingPolicy_universal_d_DefaultBookingPolicySet = DefaultBookingPolicySet;
  type bookingsV1BookingPolicy_universal_d_CreateBookingPolicyRequest = CreateBookingPolicyRequest;
  type bookingsV1BookingPolicy_universal_d_CreateBookingPolicyResponse = CreateBookingPolicyResponse;
  type bookingsV1BookingPolicy_universal_d_GetBookingPolicyRequest = GetBookingPolicyRequest;
  type bookingsV1BookingPolicy_universal_d_GetBookingPolicyResponse = GetBookingPolicyResponse;
  type bookingsV1BookingPolicy_universal_d_GetStrictestBookingPolicyRequest = GetStrictestBookingPolicyRequest;
  type bookingsV1BookingPolicy_universal_d_GetStrictestBookingPolicyResponse = GetStrictestBookingPolicyResponse;
  type bookingsV1BookingPolicy_universal_d_UpdateBookingPolicyRequest = UpdateBookingPolicyRequest;
  type bookingsV1BookingPolicy_universal_d_UpdateBookingPolicyResponse = UpdateBookingPolicyResponse;
  type bookingsV1BookingPolicy_universal_d_SetDefaultBookingPolicyRequest = SetDefaultBookingPolicyRequest;
  type bookingsV1BookingPolicy_universal_d_SetDefaultBookingPolicyResponse = SetDefaultBookingPolicyResponse;
  type bookingsV1BookingPolicy_universal_d_DeleteBookingPolicyRequest = DeleteBookingPolicyRequest;
  type bookingsV1BookingPolicy_universal_d_DeleteBookingPolicyResponse = DeleteBookingPolicyResponse;
  type bookingsV1BookingPolicy_universal_d_QueryBookingPoliciesRequest = QueryBookingPoliciesRequest;
  type bookingsV1BookingPolicy_universal_d_CursorQuery = CursorQuery;
  type bookingsV1BookingPolicy_universal_d_CursorQueryPagingMethodOneOf = CursorQueryPagingMethodOneOf;
  type bookingsV1BookingPolicy_universal_d_QueryBookingPoliciesResponse = QueryBookingPoliciesResponse;
  type bookingsV1BookingPolicy_universal_d_CountBookingPoliciesRequest = CountBookingPoliciesRequest;
  type bookingsV1BookingPolicy_universal_d_CountBookingPoliciesResponse = CountBookingPoliciesResponse;
  type bookingsV1BookingPolicy_universal_d_UpdateAllPoliciesRequest = UpdateAllPoliciesRequest;
  type bookingsV1BookingPolicy_universal_d_UpdateAllPoliciesResponse = UpdateAllPoliciesResponse;
  type bookingsV1BookingPolicy_universal_d_CreateMissingDefaultPolicyRequest = CreateMissingDefaultPolicyRequest;
  type bookingsV1BookingPolicy_universal_d_CreateMissingDefaultPolicyResponse = CreateMissingDefaultPolicyResponse;
  type bookingsV1BookingPolicy_universal_d_Empty = Empty;
  type bookingsV1BookingPolicy_universal_d_SitePropertiesNotification = SitePropertiesNotification;
  type bookingsV1BookingPolicy_universal_d_SitePropertiesEvent = SitePropertiesEvent;
  type bookingsV1BookingPolicy_universal_d_Properties = Properties;
  type bookingsV1BookingPolicy_universal_d_Categories = Categories;
  type bookingsV1BookingPolicy_universal_d_Locale = Locale;
  type bookingsV1BookingPolicy_universal_d_AddressHint = AddressHint;
  type bookingsV1BookingPolicy_universal_d_PlacementType = PlacementType;
  const bookingsV1BookingPolicy_universal_d_PlacementType: typeof PlacementType;
  type bookingsV1BookingPolicy_universal_d_GeoCoordinates = GeoCoordinates;
  type bookingsV1BookingPolicy_universal_d_BusinessSchedule = BusinessSchedule;
  type bookingsV1BookingPolicy_universal_d_TimePeriod = TimePeriod;
  type bookingsV1BookingPolicy_universal_d_DayOfWeek = DayOfWeek;
  const bookingsV1BookingPolicy_universal_d_DayOfWeek: typeof DayOfWeek;
  type bookingsV1BookingPolicy_universal_d_SpecialHourPeriod = SpecialHourPeriod;
  type bookingsV1BookingPolicy_universal_d_Multilingual = Multilingual;
  type bookingsV1BookingPolicy_universal_d_SupportedLanguage = SupportedLanguage;
  type bookingsV1BookingPolicy_universal_d_ResolutionMethod = ResolutionMethod;
  const bookingsV1BookingPolicy_universal_d_ResolutionMethod: typeof ResolutionMethod;
  type bookingsV1BookingPolicy_universal_d_ConsentPolicy = ConsentPolicy;
  type bookingsV1BookingPolicy_universal_d_Translation = Translation;
  type bookingsV1BookingPolicy_universal_d_ChangeContext = ChangeContext;
  type bookingsV1BookingPolicy_universal_d_ChangeContextPayloadOneOf = ChangeContextPayloadOneOf;
  type bookingsV1BookingPolicy_universal_d_PropertiesChange = PropertiesChange;
  type bookingsV1BookingPolicy_universal_d_SiteCreated = SiteCreated;
  type bookingsV1BookingPolicy_universal_d_SiteCloned = SiteCloned;
  const bookingsV1BookingPolicy_universal_d_createBookingPolicy: typeof createBookingPolicy;
  const bookingsV1BookingPolicy_universal_d_getBookingPolicy: typeof getBookingPolicy;
  const bookingsV1BookingPolicy_universal_d_getStrictestBookingPolicy: typeof getStrictestBookingPolicy;
  const bookingsV1BookingPolicy_universal_d_updateBookingPolicy: typeof updateBookingPolicy;
  type bookingsV1BookingPolicy_universal_d_UpdateBookingPolicy = UpdateBookingPolicy;
  type bookingsV1BookingPolicy_universal_d_UpdateBookingPolicyOptions = UpdateBookingPolicyOptions;
  const bookingsV1BookingPolicy_universal_d_setDefaultBookingPolicy: typeof setDefaultBookingPolicy;
  const bookingsV1BookingPolicy_universal_d_deleteBookingPolicy: typeof deleteBookingPolicy;
  const bookingsV1BookingPolicy_universal_d_queryBookingPolicies: typeof queryBookingPolicies;
  type bookingsV1BookingPolicy_universal_d_BookingPoliciesQueryResult = BookingPoliciesQueryResult;
  type bookingsV1BookingPolicy_universal_d_BookingPoliciesQueryBuilder = BookingPoliciesQueryBuilder;
  const bookingsV1BookingPolicy_universal_d_countBookingPolicies: typeof countBookingPolicies;
  type bookingsV1BookingPolicy_universal_d_CountBookingPoliciesOptions = CountBookingPoliciesOptions;
  namespace bookingsV1BookingPolicy_universal_d {
    export {
      bookingsV1BookingPolicy_universal_d_BookingPolicy as BookingPolicy,
      bookingsV1BookingPolicy_universal_d_PolicyDescription as PolicyDescription,
      bookingsV1BookingPolicy_universal_d_LimitEarlyBookingPolicy as LimitEarlyBookingPolicy,
      bookingsV1BookingPolicy_universal_d_LimitLateBookingPolicy as LimitLateBookingPolicy,
      bookingsV1BookingPolicy_universal_d_BookAfterStartPolicy as BookAfterStartPolicy,
      bookingsV1BookingPolicy_universal_d_CancellationPolicy as CancellationPolicy,
      bookingsV1BookingPolicy_universal_d_ReschedulePolicy as ReschedulePolicy,
      bookingsV1BookingPolicy_universal_d_WaitlistPolicy as WaitlistPolicy,
      bookingsV1BookingPolicy_universal_d_ParticipantsPolicy as ParticipantsPolicy,
      bookingsV1BookingPolicy_universal_d_ResourcesPolicy as ResourcesPolicy,
      bookingsV1BookingPolicy_universal_d_CancellationFeePolicy as CancellationFeePolicy,
      bookingsV1BookingPolicy_universal_d_Money as Money,
      bookingsV1BookingPolicy_universal_d_CancellationWindow as CancellationWindow,
      bookingsV1BookingPolicy_universal_d_CancellationWindowFeeOneOf as CancellationWindowFeeOneOf,
      bookingsV1BookingPolicy_universal_d_SaveCreditCardPolicy as SaveCreditCardPolicy,
      ExtendedFields$2 as ExtendedFields,
      bookingsV1BookingPolicy_universal_d_DefaultBookingPolicySet as DefaultBookingPolicySet,
      bookingsV1BookingPolicy_universal_d_CreateBookingPolicyRequest as CreateBookingPolicyRequest,
      bookingsV1BookingPolicy_universal_d_CreateBookingPolicyResponse as CreateBookingPolicyResponse,
      bookingsV1BookingPolicy_universal_d_GetBookingPolicyRequest as GetBookingPolicyRequest,
      bookingsV1BookingPolicy_universal_d_GetBookingPolicyResponse as GetBookingPolicyResponse,
      bookingsV1BookingPolicy_universal_d_GetStrictestBookingPolicyRequest as GetStrictestBookingPolicyRequest,
      bookingsV1BookingPolicy_universal_d_GetStrictestBookingPolicyResponse as GetStrictestBookingPolicyResponse,
      bookingsV1BookingPolicy_universal_d_UpdateBookingPolicyRequest as UpdateBookingPolicyRequest,
      bookingsV1BookingPolicy_universal_d_UpdateBookingPolicyResponse as UpdateBookingPolicyResponse,
      bookingsV1BookingPolicy_universal_d_SetDefaultBookingPolicyRequest as SetDefaultBookingPolicyRequest,
      bookingsV1BookingPolicy_universal_d_SetDefaultBookingPolicyResponse as SetDefaultBookingPolicyResponse,
      bookingsV1BookingPolicy_universal_d_DeleteBookingPolicyRequest as DeleteBookingPolicyRequest,
      bookingsV1BookingPolicy_universal_d_DeleteBookingPolicyResponse as DeleteBookingPolicyResponse,
      bookingsV1BookingPolicy_universal_d_QueryBookingPoliciesRequest as QueryBookingPoliciesRequest,
      bookingsV1BookingPolicy_universal_d_CursorQuery as CursorQuery,
      bookingsV1BookingPolicy_universal_d_CursorQueryPagingMethodOneOf as CursorQueryPagingMethodOneOf,
      Sorting$2 as Sorting,
      SortOrder$2 as SortOrder,
      CursorPaging$2 as CursorPaging,
      bookingsV1BookingPolicy_universal_d_QueryBookingPoliciesResponse as QueryBookingPoliciesResponse,
      CursorPagingMetadata$1 as CursorPagingMetadata,
      Cursors$2 as Cursors,
      bookingsV1BookingPolicy_universal_d_CountBookingPoliciesRequest as CountBookingPoliciesRequest,
      bookingsV1BookingPolicy_universal_d_CountBookingPoliciesResponse as CountBookingPoliciesResponse,
      bookingsV1BookingPolicy_universal_d_UpdateAllPoliciesRequest as UpdateAllPoliciesRequest,
      bookingsV1BookingPolicy_universal_d_UpdateAllPoliciesResponse as UpdateAllPoliciesResponse,
      bookingsV1BookingPolicy_universal_d_CreateMissingDefaultPolicyRequest as CreateMissingDefaultPolicyRequest,
      bookingsV1BookingPolicy_universal_d_CreateMissingDefaultPolicyResponse as CreateMissingDefaultPolicyResponse,
      DomainEvent$2 as DomainEvent,
      DomainEventBodyOneOf$2 as DomainEventBodyOneOf,
      EntityCreatedEvent$2 as EntityCreatedEvent,
      RestoreInfo$2 as RestoreInfo,
      EntityUpdatedEvent$2 as EntityUpdatedEvent,
      EntityDeletedEvent$2 as EntityDeletedEvent,
      ActionEvent$2 as ActionEvent,
      bookingsV1BookingPolicy_universal_d_Empty as Empty,
      bookingsV1BookingPolicy_universal_d_SitePropertiesNotification as SitePropertiesNotification,
      bookingsV1BookingPolicy_universal_d_SitePropertiesEvent as SitePropertiesEvent,
      bookingsV1BookingPolicy_universal_d_Properties as Properties,
      bookingsV1BookingPolicy_universal_d_Categories as Categories,
      bookingsV1BookingPolicy_universal_d_Locale as Locale,
      Address$2 as Address,
      bookingsV1BookingPolicy_universal_d_AddressHint as AddressHint,
      bookingsV1BookingPolicy_universal_d_PlacementType as PlacementType,
      bookingsV1BookingPolicy_universal_d_GeoCoordinates as GeoCoordinates,
      bookingsV1BookingPolicy_universal_d_BusinessSchedule as BusinessSchedule,
      bookingsV1BookingPolicy_universal_d_TimePeriod as TimePeriod,
      bookingsV1BookingPolicy_universal_d_DayOfWeek as DayOfWeek,
      bookingsV1BookingPolicy_universal_d_SpecialHourPeriod as SpecialHourPeriod,
      bookingsV1BookingPolicy_universal_d_Multilingual as Multilingual,
      bookingsV1BookingPolicy_universal_d_SupportedLanguage as SupportedLanguage,
      bookingsV1BookingPolicy_universal_d_ResolutionMethod as ResolutionMethod,
      bookingsV1BookingPolicy_universal_d_ConsentPolicy as ConsentPolicy,
      bookingsV1BookingPolicy_universal_d_Translation as Translation,
      bookingsV1BookingPolicy_universal_d_ChangeContext as ChangeContext,
      bookingsV1BookingPolicy_universal_d_ChangeContextPayloadOneOf as ChangeContextPayloadOneOf,
      bookingsV1BookingPolicy_universal_d_PropertiesChange as PropertiesChange,
      bookingsV1BookingPolicy_universal_d_SiteCreated as SiteCreated,
      bookingsV1BookingPolicy_universal_d_SiteCloned as SiteCloned,
      MessageEnvelope$2 as MessageEnvelope,
      IdentificationData$3 as IdentificationData,
      IdentificationDataIdOneOf$3 as IdentificationDataIdOneOf,
      WebhookIdentityType$2 as WebhookIdentityType,
      bookingsV1BookingPolicy_universal_d_createBookingPolicy as createBookingPolicy,
      bookingsV1BookingPolicy_universal_d_getBookingPolicy as getBookingPolicy,
      bookingsV1BookingPolicy_universal_d_getStrictestBookingPolicy as getStrictestBookingPolicy,
      bookingsV1BookingPolicy_universal_d_updateBookingPolicy as updateBookingPolicy,
      bookingsV1BookingPolicy_universal_d_UpdateBookingPolicy as UpdateBookingPolicy,
      bookingsV1BookingPolicy_universal_d_UpdateBookingPolicyOptions as UpdateBookingPolicyOptions,
      bookingsV1BookingPolicy_universal_d_setDefaultBookingPolicy as setDefaultBookingPolicy,
      bookingsV1BookingPolicy_universal_d_deleteBookingPolicy as deleteBookingPolicy,
      bookingsV1BookingPolicy_universal_d_queryBookingPolicies as queryBookingPolicies,
      bookingsV1BookingPolicy_universal_d_BookingPoliciesQueryResult as BookingPoliciesQueryResult,
      bookingsV1BookingPolicy_universal_d_BookingPoliciesQueryBuilder as BookingPoliciesQueryBuilder,
      bookingsV1BookingPolicy_universal_d_countBookingPolicies as countBookingPolicies,
      bookingsV1BookingPolicy_universal_d_CountBookingPoliciesOptions as CountBookingPoliciesOptions,
    };
  }
  
  /**
   * The `Attendance` object represents the attendance information
   * for a booked session, such as:
   *
   * + Did anyone attend the session?
   * + How many people attended the session?
   *
   * The number of session `Attendance` objects available depends on the booking type:
   * + Appointment bookings have 1 `Attendance` object per appointment session.
   * + Class bookings have 1 `Attendance` object for each session of the class. The number of sessions for a class is defined in Schedule and Sessions [`schedule.capacity`](https://dev.wix.com/api/rest/wix-bookings/schedules-and-sessions/schedule/schedule-object) property.
   * + Course bookings have an `Attendance` object for each session of the course. For example, if there are 12 sessions in a course, there are 12 `Attendance` objects. The number of sessions for a class is defined in Schedule and Sessions [`schedule.capacity`](https://dev.wix.com/api/rest/wix-bookings/schedules-and-sessions/schedule/schedule-object) property.
   */
  interface Attendance {
      /**
       * ID of the `Attendance` object.
       * @readonly
       */
      _id?: string | null;
      /** Corresponding booking ID. */
      bookingId?: string | null;
      /** Corresponding session ID. */
      sessionId?: string | null;
      /**
       * Status indicating if any participants attended the session:
       *
       * + `NOT_SET`: There is no available attendance information.
       * + `ATTENDED`: At least a single participant attended the session.
       * + `NOT_ATTENDED`: No participants attended the session.
       */
      status?: AttendanceStatus;
      /**
       * Total number of participants that attended the session. By default, the number
       * of attendees is set to `1`, but you can set a number to greater than `1` if multiple
       * participants attended.
       *
       * Do not set to `0` to indicate that no one attended the session. Instead, set the `status` field to `NOT_ATTENDED`.
       *
       * Default: 1
       */
      numberOfAttendees?: number;
      /**
       * Corresponding event ID.
       * @internal
       */
      eventId?: string | null;
      /**
       * Date and time the attendance was updated.
       * @internal
       * @readonly
       */
      _updatedDate?: Date | null;
      /**
       * Date and time the attendance status was updated.
       * @internal
       * @readonly
       */
      statusUpdatedDate?: Date | null;
  }
  enum AttendanceStatus {
      NOT_SET = "NOT_SET",
      ATTENDED = "ATTENDED",
      NOT_ATTENDED = "NOT_ATTENDED"
  }
  interface GetAttendanceRequest {
      /** ID of the object that contains the attendance information that you want to retrieve. */
      attendanceId: string;
  }
  interface GetAttendanceResponse {
      /** The retrieved attendance information for the booked session. */
      attendance?: Attendance;
  }
  interface SetAttendanceRequest {
      /** The attendance information for a booked session that you want to create or update. */
      attendance: Attendance;
      /** Information about whether to send a message to a customer after their attendance was set. */
      participantNotification?: ParticipantNotification$2;
  }
  interface ParticipantNotification$2 {
      /**
       * Whether to send the message about the changes to the customer.
       * Default is false.
       */
      notifyParticipants?: boolean | null;
      /** Optional custom message to send to the participants about the changes to the booking. */
      message?: string | null;
  }
  interface SetAttendanceResponse {
      /** The created or updated attendance information for the booked session. */
      attendance?: Attendance;
  }
  interface AttendanceMarkedAsNotAttended {
      /** The attendance information for a booked session that you want to create or update. */
      attendance?: Attendance;
      /** Information about whether to send a message to a customer after their attendance was set. */
      participantNotification?: ParticipantNotification$2;
  }
  interface BulkSetAttendanceRequest {
      /**
       * The attendance information for a booked sessions that you want to create or update. Min size 1.
       * Deprecated. use `attendance_details`.
       * @internal
       * @deprecated The attendance information for a booked sessions that you want to create or update. Min size 1.
       * Deprecated. use `attendance_details`.
       * @replacedBy attendance_details
       * @targetRemovalDate 2024-06-01
       */
      attendanceList?: Attendance[];
      returnFullEntity?: boolean;
      /** The attendance information for a booked sessions that you want to create or update. Min size 1. */
      attendanceDetails?: AttendanceDetails[];
  }
  interface AttendanceDetails {
      /** The created or updated attendance information for the booked session. */
      attendance?: Attendance;
      /** Information about whether to send a message to a customer after their attendance was set. */
      participantNotification?: ParticipantNotification$2;
  }
  interface BulkSetAttendanceResponse {
      /** The created or updated attendance information for the booked sessions. */
      results?: BulkAttendanceResult[];
      /** Total successes and failures of the bulk set attendance action. */
      bulkActionMetadata?: BulkActionMetadata$1;
  }
  interface BulkAttendanceResult {
      item?: Attendance;
      itemMetadata?: ItemMetadata$1;
  }
  interface ItemMetadata$1 {
      /** Item ID. Should always be available, unless it's impossible (for example, when failing to create an item). */
      _id?: string | null;
      /** Index of the item within the request array. Allows for correlation between request and response items. */
      originalIndex?: number;
      /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
      success?: boolean;
      /** Details about the error in case of failure. */
      error?: ApplicationError$1;
  }
  interface ApplicationError$1 {
      /** Error code. */
      code?: string;
      /** Description of the error. */
      description?: string;
      /** Data related to the error. */
      data?: Record<string, any> | null;
  }
  interface BulkActionMetadata$1 {
      /** Number of items that were successfully processed. */
      totalSuccesses?: number;
      /** Number of items that couldn't be processed. */
      totalFailures?: number;
      /** Number of failures without details because detailed failure threshold was exceeded. */
      undetailedFailures?: number;
  }
  interface QueryAttendanceRequest {
      /** Query options. */
      query: QueryV2$1;
  }
  interface QueryV2$1 extends QueryV2PagingMethodOneOf$1 {
      /**
       * Paging options to limit and skip the number of items.
       * @internal
       */
      paging?: Paging$1;
      /** Cursors to navigate through the result pages using `next` and `prev`. */
      cursorPaging?: CursorPaging$1;
      /**
       * Filter object. See [API Query Language](https://dev.wix.com/api/rest/getting-started/api-query-language) for more information.
       *
       * For a detailed list of supported fields and operators, see [Supported Filters and Sorting](https://dev.wix.com/api/rest/wix-bookings/attendance/supported-filters).
       *
       * Max: 1 filter
       */
      filter?: Record<string, any> | null;
      /**
       * Sort object in the following format:
       * `[ {"fieldName":"sortField1","order":"ASC"}, {"fieldName":"sortField2","order":"DESC"} ]`
       *
       * For details about sorting, see [Supported Filters and Sorting](https://dev.wix.com/api/rest/wix-bookings/attendance/supported-filters).
       */
      sort?: Sorting$1[];
      /** @internal */
      fieldsets?: string[];
      /**
       * Array of projected fields. A list of specific field names to return.
       * @internal
       */
      fields?: string[];
  }
  /** @oneof */
  interface QueryV2PagingMethodOneOf$1 {
      /**
       * Paging options to limit and skip the number of items.
       * @internal
       */
      paging?: Paging$1;
      /** Cursors to navigate through the result pages using `next` and `prev`. */
      cursorPaging?: CursorPaging$1;
  }
  interface Sorting$1 {
      /** Name of the field to sort by. */
      fieldName?: string;
      /** Sort order. */
      order?: SortOrder$1;
  }
  /**
   * Sort order. Use `ASC` for ascending order or `DESC` for descending order.
   *
   * Default: `ASC`.
   */
  enum SortOrder$1 {
      ASC = "ASC",
      DESC = "DESC"
  }
  interface Paging$1 {
      /** Number of items to load. */
      limit?: number | null;
      /** Number of items to skip in the current sort order. */
      offset?: number | null;
  }
  interface CursorPaging$1 {
      /**
       * Number of `Attendance` objects to return.
       *
       * Default: `50`
       * Maximum: `1000`
       */
      limit?: number | null;
      /**
       * Pointer to the next or previous page in the list of results.
       *
       * You can get the relevant cursor token
       * from the `pagingMetadata` object in the previous call's response.
       *
       * Not relevant for the first request.
       */
      cursor?: string | null;
  }
  /** List of objects that contain attendance information. */
  interface QueryAttendanceResponse {
      /** List of objects that contain attendance information for a booked session. */
      attendances?: Attendance[];
      /** Details on the paged set of results returned. */
      pagingMetadata?: CursorPagingMetadata;
  }
  /** This is the preferred message for cursor-paging enabled services */
  interface CursorPagingMetadata {
      /** @internal */
      totalCount?: number;
      /** Use these cursors to paginate between results. [Read more](https://dev.wix.com/api/rest/getting-started/api-query-language#getting-started_api-query-language_cursor-paging). */
      cursors?: Cursors$1;
      /**
       * Indicates if there are more results after the current page.
       * If `true`, another page of results can be retrieved.
       * If `false`, this is the last page.
       */
      hasNext?: boolean | null;
  }
  interface Cursors$1 {
      /** Cursor pointing to next page in the list of results. */
      next?: string | null;
      /** Cursor pointing to previous page in the list of results. */
      prev?: string | null;
  }
  interface DomainEvent$1 extends DomainEventBodyOneOf$1 {
      createdEvent?: EntityCreatedEvent$1;
      updatedEvent?: EntityUpdatedEvent$1;
      deletedEvent?: EntityDeletedEvent$1;
      actionEvent?: ActionEvent$1;
      /**
       * Unique event ID.
       * Allows clients to ignore duplicate webhooks.
       */
      _id?: string;
      /**
       * Assumes actions are also always typed to an entity_type
       * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
       */
      entityFqdn?: string;
      /**
       * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
       * This is although the created/updated/deleted notion is duplication of the oneof types
       * Example: created/updated/deleted/started/completed/email_opened
       */
      slug?: string;
      /** ID of the entity associated with the event. */
      entityId?: string;
      /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
      eventTime?: Date | null;
      /**
       * Whether the event was triggered as a result of a privacy regulation application
       * (for example, GDPR).
       */
      triggeredByAnonymizeRequest?: boolean | null;
      /** If present, indicates the action that triggered the event. */
      originatedFrom?: string | null;
      /**
       * A sequence number defining the order of updates to the underlying entity.
       * For example, given that some entity was updated at 16:00 and than again at 16:01,
       * it is guaranteed that the sequence number of the second update is strictly higher than the first.
       * As the consumer, you can use this value to ensure that you handle messages in the correct order.
       * To do so, you will need to persist this number on your end, and compare the sequence number from the
       * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
       */
      entityEventSequence?: string | null;
  }
  /** @oneof */
  interface DomainEventBodyOneOf$1 {
      createdEvent?: EntityCreatedEvent$1;
      updatedEvent?: EntityUpdatedEvent$1;
      deletedEvent?: EntityDeletedEvent$1;
      actionEvent?: ActionEvent$1;
  }
  interface EntityCreatedEvent$1 {
      entityAsJson?: string;
      /**
       * Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity
       * @internal
       */
      triggeredByUndelete?: boolean | null;
      /** Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity */
      restoreInfo?: RestoreInfo$1;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface RestoreInfo$1 {
      deletedDate?: Date | null;
  }
  interface EntityUpdatedEvent$1 {
      /**
       * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
       * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
       * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
       */
      currentEntityAsJson?: string;
      /**
       * This field is currently part of the of the EntityUpdatedEvent msg, but scala/node libraries which implements the domain events standard
       * wont populate it / have any reference to it in the API.
       * The main reason for it is that fetching the old entity from the DB will have a performance hit on an update operation so unless truly needed,
       * the developer should send only the new (current) entity.
       * An additional reason is not wanting to send this additional entity over the wire (kafka) since in some cases it can be really big
       * Developers that must reflect the old entity will have to implement their own domain event sender mechanism which will follow the DomainEvent proto message.
       * @internal
       * @deprecated
       */
      previousEntityAsJson?: string | null;
      /**
       * WIP - This property will hold both names and values of the updated fields of the entity.
       * For more details please see [adr](https://docs.google.com/document/d/1PdqsOM20Ph2HAkmx8zvUnzzk3Sekp3BR9h34wSvsRnI/edit#heading=h.phlw87mh2imx) or [issue](https://github.com/wix-private/nile-tracker/issues/363)
       * @internal
       */
      modifiedFields?: Record<string, any>;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface EntityDeletedEvent$1 {
      /**
       * Indicates if the entity is sent to trash-bin. only available when trash-bin is enabled
       * @internal
       */
      movedToTrash?: boolean | null;
      /** Entity that was deleted */
      deletedEntityAsJson?: string | null;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface ActionEvent$1 {
      bodyAsJson?: string;
  }
  interface MessageEnvelope$1 {
      /** App instance ID. */
      instanceId?: string | null;
      /** Event type. */
      eventType?: string;
      /** The identification type and identity data. */
      identity?: IdentificationData$2;
      /** Stringify payload. */
      data?: string;
  }
  interface IdentificationData$2 extends IdentificationDataIdOneOf$2 {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
      /** @readonly */
      identityType?: WebhookIdentityType$1;
  }
  /** @oneof */
  interface IdentificationDataIdOneOf$2 {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
  }
  enum WebhookIdentityType$1 {
      UNKNOWN = "UNKNOWN",
      ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
      MEMBER = "MEMBER",
      WIX_USER = "WIX_USER",
      APP = "APP"
  }
  /**
   * Retrieves attendance information by ID.
   * @param attendanceId - ID of the object that contains the attendance information that you want to retrieve.
   * @public
   * @documentationMaturity preview
   * @requiredField attendanceId
   * @permissionId BOOKINGS.ATTENDANCE_READ
   * @returns The retrieved attendance information for the booked session.
   */
  function getAttendance(attendanceId: string): Promise<Attendance>;
  /**
   * Sets information about whether a booking's session was attended. This information
   * is saved in an `Attendance` object.
   *
   *
   * If attendance was already set, meaning the `Attendance` object already exists, the
   * existing attendance information is updated. Otherwise, a new `Attendance` object
   * is created.
   *
   * By default, the number
   * of attendees is set to `1`, but you can set a number to greater than `1` if multiple
   * participants attended. Do not set to `0` to indicate that no one attended the session.
   * Instead, set the `status` field to `NOT_ATTENDED`.
   *
   * > __Note:__ Make sure your code validates that:
   * >  + There is no mismatch between `numberOfAttendees` and `attendanceStatus` to make sure, for example, that `attendanceStatus` is not `NOT_ATTENDED` while `numberOfAttendees` is `5`.
   * >  + The attendance's `numberOfAttendees` and the booking's `numberOfParticipants` correspond. For example, the number of attendees usually should not exceed the booking's intended number of participants (unless perhaps you allow walk-ins that did not sign up in advance).
   * @param attendance - The attendance information for a booked session that you want to create or update.
   * @public
   * @documentationMaturity preview
   * @requiredField attendance
   * @requiredField attendance.bookingId
   * @requiredField attendance.status
   * @permissionId BOOKINGS.ATTENDANCE_SET
   * @adminMethod
   */
  function setAttendance(attendance: Attendance, options?: SetAttendanceOptions): Promise<SetAttendanceResponse>;
  interface SetAttendanceOptions {
      /** Information about whether to send a message to a customer after their attendance was set. */
      participantNotification?: ParticipantNotification$2;
  }
  /**
   * Sets information about whether a booking's session was attended for multiple bookings
   *
   *
   * See [SetAttendance](https://dev.wix.com/docs/rest/api-reference/wix-bookings/attendance/set-attendance) documentation for more information.
   *
   * If any of the attendance list required fields were not passed on the request or if the caller doesn't have the required permissions to set the attendance, the call fails.
   * If the request contains attendance info for unavailable sessions, the call completes successfully but the attendance info for the unavailable sessions are not created and are not considered as failures in the response.
   * @public
   * @documentationMaturity preview
   * @permissionId BOOKINGS.ATTENDANCE_SET
   * @adminMethod
   */
  function bulkSetAttendance(options?: BulkSetAttendanceOptions): Promise<BulkSetAttendanceResponse>;
  interface BulkSetAttendanceOptions {
      /**
       * The attendance information for a booked sessions that you want to create or update. Min size 1.
       * Deprecated. use `attendance_details`.
       * @internal
       * @deprecated The attendance information for a booked sessions that you want to create or update. Min size 1.
       * Deprecated. use `attendance_details`.
       * @replacedBy attendance_details
       * @targetRemovalDate 2024-06-01
       */
      attendanceList?: Attendance[];
      returnFullEntity?: boolean;
      /** The attendance information for a booked sessions that you want to create or update. Min size 1. */
      attendanceDetails?: AttendanceDetails[];
  }
  /**
   * Retrieves attendance information for booked sessions, given the provided paging, filtering, and sorting.
   *
   *
   * When querying attendance information, you can query from the perspective of:
   * + **A booking.** Specify a booking ID to retrieve attendance information
   * for all sessions related to that booking.
   * + **A session.** Specify a session ID to  retrieve attendance information
   * for all bookings related to that session.
   *
   * For example, query by a course's `bookingId` and `status = "NOT_ATTENDED"` to
   * retrieve the attendance of a given participant in a course. For example, this query
   * helps you determine if a participant booked the course
   * but did not attend most of its sessions, taking away spots for other potential participants.
   *
   * Query Attendance runs with the following defaults, which you can override:
   *
   * - `id` sorted in `ASC` order
   * - `cursorPaging.limit` is `50`
   *
   * For field support, see [supported filters](https://dev.wix.com/api/rest/wix-bookings/attendance/supported-filters).
   *
   * > __Notes__:
   * > + Another way to retrieve attendance information is to call Bookings Reader V2's [Query Extended Bookings](https://dev.wix.com/api/rest/wix-bookings/bookings-reader-v2/query-extended-bookings) with `withBookingAttendanceDetails` as `true`.
   * > + Up to 100 results can be returned per request.
   * > + Only 1 filter is supported per query. If you define multiple filters in the same query, only the first is processed.
   *
   * To learn about working with query endpoints, see
   * [API Query Language](https://dev.wix.com/api/rest/getting-started/api-query-language).
   * @public
   * @documentationMaturity preview
   * @permissionId BOOKINGS.ATTENDANCE_READ
   */
  function queryAttendance(): AttendancesQueryBuilder;
  interface QueryCursorResult {
      cursors: Cursors$1;
      hasNext: () => boolean;
      hasPrev: () => boolean;
      length: number;
      pageSize: number;
  }
  interface AttendancesQueryResult extends QueryCursorResult {
      items: Attendance[];
      query: AttendancesQueryBuilder;
      next: () => Promise<AttendancesQueryResult>;
      prev: () => Promise<AttendancesQueryResult>;
  }
  interface AttendancesQueryBuilder {
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       * @documentationMaturity preview
       */
      eq: (propertyName: '_id' | 'bookingId' | 'sessionId' | 'status' | 'numberOfAttendees', value: any) => AttendancesQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       * @documentationMaturity preview
       */
      ne: (propertyName: '_id' | 'bookingId' | 'sessionId' | 'status' | 'numberOfAttendees', value: any) => AttendancesQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       * @documentationMaturity preview
       */
      ge: (propertyName: 'numberOfAttendees', value: any) => AttendancesQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       * @documentationMaturity preview
       */
      gt: (propertyName: 'numberOfAttendees', value: any) => AttendancesQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       * @documentationMaturity preview
       */
      le: (propertyName: 'numberOfAttendees', value: any) => AttendancesQueryBuilder;
      /** @param propertyName - Property whose value is compared with `value`.
       * @param value - Value to compare against.
       * @documentationMaturity preview
       */
      lt: (propertyName: 'numberOfAttendees', value: any) => AttendancesQueryBuilder;
      /** @documentationMaturity preview */
      in: (propertyName: '_id' | 'bookingId' | 'sessionId' | 'status' | 'numberOfAttendees', value: any) => AttendancesQueryBuilder;
      /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments.
       * @documentationMaturity preview
       */
      ascending: (...propertyNames: Array<'_id' | 'bookingId' | 'sessionId' | 'status' | 'numberOfAttendees'>) => AttendancesQueryBuilder;
      /** @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments.
       * @documentationMaturity preview
       */
      descending: (...propertyNames: Array<'numberOfAttendees'>) => AttendancesQueryBuilder;
      /** @param limit - Number of items to return, which is also the `pageSize` of the results object.
       * @documentationMaturity preview
       */
      limit: (limit: number) => AttendancesQueryBuilder;
      /** @param cursor - A pointer to specific record
       * @documentationMaturity preview
       */
      skipTo: (cursor: string) => AttendancesQueryBuilder;
      /** @documentationMaturity preview */
      find: () => Promise<AttendancesQueryResult>;
  }
  
  type bookingsV2Attendance_universal_d_Attendance = Attendance;
  type bookingsV2Attendance_universal_d_AttendanceStatus = AttendanceStatus;
  const bookingsV2Attendance_universal_d_AttendanceStatus: typeof AttendanceStatus;
  type bookingsV2Attendance_universal_d_GetAttendanceRequest = GetAttendanceRequest;
  type bookingsV2Attendance_universal_d_GetAttendanceResponse = GetAttendanceResponse;
  type bookingsV2Attendance_universal_d_SetAttendanceRequest = SetAttendanceRequest;
  type bookingsV2Attendance_universal_d_SetAttendanceResponse = SetAttendanceResponse;
  type bookingsV2Attendance_universal_d_AttendanceMarkedAsNotAttended = AttendanceMarkedAsNotAttended;
  type bookingsV2Attendance_universal_d_BulkSetAttendanceRequest = BulkSetAttendanceRequest;
  type bookingsV2Attendance_universal_d_AttendanceDetails = AttendanceDetails;
  type bookingsV2Attendance_universal_d_BulkSetAttendanceResponse = BulkSetAttendanceResponse;
  type bookingsV2Attendance_universal_d_BulkAttendanceResult = BulkAttendanceResult;
  type bookingsV2Attendance_universal_d_QueryAttendanceRequest = QueryAttendanceRequest;
  type bookingsV2Attendance_universal_d_QueryAttendanceResponse = QueryAttendanceResponse;
  type bookingsV2Attendance_universal_d_CursorPagingMetadata = CursorPagingMetadata;
  const bookingsV2Attendance_universal_d_getAttendance: typeof getAttendance;
  const bookingsV2Attendance_universal_d_setAttendance: typeof setAttendance;
  type bookingsV2Attendance_universal_d_SetAttendanceOptions = SetAttendanceOptions;
  const bookingsV2Attendance_universal_d_bulkSetAttendance: typeof bulkSetAttendance;
  type bookingsV2Attendance_universal_d_BulkSetAttendanceOptions = BulkSetAttendanceOptions;
  const bookingsV2Attendance_universal_d_queryAttendance: typeof queryAttendance;
  type bookingsV2Attendance_universal_d_AttendancesQueryResult = AttendancesQueryResult;
  type bookingsV2Attendance_universal_d_AttendancesQueryBuilder = AttendancesQueryBuilder;
  namespace bookingsV2Attendance_universal_d {
    export {
      bookingsV2Attendance_universal_d_Attendance as Attendance,
      bookingsV2Attendance_universal_d_AttendanceStatus as AttendanceStatus,
      bookingsV2Attendance_universal_d_GetAttendanceRequest as GetAttendanceRequest,
      bookingsV2Attendance_universal_d_GetAttendanceResponse as GetAttendanceResponse,
      bookingsV2Attendance_universal_d_SetAttendanceRequest as SetAttendanceRequest,
      ParticipantNotification$2 as ParticipantNotification,
      bookingsV2Attendance_universal_d_SetAttendanceResponse as SetAttendanceResponse,
      bookingsV2Attendance_universal_d_AttendanceMarkedAsNotAttended as AttendanceMarkedAsNotAttended,
      bookingsV2Attendance_universal_d_BulkSetAttendanceRequest as BulkSetAttendanceRequest,
      bookingsV2Attendance_universal_d_AttendanceDetails as AttendanceDetails,
      bookingsV2Attendance_universal_d_BulkSetAttendanceResponse as BulkSetAttendanceResponse,
      bookingsV2Attendance_universal_d_BulkAttendanceResult as BulkAttendanceResult,
      ItemMetadata$1 as ItemMetadata,
      ApplicationError$1 as ApplicationError,
      BulkActionMetadata$1 as BulkActionMetadata,
      bookingsV2Attendance_universal_d_QueryAttendanceRequest as QueryAttendanceRequest,
      QueryV2$1 as QueryV2,
      QueryV2PagingMethodOneOf$1 as QueryV2PagingMethodOneOf,
      Sorting$1 as Sorting,
      SortOrder$1 as SortOrder,
      Paging$1 as Paging,
      CursorPaging$1 as CursorPaging,
      bookingsV2Attendance_universal_d_QueryAttendanceResponse as QueryAttendanceResponse,
      bookingsV2Attendance_universal_d_CursorPagingMetadata as CursorPagingMetadata,
      Cursors$1 as Cursors,
      DomainEvent$1 as DomainEvent,
      DomainEventBodyOneOf$1 as DomainEventBodyOneOf,
      EntityCreatedEvent$1 as EntityCreatedEvent,
      RestoreInfo$1 as RestoreInfo,
      EntityUpdatedEvent$1 as EntityUpdatedEvent,
      EntityDeletedEvent$1 as EntityDeletedEvent,
      ActionEvent$1 as ActionEvent,
      MessageEnvelope$1 as MessageEnvelope,
      IdentificationData$2 as IdentificationData,
      IdentificationDataIdOneOf$2 as IdentificationDataIdOneOf,
      WebhookIdentityType$1 as WebhookIdentityType,
      bookingsV2Attendance_universal_d_getAttendance as getAttendance,
      bookingsV2Attendance_universal_d_setAttendance as setAttendance,
      bookingsV2Attendance_universal_d_SetAttendanceOptions as SetAttendanceOptions,
      bookingsV2Attendance_universal_d_bulkSetAttendance as bulkSetAttendance,
      bookingsV2Attendance_universal_d_BulkSetAttendanceOptions as BulkSetAttendanceOptions,
      bookingsV2Attendance_universal_d_queryAttendance as queryAttendance,
      bookingsV2Attendance_universal_d_AttendancesQueryResult as AttendancesQueryResult,
      bookingsV2Attendance_universal_d_AttendancesQueryBuilder as AttendancesQueryBuilder,
    };
  }
  
  /** The booking object, version 2. */
  interface Booking$1 extends BookingParticipantsInfoOneOf$1 {
      /** Total number of participants. Available only when the booking includes a single service variant. */
      totalParticipants?: number;
      /**
       * Information about the booked service choices and participants.
       * Available only when the booking includes multiple service variants.
       */
      participantsChoices?: ParticipantChoices$1;
      /**
       * Booking ID.
       * @readonly
       */
      _id?: string | null;
      /** An object describing the slot or schedule that was booked. */
      bookedEntity?: BookedEntity$1;
      /** Contact details of the site visitor or member making the booking. */
      contactDetails?: ContactDetails$1;
      /** Additional custom fields submitted with the booking form. */
      additionalFields?: CustomFormField$1[];
      /**
       * Number of participants.
       * @internal
       */
      numberOfParticipants?: number | null;
      /**
       * Internal business note
       * @internal
       * @deprecated
       */
      internalBusinessNote?: string | null;
      /**
       *   Booking status.
       *   Supported values:
       *   - `CREATED`: The booking was created.
       *   - `UPDATED`: The booking was updated.
       *   - `PENDING`: The booking is waiting to be confirmed or declined by the business owner. A booking is automatically set as `PENDING` if the service is configured to require manual business owner confirmation and an eCommerce order was created.
       *   - `CONFIRMED`: The booking was confirmed. A booking is automatically confirmed if the service is configured to automatically confirm bookings and an eCommerce order was created. If the service isn't configured to automatically confirm bookings, you can use `confirmOrDeclineBooking()`.
       *   - `DECLINED`: The booking was declined by the business owner. A booking is also declined if an eCommerce order was created that resulted in a double booking.
       *   - `CANCELED`: The booking was canceled.
       *   - `WAITING_LIST`: The booking is on a wait list.
       */
      status?: BookingStatus$1;
      /**
       * Payment status.
       * One of:
       * - `"NOT_PAID"` The booking is not paid for.
       * - `"PAID"` The booking is fully paid.
       * - `"PARTIALLY_PAID"` The booking is partially paid.
       * - `"REFUNDED"` The booking is refunded.
       * - `"EXEMPT"` The booking is free of charge.
       */
      paymentStatus?: PaymentStatus$1;
      /**
       * Selected payment option.
       * One of the payment options offered by the service, or another option if `skipSelectedPaymentOptionValidation` is `true`.
       * When undefined, the payment option is resolved by the service configuration on checkout.
       */
      selectedPaymentOption?: SelectedPaymentOption$1;
      /**
       * Date and time the booking was created.
       * @readonly
       */
      _createdDate?: Date | null;
      /** External ID provided by the client app on creation. */
      externalUserId?: string | null;
      /**
       * An object describing the platform and application that made the booking.
       * @internal
       */
      bookingSource?: BookingSource$1;
      /**
       * The last notification used by Cancel, Confirm, Decline, or Reschedule Booking.
       * @internal
       * @deprecated
       */
      participantNotification?: ParticipantNotification$1;
      /**
       * When value is set to True, an SMS reminder would be sent to the phone number specified in the ContactDetails, 24 hours before the session starts.
       * @internal
       * @deprecated
       */
      sendSmsReminder?: boolean | null;
      /** Revision number to be used when updating, rescheduling, or cancelling the booking. Revision number, which increments by 1 each time the booking is updated, rescheduled, or canceled. To prevent conflicting changes,the current revision must be passed when updating the booking. */
      revision?: string | null;
      /**
       * ID of the creator of the Booking.
       * If `appId` and another ID are present, the other ID takes precedence.
       * @readonly
       */
      createdBy?: CommonIdentificationData;
      /**
       * The start date of this booking. For a slot, this is the start date of the slot. For a schedule, this is the start date of the first session.
       * @readonly
       */
      startDate?: Date | null;
      /**
       * The end date of this booking. For a slot, this is the end date of the slot. For a schedule, this is the end date of the last session.
       * @readonly
       */
      endDate?: Date | null;
      /**
       * Sets the booking flow behavior. Some behaviors require permissions.
       * @internal
       */
      flowControlSettings?: FlowControlSettings$1;
      /**
       * Date and time the booking was updated.
       * @readonly
       */
      _updatedDate?: Date | null;
      /**
       * Custom field data for this object. Extended fields must be configured in the app dashboard before they can be accessed with API calls.
       * For usage of extended fields with [Wix Forms](https://dev.wix.com/docs/rest/crm/forms/form-schema-api/introduction-to-forms), after configuring your form custom fields, pass the form field values under the `_user_fields` namespace.
       * For example, if you have a custom form field named `age`, pass it as `"extendedFields":{"_user_fields": { "age": 22 }}`.
       */
      extendedFields?: ExtendedFields$1;
      /**
       * Whether this booking overlaps another existing confirmed booking. Returned when: `true`
       * @readonly
       */
      doubleBooked?: boolean | null;
      /**
       * whether this booking availability should be checked with v1 or v2
       * @internal
       */
      v2Availability?: boolean | null;
      /**
       * Multi service booking info of which the booking is part of.
       * @internal
       * @readonly
       */
      multiServiceBookingInfo?: MultiServiceBookingInfo$1;
      /**
       * The date this booking was canceled on
       * @internal
       * @readonly
       */
      canceledDate?: Date | null;
      /**
       * whether this booking availability should be checked with v1 or v2
       * @internal
       */
      v2AvailabilityProxy?: boolean | null;
      /**
       * Having booking language means that the booking was made in a secondary language, having no booking.language implies that the booking was made using the main language
       * @internal
       */
      language?: string | null;
  }
  /** @oneof */
  interface BookingParticipantsInfoOneOf$1 {
      /** Total number of participants. Available only when the booking includes a single service variant. */
      totalParticipants?: number;
      /**
       * Information about the booked service choices and participants.
       * Available only when the booking includes multiple service variants.
       */
      participantsChoices?: ParticipantChoices$1;
  }
  enum MultiServiceBookingType$1 {
      /**
       * Multi service booking will be considered available if its bookings are
       * available as returned from ListMultiServiceAvailabilityTimeSlots API.
       * See [List Multi Service Availability Time Slots] (url) documentation // todo: complete url
       */
      SEQUENTIAL_BOOKINGS = "SEQUENTIAL_BOOKINGS",
      /**
       * Multi service booking will be considered available if each of its bookings is available separately.
       * Not supported yet
       */
      SEPARATE_BOOKINGS = "SEPARATE_BOOKINGS",
      /** Not supported yet */
      PARALLEL_BOOKINGS = "PARALLEL_BOOKINGS"
  }
  interface BookedEntity$1 extends BookedEntityItemOneOf$1 {
      /** The booked slot, once booked becomes a session, The booking is automatically assigned to the session if it already exists, or creates a session if one doesn't already exist. */
      slot?: BookedSlot$1;
      /** The booked schedule. The booking is automatically assigned to the schedule's sessions. */
      schedule?: BookedSchedule$1;
      /**
       * Session title at the time of booking.
       * If session doesn't exist at the time of the booking, service name is used.
       * @readonly
       */
      title?: string | null;
      /**
       * If the user made the booking in a secondary language, this field will contain the translated title.
       * @internal
       * @readonly
       */
      titleTranslated?: string | null;
      /**
       * List of tags for the booking.
       * System-assigned tags for sessions and schedules are:
       * + "INDIVIDUAL" Appointments, including appointments with more than 1 participant.
       * + "GROUP" Individual classes.
       * + "COURSE" Courses.
       */
      tags?: string[] | null;
  }
  /** @oneof */
  interface BookedEntityItemOneOf$1 {
      /** The booked slot, once booked becomes a session, The booking is automatically assigned to the session if it already exists, or creates a session if one doesn't already exist. */
      slot?: BookedSlot$1;
      /** The booked schedule. The booking is automatically assigned to the schedule's sessions. */
      schedule?: BookedSchedule$1;
  }
  interface BookedSlot$1 {
      /**
       * ID of the underlying session when session is a single session or generated from a recurring session.
       * If `sessionId` is defined in the `Create Booking` request, the `startDate`, `endDate`, `timezone`, `resource`, and `location` fields are ignored and populated from the existing session's information.
       */
      sessionId?: string | null;
      /** Service ID. */
      serviceId?: string;
      /** Schedule ID. Required. */
      scheduleId?: string;
      /**
       * Calendar 3 event ID
       * If not empty, on all write flows (create / update) gets priority over session_id.
       * so if both session_id and event_id are provided, the session_id that will be set on the booking will be based on the event_id.
       * Otherwise, if event_id is empty on write flow,
       */
      eventId?: string | null;
      /**
       * The start time of this slot in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339)
       * format.
       */
      startDate?: string | null;
      /**
       * The end time of this slot in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339)
       * format.
       */
      endDate?: string | null;
      /** The timezone according to which the slot was shown to the user when booking, and should be shown in future. */
      timezone?: string | null;
      /**
       * The enriched resource assigned to the slot, can be either the requested resource or the resource chosen by the system.
       * When populated, the given resource will be booked according to it's availability.
       * When empty, If `skip_availability_validation` is `false`, a random available resource will be assigned to the slot upon confirmation,
       * otherwise one of the service resources will be assigned to the slot randomly upon confirmation.
       * This resource is the slot primary resource.
       */
      resource?: BookedResource$1;
      /** Location where the slot's session takes place. */
      location?: Location$1;
      /**
       * Optional.
       * In addition to the `resource` field, these are the additional enriched resources that are assigned to the slot.
       * For example the room, equipment or the additional staff member that are assigned to the slot.
       * @internal
       */
      additionalResources?: BookedResource$1[];
  }
  interface BookedResource$1 {
      /** Booked resource ID. */
      _id?: string;
      /** Resource's name at the time of booking. */
      name?: string | null;
      /**
       * Resource's name translated to the language the booking was made in if applicable.
       * @internal
       * @readonly
       */
      nameTranslated?: string | null;
      /** Resource's email at the time of booking. */
      email?: string | null;
      /** Resource's schedule ID. */
      scheduleId?: string | null;
      /**
       * Indicates whether the resource was specifically requested or should be auto selected by the Server.
       * The value will be true if the resource was explicitly given in the request, otherwise false.
       * @internal
       * @readonly
       */
      explicitlyRequested?: boolean | null;
      /**
       * Resource's type.
       * @internal
       * @readonly
       */
      type?: string | null;
  }
  interface Location$1 {
      /**
       * Business location ID. Available only for locations that are business locations,
       * meaning the `location_type` is `"OWNER_BUSINESS"`.
       */
      _id?: string | null;
      /** Location name. */
      name?: string | null;
      /** The full address of this location. */
      formattedAddress?: string | null;
      /** The full translated address of this location. */
      formattedAddressTranslated?: string | null;
      /**
       * Location type.
       *
       * - `"OWNER_BUSINESS"`: The business address, as set in the sites general settings.
       * - `"OWNER_CUSTOM"`: The address as set when creating the service.
       * - `"CUSTOM"`: The address as set for the individual session.
       */
      locationType?: LocationType$1;
  }
  enum LocationType$1 {
      UNDEFINED = "UNDEFINED",
      OWNER_BUSINESS = "OWNER_BUSINESS",
      OWNER_CUSTOM = "OWNER_CUSTOM",
      CUSTOM = "CUSTOM"
  }
  interface BookedSchedule$1 {
      /** Schedule ID. */
      scheduleId?: string;
      /** Booked service ID. */
      serviceId?: string | null;
      /**
       * Location where the schedule's sessions take place. Read only.
       * @readonly
       */
      location?: Location$1;
      /** The timezone according to which the slot was shown to the user when booking, and should be shown in future. */
      timezone?: string | null;
      /**
       * The start time of the first session in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339)
       * format. Required.
       * @readonly
       */
      firstSessionStart?: string | null;
      /**
       * The end time of the last session in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339)
       * format. Required.
       * @readonly
       */
      lastSessionEnd?: string | null;
  }
  interface ContactDetails$1 {
      /** Contact's ID. */
      contactId?: string | null;
      /** Contact's first name. When populated from a standard booking form, this property corresponds to the **Name** field. */
      firstName?: string | null;
      /** Contact's last name. */
      lastName?: string | null;
      /** Contact's email, used to create a new contact or get existing one from the [Contacts API](https://www.wix.com/velo/reference/wix-crm/contacts/introduction). Used to validate coupon usage limitations per contact. If not passed, the coupon usage limitation will not be enforced. (Coupon usage limitation validation is not supported yet). */
      email?: string | null;
      /** Contact's phone number. */
      phone?: string | null;
      /** Contact's full address. */
      fullAddress?: Address$1;
      /**
       * Contact's time zone.
       * @deprecated
       */
      timeZone?: string | null;
      /** Contact's country in [ISO 3166-1 alpha-2 code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format. */
      countryCode?: string | null;
  }
  /** Physical address */
  interface Address$1 extends AddressStreetOneOf$1 {
      /** Street name, number and apartment number. */
      streetAddress?: StreetAddress$1;
      /** Main address line, usually street and number, as free text. */
      addressLine?: string | null;
      /** Country code. */
      country?: string | null;
      /** Subdivision. Usually state, region, prefecture or province code, according to [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). */
      subdivision?: string | null;
      /** City name. */
      city?: string | null;
      /** Zip/postal code. */
      postalCode?: string | null;
      /** Free text providing more detailed address info. Usually contains Apt, Suite, and Floor. */
      addressLine2?: string | null;
      /** A string containing the full address of this location. */
      formattedAddress?: string | null;
      /** Free text to help find the address. */
      hint?: string | null;
      /** Coordinates of the physical address. */
      geocode?: AddressLocation$1;
      /** Country full name. */
      countryFullname?: string | null;
      /** Multi-level subdivisions from top to bottom. */
      subdivisions?: Subdivision$1[];
  }
  /** @oneof */
  interface AddressStreetOneOf$1 {
      /** Street name, number and apartment number. */
      streetAddress?: StreetAddress$1;
      /** Main address line, usually street and number, as free text. */
      addressLine?: string | null;
  }
  interface StreetAddress$1 {
      /** Street number. */
      number?: string;
      /** Street name. */
      name?: string;
      /** Apartment number. */
      apt?: string;
  }
  interface AddressLocation$1 {
      /** Address latitude. */
      latitude?: number | null;
      /** Address longitude. */
      longitude?: number | null;
  }
  interface Subdivision$1 {
      /** Subdivision code. Usually state, region, prefecture or province code, according to [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). */
      code?: string;
      /** Subdivision full name. */
      name?: string;
  }
  interface CustomFormField$1 {
      /** ID of the form field as defined in the form. */
      _id?: string;
      /** Value that was submitted for this field. */
      value?: string | null;
      /**
       * Form field's label at the time of submission.
       * @readonly
       */
      label?: string | null;
      valueType?: ValueType$1;
  }
  enum ValueType$1 {
      /** Short text. This is the default value type. */
      SHORT_TEXT = "SHORT_TEXT",
      /** Long text */
      LONG_TEXT = "LONG_TEXT",
      /** a text that represent the check box value: if selected the value is "true", otherwise "false". */
      CHECK_BOX = "CHECK_BOX"
  }
  /** Booking status. */
  enum BookingStatus$1 {
      CREATED = "CREATED",
      CONFIRMED = "CONFIRMED",
      CANCELED = "CANCELED",
      PENDING = "PENDING",
      DECLINED = "DECLINED",
      WAITING_LIST = "WAITING_LIST"
  }
  /**
   * Payment status.
   * Automatically updated when using eCom checkout APIs.
   */
  enum PaymentStatus$1 {
      UNDEFINED = "UNDEFINED",
      NOT_PAID = "NOT_PAID",
      PAID = "PAID",
      /** not supported yet. */
      PARTIALLY_PAID = "PARTIALLY_PAID",
      /** not supported yet */
      REFUNDED = "REFUNDED",
      EXEMPT = "EXEMPT"
  }
  /**
   * The selected payment option.
   * One of the payment options offered by the service.
   * This field is be set when the user selects an option during booking.
   * If left undefined, the payment option is resolved by the service configuration on checkout.
   */
  enum SelectedPaymentOption$1 {
      UNDEFINED = "UNDEFINED",
      OFFLINE = "OFFLINE",
      ONLINE = "ONLINE",
      MEMBERSHIP = "MEMBERSHIP",
      /** Payment can only be done using a membership and must be manually redeemed in the dashboard by the site owner. */
      MEMBERSHIP_OFFLINE = "MEMBERSHIP_OFFLINE"
  }
  interface BookingSource$1 {
      /** Platform from which a booking was created */
      platform?: Platform$1;
      /** Actor that created this booking. */
      actor?: Actor$1;
      /**
       * Wix site ID of the application that created the booking.
       * @readonly
       */
      appDefId?: string | null;
      /**
       * Name of the application that created the booking, as saved in Wix Developers Center at the time of booking.
       * @readonly
       */
      appName?: string | null;
  }
  enum Platform$1 {
      UNDEFINED_PLATFORM = "UNDEFINED_PLATFORM",
      WEB = "WEB",
      MOBILE_APP = "MOBILE_APP"
  }
  enum Actor$1 {
      UNDEFINED_ACTOR = "UNDEFINED_ACTOR",
      BUSINESS = "BUSINESS",
      CUSTOMER = "CUSTOMER"
  }
  interface ParticipantNotification$1 {
      /**
       * Whether to send the message about the changes to the customer.
       *
       * Default: `false`
       */
      notifyParticipants?: boolean;
      /** Custom message to send to the participants about the changes to the booking. */
      message?: string | null;
      /**
       * Optional additional metadata.
       * Supported only in V3 APIs.
       * @internal
       */
      metadata?: Record<string, string>;
  }
  interface CommonIdentificationData extends CommonIdentificationDataIdOneOf {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
      /** ID of of a contact in the site's [CRM by Ascend](https://www.wix.com/ascend/crm) system. */
      contactId?: string | null;
      /**
       * @internal
       * @readonly
       */
      identityType?: IdentificationDataIdentityType;
  }
  /** @oneof */
  interface CommonIdentificationDataIdOneOf {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
  }
  enum IdentificationDataIdentityType {
      UNKNOWN = "UNKNOWN",
      ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
      MEMBER = "MEMBER",
      WIX_USER = "WIX_USER",
      APP = "APP"
  }
  interface FlowControlSettings$1 {
      /**
       * When true, skips the service defined booking-window in the booking policy.
       * Requires BOOKINGS.IGNORE_BOOKING_POLICY permissions.
       * private because it's confusing to external users - collides with skip_availability_validation
       * and yet, clients send it (though always with skip_availability_validation=true) so we're not just removing it
       * When removing, we need to use proto's `reserved` field
       * @internal
       * @deprecated
       */
      ignoreBookingWindow?: boolean;
      /**
       * When true, skips availability checking and allows booking.
       * Requires BOOKINGS.OVERRIDE_AVAILABILITY permissions.
       */
      skipAvailabilityValidation?: boolean;
      /**
       * When true, allows booking a confirmation-required service without requiring confirmation.
       * Requires BOOKINGS.IGNORE_BOOKING_POLICY permissions.
       */
      skipBusinessConfirmation?: boolean;
      /**
       * When true, skips selected payment option checking as defined in `selectedPaymentOption` field
       * and allows booking.
       * Requires BOOKINGS.MANAGE_PAYMENTS permissions.
       */
      skipSelectedPaymentOptionValidation?: boolean;
      /** When true, refunds the booking's payment when the booking is canceled. */
      withRefund?: boolean | null;
  }
  interface ExtendedFields$1 {
      /**
       * Extended field data. Each key corresponds to the namespace of the app that created the extended fields.
       * The value of each key is structured according to the schema defined when the extended fields were configured.
       *
       * You can only access fields for which you have the appropriate permissions.
       *
       * Learn more about [extended fields](https://dev.wix.com/docs/rest/articles/getting-started/extended-fields).
       */
      namespaces?: Record<string, Record<string, any>>;
  }
  interface ParticipantChoices$1 {
      /** Information about the booked service choices. Includes the number of participants. */
      serviceChoices?: ServiceChoices$1[];
  }
  interface ServiceChoices$1 {
      /** Number of participants for this variant. */
      numberOfParticipants?: number | null;
      /** Service choices for these participants. */
      choices?: ServiceChoice$1[];
  }
  interface ServiceChoice$1 extends ServiceChoiceChoiceOneOf$1 {
      /**
       * Value for one of the choices in the `CustomServiceOption.choices` list.
       * Choices are specific values for an option the customer can choose to book. For example,
       * the option `ageGroup` may have these choices: `child`, `student`, `adult`, and `senior`.
       * Each choice may have a different price.
       */
      custom?: string;
      /**
       * ID of the corresponding option for the choice. For example, the choice `child`
       * could correspond to the option `ageGroup`. In this case, `optionId` is the ID
       * for the `ageGroup` option.
       */
      optionId?: string;
  }
  /** @oneof */
  interface ServiceChoiceChoiceOneOf$1 {
      /**
       * Value for one of the choices in the [`CustomServiceOption.choices`](https://example.com) list.
       * Choices are specific values for an option the customer can choose to book. For example,
       * the option `ageGroup` may have these choices: `child`, `student`, `adult`, and `senior`.
       * Each choice may have a different price.
       */
      custom?: string;
  }
  interface MultiServiceBookingInfo$1 {
      /**
       * Multi service booking ID.
       * @readonly
       */
      _id?: string | null;
      /** Multi service booking type. */
      type?: MultiServiceBookingType$1;
  }
  interface CreateMultiServiceBookingRequest {
      /** The bookings to create as multi service booking. */
      bookings: Booking$1[];
      /** Information about a message to send to the customer. */
      participantNotification?: ParticipantNotification$1;
      /**
       * Whether to send an SMS reminder to the customer 24 hours before the
       * session starts. The phone number is taken from `contactDetails.phone`.
       * Default: `true`.
       */
      sendSmsReminder?: boolean | null;
      /**
       * Information about whether specific procedures of the standard Wix Bookings
       * creation flow are changed. For example, whether the availability is
       * checked before creating the booking or if additional payment options are
       * accepted.
       */
      flowControlSettings?: CreateBookingFlowControlSettings;
      /** Whether to return the created bookings entities. */
      returnFullEntity?: boolean;
      /**
       * Multi service booking type.
       * One of:
       * - `"SEQUENTIAL_BOOKINGS"` Multi service booking will be considered available if its bookings are available as returned from ListMultiServiceAvailabilityTimeSlots API.
       * - `"SEPARATE_BOOKINGS"` Not supported yet.
       * - `"PARALLEL_BOOKINGS"` Not supported yet.
       */
      multiServiceBookingType?: MultiServiceBookingType$1;
  }
  interface CreateBookingFlowControlSettings {
      /**
       * when defined as `true`, skips the service defined booking-window in the booking policy.
       * required BOOKINGS.IGNORE_BOOKING_POLICY permission. TODO - check if can be merged with skit_availability_validation
       * private because it's confusing to external users - collides with skip_availability_validation
       * and yet, clients send it (though always with skip_availability_validation=true) so we're not just removing it
       * When removing, we need to use proto's `reserved` field
       * @internal
       * @deprecated
       */
      ignoreBookingWindow?: boolean;
      /**
       * Whether the availability is checked before creating the booking. When
       * passing `false` a booking is only created when the slot or schedule is
       * available.
       * Default: `false`.
       */
      skipAvailabilityValidation?: boolean;
      /**
       * Whether `PENDING` bookings are automatically set to `CONFIRMED` for
       * services that normally require the owner's manual confirmation. Your
       * app must have the `BOOKINGS.OVERRIDE_AVAILABILITY` permission scope
       * when passing `true`.
       * Default: `false`.
       */
      skipBusinessConfirmation?: boolean;
      /**
       * Whether customers can pay using a payment method that isn't supported
       * for the service, but that's supported for other services. Your app
       * must have the `BOOKINGS.MANAGE_PAYMENTS` permission scope when passing
       * `true`.
       * Default: `false`.
       */
      skipSelectedPaymentOptionValidation?: boolean;
  }
  interface CreateMultiServiceBookingResponse {
      /**
       * Created multi service booking.
       * Contains the booking results on the same order as passed on the request.
       */
      multiServiceBooking?: MultiServiceBooking;
  }
  interface MultiServiceBooking {
      /** Multi service booking ID. */
      _id?: string | null;
      /** The created bookings which are part of the multi service booking */
      bookings?: BookingResult[];
  }
  interface BookingResult {
      /** Booking ID. */
      bookingId?: string | null;
      /** Booking entity. */
      booking?: Booking$1;
  }
  interface RescheduleMultiServiceBookingRequest {
      /** ID of the multi service booking to reschedule it's related bookings. */
      multiServiceBookingId: string | null;
      /** Bookings to reschedule. */
      rescheduleBookingsInfo: RescheduleMultiServiceBookingRequestRescheduleBookingInfo[];
      /** Information about whether to notify the customer about the rescheduling and the message to send. */
      participantNotification?: ParticipantNotification$1;
      /**
       * Information about whether specific procedures of the standard Wix Bookings
       * rescheduling flow are changed. For example, whether the availability of
       * the new slot is checked before rescheduling the booking or if you can
       * reschedule the booking even though the rescheduling policy doesn't allow it.
       */
      flowControlSettings?: RescheduleBookingFlowControlSettings;
      /** Whether to return the rescheduled bookings entities. */
      returnFullEntity?: boolean;
  }
  interface V2Slot {
      /** Identifier for underlying session when session is a single session or generated from a recurring session. */
      sessionId?: string | null;
      /** Service identifier. Required. */
      serviceId?: string;
      /** Schedule identifier. Required. */
      scheduleId?: string;
      /** The start time of this Slot (formatted according to RFC3339). */
      startDate?: string | null;
      /** The end time of this Slot (formatted according to RFC3339). */
      endDate?: string | null;
      /** The timezone according to which the slot is calculated presented. */
      timezone?: string | null;
      /**
       * The resource required for this slot.
       * When populated, the given resource will be assigned to the slot upon confirmation according to it's availability.
       * When empty, If `skip_availability_validation` is `false`, a random available resource will be assigned to the slot upon confirmation,
       * otherwise one of the service resources will be assigned to the slot randomly upon confirmation.
       */
      resource?: SlotSlotResource;
      /** Geographic location of the slot. */
      location?: SlotLocation;
      /**
       * Calendar 3 event ID - not supported
       * If not empty, on all write flows (create / update) gets priority over session_id.
       * so if both session_id and event_id are provided, the session_id that will be set on the booking will be based on the event_id.
       * Otherwise, if event_id is empty on write flow,
       * @internal
       */
      eventId?: string | null;
      /**
       * Optional.
       * In addition to the `resource` field, these are the additional enriched resources that are assigned to the slot.
       * For example the room, equipment or the additional staff member that are assigned to the slot.
       * @internal
       */
      additionalResources?: SlotSlotResource[];
  }
  enum LocationLocationType {
      UNDEFINED = "UNDEFINED",
      OWNER_BUSINESS = "OWNER_BUSINESS",
      OWNER_CUSTOM = "OWNER_CUSTOM",
      CUSTOM = "CUSTOM"
  }
  interface SlotSlotResource {
      /**
       * Resource ID
       * @readonly
       */
      _id?: string | null;
      /** Read only. Resource name. */
      name?: string | null;
      /**
       * Read only. Schedule ID
       * @internal
       */
      scheduleId?: string | null;
  }
  interface SlotLocation {
      /** Business Location ID. Present if the location is a business location. */
      _id?: string | null;
      /** Location name. */
      name?: string | null;
      /** A string containing the full address of this location. */
      formattedAddress?: string | null;
      /**
       * Location type.
       * One of:
       * - `"OWNER_BUSINESS"` The business address as set in the sites general settings.
       * - `"OWNER_CUSTOM"` The address as set when creating the service.
       * - `"CUSTOM"` The address set for the individual session.
       */
      locationType?: LocationLocationType;
  }
  interface RescheduleMultiServiceBookingRequestRescheduleBookingInfo extends RescheduleMultiServiceBookingRequestRescheduleBookingInfoParticipantsInfoOneOf {
      /**
       * Total number of participants. Available only for services with
       * variants.
       * Pass when all participants book the same variant.
       */
      totalParticipants?: number;
      /**
       * Information about the service choices to book. Available only for services with
       * variants.
       * Pass when not all participants book the same variant.
       */
      participantsChoices?: ParticipantChoices$1;
      /** ID of the booking to reschedule. */
      bookingId?: string | null;
      /** Information about the new slot. */
      slot?: V2Slot;
      /**
       * Revision number, which increments by 1 each time the booking is updated.
       * To prevent conflicting changes, the current revision must be passed when
       * managing the booking.
       */
      revision?: string | null;
  }
  /** @oneof */
  interface RescheduleMultiServiceBookingRequestRescheduleBookingInfoParticipantsInfoOneOf {
      /**
       * Total number of participants. Available only for services with
       * variants.
       * Pass when all participants book the same variant.
       */
      totalParticipants?: number;
      /**
       * Information about the service choices to book. Available only for services with
       * variants.
       * Pass when not all participants book the same variant.
       */
      participantsChoices?: ParticipantChoices$1;
  }
  interface RescheduleBookingFlowControlSettings {
      /**
       * Whether the rescheduling policy applies when rescheduling the booking.
       * When passing `false` you can only cancel a booking if the rescheduling
       * policy allows it.
       * Default: `false`.
       */
      ignoreReschedulePolicy?: boolean;
      /**
       * when defined as true, skips the service defined booking-window validation in the booking policy.
       * required BOOKINGS.IGNORE_BOOKING_POLICY permission.
       * @internal
       * @deprecated
       */
      ignoreBookingWindow?: boolean;
      /**
       * Whether the availability is checked before rescheduling the booking.
       * When passing `false` a booking is only created when the slot or
       * schedule is available.
       * Default: `false`.
       */
      skipAvailabilityValidation?: boolean;
      /**
       * Whether the rescheduled booking's status is automatically set to
       * `CONFIRMED` for services that normally require the owner's manual
       * confirmation.
       * Default: `false`.
       */
      skipBusinessConfirmation?: boolean;
  }
  interface RescheduleMultiServiceBookingResponse {
      /** Rescheduled multi service booking. */
      multiServiceBooking?: MultiServiceBooking;
  }
  interface BookingRescheduled extends BookingRescheduledPreviousParticipantsInfoOneOf {
      /** The previous total number of participants. Available only when the booking includes a single service variant. */
      previousTotalParticipants?: number;
      /**
       * Information about the previous booked service choices and participants.
       * Available only when the booking includes multiple service variants.
       */
      previousParticipantsChoices?: ParticipantChoices$1;
      /** The rescheduled booking object. */
      booking?: Booking$1;
      /** Information about whether to notify the customer about the rescheduling and the message to send. */
      participantNotification?: ParticipantNotification$1;
      /**
       * Information about whether specific procedures of the standard Wix Bookings
       * rescheduling flow are changed. For example, whether the availability of
       * the new slot is checked before rescheduling the booking or if you can
       * reschedule the booking even though the rescheduling policy doesn't allow it.
       */
      flowControlSettings?: RescheduleBookingFlowControlSettings;
      /** ID of the rescheduling initiator. */
      initiatedBy?: IdentificationData$1;
      /** The previous status of the booking. */
      previousStatus?: BookingStatus$1;
      /** An object describing the previous slot or schedule of the booking. */
      previousBookedEntity?: BookedEntity$1;
      /** The previous start date of the booking. For a slot, this is the start date of the slot. For a schedule, this is the start date of the first session. */
      previousStartDate?: Date | null;
      /** The previous end date of the booking. For a slot, this is the end date of the slot. For a schedule, this is the end date of the last session. */
      previousEndDate?: Date | null;
  }
  /** @oneof */
  interface BookingRescheduledPreviousParticipantsInfoOneOf {
      /** The previous total number of participants. Available only when the booking includes a single service variant. */
      previousTotalParticipants?: number;
      /**
       * Information about the previous booked service choices and participants.
       * Available only when the booking includes multiple service variants.
       */
      previousParticipantsChoices?: ParticipantChoices$1;
  }
  interface IdentificationData$1 extends IdentificationDataIdOneOf$1 {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
      /**
       * ID of of a contact in the site's [CRM by Ascend](https://www.wix.com/ascend/crm) system.
       * @readonly
       */
      contactId?: string | null;
      /**
       * @internal
       * @readonly
       */
      identityType?: IdentityType$1;
  }
  /** @oneof */
  interface IdentificationDataIdOneOf$1 {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
  }
  enum IdentityType$1 {
      UNKNOWN = "UNKNOWN",
      ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
      MEMBER = "MEMBER",
      WIX_USER = "WIX_USER",
      APP = "APP"
  }
  interface GetMultiServiceBookingAvailabilityRequest {
      multiServiceBookingId: string | null;
  }
  interface GetMultiServiceBookingAvailabilityResponse {
      /** Whether these bookings are bookable. */
      bookable?: boolean;
      /** Total number of spots for this availability. */
      totalCapacity?: number | null;
      /** Number of open spots for this availability. */
      remainingCapacity?: number | null;
      /** Indicators for policy violations of the multi service booking. */
      policyViolations?: BookingPolicyViolations;
      /** Multi service booking policy settings */
      policySettings?: BookingPolicySettings;
      /** Info of the bookings this availability was calculated for. */
      multiServiceBookingInfo?: GetMultiServiceBookingAvailabilityResponseBookingInfo[];
  }
  interface BookingPolicyViolations {
      /** Bookings policy violation. Too early to book this slot. */
      tooEarlyToBook?: boolean | null;
      /** Bookings policy violation. Too late to book this slot. */
      tooLateToBook?: boolean | null;
      /** Bookings policy violation. Online booking is disabled for this slot. */
      bookOnlineDisabled?: boolean | null;
  }
  interface BookingPolicySettings {
      /** Booking policy settings for a given Slot/Schedule */
      maxParticipantsPerBooking?: number | null;
  }
  interface GetMultiServiceBookingAvailabilityResponseBookingInfo {
      /** Booking id */
      bookingId?: string | null;
  }
  interface CancelMultiServiceBookingRequest {
      /** ID of the multi service booking to cancel it's related bookings. */
      multiServiceBookingId: string | null;
      /** Information about whether to notify the customer about the cancelation and the message to send. */
      participantNotification?: ParticipantNotification$1;
      /**
       * Information about whether specific procedures of the standard Wix Bookings
       * cancelation flow are changed. For example, whether the you can cancel
       * a booking even though the cancelation policy doesn't allow it or whether
       * to issue a refund.
       */
      flowControlSettings?: CancelBookingFlowControlSettings;
      /** Whether to return the canceled bookings entities. */
      returnFullEntity?: boolean;
  }
  interface CancelBookingFlowControlSettings {
      /**
       * Whether the cancelation policy applies when canceling the booking. When
       * passing `false` you can only cancel a booking if the cancelation policy
       * allows it.
       * Default: `false`.
       */
      ignoreCancellationPolicy?: boolean | null;
      /**
       * Whether to issue a refund when canceling the booking.
       * The refund will be issued only if the booking is refundable.
       * Currently, booking is considered refundable when it was paid by membership.
       * If passing `true`, the booking flow control settings will be set with refund,
       * otherwise, either if `false` is passed or the field remains empty,
       * the booking flow control settings will be set with no refund.
       * Default: `false`.
       */
      withRefund?: boolean | null;
      /**
       * Whether to waive the cancellation fee when canceling the booking.
       * By default, cancellation fee will be applied.
       * If passing `true`, the cancellation fee will not be applied upon canceling the booking.
       * Must have the `BOOKINGS.MANAGE_PAYMENTS` permission scope when passing `true`.
       * Default: `false`.
       * @internal
       */
      waiveCancellationFee?: boolean | null;
  }
  interface CancelMultiServiceBookingResponse {
      /** Canceled multi service booking. */
      multiServiceBooking?: MultiServiceBooking;
  }
  interface BookingCanceled {
      /** The canceled booking object. */
      booking?: Booking$1;
      /** Information about whether to notify the customer about the cancelation and the message to send. */
      participantNotification?: ParticipantNotification$1;
      /**
       * Information about whether specific procedures of the standard Wix Bookings
       * cancelation flow are changed. For example, whether you can cancel
       * a booking even though the cancelation policy doesn't allow it or whether
       * to issue a refund.
       */
      flowControlSettings?: CancelBookingFlowControlSettings;
      /** ID of the cancelation initiator. */
      initiatedBy?: IdentificationData$1;
      /** The previous status of the booking. */
      previousStatus?: BookingStatus$1;
  }
  interface MarkMultiServiceBookingAsPendingRequest {
      /** ID of the multi service booking to mark as pending it's related bookings. */
      multiServiceBookingId: string | null;
      /** Bookings to mark as pending. */
      markAsPendingBookingsInfo?: BookingInfo[];
      /** Information about whether to notify the customer upon manual confirmation and the message to send. */
      participantNotification?: ParticipantNotification$1;
      /**
       * Whether to send an SMS reminder to the customer 24 hours before the
       * session starts. The phone number is taken from `contactDetails.phone`.
       */
      sendSmsReminder?: boolean | null;
      /** Whether this booking overlaps with another existing confirmed booking. */
      doubleBooked?: boolean | null;
      /** Whether to return the pending bookings entities. */
      returnFullEntity?: boolean;
      /**
       * Information about whether specific procedures of the standard Wix Bookings
       * creation flow are changed. For example, whether the availability is
       * checked before updating the booking.
       */
      flowControlSettings?: MarkBookingAsPendingFlowControlSettings;
  }
  interface BookingInfo {
      /** ID of the booking. */
      bookingId?: string | null;
      /**
       * Revision number, which increments by 1 each time the booking is updated.
       * To prevent conflicting changes, the current revision must be passed when
       * managing the booking.
       */
      revision?: string | null;
      /**
       * Payment status to set for the booking.
       * One of:
       * - `"NOT_PAID"` The booking is not paid for.
       * - `"PAID"` The booking is fully paid.
       * - `"PARTIALLY_PAID"` The booking is partially paid.
       * - `"REFUNDED"` The booking is refunded.
       * - `"EXEMPT"` The booking is free of charge.
       */
      paymentStatus?: PaymentStatus$1;
  }
  interface MarkBookingAsPendingFlowControlSettings {
      /**
       * Whether should check for double bookings before updating the booking as pending.
       * When passing `false` a booking is only being updated with status PENDING
       * Default: `false`.
       */
      checkAvailabilityValidation?: boolean;
      /**
       * Whether should validate that the given booking to be marked as pending, has a booking.slot.serviceId
       * of a pending approval service.
       * Default: `false`.
       */
      skipPendingApprovalServiceValidation?: boolean;
  }
  interface MarkMultiServiceBookingAsPendingResponse {
      /** Pending multi service booking. */
      multiServiceBooking?: MultiServiceBooking;
  }
  interface ConfirmMultiServiceBookingRequest {
      /** ID of the multi service booking to confirm it's related bookings. */
      multiServiceBookingId: string | null;
      /** Bookings to confirm. */
      confirmBookingsInfo?: BookingInfo[];
      /** Information about whether to notify the customer about the confirmation and the message to send. */
      participantNotification?: ParticipantNotification$1;
      /**
       * Whether to send an SMS reminder to the customer 24 hours before the
       * session starts. The phone number is taken from `contactDetails.phone`.
       */
      sendSmsReminder?: boolean | null;
      /** Whether this booking overlaps with another existing confirmed booking. */
      doubleBooked?: boolean | null;
      /** Whether to return the confirmed bookings entities. */
      returnFullEntity?: boolean;
      /**
       * Information about whether specific procedures of the standard Wix Bookings
       * confirmation flow are changed. For example, whether the availability is
       * checked before confirming the booking.
       */
      flowControlSettings?: ConfirmBookingFlowControlSettings;
  }
  interface ConfirmBookingFlowControlSettings {
      /**
       * Whether the availability is checked before confirming the booking.
       * When passing `false` a booking is only being updated with status CONFIRMED
       * Default: `false`.
       */
      checkAvailabilityValidation?: boolean;
  }
  interface ConfirmMultiServiceBookingResponse {
      /** Confirmed multi service booking. */
      multiServiceBooking?: MultiServiceBooking;
  }
  interface BookingConfirmed {
      /** The confirmed booking object. */
      booking?: Booking$1;
      /** Information about whether to notify the customer about the confirmation and the message to send. */
      participantNotification?: ParticipantNotification$1;
      /**
       * Whether to send an SMS reminder to the customer 24 hours before the
       * session starts. The phone number is taken from `contactDetails.phone`.
       */
      sendSmsReminder?: boolean | null;
      /** Whether this booking overlaps with another existing confirmed booking. */
      doubleBooked?: boolean | null;
      /** ID of the confirmation initiator. */
      initiatedBy?: IdentificationData$1;
      /** The previous status of the booking. */
      previousStatus?: BookingStatus$1;
      /** The previous payment status of the booking. */
      previousPaymentStatus?: PaymentStatus$1;
  }
  interface DeclineMultiServiceBookingRequest {
      /** ID of the multi service booking to decline it's related bookings. */
      multiServiceBookingId: string | null;
      /** Bookings to decline. */
      declineBookingsInfo?: BookingInfo[];
      /** Information about whether to notify the customer about the decline and the message to send. */
      participantNotification?: ParticipantNotification$1;
      /** Whether this booking overlaps with another existing confirmed booking. */
      doubleBooked?: boolean | null;
      /** Whether to return the declined bookings entities. */
      returnFullEntity?: boolean;
      /**
       * Information about whether specific procedures of the standard Wix Bookings
       * declining flow are changed. For example, whether to issue a refund.
       */
      flowControlSettings?: DeclineBookingFlowControlSettings;
  }
  interface DeclineBookingFlowControlSettings {
      /**
       * Whether to issue a refund when declining the booking.
       * The refund will be issued only if the booking is refundable.
       * Currently, booking is considered refundable when it was paid by membership.
       * If passing `true`, the booking flow control settings will be set with refund,
       * otherwise, either if `false` is passed or the field remains empty,
       * the booking flow control settings will be set with no refund.
       * Default: `false`.
       */
      withRefund?: boolean | null;
  }
  interface DeclineMultiServiceBookingResponse {
      /** Declined multi service booking. */
      multiServiceBooking?: MultiServiceBooking;
  }
  interface BookingDeclined {
      /** The declined booking object. */
      booking?: Booking$1;
      /** Information about whether to notify the customer about the decline and the message to send. */
      participantNotification?: ParticipantNotification$1;
      /** Whether this booking overlaps with another existing confirmed booking. */
      doubleBooked?: boolean | null;
      /** ID of the decline initiator. */
      initiatedBy?: IdentificationData$1;
      /** The previous status of the booking. */
      previousStatus?: BookingStatus$1;
      /** The previous payment status of the booking. */
      previousPaymentStatus?: PaymentStatus$1;
      /**
       * Information about whether specific procedures of the standard Wix Bookings
       * declining flow are changed. For example, whether to issue a refund.
       */
      flowControlSettings?: DeclineBookingFlowControlSettings;
  }
  interface BulkGetMultiServiceBookingAllowedActionsRequest {
      /** The multi service booking ids to get the allowedActions for. */
      multiServiceBookingIds: string[] | null;
  }
  interface BulkGetMultiServiceBookingAllowedActionsResponse {
      results?: BulkCalculateAllowedActionsResult[];
      bulkActionMetadata?: BulkActionMetadata;
  }
  interface BulkCalculateAllowedActionsResult {
      /** (id, indexInGivenSeq, isSuccessful, error) */
      itemMetadata?: ItemMetadata;
      item?: AllowedActions;
  }
  interface ItemMetadata {
      /** Item ID. Should always be available, unless it's impossible (for example, when failing to create an item). */
      _id?: string | null;
      /** Index of the item within the request array. Allows for correlation between request and response items. */
      originalIndex?: number;
      /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
      success?: boolean;
      /** Details about the error in case of failure. */
      error?: ApplicationError;
  }
  interface ApplicationError {
      /** Error code. */
      code?: string;
      /** Description of the error. */
      description?: string;
      /** Data related to the error. */
      data?: Record<string, any> | null;
  }
  /** Possible allowed actions for a Booking */
  interface AllowedActions {
      /** Is cancel booking allowed */
      cancel?: boolean;
      /** Is reschedule booking allowed */
      reschedule?: boolean;
      /**
       * Is it possible to book another booking to the same service.
       * @internal
       */
      bookAnother?: boolean;
  }
  interface BulkActionMetadata {
      /** Number of items that were successfully processed. */
      totalSuccesses?: number;
      /** Number of items that couldn't be processed. */
      totalFailures?: number;
      /** Number of failures without details because detailed failure threshold was exceeded. */
      undetailedFailures?: number;
  }
  interface MarkAsMultiServiceBookingRequest {
      /** IDs of the bookings to mark as multi service booking. */
      bookingIds: string[] | null;
      /**
       * Multi service booking type.
       * One of:
       * - `"SEQUENTIAL_BOOKINGS"` Multi service booking will be considered available if its bookings are available as returned from ListMultiServiceAvailabilityTimeSlots API.
       * - `"SEPARATE_BOOKINGS"` Not supported yet.
       * - `"PARALLEL_BOOKINGS"` Not supported yet.
       */
      multiServiceBookingType?: MultiServiceBookingType$1;
  }
  interface MarkAsMultiServiceBookingResponse {
      /** Multi service booking ID. */
      multiServiceBookingId?: string | null;
  }
  interface GetMultiServiceBookingRequest {
      /** Multi service booking ID. */
      multiServiceBookingId: string | null;
  }
  interface GetMultiServiceBookingResponse {
      /** Multi service booking. */
      multiServiceBooking?: MultiServiceBooking;
      metadata?: MultiServiceBookingMetadata;
  }
  interface MultiServiceBookingMetadata {
      /**
       * Total number of the scheduled bookings within the multi service booking, including bookings which were not retrieved due to lack of read permissions.
       * Scheduled bookings are bookings with status CONFIRMED or PENDING.
       */
      totalNumberOfScheduledBookings?: number | null;
  }
  interface AddBookingsToMultiServiceBookingRequest {
      /** ID of the multi service booking. */
      multiServiceBookingId: string | null;
      /** List of bookings ids and their revisions to add to the multi service booking. */
      bookings: BookingIdAndRevision[];
      /** Whether to return the bookings entities. */
      returnFullEntity?: boolean;
  }
  interface BookingIdAndRevision {
      /** ID of the booking. */
      bookingId?: string | null;
      /**
       * Revision number, which increments by 1 each time the booking is updated.
       * To prevent conflicting changes, the current revision must be passed when
       * managing the booking.
       */
      revision?: string | null;
  }
  interface AddBookingsToMultiServiceBookingResponse {
      /** The bookings that were added to the multi service booking. */
      bookings?: BookingResult[];
  }
  interface RemoveBookingsFromMultiServiceBookingRequest {
      /** ID of the multi service booking. */
      multiServiceBookingId: string | null;
      /** List of bookings ids and their revisions to remove from the multi service booking. */
      bookings?: BookingIdAndRevision[];
      /** Whether to return the bookings entities. */
      returnFullEntity?: boolean;
  }
  interface RemoveBookingsFromMultiServiceBookingResponse {
      /** The bookings that were removed from the multi service booking. */
      bookings?: BookingResult[];
  }
  interface DomainEvent extends DomainEventBodyOneOf {
      createdEvent?: EntityCreatedEvent;
      updatedEvent?: EntityUpdatedEvent;
      deletedEvent?: EntityDeletedEvent;
      actionEvent?: ActionEvent;
      /**
       * Unique event ID.
       * Allows clients to ignore duplicate webhooks.
       */
      _id?: string;
      /**
       * Assumes actions are also always typed to an entity_type
       * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
       */
      entityFqdn?: string;
      /**
       * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
       * This is although the created/updated/deleted notion is duplication of the oneof types
       * Example: created/updated/deleted/started/completed/email_opened
       */
      slug?: string;
      /** ID of the entity associated with the event. */
      entityId?: string;
      /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
      eventTime?: Date | null;
      /**
       * Whether the event was triggered as a result of a privacy regulation application
       * (for example, GDPR).
       */
      triggeredByAnonymizeRequest?: boolean | null;
      /** If present, indicates the action that triggered the event. */
      originatedFrom?: string | null;
      /**
       * A sequence number defining the order of updates to the underlying entity.
       * For example, given that some entity was updated at 16:00 and than again at 16:01,
       * it is guaranteed that the sequence number of the second update is strictly higher than the first.
       * As the consumer, you can use this value to ensure that you handle messages in the correct order.
       * To do so, you will need to persist this number on your end, and compare the sequence number from the
       * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
       */
      entityEventSequence?: string | null;
  }
  /** @oneof */
  interface DomainEventBodyOneOf {
      createdEvent?: EntityCreatedEvent;
      updatedEvent?: EntityUpdatedEvent;
      deletedEvent?: EntityDeletedEvent;
      actionEvent?: ActionEvent;
  }
  interface EntityCreatedEvent {
      entityAsJson?: string;
      /**
       * Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity
       * @internal
       */
      triggeredByUndelete?: boolean | null;
      /** Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity */
      restoreInfo?: RestoreInfo;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface RestoreInfo {
      deletedDate?: Date | null;
  }
  interface EntityUpdatedEvent {
      /**
       * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
       * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
       * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
       */
      currentEntityAsJson?: string;
      /**
       * This field is currently part of the of the EntityUpdatedEvent msg, but scala/node libraries which implements the domain events standard
       * wont populate it / have any reference to it in the API.
       * The main reason for it is that fetching the old entity from the DB will have a performance hit on an update operation so unless truly needed,
       * the developer should send only the new (current) entity.
       * An additional reason is not wanting to send this additional entity over the wire (kafka) since in some cases it can be really big
       * Developers that must reflect the old entity will have to implement their own domain event sender mechanism which will follow the DomainEvent proto message.
       * @internal
       * @deprecated
       */
      previousEntityAsJson?: string | null;
      /**
       * WIP - This property will hold both names and values of the updated fields of the entity.
       * For more details please see [adr](https://docs.google.com/document/d/1PdqsOM20Ph2HAkmx8zvUnzzk3Sekp3BR9h34wSvsRnI/edit#heading=h.phlw87mh2imx) or [issue](https://github.com/wix-private/nile-tracker/issues/363)
       * @internal
       */
      modifiedFields?: Record<string, any>;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface EntityDeletedEvent {
      /**
       * Indicates if the entity is sent to trash-bin. only available when trash-bin is enabled
       * @internal
       */
      movedToTrash?: boolean | null;
      /** Entity that was deleted */
      deletedEntityAsJson?: string | null;
      /**
       * WIP
       * @internal
       */
      additionalMetadataAsJson?: string | null;
  }
  interface ActionEvent {
      bodyAsJson?: string;
  }
  interface MessageEnvelope {
      /** App instance ID. */
      instanceId?: string | null;
      /** Event type. */
      eventType?: string;
      /** The identification type and identity data. */
      identity?: WebhooksIdentificationData;
      /** Stringify payload. */
      data?: string;
  }
  interface WebhooksIdentificationData extends WebhooksIdentificationDataIdOneOf {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
      /** @readonly */
      identityType?: WebhookIdentityType;
  }
  /** @oneof */
  interface WebhooksIdentificationDataIdOneOf {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
  }
  enum WebhookIdentityType {
      UNKNOWN = "UNKNOWN",
      ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
      MEMBER = "MEMBER",
      WIX_USER = "WIX_USER",
      APP = "APP"
  }
  interface BookingChanged {
      /** The booking before the changes. */
      previousBooking?: Booking$1;
      /** The booking after the changes. */
      currentBooking?: Booking$1;
  }
  interface CreateBookingRequest {
      /** The booking to create. */
      booking: Booking$1;
      /** Information about a message to send to the customer. */
      participantNotification?: ParticipantNotification$1;
      /**
       * Whether to send an SMS reminder to the customer 24 hours before the
       * session starts. The phone number is taken from `contactDetails.phone`.
       * Default: `true`.
       */
      sendSmsReminder?: boolean | null;
      /**
       * Information about whether specific procedures of the standard Wix Bookings
       * creation flow are changed. For example, whether the availability is
       * checked before creating the booking or if additional payment options are
       * accepted.
       */
      flowControlSettings?: CreateBookingFlowControlSettings;
  }
  interface CreateBookingResponse {
      /** Created booking. */
      booking?: Booking$1;
  }
  /**
   * The `fieldMask` should not include both the `numberOfParticipants` and `participantsInfo` paths. Including both results
   * in an error. `participantsInfo` is preferred over `numberOfParticipants`.
   */
  interface UpdateBookingRequest {
      booking: Booking$1;
      /** @internal */
      mask?: string[];
  }
  interface UpdateBookingResponse {
      booking?: Booking$1;
  }
  interface LegacyCreateBookingRequest {
      booking: Booking$1;
  }
  interface LegacyCreateBookingResponse {
      booking?: Booking$1;
  }
  /**
   * The `fieldMask` for each booking should not include both the `numberOfParticipants` and `participantsInfo` paths. Including both results
   * in an error. `participantsInfo` is preferred over `numberOfParticipants`.
   */
  interface BulkUpdateBookingRequest {
      bookings: MaskedBooking[];
  }
  interface MaskedBooking {
      booking?: Booking$1;
      /** @internal */
      mask?: string[];
  }
  interface BulkUpdateBookingResponse {
      results?: ItemMetadata[];
      bulkActionMetadata?: BulkActionMetadata;
  }
  interface BulkCreateBookingRequest {
      /**
       * Bookings to create.
       * Max: 8 bookings.
       */
      createBookingsInfo: CreateBookingInfo[];
      /** Whether to return the created bookings entities. */
      returnFullEntity?: boolean;
  }
  interface CreateBookingInfo {
      /** The booking to create */
      booking?: Booking$1;
      /** Information about a message to send to the customer. */
      participantNotification?: ParticipantNotification$1;
      /**
       * Whether to send an SMS reminder to the customer 24 hours before the
       * session starts. The phone number is taken from `contactDetails.phone`.
       * Default: `true`.
       */
      sendSmsReminder?: boolean | null;
      /**
       * Information about whether specific procedures of the standard Wix Bookings
       * creation flow are changed. For example, whether the availability is
       * checked before creating the booking or if additional payment options are
       * accepted.
       */
      flowControlSettings?: CreateBookingFlowControlSettings;
  }
  interface BulkCreateBookingResponse {
      /**
       * Bulk create booking results.
       * Whether it successfully created each booking, providing the corresponding error message if a failure occurred, and includes the created booking entity if the `returnFullEntity` is `true`.
       */
      results?: BulkBookingResult[];
      /** Total successes and failures of the bulk create booking action. */
      bulkActionMetadata?: BulkActionMetadata;
  }
  interface BulkBookingResult {
      itemMetadata?: ItemMetadata;
      item?: Booking$1;
  }
  interface RescheduleBookingRequest extends RescheduleBookingRequestParticipantsInfoOneOf {
      /**
       * Total number of participants. Available only for services with
       * variants.
       * Pass when all participants book the same variant.
       */
      totalParticipants?: number;
      /**
       * Information about the service choices to book. Available only for services with
       * variants.
       * Pass when not all participants book the same variant.
       */
      participantsChoices?: ParticipantChoices$1;
      /** ID of the booking to reschedule. */
      bookingId: string;
      /** Information about the new slot. */
      slot: V2Slot;
      /**
       * Revision number, which increments by 1 each time the booking is updated.
       * To prevent conflicting changes, the current revision must be passed when
       * managing the booking.
       */
      revision: string | null;
      /**
       * Information about whether to notify the customer about the rescheduling and
       * the message to send.
       */
      participantNotification?: ParticipantNotification$1;
      /**
       * Information about whether specific procedures of the standard Wix Bookings
       * rescheduling flow are changed. For example, whether the availability of
       * the new slot is checked before rescheduling the booking or if you can
       * reschedule the booking even though the rescheduling policy doesn't allow it.
       */
      flowControlSettings?: RescheduleBookingFlowControlSettings;
      /**
       * whether this booking availability should be checked with v1 or v2
       * @internal
       */
      v2Availability?: boolean | null;
  }
  /** @oneof */
  interface RescheduleBookingRequestParticipantsInfoOneOf {
      /**
       * Total number of participants. Available only for services with
       * variants.
       * Pass when all participants book the same variant.
       */
      totalParticipants?: number;
      /**
       * Information about the service choices to book. Available only for services with
       * variants.
       * Pass when not all participants book the same variant.
       */
      participantsChoices?: ParticipantChoices$1;
  }
  interface RescheduleBookingResponse {
      /** Rescheduled booking. */
      booking?: Booking$1;
  }
  interface BulkRescheduleBookingRequest {
      /** Reschedule multiple bookings to multiple slots. */
      slotsBookings: SlotBookings[];
      /** Whether to notify participants about the change and an optional custom message */
      participantNotification?: ParticipantNotification$1;
  }
  interface BulkRescheduleBookingRequestBooking {
      /** ID of the bookings to be rescheduled. */
      _id?: string;
      revision?: string | null;
  }
  /** Bookings to be rescheduled to the given slot. */
  interface SlotBookings {
      /** The bookings details. */
      bookings?: BulkRescheduleBookingRequestBooking[];
      /**
       * The slot to which the bookings were rescheduled.
       * This bookings are automatically assigned to the session, if given. Otherwise, a new session is created.
       */
      slot?: BookedSlot$1;
  }
  interface BulkRescheduleBookingResponse {
      /** The bulk reschedule results. For each booking, the results contain the metadata of the reschedule action. */
      results?: ItemMetadata[];
      /** Total successes and failures of the bulk reschedule action. */
      bulkActionMetadata?: BulkActionMetadata;
  }
  /** Update the booked schedule of multiple bookings to the given schedule. */
  interface BulkUpdateBookedScheduleRequest {
      /** The bookings whose booked schedule is to be updated to the given schedule. */
      bookings: BookingDetails[];
      /** The ID of the schedule to be updated. */
      scheduleId: string;
      /** Whether to notify participants about the change and an optional custom message. */
      participantNotification?: ParticipantNotification$1;
  }
  interface BookingDetails {
      /** ID of the bookings to be updated. */
      _id?: string;
      revision?: string | null;
  }
  interface BulkUpdateBookedScheduleResponse {
      /** The bulk update results. For each booking, the results contain the metadata of the update action. */
      results?: ItemMetadata[];
      /** Total successes and failures of the bulk update action. */
      bulkActionMetadata?: BulkActionMetadata;
  }
  interface QueryBookingsRequest {
      query: QueryV2;
      /**
       * Whether the authorization constraint should be handled on Bookings-Service. To be removed when rollout of SCHED-SCHED-25500 is finished.
       * @internal
       */
      shouldNotHandleAuthorizationConstraints?: boolean;
      /**
       * Whether information about the total entities is returned.
       * @internal
       */
      withPagingMetadataTotal?: boolean;
  }
  interface QueryV2 extends QueryV2PagingMethodOneOf {
      /** Paging options to limit and skip the number of items. */
      paging?: Paging;
      /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
      cursorPaging?: CursorPaging;
      /**
       * Filter object in the following format:
       * `"filter" : {
       * "fieldName1": "value1",
       * "fieldName2":{"$operator":"value2"}
       * }`
       * Example of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`, `$contains`
       */
      filter?: Record<string, any> | null;
      /**
       * Sort object in the following format:
       * `[{"fieldName":"sortField1","order":"ASC"},{"fieldName":"sortField2","order":"DESC"}]`
       */
      sort?: Sorting[];
      /** Array of projected fields. A list of specific field names to return. If `fieldsets` are also specified, the union of `fieldsets` and `fields` is returned. */
      fields?: string[];
      /** Array of named, predefined sets of projected fields. A array of predefined named sets of fields to be returned. Specifying multiple `fieldsets` will return the union of fields from all sets. If `fields` are also specified, the union of `fieldsets` and `fields` is returned. */
      fieldsets?: string[];
  }
  /** @oneof */
  interface QueryV2PagingMethodOneOf {
      /** Paging options to limit and skip the number of items. */
      paging?: Paging;
      /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
      cursorPaging?: CursorPaging;
  }
  interface Sorting {
      /** Name of the field to sort by. */
      fieldName?: string;
      /** Sort order. */
      order?: SortOrder;
      /**
       * When `field_name` is a property of repeated field that is marked as `MATCH_ITEMS` and sort should be done by
       * a specific element from a collection, filter can/should be provided to ensure correct sort value is picked.
       *
       * If multiple filters are provided, they are combined with AND operator.
       *
       * Example:
       * Given we have document like {"id": "1", "nestedField": [{"price": 10, "region": "EU"}, {"price": 20, "region": "US"}]}
       * and `nestedField` is marked as `MATCH_ITEMS`, to ensure that sorting is done by correct region, filter should be
       * { fieldName: "nestedField.price", "select_items_by": [{"nestedField.region": "US"}] }
       * @internal
       */
      selectItemsBy?: Record<string, any>[] | null;
  }
  enum SortOrder {
      ASC = "ASC",
      DESC = "DESC"
  }
  interface Paging {
      /** Number of items to load. */
      limit?: number | null;
      /** Number of items to skip in the current sort order. */
      offset?: number | null;
  }
  interface CursorPaging {
      /** Maximum number of items to return in the results. */
      limit?: number | null;
      /**
       * Pointer to the next or previous page in the list of results.
       *
       * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
       * Not relevant for the first request.
       */
      cursor?: string | null;
  }
  interface QueryBookingsResponse {
      bookings?: Booking$1[];
      pagingMetadata?: PagingMetadataV2;
  }
  interface PagingMetadataV2 {
      /** Number of items returned in the response. */
      count?: number | null;
      /** Offset that was requested. */
      offset?: number | null;
      /** Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set. */
      total?: number | null;
      /** Flag that indicates the server failed to calculate the `total` field. */
      tooManyToCount?: boolean | null;
      /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
      cursors?: Cursors;
      /**
       * Indicates if there are more results after the current page.
       * If `true`, another page of results can be retrieved.
       * If `false`, this is the last page.
       * @internal
       */
      hasNext?: boolean | null;
  }
  interface Cursors {
      /** Cursor string pointing to the next page in the list of results. */
      next?: string | null;
      /** Cursor pointing to the previous page in the list of results. */
      prev?: string | null;
  }
  interface ConfirmRequest {
      /** ID of the booking to be confirmed. */
      _id?: string;
      /** Whether to notify the participants about the booking confirmation, and an optional custom message. */
      participantNotification?: ParticipantNotification$1;
  }
  interface ConfirmResponse {
      /** Confirmed booking. */
      booking?: Booking$1;
      /** Whether this booking overlaps with another existing confirmed booking. */
      doubleBooked?: boolean | null;
  }
  interface ConfirmBookingRequest {
      /** ID of the booking to confirm. */
      bookingId: string;
      /**
       * Revision number, which increments by 1 each time the booking is updated.
       * To prevent conflicting changes, the current revision must be passed when
       * managing the booking.
       */
      revision: string | null;
      /**
       * Information about whether to notify the customer about the confirmation and
       * the message to send.
       */
      participantNotification?: ParticipantNotification$1;
      /**
       * Whether to send an SMS reminder to the customer 24 hours before the
       * session starts. The phone number is taken from `contactDetails.phone`.
       */
      sendSmsReminder?: boolean | null;
      /**
       * Payment status to set for the booking.
       * One of:
       * - `"NOT_PAID"` The booking is not paid for.
       * - `"PAID"` The booking is fully paid.
       * - `"PARTIALLY_PAID"` The booking is partially paid.
       * - `"REFUNDED"` The booking is refunded.
       * - `"EXEMPT"` The booking is free of charge.
       */
      paymentStatus?: PaymentStatus$1;
      /** Whether this booking overlaps with another existing confirmed booking. */
      doubleBooked?: boolean | null;
      /**
       * Information about whether specific procedures of the standard Wix Bookings
       * creation flow are changed. For example, whether the availability is
       * checked before confirming the booking.
       */
      flowControlSettings?: ConfirmBookingFlowControlSettings;
  }
  interface ConfirmBookingResponse {
      booking?: Booking$1;
  }
  interface PartySizeRequest extends PartySizeRequestPartySizeForOneOf {
      sessionId?: string | null;
      scheduleId?: string | null;
  }
  /** @oneof */
  interface PartySizeRequestPartySizeForOneOf {
      sessionId?: string | null;
      scheduleId?: string | null;
  }
  interface PartySizeResponse {
      partySize?: number | null;
  }
  interface ConsistentQueryBookingsRequest {
      query?: QueryV2;
  }
  interface ConsistentQueryBookingsResponse {
      bookings?: Booking$1[];
      pagingMetadata?: PagingMetadataV2;
  }
  interface SetBookingSessionIdRequest {
      /** ID of the booking to set its sessionId. */
      _id: string;
      /** The sessionId to be set. */
      sessionId?: string;
  }
  interface SetBookingSessionIdResponse {
      /** The updated booking. */
      booking?: Booking$1;
  }
  interface UpdateExtendedFieldsRequest {
      /** ID of the booking for which to update extended fields. */
      _id: string;
      /** [Namespace](https://dev.wix.com/docs/build-apps/develop-your-app/extensions/backend-extensions/schema-plugins/about-reading-and-writing-schema-plugin-fields#namespaces) of the app for which to update extended fields. */
      namespace: string;
      /** Data of the extended field to update. Must be structured according to the [schema](https://dev.wix.com/docs/build-apps/develop-your-app/extensions/backend-extensions/schema-plugins/about-schema-plugin-extensions#json-schema-for-extended-fields) defined during the configuration of the extended fields. */
      namespaceData: Record<string, any> | null;
  }
  interface UpdateExtendedFieldsResponse {
      /** [Namespace](https://dev.wix.com/docs/build-apps/develop-your-app/extensions/backend-extensions/schema-plugins/about-reading-and-writing-schema-plugin-fields#namespaces) of the app for which the extended fields were updated. */
      namespace?: string;
      /** Updated data of the extended fields. */
      namespaceData?: Record<string, any> | null;
  }
  interface DeclineBookingRequest {
      /** ID of the booking to decline. */
      bookingId: string;
      /**
       * Revision number, which increments by 1 each time the booking is updated.
       * To prevent conflicting changes, the current revision must be passed when
       * managing the booking.
       */
      revision: string | null;
      /**
       * Information about whether to notify the customer about the decline and
       * the message to send.
       */
      participantNotification?: ParticipantNotification$1;
      /**
       * Payment status to set on the booking.
       * One of:
       * - `"NOT_PAID"` The booking is not paid for.
       * - `"PAID"` The booking is fully paid.
       * - `"PARTIALLY_PAID"` The booking is partially paid.
       * - `"REFUNDED"` The booking is refunded.
       * - `"EXEMPT"` The booking is free of charge.
       */
      paymentStatus?: PaymentStatus$1;
      /** Whether this booking overlaps with another existing confirmed booking. */
      doubleBooked?: boolean | null;
      /**
       * Information about whether specific procedures of the standard Wix Bookings
       * declining flow are changed. For example, whether to issue a refund.
       */
      flowControlSettings?: DeclineBookingFlowControlSettings;
  }
  interface DeclineBookingResponse {
      /** eclined booking */
      booking?: Booking$1;
  }
  interface CancelBookingRequest {
      /** ID of the booking to cancel. */
      bookingId: string;
      /**
       * Information about whether to notify the customer about the cancelation and
       * the message to send.
       */
      participantNotification?: ParticipantNotification$1;
      /**
       * Information about whether specific procedures of the standard Wix Bookings
       * cancelation flow are changed. For example, whether the you can cancel
       * a booking even though the cancelation policy doesn't allow it or whether
       * to issue a refund.
       */
      flowControlSettings?: CancelBookingFlowControlSettings;
      /**
       * Revision number, which increments by 1 each time the booking is updated.
       * To prevent conflicting changes,
       * the current revision must be passed when managing the booking.
       */
      revision: string | null;
  }
  interface CancelBookingResponse {
      /** Canceled booking. */
      booking?: Booking$1;
  }
  interface UpdateNumberOfParticipantsRequest extends UpdateNumberOfParticipantsRequestParticipantsInfoOneOf {
      /**
       * Total number of participants. Available only for services with
       * variants.
       * Pass when all participants book the same variant.
       */
      totalParticipants?: number;
      /**
       * Information about the service choices to book. Available only for services with
       * variants.
       * Pass when not all participants book the same variant.
       */
      participantsChoices?: ParticipantChoices$1;
      /** ID of the booking to update the number of participants for. */
      bookingId: string;
      /**
       * Updated number of participants.
       * @internal
       * @deprecated
       */
      numberOfParticipants?: number | null;
      /**
       * Revision number, which increments by 1 each time the booking is updated.
       * To prevent conflicting changes, the current revision must be passed when
       * managing the booking.
       */
      revision: string | null;
  }
  /** @oneof */
  interface UpdateNumberOfParticipantsRequestParticipantsInfoOneOf {
      /**
       * Total number of participants. Available only for services with
       * variants.
       * Pass when all participants book the same variant.
       */
      totalParticipants?: number;
      /**
       * Information about the service choices to book. Available only for services with
       * variants.
       * Pass when not all participants book the same variant.
       */
      participantsChoices?: ParticipantChoices$1;
  }
  interface UpdateNumberOfParticipantsResponse {
      /** Booking with updated number of participants. */
      booking?: Booking$1;
  }
  interface NumberOfParticipantsUpdated extends NumberOfParticipantsUpdatedPreviousParticipantsInfoOneOf {
      /** The previous total number of participants. Available only when the booking includes a single service variant. */
      previousTotalParticipants?: number;
      /**
       * Information about the previous booked service choices and participants.
       * Available only when the booking includes multiple service variants.
       */
      previousParticipantsChoices?: ParticipantChoices$1;
      /** The updated booking object. */
      booking?: Booking$1;
      /** ID of the participant number update initiator. */
      initiatedBy?: IdentificationData$1;
  }
  /** @oneof */
  interface NumberOfParticipantsUpdatedPreviousParticipantsInfoOneOf {
      /** The previous total number of participants. Available only when the booking includes a single service variant. */
      previousTotalParticipants?: number;
      /**
       * Information about the previous booked service choices and participants.
       * Available only when the booking includes multiple service variants.
       */
      previousParticipantsChoices?: ParticipantChoices$1;
  }
  interface CalculateAllowedActionsRequest {
      /** The booking id that we want to calculate the allowedActions for */
      bookingId: string | null;
  }
  interface CalculateAllowedActionsResponse {
      allowedActions?: AllowedActions;
  }
  interface BulkCalculateAllowedActionsRequest {
      /** The booking id's that we want to calculate the allowedActions for */
      bookingIds: string[] | null;
  }
  interface BulkCalculateAllowedActionsResponse {
      results?: BulkCalculateAllowedActionsResult[];
      bulkActionMetadata?: BulkActionMetadata;
  }
  interface GetSlotAvailabilityRequest {
      /** The slot for which the availability is checked. */
      slot?: V2Slot;
      /** The timezone for which availability is to be calculated. */
      timezone?: string | null;
      /**
       * Return the IDs of bookings that are currently allowed to book the given slot due to being a part of a waitlist in a "suggested" status.
       * @internal
       */
      returnAllowedBookingIds?: boolean;
      /**
       * Check if this booking is allowed to book the given slot due to being a part of a waitlist in a "suggested" status.
       * If passed and the slot is locked for a booking other than this one, `bookable = false` is returned.
       * @internal
       */
      bookingId?: string | null;
      /**
       * Whether availability should be queried to availability calendar or availability service
       * @internal
       */
      shouldUseV2Availability?: boolean;
      /**
       * TODO: remove after qa and add a dedicated EP for calculating all available non double booked resources instead.
       * Whether to skip optimizations during the calculation for overlapping bookings, in order to get the full list of possible
       * non double booked resources.
       * @internal
       */
      returnAllAvailableResources?: boolean;
      /**
       * Whether availability should be queried to availability calendar or availability service
       * @internal
       */
      v2Availability?: boolean | null;
  }
  interface GetSlotAvailabilityResponse {
      availability?: SlotAvailability;
      bookingPolicySettings?: BookingPolicySettings;
      /**
       * Bookings that are currently allowed to book the given slot due to being a part of a waitlist in a "suggested" status.
       * @internal
       */
      allowedBookingIds?: string[];
      /**
       * List of `AvailableResources` for the slot.
       * Each `AvailableResources` contains information about available resources of the same type.
       * @internal
       */
      availableResources?: AvailableResources[];
  }
  interface SlotAvailability {
      /** Identifier for underlying session when session is a single session or generated from a recurring session. Required. */
      slot?: V2Slot;
      /** Whether this available slot is bookable. */
      bookable?: boolean;
      /**
       * Total number of spots for this availability.
       * For example, for a class of 10 spots with 3 spots booked, `spotsTotal` is 10, `openSpots` is 7.
       */
      totalSpots?: number | null;
      /**
       * Number of open spots for this availability.
       * For appointment if there are existing bookings with overlapping time, service & resource, `openSpots` is 0, otherwise `openSpots` is 1.
       */
      openSpots?: number | null;
      /** An object describing the slot's waiting-list and its occupancy. */
      waitingList?: WaitingList;
      /** Indicators for booking policy violations for the slot. */
      bookingPolicyViolations?: BookingPolicyViolations;
      /** Indicates whether this slot is locked. */
      locked?: boolean | null;
  }
  interface WaitingList {
      /**
       * Total number of spots and open spots for this waiting list.
       * For example, a Yoga class of 10 waiting list spots with 3 registered on the waiting list  has total_spots: 10 and open_spots: 7.
       */
      totalSpots?: number | null;
      openSpots?: number | null;
  }
  interface AvailableResources {
      /** Resource type ID. */
      resourceTypeId?: string | null;
      /**
       * Available resources for the slot.
       * maxSize defined by 135 staff members + 3 resource types and 50 resources per type.
       * Availability-2 currently have no maxSize defined.
       */
      resourceIds?: string[];
      /**
       * The required number of resources of this type in order to book the service.
       * @internal
       */
      numberOfResourcesRequired?: number | null;
  }
  interface GetScheduleAvailabilityRequest {
      /** The schedule ID for which availability is checked. */
      scheduleId: string;
  }
  interface GetScheduleAvailabilityResponse {
      availability?: ScheduleAvailability;
      bookingPolicySettings?: BookingPolicySettings;
  }
  interface ScheduleAvailability {
      totalSpots?: number | null;
      openSpots?: number | null;
      /** Indicators of booking policy violations for the given Schedule. */
      bookingPolicyViolations?: BookingPolicyViolations;
  }
  interface MarkBookingAsPendingRequest {
      /** ID of the booking to mark as PENDING. */
      bookingId: string;
      /**
       * Revision number, which increments by 1 each time the booking is updated.
       * To prevent conflicting changes, the current revision must be passed when
       * managing the booking.
       */
      revision: string | null;
      /**
       * Information about whether to notify the customer and
       * the message to send.
       */
      participantNotification?: ParticipantNotification$1;
      /**
       * Whether to send an SMS reminder to the customer 24 hours before the
       * session starts. The phone number is taken from `contactDetails.phone`.
       */
      sendSmsReminder?: boolean | null;
      /**
       * Payment status to set for the booking.
       * One of:
       * - `"NOT_PAID"` The booking is not paid for.
       * - `"PAID"` The booking is fully paid.
       * - `"PARTIALLY_PAID"` The booking is partially paid.
       * - `"REFUNDED"` The booking is refunded.
       * - `"EXEMPT"` The booking is free of charge.
       */
      paymentStatus?: PaymentStatus$1;
      /** Whether this booking overlaps with another existing confirmed booking. */
      doubleBooked?: boolean | null;
      /**
       * Information about whether specific procedures of the standard Wix Bookings
       * creation flow are changed. For example, whether the availability is
       * checked before updating the booking's status.
       */
      flowControlSettings?: MarkBookingAsPendingFlowControlSettings;
  }
  interface MarkBookingAsPendingResponse {
      /** The updated booking */
      booking?: Booking$1;
  }
  interface BookingMarkedAsPending {
      /** The booking object that was marked as pending. */
      booking?: Booking$1;
      /** Information about whether to notify the customer upon manual confirmation of the pending booking and the message to send. */
      participantNotification?: ParticipantNotification$1;
      /**
       * Whether to send an SMS reminder to the customer 24 hours before the
       * session starts. The phone number is taken from `contactDetails.phone`.
       */
      sendSmsReminder?: boolean | null;
      /** Whether this booking overlaps with another existing confirmed booking. */
      doubleBooked?: boolean | null;
      /** ID of the mark as pending initiator. */
      initiatedBy?: IdentificationData$1;
      /** The previous status of the booking. */
      previousStatus?: BookingStatus$1;
      /** The previous payment status of the booking. */
      previousPaymentStatus?: PaymentStatus$1;
  }
  interface MigrationCheckIfClashesWithBlockedTimeRequest {
      msidAndBookingIds?: MsidAndBookingId[];
  }
  interface MsidAndBookingId {
      msid?: string;
      bookingId?: string;
  }
  interface MigrationCheckIfClashesWithBlockedTimeResponse {
      clashes?: Clash[];
  }
  interface Clash {
      msid?: string;
      bookingId?: string;
      sessionId?: string;
      resourceName?: string;
      contactName?: string;
  }
  interface ConfirmOrDeclineBookingRequest {
      /** ID of the booking to confirm or decline. */
      bookingId: string;
      /**
       * Current payment status of the booking when using a custom checkout page and
       * not the [Wix eCommerce checkout](https://dev.wix.com/docs/rest/business-solutions/e-commerce/checkout/introduction).
       *
       * The booking is declined if there is a double booking conflict and you provide
       * one of these payment statuses: `UNDEFINED`, `NOT_PAID`, `REFUNDED`, or `EXEMPT`.
       */
      paymentStatus?: PaymentStatus$1;
      /**
       * When true  decline the booking if double booked.
       * @internal
       */
      declineDoubleBooking?: boolean | null;
  }
  interface ConfirmOrDeclineBookingResponse {
      /** Updated booking. */
      booking?: Booking$1;
  }
  interface BulkConfirmOrDeclineBookingRequest {
      /** The bookings to confirm or decline. */
      details: BulkConfirmOrDeclineBookingRequestBookingDetails[];
      /**
       * Whether to return the confirmed or declined bookings entities.
       * Not supported yet, currently the entity is not returned.
       */
      returnEntity?: boolean;
  }
  interface BulkConfirmOrDeclineBookingRequestBookingDetails {
      /** ID of the booking to confirm or decline. */
      bookingId?: string;
      /**
       * Current payment status of the booking when using a custom checkout page and
       * not the [Wix eCommerce checkout](https://dev.wix.com/docs/rest/business-solutions/e-commerce/checkout/introduction).
       *
       * The booking is declined if there is a double booking conflict and you provide
       * one of these payment statuses: `UNDEFINED`, `NOT_PAID`, `REFUNDED`, or `EXEMPT`.
       */
      paymentStatus?: PaymentStatus$1;
      /**
       * When true  decline the booking if double booked.
       * @internal
       */
      declineDoubleBooking?: boolean | null;
  }
  interface BulkConfirmOrDeclineBookingResponse {
      /**
       * The bulk confirm or decline results.
       * For each booking, the results contain the metadata of the confirm or decline action.
       */
      results?: BulkBookingResult[];
      /** Total successes and failures of the bulk confirm or decline action. */
      bulkActionMetadata?: BulkActionMetadata;
  }
  interface V2CreateBookingRequest extends V2CreateBookingRequestBookableItemOneOf, V2CreateBookingRequestParticipantsInfoOneOf {
      /**
       * Information about the slot to create a booking for.
       * If you set `slot.location.locationType` to `CUSTOM`, the created slot's
       * location is set to `slot.location.formattedAddress` when provided.
       * Otherwise it's set to `contactDetails.fullAddress.formattedAddress`.
       */
      slot?: Slot;
      /** Information about the schedule to create a booking for. */
      schedule?: BookedSchedule$1;
      /**
       * Total number of participants.
       * Provide when the service doesn't have
       * [variants](https://dev.wix.com/api/rest/wix-bookings/service-options-and-variants/introduction).
       * @internal
       */
      totalParticipants?: number;
      /**
       * Information about the service choices to book. Provide for services with
       * [variants](https://dev.wix.com/api/rest/wix-bookings/service-options-and-variants/introduction).
       * @internal
       */
      participantsChoices?: ParticipantChoices$1;
      /** Contact details of the customer booking the service. */
      contactDetails?: ContactDetails$1;
      /**
       * Booking status.
       * One of:
       * - `"CREATED"` - The booking was created.
       * - `"UPDATED"` - The booking was updated.
       * - `"CONFIRMED"` - The booking has been confirmed and appears on the bookings calendar.
       * Booking can be manually confirmed using the Set As Confirmed endpoint.
       * Booking can be automatically confirmed when the following requirements are met:
       * + The service is configured as automatically confirmed.
       * + Invoking eCommerce checkout API and an order has been created.
       * - `"CANCELED"` - The booking has been canceled and synced to bookings calendar.
       * The booking can be canceled using cancel API.
       * - `"PENDING"` - The booking waiting to be confirmed or declined buy the owner and is synced to bookings calendar.
       * Bookings can be manually set as pending using setAsPending API, requires manage booking status permissions.
       * Booking can be automatically set as pending when the following requirements are met:
       * + The Service is configured as manually confirmed.
       * + Invoking the eCommerce checkout API and an order has been created.
       * - `"WAITING_LIST"` - The booking is pending on a waiting list.
       * Booking can be created with this status when invoking waiting list join API.
       * - `"DECLINED"` - The booking was declined by the owner and synced to bookings calendar.
       * Booking can be manually declined using decline API and requires manage booking permissions.
       * Booking can be automatically declined when the following requirements are met:
       * + Invoking eCommerce checkout API and the order declined event has been sent.
       * + Invoking eCommerce checkout API and order approved event has been sent, but the booking is offline and the booking causes a double booking.
       */
      status?: BookingStatus$1;
      /**
       * Additional custom fields of the booking form. The customer must provide
       * information for each field when booking the service. For example, that they
       * bring their own towels or whether they use a wheelchair.
       *
       * Max: 100 fields
       */
      additionalFields?: CustomFormField$1[];
      /**
       * Total number of participants. Available only when the service doesn't have
       * [variants](https://dev.wix.com/api/rest/wix-bookings/service-options-and-variants/introduction).
       *
       * Max: `20`
       */
      numberOfParticipants?: number | null;
      /**
       * Internal business note. Not visible to the customer.
       *
       * Max: 200 characters
       */
      internalBusinessNote?: string | null;
      /**
       * Payment option the customer intends to use.
       * Must be one of the payment options defined for the service, unless
       * you pass `flowControlSettings.skipSelectedPaymentOptionValidation` as `true`.
       */
      selectedPaymentOption?: SelectedPaymentOption$1;
      /**
       * Identifies the source (platform, actor and app) that created this booking.
       * This property of the booking cannot be changed.
       * The app_def_id and app_name will be resolved automatically.
       * TODO GAP See if we need this - might be able to get this data from the headers?
       */
      bookingSource?: BookingSource$1;
      /**
       * A user identifier of an external application user that initiated the book request.
       * Allows an external application to later identify its own bookings and correlate to its own internal users
       */
      externalUserId?: string | null;
      /** Information about a message to send to the customer. */
      participantNotification?: ParticipantNotification$1;
      /**
       * Whether to send an SMS reminder to the customer 24 hours before the
       * session starts. The phone number is taken from `contactDetails.phone`.
       *
       * Default: `true`.
       */
      sendSmsReminder?: boolean | null;
      /**
       * Information about whether specific procedures of the standard Wix Bookings
       * creation flow are changed. For example, whether the availability is
       * checked before creating the booking or if additional payment options are
       * accepted.
       */
      flowControlSettings?: CreateBookingRequestFlowControlSettings;
      /**
       * whether this booking availability should be checked with v1 or v2
       * @internal
       */
      v2Availability?: boolean | null;
  }
  /** @oneof */
  interface V2CreateBookingRequestBookableItemOneOf {
      /**
       * Information about the slot to create a booking for.
       * If you set `slot.location.locationType` to `CUSTOM`, the created slot's
       * location is set to `slot.location.formattedAddress` when provided.
       * Otherwise it's set to `contactDetails.fullAddress.formattedAddress`.
       */
      slot?: Slot;
      /** Information about the schedule to create a booking for. */
      schedule?: BookedSchedule$1;
  }
  /** @oneof */
  interface V2CreateBookingRequestParticipantsInfoOneOf {
      /**
       * Total number of participants.
       * Provide when the service doesn't have
       * [variants](https://dev.wix.com/api/rest/wix-bookings/service-options-and-variants/introduction).
       * @internal
       */
      totalParticipants?: number;
      /**
       * Information about the service choices to book. Provide for services with
       * [variants](https://dev.wix.com/api/rest/wix-bookings/service-options-and-variants/introduction).
       * @internal
       */
      participantsChoices?: ParticipantChoices$1;
  }
  interface Slot {
      /**
       * ID for the slot's corresponding session, when the session is either a single session
       * or a specific session generated from a recurring session.
       */
      sessionId?: string | null;
      /** Service ID. */
      serviceId?: string;
      /** Schedule ID. */
      scheduleId?: string;
      /**
       * The start time of this slot in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339)
       * format.
       *
       * If `timezone` is specified,
       * dates are based on the local date/time. This means that the timezone offset
       * in the `start_date` is ignored.
       */
      startDate?: string | null;
      /**
       * The end time of this slot in
       * [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339) format.
       *
       * If `timezone` is specified,
       * dates are based on the local date/time. This means that the timezone offset
       * in the `end_date` is ignored.
       */
      endDate?: string | null;
      /**
       * The timezone for which slot availability is to be calculated.
       *
       * Learn more about [handling Daylight Savings Time (DST) for local time zones](https://dev.wix.com/api/rest/wix-bookings/availability-calendar/query-availability#wix-bookings_availability-calendar_query-availability_handling-daylight-savings-time-dst-for-local-time-zones)
       * when calculating availability.
       */
      timezone?: string | null;
      /**
       * The resource required for this slot. Currently, the only supported resource
       * is the relevant staff member for the slot.
       */
      resource?: SlotResource;
      /** Geographic location of the slot. */
      location?: Location$1;
  }
  interface SlotResource {
      /**
       * Resource ID.
       * @readonly
       */
      _id?: string | null;
      /** Resource name. Read only. */
      name?: string | null;
      /**
       * Schedule ID. Read only.
       * @internal
       */
      scheduleId?: string | null;
  }
  interface CreateBookingRequestFlowControlSettings {
      /**
       * when defined as true, skips the service defined booking-window in the booking policy.
       * required BOOKINGS.IGNORE_BOOKING_POLICY permission. TODO - check if can be merged with skit_availability_validation
       * private because it's confusing to external users - collides with skip_availability_validation
       * and yet, clients send it (though always with skip_availability_validation=true) so we're not just removing it
       * When removing, we need to use proto's `reserved` field
       * @internal
       * @deprecated
       */
      ignoreBookingWindow?: boolean;
      /**
       * Whether the availability is checked before creating the booking. When
       * passing `false` a booking is only created when the slot or schedule is
       * available. Your app must have the `BOOKINGS.OVERRIDE_AVAILABILITY`
       * permission scope when passing `true`.
       *
       * Default: `false`.
       */
      skipAvailabilityValidation?: boolean;
      /**
       * Whether `PENDING` bookings are automatically set to `CONFIRMED` for
       * services that normally require the owner's manual confirmation. Your
       * app must have the `BOOKINGS.OVERRIDE_AVAILABILITY` permission scope
       * when passing `true`.
       *
       * Default: `false`.
       */
      skipBusinessConfirmation?: boolean;
      /**
       * Whether customers can pay using a payment method that isn't supported
       * for the service, but that's supported for other services. Your app
       * must have the `BOOKINGS.MANAGE_PAYMENTS` permission scope when passing
       * `true`.
       *
       * Default: `false`.
       */
      skipSelectedPaymentOptionValidation?: boolean;
  }
  interface V2CreateBookingResponse {
      /** Created booking. */
      booking?: Booking$1;
  }
  interface V2CancelBookingRequest {
      /** ID of the booking to cancel. */
      bookingId: string;
      /**
       * Information about whether to notify the customer about the cancelation and
       * the message to send.
       */
      participantNotification?: ParticipantNotification$1;
      /**
       * Information about whether specific procedures of the standard Wix Bookings
       * cancelation flow are changed. For example, whether the you can cancel
       * a booking even though the cancelation policy doesn't allow it or whether
       * to issue a refund.
       * @internal
       */
      flowControlSettings?: V2CancelBookingRequestFlowControlSettings;
      /**
       * Revision number, which increments by 1 each time the booking is updated.
       * To prevent conflicting changes,
       * the current revision must be passed when managing the booking.
       */
      revision: string | null;
  }
  interface V2CancelBookingRequestFlowControlSettings {
      /**
       * Whether the cancelation policy applies when canceling the booking. When
       * passing `false` you can only cancel a booking if the cancelation policy
       * allows it. Your app must have the `BOOKINGS.IGNORE_BOOKING_POLICY `
       * permission scope when passing `true`.
       *
       * Default: `false`.
       */
      ignoreCancellationPolicy?: boolean;
      /**
       * Whether to issue a refund when canceling the booking.
       * The refund will be issued only if the booking is refundable.
       * Currently, booking is considered refundable when it was paid by membership.
       * If passing `true`, the booking flow control settings will be set with refund,
       * otherwise, either if `false` is passed or the field remains empty,
       * the booking flow control settings will be set with no refund.
       *
       * Default: `false`.
       */
      withRefund?: boolean | null;
      /**
       * Whether to waive the cancellation fee when canceling the booking.
       * By default, cancellation fee will be applied.
       * If passing `true`, the cancellation fee will not be applied upon canceling the booking.
       * Must have the `BOOKINGS.MANAGE_PAYMENTS` permission scope when passing `true`.
       *
       * Default: `false`.
       * @internal
       */
      waiveCancellationFee?: boolean | null;
  }
  interface V2CancelBookingResponse {
      /** Canceled booking. */
      booking?: Booking$1;
  }
  interface V2RescheduleBookingRequest extends V2RescheduleBookingRequestParticipantsInfoOneOf {
      /**
       * Total number of participants. Available only for services with
       * [variants](https://dev.wix.com/api/rest/wix-bookings/service-options-and-variants/introduction).
       * Pass when all participants book the same variant.
       * @internal
       */
      totalParticipants?: number;
      /**
       * Information about the service choices to book. Available only for services with
       * [variants](https://dev.wix.com/api/rest/wix-bookings/service-options-and-variants/introduction).
       * Pass when not all participants book the same variant.
       * @internal
       */
      participantsChoices?: ParticipantChoices$1;
      /** Id of the booking to reschedule. */
      bookingId: string;
      /** Information about the new slot. */
      slot: Slot;
      /**
       * Revision number, which increments by 1 each time the booking is updated.
       * To prevent conflicting changes, the current revision must be passed when
       * managing the booking.
       */
      revision: string | null;
      /**
       * Information about whether to notify the customer about the rescheduling and
       * the message to send.
       */
      participantNotification?: ParticipantNotification$1;
      /**
       * Information about whether specific procedures of the standard Wix Bookings
       * rescheduling flow are changed. For example, whether the availability of
       * the new slot is checked before rescheduling the booking or if you can
       * reschedule the booking even though the rescheduling policy doesn't allow it.
       * @internal
       */
      flowControlSettings?: V2RescheduleBookingRequestFlowControlSettings;
  }
  /** @oneof */
  interface V2RescheduleBookingRequestParticipantsInfoOneOf {
      /**
       * Total number of participants. Available only for services with
       * [variants](https://dev.wix.com/api/rest/wix-bookings/service-options-and-variants/introduction).
       * Pass when all participants book the same variant.
       * @internal
       */
      totalParticipants?: number;
      /**
       * Information about the service choices to book. Available only for services with
       * [variants](https://dev.wix.com/api/rest/wix-bookings/service-options-and-variants/introduction).
       * Pass when not all participants book the same variant.
       * @internal
       */
      participantsChoices?: ParticipantChoices$1;
  }
  interface V2RescheduleBookingRequestFlowControlSettings {
      /**
       * Whether the rescheduling policy applies when rescheduling the booking.
       * When passing `false` you can only cancel a booking if the rescheduling
       * policy allows it. Your app must have the `BOOKINGS.IGNORE_BOOKING_POLICY `
       * permission scope when passing `true`.
       *
       * Default: `false`.
       */
      ignoreReschedulePolicy?: boolean;
      /**
       * when defined as true, skips the service defined booking-window validation in the booking policy.
       * required BOOKINGS.IGNORE_BOOKING_POLICY permission.
       * @internal
       * @deprecated
       */
      ignoreBookingWindow?: boolean;
      /**
       * Whether the availability is checked before rescheduling the booking.
       * When passing `false` a booking is only created when the slot or
       * schedule is available. Your app must have the `BOOKINGS.OVERRIDE_AVAILABILITY`
       * permission scope when passing `true`.
       *
       * Default: `false`.
       */
      skipAvailabilityValidation?: boolean;
      /**
       * Whether the rescheduled booking's status is automatically set to
       * `CONFIRMED` for services that normally require the owner's manual
       * confirmation. Your app must have the `BOOKINGS.OVERRIDE_AVAILABILITY`
       * permission scope when passing `true`.
       *
       * Default: `false`.
       */
      skipBusinessConfirmation?: boolean;
  }
  interface V2RescheduleBookingResponse {
      /** Rescheduled booking. */
      booking?: Booking$1;
  }
  interface V2ConfirmBookingRequest {
      /** ID of the booking to confirm. */
      bookingId: string;
      /**
       * Revision number, which increments by 1 each time the booking is updated.
       * To prevent conflicting changes, the current revision must be passed when
       * managing the booking.
       */
      revision: string | null;
      /**
       * Information about whether to notify the customer about the confirmation and
       * the message to send.
       */
      participantNotification?: ParticipantNotification$1;
  }
  interface V2ConfirmBookingResponse {
      booking?: Booking$1;
  }
  interface V2DeclineBookingRequest {
      /** ID of the booking to decline. */
      bookingId: string;
      /**
       * Revision number, which increments by 1 each time the booking is updated.
       * To prevent conflicting changes, the current revision must be passed when
       * managing the booking.
       */
      revision: string | null;
      /**
       * Information about whether to notify the customer about the decline and
       * the message to send.
       */
      participantNotification?: ParticipantNotification$1;
  }
  interface V2DeclineBookingResponse {
      /** Declined booking. */
      booking?: Booking$1;
  }
  interface V2UpdateNumberOfParticipantsRequest extends V2UpdateNumberOfParticipantsRequestParticipantsInfoOneOf {
      /**
       * Total number of participants. Available only for services with
       * [variants](https://dev.wix.com/api/rest/wix-bookings/service-options-and-variants/introduction).
       * Pass when all participants book the same variant.
       * @internal
       */
      totalParticipants?: number;
      /**
       * Information about the service choices to book. Available only for services with
       * [variants](https://dev.wix.com/api/rest/wix-bookings/service-options-and-variants/introduction).
       * Pass when not all participants book the same variant.
       * @internal
       */
      participantsChoices?: ParticipantChoices$1;
      /** ID of the booking to update the number of participants for. */
      bookingId: string;
      /** Updated number of participants. */
      numberOfParticipants?: number | null;
      /**
       * Revision number, which increments by 1 each time the booking is updated.
       * To prevent conflicting changes, the current revision must be passed when
       * managing the booking.
       */
      revision: string | null;
  }
  /** @oneof */
  interface V2UpdateNumberOfParticipantsRequestParticipantsInfoOneOf {
      /**
       * Total number of participants. Available only for services with
       * [variants](https://dev.wix.com/api/rest/wix-bookings/service-options-and-variants/introduction).
       * Pass when all participants book the same variant.
       * @internal
       */
      totalParticipants?: number;
      /**
       * Information about the service choices to book. Available only for services with
       * [variants](https://dev.wix.com/api/rest/wix-bookings/service-options-and-variants/introduction).
       * Pass when not all participants book the same variant.
       * @internal
       */
      participantsChoices?: ParticipantChoices$1;
  }
  interface V2UpdateNumberOfParticipantsResponse {
      /** Booking with updated number of participants. */
      booking?: Booking$1;
  }
  /**
   * Creates multi service booking.
   *
   * See [Create Booking](/bookings-v2/bookings-v2-and-confirmation/bookings-create-booking) documentation.
   * @param bookings - The bookings to create as multi service booking.
   * @public
   * @documentationMaturity preview
   * @requiredField bookings
   * @requiredField bookings.additionalFields._id
   * @requiredField bookings.bookedEntity
   * @requiredField bookings.bookedEntity.slot
   * @requiredField bookings.bookedEntity.slot.endDate
   * @requiredField bookings.bookedEntity.slot.location.locationType
   * @requiredField bookings.bookedEntity.slot.scheduleId
   * @requiredField bookings.bookedEntity.slot.startDate
   * @permissionId MULTI_SERVICE_BOOKINGS.MULTI_SERVICE_BOOKING_CREATE
   */
  function createMultiServiceBooking(bookings: Booking$1[], options?: CreateMultiServiceBookingOptions): Promise<CreateMultiServiceBookingResponse>;
  interface CreateMultiServiceBookingOptions {
      /** Information about a message to send to the customer. */
      participantNotification?: ParticipantNotification$1;
      /**
       * Whether to send an SMS reminder to the customer 24 hours before the
       * session starts. The phone number is taken from `contactDetails.phone`.
       * Default: `true`.
       */
      sendSmsReminder?: boolean | null;
      /**
       * Information about whether specific procedures of the standard Wix Bookings
       * creation flow are changed. For example, whether the availability is
       * checked before creating the booking or if additional payment options are
       * accepted.
       */
      flowControlSettings?: CreateBookingFlowControlSettings;
      /** Whether to return the created bookings entities. */
      returnFullEntity?: boolean;
      /**
       * Multi service booking type.
       * One of:
       * - `"SEQUENTIAL_BOOKINGS"` Multi service booking will be considered available if its bookings are available as returned from ListMultiServiceAvailabilityTimeSlots API.
       * - `"SEPARATE_BOOKINGS"` Not supported yet.
       * - `"PARALLEL_BOOKINGS"` Not supported yet.
       */
      multiServiceBookingType?: MultiServiceBookingType$1;
  }
  /**
   * Reschedules the multi service booking.
   * Validates all the bookings were passed.
   * Throws an exception if there is reschedule policy violation for any of the bookings or if the requested slots are not available.
   * See [Reschedule Booking](https://dev.wix.com/api/rest/wix-bookings/bookings-v2/reschedule-booking) documentation.
   * @param multiServiceBookingId - ID of the multi service booking to reschedule it's related bookings.
   * @param rescheduleBookingsInfo - Bookings to reschedule.
   * @public
   * @documentationMaturity preview
   * @requiredField multiServiceBookingId
   * @requiredField rescheduleBookingsInfo
   * @requiredField rescheduleBookingsInfo.bookingId
   * @requiredField rescheduleBookingsInfo.revision
   * @requiredField rescheduleBookingsInfo.slot
   * @permissionId MULTI_SERVICE_BOOKINGS.MULTI_SERVICE_BOOKING_RESCHEDULE
   */
  function rescheduleMultiServiceBooking(multiServiceBookingId: string | null, rescheduleBookingsInfo: RescheduleMultiServiceBookingRequestRescheduleBookingInfo[], options?: RescheduleMultiServiceBookingOptions): Promise<RescheduleMultiServiceBookingResponse>;
  interface RescheduleMultiServiceBookingOptions {
      /** Information about whether to notify the customer about the rescheduling and the message to send. */
      participantNotification?: ParticipantNotification$1;
      /**
       * Information about whether specific procedures of the standard Wix Bookings
       * rescheduling flow are changed. For example, whether the availability of
       * the new slot is checked before rescheduling the booking or if you can
       * reschedule the booking even though the rescheduling policy doesn't allow it.
       */
      flowControlSettings?: RescheduleBookingFlowControlSettings;
      /** Whether to return the rescheduled bookings entities. */
      returnFullEntity?: boolean;
  }
  /**
   * Get multi service booking availability.
   * If the multi service booking is of type SEQUENTIAL_BOOKINGS, its availability is checked through ListMultiServiceAvailabilityTimeSlots API.
   * @public
   * @documentationMaturity preview
   * @requiredField multiServiceBookingId
   * @permissionId MULTI_SERVICE_BOOKINGS.MULTI_SERVICE_BOOKING_GET_AVAILABILITY
   */
  function getMultiServiceBookingAvailability(multiServiceBookingId: string | null): Promise<GetMultiServiceBookingAvailabilityResponse>;
  /**
   * Cancels the multi service booking.
   * Each booking within this multi service booking is being canceled.
   * @param multiServiceBookingId - ID of the multi service booking to cancel it's related bookings.
   * @public
   * @documentationMaturity preview
   * @requiredField multiServiceBookingId
   * @permissionId MULTI_SERVICE_BOOKINGS.MULTI_SERVICE_BOOKING_CANCEL
   */
  function cancelMultiServiceBooking(multiServiceBookingId: string | null, options?: CancelMultiServiceBookingOptions): Promise<CancelMultiServiceBookingResponse>;
  interface CancelMultiServiceBookingOptions {
      /** Information about whether to notify the customer about the cancelation and the message to send. */
      participantNotification?: ParticipantNotification$1;
      /**
       * Information about whether specific procedures of the standard Wix Bookings
       * cancelation flow are changed. For example, whether the you can cancel
       * a booking even though the cancelation policy doesn't allow it or whether
       * to issue a refund.
       */
      flowControlSettings?: CancelBookingFlowControlSettings;
      /** Whether to return the canceled bookings entities. */
      returnFullEntity?: boolean;
  }
  /**
   * Mark the multi service booking as PENDING.
   * Changes the status of each of the bookings within the multi service booking to PENDING
   * Validates all the bookings were passed.
   * See [MarkBookingAsPending](https://dev.wix.com/api/rest/wix-bookings/bookings-v2/mark-booking-as-pending) documentation.
   * @param multiServiceBookingId - ID of the multi service booking to mark as pending it's related bookings.
   * @public
   * @documentationMaturity preview
   * @requiredField multiServiceBookingId
   * @permissionId MULTI_SERVICE_BOOKINGS.MULTI_SERVICE_BOOKING_MARK_AS_PENDING
   * @adminMethod
   */
  function markMultiServiceBookingAsPending(multiServiceBookingId: string | null, options?: MarkMultiServiceBookingAsPendingOptions): Promise<MarkMultiServiceBookingAsPendingResponse>;
  interface MarkMultiServiceBookingAsPendingOptions {
      /** Bookings to mark as pending. */
      markAsPendingBookingsInfo?: BookingInfo[];
      /** Information about whether to notify the customer upon manual confirmation and the message to send. */
      participantNotification?: ParticipantNotification$1;
      /**
       * Whether to send an SMS reminder to the customer 24 hours before the
       * session starts. The phone number is taken from `contactDetails.phone`.
       */
      sendSmsReminder?: boolean | null;
      /** Whether this booking overlaps with another existing confirmed booking. */
      doubleBooked?: boolean | null;
      /** Whether to return the pending bookings entities. */
      returnFullEntity?: boolean;
      /**
       * Information about whether specific procedures of the standard Wix Bookings
       * creation flow are changed. For example, whether the availability is
       * checked before updating the booking.
       */
      flowControlSettings?: MarkBookingAsPendingFlowControlSettings;
  }
  /**
   * Confirms the multi service booking.
   * Each booking within this multi service booking is being confirmed.
   * Validates all the bookings were passed.
   * See [Confirm Booking](https://dev.wix.com/api/rest/wix-bookings/bookings-v2/confirm-booking) documentation.
   * @param multiServiceBookingId - ID of the multi service booking to confirm it's related bookings.
   * @public
   * @documentationMaturity preview
   * @requiredField multiServiceBookingId
   * @permissionId MULTI_SERVICE_BOOKINGS.MULTI_SERVICE_BOOKING_CONFIRM
   * @adminMethod
   */
  function confirmMultiServiceBooking(multiServiceBookingId: string | null, options?: ConfirmMultiServiceBookingOptions): Promise<ConfirmMultiServiceBookingResponse>;
  interface ConfirmMultiServiceBookingOptions {
      /** Bookings to confirm. */
      confirmBookingsInfo?: BookingInfo[];
      /** Information about whether to notify the customer about the confirmation and the message to send. */
      participantNotification?: ParticipantNotification$1;
      /**
       * Whether to send an SMS reminder to the customer 24 hours before the
       * session starts. The phone number is taken from `contactDetails.phone`.
       */
      sendSmsReminder?: boolean | null;
      /** Whether this booking overlaps with another existing confirmed booking. */
      doubleBooked?: boolean | null;
      /** Whether to return the confirmed bookings entities. */
      returnFullEntity?: boolean;
      /**
       * Information about whether specific procedures of the standard Wix Bookings
       * confirmation flow are changed. For example, whether the availability is
       * checked before confirming the booking.
       */
      flowControlSettings?: ConfirmBookingFlowControlSettings;
  }
  /**
   * Declines the multi service booking.
   * Each booking within this multi service booking is being declined.
   * Validates all the bookings were passed.
   * See [Decline Booking](https://dev.wix.com/api/rest/wix-bookings/bookings-v2/decline-booking) documentation.
   * @param multiServiceBookingId - ID of the multi service booking to decline it's related bookings.
   * @public
   * @documentationMaturity preview
   * @requiredField multiServiceBookingId
   * @permissionId MULTI_SERVICE_BOOKINGS.MULTI_SERVICE_BOOKING_DECLINE
   * @adminMethod
   */
  function declineMultiServiceBooking(multiServiceBookingId: string | null, options?: DeclineMultiServiceBookingOptions): Promise<DeclineMultiServiceBookingResponse>;
  interface DeclineMultiServiceBookingOptions {
      /** Bookings to decline. */
      declineBookingsInfo?: BookingInfo[];
      /** Information about whether to notify the customer about the decline and the message to send. */
      participantNotification?: ParticipantNotification$1;
      /** Whether this booking overlaps with another existing confirmed booking. */
      doubleBooked?: boolean | null;
      /** Whether to return the declined bookings entities. */
      returnFullEntity?: boolean;
      /**
       * Information about whether specific procedures of the standard Wix Bookings
       * declining flow are changed. For example, whether to issue a refund.
       */
      flowControlSettings?: DeclineBookingFlowControlSettings;
  }
  /**
   * Get the allowed actions for a given multi service bookings by a list of multi service booking ids
   * @param multiServiceBookingIds - The multi service booking ids to get the allowedActions for.
   * @public
   * @documentationMaturity preview
   * @requiredField multiServiceBookingIds
   * @permissionId MULTI_SERVICE_BOOKINGS.MULTI_SERVICE_BOOKING_GET_ALLOWED_ACTIONS
   */
  function bulkGetMultiServiceBookingAllowedActions(multiServiceBookingIds: string[] | null): Promise<BulkGetMultiServiceBookingAllowedActionsResponse>;
  interface MarkAsMultiServiceBookingOptions {
      /**
       * Multi service booking type.
       * One of:
       * - `"SEQUENTIAL_BOOKINGS"` Multi service booking will be considered available if its bookings are available as returned from ListMultiServiceAvailabilityTimeSlots API.
       * - `"SEPARATE_BOOKINGS"` Not supported yet.
       * - `"PARALLEL_BOOKINGS"` Not supported yet.
       */
      multiServiceBookingType?: MultiServiceBookingType$1;
  }
  /**
   * Retrieves the bookings of a given multi service booking id.
   * In case the caller have permissions to read only part of a bookings, only the permitted bookings would be
   * retrieved, but the total amount of bookings would be returned on response.
   * @param multiServiceBookingId - Multi service booking ID.
   * @public
   * @documentationMaturity preview
   * @requiredField multiServiceBookingId
   * @permissionId MULTI_SERVICE_BOOKINGS.MULTI_SERVICE_BOOKING_READ
   * @adminMethod
   * @returns Multi service booking.
   */
  function getMultiServiceBooking(multiServiceBookingId: string | null): Promise<MultiServiceBooking>;
  /**
   * Adds existing bookings to a multi service booking.
   * @param multiServiceBookingId - ID of the multi service booking.
   * @public
   * @documentationMaturity preview
   * @requiredField multiServiceBookingId
   * @requiredField options.bookings
   * @requiredField options.bookings.bookingId
   * @requiredField options.bookings.revision
   * @permissionId MULTI_SERVICE_BOOKINGS.MULTI_SERVICE_BOOKING_ADD_BOOKINGS
   * @adminMethod
   */
  function addBookingsToMultiServiceBooking(multiServiceBookingId: string | null, options?: AddBookingsToMultiServiceBookingOptions): Promise<AddBookingsToMultiServiceBookingResponse>;
  interface AddBookingsToMultiServiceBookingOptions {
      /** List of bookings ids and their revisions to add to the multi service booking. */
      bookings: BookingIdAndRevision[];
      /** Whether to return the bookings entities. */
      returnFullEntity?: boolean;
  }
  /**
   * Removes existing bookings from a multi service booking.
   * If request.bookings is empty, all the bookings that the caller is authorized to read will be removed from the multi booking service.
   * Otherwise only the bookings in the request will be removed.
   * Throws an exception if the multi booking service is not found or one of the bookings in the request if present.
   * If the removal of the bookings was successful, the response will contain the bookings that were removed.
   * In case that the removal of the bookings will result in a multi bookings service with only one booking, the multi booking service will be deleted,
   * meaning also the last booking will be removed from the multi booking service.
   * @param multiServiceBookingId - ID of the multi service booking.
   * @public
   * @documentationMaturity preview
   * @requiredField multiServiceBookingId
   * @permissionId MULTI_SERVICE_BOOKINGS.MULTI_SERVICE_BOOKING_REMOVE_BOOKINGS
   * @adminMethod
   */
  function removeBookingsFromMultiServiceBooking(multiServiceBookingId: string | null, options?: RemoveBookingsFromMultiServiceBookingOptions): Promise<RemoveBookingsFromMultiServiceBookingResponse>;
  interface RemoveBookingsFromMultiServiceBookingOptions {
      /** List of bookings ids and their revisions to remove from the multi service booking. */
      bookings?: BookingIdAndRevision[];
      /** Whether to return the bookings entities. */
      returnFullEntity?: boolean;
  }
  /**
   * Creates a booking.
   *
   *
   * To create a booking for an appointment or a session of a class, pass a booking with the relevant `slot`.
   *
   * To create a booking for the entire course, pass a booking with the relevant `schedule`.
   * You can use Query Availability to check the availability beforehand.
   *
   * If you create a booking for an existing session, we recommend that you only pass `slot.sessionId`.
   * Then, any specified slot details are calculated.
   *
   * If you create a booking for a new session, we recommend to call Query Availability first.
   * Then, pass the retrieved `availability.slot` object as the BookedEntity.Slot of the booking in the request.
   *
   * Bookings are created with a status of `CREATED`.
   * `CREATED` bookings don't appear on the business calendar and don't affect a related schedule's availability.
   *
   * To create a booking with a given status, pass a booking with the wanted status.
   * This is only permitted for site Owners.
   *
   * You can pass a `participantNotification.message` to notify the customer of the booking with a message.
   * It's also necessary to pass `participantNotification.notifyParticipants`as `true` to send the message.
   *
   * You can pass `sendSmsReminder` as `true`, if you want an SMS reminder to be sent to the phone number specified in the ContactDetails, 24 hours before the session starts.
   *
   * When creating a booking you must pass either `participantsChoices` or `totalParticipants`. If you pass `participantsChoices`, all the
   * provided choices must exist for the service, otherwise the call returns an `INVALID_SERVICE_CHOICES` error.
   *
   * When creating a booking, you can pass `selectedPaymentOption`.
   * This specifies which payment method the customer plans to use.
   * But it's possible for them to later use another supported payment method.
   *
   * You can skip the checkout and payment flow if you call Confirm Or Decline Booking otherwise, after you create the booking, you can use the
   * Wix eCommerce APIs (coming soon) for the checkout and payment flow or use a different service for checkout.
   * @param booking - The booking to create.
   * @public
   * @documentationMaturity preview
   * @requiredField booking
   * @requiredField booking.additionalFields._id
   * @requiredField booking.bookedEntity
   * @permissionId BOOKINGS.BOOKING_CREATE
   */
  function createBooking(booking: Booking$1, options?: CreateBookingOptions): Promise<CreateBookingResponse>;
  interface CreateBookingOptions {
      /** Information about a message to send to the customer. */
      participantNotification?: ParticipantNotification$1;
      /**
       * Whether to send an SMS reminder to the customer 24 hours before the
       * session starts. The phone number is taken from `contactDetails.phone`.
       * Default: `true`.
       */
      sendSmsReminder?: boolean | null;
      /**
       * Information about whether specific procedures of the standard Wix Bookings
       * creation flow are changed. For example, whether the availability is
       * checked before creating the booking or if additional payment options are
       * accepted.
       */
      flowControlSettings?: CreateBookingFlowControlSettings;
  }
  /** @param _id - Booking ID.
   * @internal
   * @documentationMaturity preview
   * @requiredField _id
   * @requiredField booking
   * @requiredField booking.revision
   * @permissionId BOOKINGS.BOOKING_MANAGE
   * @adminMethod
   * @deprecated
   */
  function updateBooking(_id: string | null, booking: UpdateBooking, options?: UpdateBookingOptions): Promise<UpdateBookingResponse>;
  interface UpdateBooking {
      /** Total number of participants. Available only when the booking includes a single service variant. */
      totalParticipants?: number;
      /**
       * Information about the booked service choices and participants.
       * Available only when the booking includes multiple service variants.
       */
      participantsChoices?: ParticipantChoices$1;
      /**
       * Booking ID.
       * @readonly
       */
      _id?: string | null;
      /** An object describing the slot or schedule that was booked. */
      bookedEntity?: BookedEntity$1;
      /** Contact details of the site visitor or member making the booking. */
      contactDetails?: ContactDetails$1;
      /** Additional custom fields submitted with the booking form. */
      additionalFields?: CustomFormField$1[];
      /**
       * Number of participants.
       * @internal
       */
      numberOfParticipants?: number | null;
      /**
       * Internal business note
       * @internal
       * @deprecated
       */
      internalBusinessNote?: string | null;
      /**
       *   Booking status.
       *   Supported values:
       *   - `CREATED`: The booking was created.
       *   - `UPDATED`: The booking was updated.
       *   - `PENDING`: The booking is waiting to be confirmed or declined by the business owner. A booking is automatically set as `PENDING` if the service is configured to require manual business owner confirmation and an eCommerce order was created.
       *   - `CONFIRMED`: The booking was confirmed. A booking is automatically confirmed if the service is configured to automatically confirm bookings and an eCommerce order was created. If the service isn't configured to automatically confirm bookings, you can use `confirmOrDeclineBooking()`.
       *   - `DECLINED`: The booking was declined by the business owner. A booking is also declined if an eCommerce order was created that resulted in a double booking.
       *   - `CANCELED`: The booking was canceled.
       *   - `WAITING_LIST`: The booking is on a wait list.
       */
      status?: BookingStatus$1;
      /**
       * Payment status.
       * One of:
       * - `"NOT_PAID"` The booking is not paid for.
       * - `"PAID"` The booking is fully paid.
       * - `"PARTIALLY_PAID"` The booking is partially paid.
       * - `"REFUNDED"` The booking is refunded.
       * - `"EXEMPT"` The booking is free of charge.
       */
      paymentStatus?: PaymentStatus$1;
      /**
       * Selected payment option.
       * One of the payment options offered by the service, or another option if `skipSelectedPaymentOptionValidation` is `true`.
       * When undefined, the payment option is resolved by the service configuration on checkout.
       */
      selectedPaymentOption?: SelectedPaymentOption$1;
      /**
       * Date and time the booking was created.
       * @readonly
       */
      _createdDate?: Date | null;
      /** External ID provided by the client app on creation. */
      externalUserId?: string | null;
      /**
       * An object describing the platform and application that made the booking.
       * @internal
       */
      bookingSource?: BookingSource$1;
      /**
       * The last notification used by Cancel, Confirm, Decline, or Reschedule Booking.
       * @internal
       * @deprecated
       */
      participantNotification?: ParticipantNotification$1;
      /**
       * When value is set to True, an SMS reminder would be sent to the phone number specified in the ContactDetails, 24 hours before the session starts.
       * @internal
       * @deprecated
       */
      sendSmsReminder?: boolean | null;
      /** Revision number to be used when updating, rescheduling, or cancelling the booking. Revision number, which increments by 1 each time the booking is updated, rescheduled, or canceled. To prevent conflicting changes,the current revision must be passed when updating the booking. */
      revision?: string | null;
      /**
       * ID of the creator of the Booking.
       * If `appId` and another ID are present, the other ID takes precedence.
       * @readonly
       */
      createdBy?: CommonIdentificationData;
      /**
       * The start date of this booking. For a slot, this is the start date of the slot. For a schedule, this is the start date of the first session.
       * @readonly
       */
      startDate?: Date | null;
      /**
       * The end date of this booking. For a slot, this is the end date of the slot. For a schedule, this is the end date of the last session.
       * @readonly
       */
      endDate?: Date | null;
      /**
       * Sets the booking flow behavior. Some behaviors require permissions.
       * @internal
       */
      flowControlSettings?: FlowControlSettings$1;
      /**
       * Date and time the booking was updated.
       * @readonly
       */
      _updatedDate?: Date | null;
      /**
       * Custom field data for this object. Extended fields must be configured in the app dashboard before they can be accessed with API calls.
       * For usage of extended fields with [Wix Forms](https://dev.wix.com/docs/rest/crm/forms/form-schema-api/introduction-to-forms), after configuring your form custom fields, pass the form field values under the `_user_fields` namespace.
       * For example, if you have a custom form field named `age`, pass it as `"extendedFields":{"_user_fields": { "age": 22 }}`.
       */
      extendedFields?: ExtendedFields$1;
      /**
       * Whether this booking overlaps another existing confirmed booking. Returned when: `true`
       * @readonly
       */
      doubleBooked?: boolean | null;
      /**
       * whether this booking availability should be checked with v1 or v2
       * @internal
       */
      v2Availability?: boolean | null;
      /**
       * Multi service booking info of which the booking is part of.
       * @internal
       * @readonly
       */
      multiServiceBookingInfo?: MultiServiceBookingInfo$1;
      /**
       * The date this booking was canceled on
       * @internal
       * @readonly
       */
      canceledDate?: Date | null;
      /**
       * whether this booking availability should be checked with v1 or v2
       * @internal
       */
      v2AvailabilityProxy?: boolean | null;
      /**
       * Having booking language means that the booking was made in a secondary language, having no booking.language implies that the booking was made using the main language
       * @internal
       */
      language?: string | null;
  }
  interface UpdateBookingOptions {
      /** @internal */
      mask?: string[];
  }
  /** @internal
   * @documentationMaturity preview
   * @requiredField booking
   * @requiredField booking.additionalFields._id
   * @requiredField booking.bookedEntity
   * @permissionId BOOKINGS.BOOKING_MANAGE
   * @adminMethod
   */
  function legacyCreateBooking(booking: Booking$1): Promise<LegacyCreateBookingResponse>;
  /**
   * Updates a batch of bookings.
   * If any `fieldMask` contains `numberOfParticipants` and the field is not defined in the `request.booking` the update fails.
   * If any `fieldMask` contains `participantsInfo` and the field is not defined in the `request.booking` the update fails.
   * If any `fieldMask` contains both `numberOfParticipants` and `participantsInfo` the update fails.
   * If participantsChoices are provided, they are validated against the service variants.if not all choices exist in the variants list a INVALID_SERVICE_CHOICES error is returned.
   * @internal
   * @documentationMaturity preview
   * @requiredField bookings
   * @requiredField bookings.booking
   * @requiredField bookings.booking._id
   * @requiredField bookings.booking.revision
   * @permissionId BOOKINGS.BOOKING_MANAGE
   * @adminMethod
   */
  function bulkUpdateBooking(bookings: MaskedBooking[]): Promise<BulkUpdateBookingResponse>;
  /**
   * Creates multiple bookings.
   *
   *
   * See [`createBooking()`](https://www.wix.com/velo/reference/wix-bookings-v2/bookings/createbooking) documentation.
   *
   * If for any of the bookings required fields were not passed on the request or if the caller doesn't have the required permissions to create such booking, the call will fail.
   * If the request contains unavailable bookings, the call will be completed successfully, but the unavailable bookings will not be created and will be considered as a failure on the response.
   * @param createBookingsInfo - Bookings to create.
   * Max: 8 bookings.
   * @public
   * @documentationMaturity preview
   * @requiredField createBookingsInfo
   * @requiredField createBookingsInfo.booking
   * @requiredField createBookingsInfo.booking.additionalFields._id
   * @requiredField createBookingsInfo.booking.bookedEntity
   * @permissionId BOOKINGS.BOOKING_CREATE
   */
  function bulkCreateBooking(createBookingsInfo: CreateBookingInfo[], options?: BulkCreateBookingOptions): Promise<BulkCreateBookingResponse>;
  interface BulkCreateBookingOptions {
      /** Whether to return the created bookings entities. */
      returnFullEntity?: boolean;
  }
  /**
   * Reschedules a booking to a different slot or session.
   *
   *
   * You can only reschedule bookings for appointments or classes, you can't
   * reschedule course bookings.
   *
   * The old session is removed from the calendar and the new session is
   * added.
   *
   * If you reschedule a booking for a class session the new session must be an
   * existing session for the same class.
   *
   * You can pass a `participantNotification.message` to notify the customer of
   * the rescheduling. You also need to pass `participantNotification.notifyParticipants`
   * as `true` to actually send the message.
   *
   * In case the service has
   * variants, you can call this endpoint to update the booking's `totalParticipants` or `participantsChoices`.
   * If you provide `participantsChoices`, all of the provided choices must exist for
   * the service. Otherwise, the call returns an `INVALID_SERVICE_CHOICES` error.
   * If you omit `participantsChoices` in the request, the existing choices are
   * kept and not replaced with an empty object.
   *
   * <!-- INTERNAL PERMISSION COMMENT:
   * You need to have the `BOOKINGS.NUMBER_OF_PARTICIPANTS_UPDATE` permission
   * to reschedule bookings including `participantsInfo`.
   * <!--END: INTERNAL PERMISSION COMMENT-->
   *
   * In case you want to reschedule a booking on behalf of a customer, we recommend
   * to pass `flowControlSettings.ignoreReschedulePolicy` as `false`. This
   * ensures that the rescheduling is validated against the service's rescheduling
   * policy.
   * @param bookingId - ID of the booking to reschedule.
   * @param slot - Information about the new slot.
   * @public
   * @documentationMaturity preview
   * @requiredField bookingId
   * @requiredField options.revision
   * @requiredField slot
   * @param options - An object representing the available options for rescheduling a booking.
   * @permissionId BOOKINGS.BOOKING_RESCHEDULE
   * @adminMethod
   */
  function rescheduleBooking(bookingId: string, slot: V2Slot, options?: RescheduleBookingOptions): Promise<RescheduleBookingResponse>;
  interface RescheduleBookingOptions extends RescheduleBookingRequestParticipantsInfoOneOf {
      /**
       * Revision number, which increments by 1 each time the booking is updated.
       * To prevent conflicting changes, the current revision must be passed when
       * managing the booking.
       */
      revision: string | null;
      /**
       * Information about whether to notify the customer about the rescheduling and
       * the message to send.
       */
      participantNotification?: ParticipantNotification$1;
      /**
       * Information about whether specific procedures of the standard Wix Bookings
       * rescheduling flow are changed. For example, whether the availability of
       * the new slot is checked before rescheduling the booking or if you can
       * reschedule the booking even though the rescheduling policy doesn't allow it.
       */
      flowControlSettings?: RescheduleBookingFlowControlSettings;
      /**
       * Total number of participants. Available only for services with
       * variants.
       * Pass when all participants book the same variant.
       */
      totalParticipants?: number;
      /**
       * Information about the service choices to book. Available only for services with
       * variants.
       * Pass when not all participants book the same variant.
       */
      participantsChoices?: ParticipantChoices$1;
      /**
       * whether this booking availability should be checked with v1 or v2
       * @internal
       */
      v2Availability?: boolean | null;
  }
  /** @param slotsBookings - Reschedule multiple bookings to multiple slots.
   * @internal
   * @documentationMaturity preview
   * @requiredField slotsBookings
   * @requiredField slotsBookings.bookings
   * @requiredField slotsBookings.bookings._id
   * @requiredField slotsBookings.bookings.revision
   * @requiredField slotsBookings.slot
   * @permissionId BOOKINGS.BOOKING_MANAGE
   * @adminMethod
   */
  function bulkRescheduleBooking(slotsBookings: SlotBookings[], options?: BulkRescheduleBookingOptions): Promise<BulkRescheduleBookingResponse>;
  interface BulkRescheduleBookingOptions {
      /** Whether to notify participants about the change and an optional custom message */
      participantNotification?: ParticipantNotification$1;
  }
  /** @param bookings - The bookings whose booked schedule is to be updated to the given schedule.
   * @internal
   * @documentationMaturity preview
   * @requiredField bookings
   * @requiredField bookings._id
   * @requiredField bookings.revision
   * @requiredField options.scheduleId
   * @permissionId BOOKINGS.BOOKING_MANAGE
   * @adminMethod
   */
  function bulkUpdateBookedSchedule(bookings: BookingDetails[], options?: BulkUpdateBookedScheduleOptions): Promise<BulkUpdateBookedScheduleResponse>;
  interface BulkUpdateBookedScheduleOptions {
      /** The ID of the schedule to be updated. */
      scheduleId: string;
      /** Whether to notify participants about the change and an optional custom message. */
      participantNotification?: ParticipantNotification$1;
  }
  /**
   * > **Deprecation Notice**
   * >
   * > **This endpoint has been replaced with [Query Extended Bookings](https://dev.wix.com/api/rest/wix-bookings/bookings-reader-v2/query-extended-bookings) and will be removed on December 31, 2023.**
   * > **If your app uses this endpoint, we recommend updating your code as soon as possible.**
   *
   * Retrieves a list of bookings according to the provided filters and paging.
   *
   * <!-- Internal only
   * Site owner can read all the bookings created in the site.
   * Members can read only the bookings they created or the bookings created for them (which means: booking.contactDetails.contactId = memberId)
   * Visitors can read only the bookings they created or the bookings created for them (which means: booking.contactDetails.contactId = visitorId)
   * -->
   *
   * Create a query with filters on any booking object property.
   * See [Query Syntax: Filters, Sorting, Fields, and Paging.](https://bo.wix.com/wix-docs/rest/bookings/bookings---bookings-service/query-syntax) for the full query syntax description.
   *
   * To retrieve all bookings use an empty query:
   * ```javascript
   * {
   * "query": {}
   * }
   * ```
   *
   * The query runs with the following defaults:
   * + skip(0)
   * + limit(50)
   * + descending("_createdDate")
   *
   *
   * >**Notes:**
   * > + Use UTC when specifying filters with dates.
   * > + The following objects in the `query` parameter are not supported for this query:
   * >    - `fields`
   * >    - `fieldsets`
   * >  - Only 1 use at a time of each filter once in the same query is supported. If a filter is defined  more than once in a query, only the first occurrence is taken.
   * >  - To get the available actions for a member for each booking, based on the business bookings policy, use the `withBookingAllowedActions` field.
   * >  - When using the queryBookings() function immediately following a change to your bookings, the data retrieved may not contain your most recent changes. See [Wix-data and Eventual Consistency](reference/wix-data/introduction#wix-data_introduction_wix-data-and-eventual-consistency) for more information.
   * >  - The `businessLocation.businessSchedule` object in the `bookedEntity.location` object is not supported.
   *
   *
   * > **Permissions**
   * > This endpoint requires the Read Bookings - Including Participants permission scope.
   * @internal
   * @documentationMaturity preview
   * @requiredField query
   * @permissionId BOOKINGS.BOOKING_READ
   */
  function query(query: QueryV2, options?: QueryOptions): Promise<QueryBookingsResponse>;
  interface QueryOptions {
      /**
       * Whether the authorization constraint should be handled on Bookings-Service. To be removed when rollout of SCHED-SCHED-25500 is finished.
       * @internal
       */
      shouldNotHandleAuthorizationConstraints?: boolean;
      /**
       * Whether information about the total entities is returned.
       * @internal
       */
      withPagingMetadataTotal?: boolean;
  }
  /**
   * Confirms a booking request and changes the booking status to `CONFIRMED`.
   *
   *
   * Calling this method doesn't check whether a slot or schedule is still
   * available at this time.
   *
   * You can only confirm bookings for services that require the owner's manual
   * approval for bookings and that have a status of `PENDING`.
   *
   * For appointment services the slot may become unavailable, depending on the
   * [service's](https://support.wix.com/en/article/creating-the-right-booking-service-for-your-business)
   * `policy.bookingApprovalPolicy.requestsAffectsAvailability`.
   *
   * Calling this method also changes the
   * [session's](https://www.wix.com/velo/reference/wix-bookings-backend/sessions/getsession)
   * `participants.approvalStatus` to `APPROVED`.
   *
   * You can pass a `participantNotification.message` to notify the customer of
   * the confirmation. You also need to pass `participantNotification.notifyParticipants`
   * as `true` to actually send the message.
   *
   * Bookings are automatically confirmed when the
   * service is configured to automatically confirm
   * bookings and the [eCommerce order](https://www.wix.com/velo/reference/wix-ecom-backend/orders)
   * has been approved. The slot's or schedule's availability is checked just
   * before confirming the booking as part of the automatic flow.
   * @param bookingId - ID of the booking to confirm.
   * @param revision - Revision number, which increments by 1 each time the booking is updated.
   * To prevent conflicting changes, the current revision must be passed when
   * managing the booking.
   * @public
   * @documentationMaturity preview
   * @requiredField bookingId
   * @requiredField revision
   * @param options - An object representing the available options for canceling a booking.
   * @permissionId BOOKINGS.BOOKING_CONFIRM
   * @adminMethod
   */
  function confirmBooking(bookingId: string, revision: string | null, options?: ConfirmBookingOptions): Promise<ConfirmBookingResponse>;
  interface ConfirmBookingOptions {
      /**
       * Information about whether to notify the customer about the confirmation and
       * the message to send.
       */
      participantNotification?: ParticipantNotification$1;
      /**
       * Whether to send an SMS reminder to the customer 24 hours before the
       * session starts. The phone number is taken from `contactDetails.phone`.
       */
      sendSmsReminder?: boolean | null;
      /**
       * Payment status to set for the booking.
       * One of:
       * - `"NOT_PAID"` The booking is not paid for.
       * - `"PAID"` The booking is fully paid.
       * - `"PARTIALLY_PAID"` The booking is partially paid.
       * - `"REFUNDED"` The booking is refunded.
       * - `"EXEMPT"` The booking is free of charge.
       */
      paymentStatus?: PaymentStatus$1;
      /** Whether this booking overlaps with another existing confirmed booking. */
      doubleBooked?: boolean | null;
      /**
       * Information about whether specific procedures of the standard Wix Bookings
       * creation flow are changed. For example, whether the availability is
       * checked before confirming the booking.
       */
      flowControlSettings?: ConfirmBookingFlowControlSettings;
  }
  interface PartySizeOptions extends PartySizeRequestPartySizeForOneOf {
      sessionId?: string | null;
      scheduleId?: string | null;
  }
  /**
   * private API, similarly to Query, with consistent DB connection
   * @internal
   * @documentationMaturity preview
   * @adminMethod
   */
  function consistentQuery(options?: ConsistentQueryOptions): Promise<ConsistentQueryBookingsResponse>;
  interface ConsistentQueryOptions {
      query?: QueryV2;
  }
  /**
   * Private API, dedicated for setting booking sessionId after the session was created for the booking.
   * @param _id - ID of the booking to set its sessionId.
   * @internal
   * @documentationMaturity preview
   * @requiredField _id
   * @adminMethod
   */
  function setBookingSessionId(_id: string, options?: SetBookingSessionIdOptions): Promise<SetBookingSessionIdResponse>;
  interface SetBookingSessionIdOptions {
      /** The sessionId to be set. */
      sessionId?: string;
  }
  /**
   * Updates the extended fields for a booking.
   *
   *
   * Extended fields must first be configured in the [Wix Developers Center](https://dev.wix.com/app-selector?title=Select+an+App&primaryButtonText=Select+Site&actionUrl=https%3A%2F%2Fdev.wix.com%2Fapps%2F%7BappId%7D%2Fextensions).
   *
   * Learn more about setting up extended fields with [schema plugins](https://dev.wix.com/docs/build-apps/develop-your-app/extensions/backend-extensions/schema-plugins/about-schema-plugin-extensions).
   * @public
   * @documentationMaturity preview
   * @requiredField _id
   * @requiredField namespace
   * @requiredField options
   * @requiredField options.namespaceData
   * @param _id - ID of the booking for which to update extended fields.
   * @param namespace - [Namespace](https://dev.wix.com/docs/build-apps/develop-your-app/extensions/backend-extensions/schema-plugins/about-reading-and-writing-schema-plugin-fields#namespaces) of the app for which to update extended fields.
   * @param options - Options for updating the booking's extended fields.
   * @permissionId BOOKINGS.BOOKING_UPDATE_EXTENDED_FIELDS
   * @adminMethod
   */
  function updateExtendedFields(_id: string, namespace: string, options: UpdateExtendedFieldsOptions): Promise<UpdateExtendedFieldsResponse>;
  interface UpdateExtendedFieldsOptions {
      /** Data of the extended field to update. Must be structured according to the [schema](https://dev.wix.com/docs/build-apps/develop-your-app/extensions/backend-extensions/schema-plugins/about-schema-plugin-extensions#json-schema-for-extended-fields) defined during the configuration of the extended fields. */
      namespaceData: Record<string, any> | null;
  }
  /**
   * Declines a `PENDING` booking request and changes the booking status to
   * `DECLINED`.
   *
   * Calling this method also changes the
   * [session's](https://www.wix.com/velo/reference/wix-bookings-backend/sessions/getsession)
   * `participants.approvalStatus` to `DECLINED`.
   *
   * You can only decline bookings for services that require the owner's manual
   * approval for bookings and that have a status of `PENDING`.
   *
   * You can pass a `participantNotification.message` to notify the customer of
   * the decline. You also need to pass `participantNotification.notifyParticipants`
   * as `true` to actually send the message.
   * @param bookingId - ID of the booking to decline.
   * @param revision - Revision number, which increments by 1 each time the booking is updated.
   * To prevent conflicting changes, the current revision must be passed when
   * managing the booking.
   * @public
   * @documentationMaturity preview
   * @requiredField bookingId
   * @requiredField revision
   * @param options - An object representing the available options for declining a booking.
   * @permissionId BOOKINGS.BOOKING_DECLINE
   * @adminMethod
   */
  function declineBooking(bookingId: string, revision: string | null, options?: DeclineBookingOptions): Promise<DeclineBookingResponse>;
  interface DeclineBookingOptions {
      /**
       * Information about whether to notify the customer about the decline and
       * the message to send.
       */
      participantNotification?: ParticipantNotification$1;
      /**
       * Payment status to set on the booking.
       * One of:
       * - `"NOT_PAID"` The booking is not paid for.
       * - `"PAID"` The booking is fully paid.
       * - `"PARTIALLY_PAID"` The booking is partially paid.
       * - `"REFUNDED"` The booking is refunded.
       * - `"EXEMPT"` The booking is free of charge.
       */
      paymentStatus?: PaymentStatus$1;
      /** Whether this booking overlaps with another existing confirmed booking. */
      doubleBooked?: boolean | null;
      /**
       * Information about whether specific procedures of the standard Wix Bookings
       * declining flow are changed. For example, whether to issue a refund.
       */
      flowControlSettings?: DeclineBookingFlowControlSettings;
  }
  /**
   * Cancels a booking.
   *
   *
   * The booking status changes to `CANCELED`.
   *
   * If the booking was for an appointment, the corresponding session is
   * deleted from the business calendar.
   *
   * If the booking was for a class or course, the participants are removed
   * from the class session or the course. But the course or class session
   * remains on the business calendar.
   *
   * You can pass a `participantNotification.message` to notify the customer of
   * the cancelation. You also need to pass `participantNotification.notifyParticipants`
   * as `true` to actually send the message.
   *
   * In case you want to cancel a booking on behalf of a customer, we recommend
   * to pass `flowControlSettings.ignoreCancellationPolicy` as `false`. This
   * ensures that the cancelation is validated against the service's cancelation
   * policy.
   * @param bookingId - ID of the booking to cancel.
   * @public
   * @documentationMaturity preview
   * @requiredField bookingId
   * @requiredField options.revision
   * @param options - An object representing the available options for canceling a booking.
   * @permissionId BOOKINGS.BOOKING_CANCEL
   * @adminMethod
   */
  function cancelBooking(bookingId: string, options?: CancelBookingOptions): Promise<CancelBookingResponse>;
  interface CancelBookingOptions {
      /**
       * Information about whether to notify the customer about the cancelation and
       * the message to send.
       */
      participantNotification?: ParticipantNotification$1;
      /**
       * Information about whether specific procedures of the standard Wix Bookings
       * cancelation flow are changed. For example, whether the you can cancel
       * a booking even though the cancelation policy doesn't allow it or whether
       * to issue a refund.
       */
      flowControlSettings?: CancelBookingFlowControlSettings;
      /**
       * Revision number, which increments by 1 each time the booking is updated.
       * To prevent conflicting changes,
       * the current revision must be passed when managing the booking.
       */
      revision: string | null;
  }
  /**
   * Updates the number of participants for a booking.
   *
   *
   * You can only update the number of participants for class and course
   * bookings, you can't update it for appointment bookings.
   *
   * Calling this method also changes the
   * [session's](https://www.wix.com/velo/reference/wix-bookings-backend/sessions/getsession)
   * `totalNumberOfParticipants`.
   *
   * When updating the number of participants for a booking you must pass either
   * `participantsChoices` or `totalParticipants`. If you pass `participantsChoices`
   * for services that have variants,
   * all of the provided choices must exist for the service. Otherwise, the
   * call returns an `INVALID_SERVICE_CHOICES` error.
   * @param bookingId - ID of the booking to update the number of participants for.
   * @public
   * @documentationMaturity preview
   * @requiredField bookingId
   * @requiredField options.revision
   * @permissionId BOOKINGS.NUMBER_OF_PARTICIPANTS_UPDATE
   * @adminMethod
   */
  function updateNumberOfParticipants(bookingId: string, options?: UpdateNumberOfParticipantsOptions): Promise<UpdateNumberOfParticipantsResponse>;
  interface UpdateNumberOfParticipantsOptions extends UpdateNumberOfParticipantsRequestParticipantsInfoOneOf {
      /**
       * Updated number of participants.
       * @internal
       * @deprecated
       */
      numberOfParticipants?: number | null;
      /**
       * Revision number, which increments by 1 each time the booking is updated.
       * To prevent conflicting changes, the current revision must be passed when
       * managing the booking.
       */
      revision: string | null;
      /**
       * Total number of participants. Available only for services with
       * variants.
       * Pass when all participants book the same variant.
       */
      totalParticipants?: number;
      /**
       * Information about the service choices to book. Available only for services with
       * variants.
       * Pass when not all participants book the same variant.
       */
      participantsChoices?: ParticipantChoices$1;
  }
  /**
   * Calculates the allowed actions for a given list of booking id's
   * @param bookingIds - The booking id's that we want to calculate the allowedActions for
   * @internal
   * @documentationMaturity preview
   * @requiredField bookingIds
   * @permissionId BOOKINGS.BULK_CALCULATE_ALLOWED_ACTIONS
   */
  function bulkCalculateAllowedActions(bookingIds: string[] | null): Promise<BulkCalculateAllowedActionsResponse>;
  /** @internal
   * @documentationMaturity preview
   * @adminMethod
   */
  function getSlotAvailability(options?: GetSlotAvailabilityOptions): Promise<GetSlotAvailabilityResponse>;
  interface GetSlotAvailabilityOptions {
      /** The slot for which the availability is checked. */
      slot?: V2Slot;
      /** The timezone for which availability is to be calculated. */
      timezone?: string | null;
      /**
       * Return the IDs of bookings that are currently allowed to book the given slot due to being a part of a waitlist in a "suggested" status.
       * @internal
       */
      returnAllowedBookingIds?: boolean;
      /**
       * Check if this booking is allowed to book the given slot due to being a part of a waitlist in a "suggested" status.
       * If passed and the slot is locked for a booking other than this one, `bookable = false` is returned.
       * @internal
       */
      bookingId?: string | null;
      /**
       * Whether availability should be queried to availability calendar or availability service
       * @internal
       */
      shouldUseV2Availability?: boolean;
      /**
       * TODO: remove after qa and add a dedicated EP for calculating all available non double booked resources instead.
       * Whether to skip optimizations during the calculation for overlapping bookings, in order to get the full list of possible
       * non double booked resources.
       * @internal
       */
      returnAllAvailableResources?: boolean;
      /**
       * Whether availability should be queried to availability calendar or availability service
       * @internal
       */
      v2Availability?: boolean | null;
  }
  /**
   * Returns availability for a given schedule ID
   * The availability for a course is calculated by:
   * - Checking for total spots by the schedule's capacity
   * - Checking for open spots by subtracting the current number of participants from the total spots
   * @param scheduleId - The schedule ID for which availability is checked.
   * @internal
   * @documentationMaturity preview
   * @requiredField scheduleId
   * @adminMethod
   */
  function getScheduleAvailability(scheduleId: string): Promise<GetScheduleAvailabilityResponse>;
  /** @param bookingId - ID of the booking to mark as PENDING.
   * @param revision - Revision number, which increments by 1 each time the booking is updated.
   * To prevent conflicting changes, the current revision must be passed when
   * managing the booking.
   * @internal
   * @documentationMaturity preview
   * @requiredField bookingId
   * @requiredField revision
   * @permissionId BOOKINGS.BOOKING_MARK_BOOKING_AS_PENDING
   * @adminMethod
   */
  function markBookingAsPending(bookingId: string, revision: string | null, options?: MarkBookingAsPendingOptions): Promise<MarkBookingAsPendingResponse>;
  interface MarkBookingAsPendingOptions {
      /**
       * Information about whether to notify the customer and
       * the message to send.
       */
      participantNotification?: ParticipantNotification$1;
      /**
       * Whether to send an SMS reminder to the customer 24 hours before the
       * session starts. The phone number is taken from `contactDetails.phone`.
       */
      sendSmsReminder?: boolean | null;
      /**
       * Payment status to set for the booking.
       * One of:
       * - `"NOT_PAID"` The booking is not paid for.
       * - `"PAID"` The booking is fully paid.
       * - `"PARTIALLY_PAID"` The booking is partially paid.
       * - `"REFUNDED"` The booking is refunded.
       * - `"EXEMPT"` The booking is free of charge.
       */
      paymentStatus?: PaymentStatus$1;
      /** Whether this booking overlaps with another existing confirmed booking. */
      doubleBooked?: boolean | null;
      /**
       * Information about whether specific procedures of the standard Wix Bookings
       * creation flow are changed. For example, whether the availability is
       * checked before updating the booking's status.
       */
      flowControlSettings?: MarkBookingAsPendingFlowControlSettings;
  }
  /**
   * Use `confirmOrDeclineBooking()` to determine if the booking is valid, payment is received, and the booking can be processed.
   * Call `confirmOrDeclineBooking()` after checkout or after calling `createBooking()` to verify the booking.
   *
   * + If a session is valid and payment is received, the booking is visible on the calendar.
   * + If a session is double booked, `confirmOrDeclineBooking()` can catch this and decline the duplicate booking, the booking is not visible on the calendar.
   * @param bookingId - ID of the booking to confirm or decline.
   * @public
   * @documentationMaturity preview
   * @requiredField bookingId
   * @permissionId BOOKINGS.BOOKING_CONFIRM_OR_DECLINE
   * @adminMethod
   */
  function confirmOrDeclineBooking(bookingId: string, options?: ConfirmOrDeclineBookingOptions): Promise<ConfirmOrDeclineBookingResponse>;
  interface ConfirmOrDeclineBookingOptions {
      /**
       * Current payment status of the booking when using a custom checkout page and
       * not the [Wix eCommerce checkout](https://dev.wix.com/docs/rest/business-solutions/e-commerce/checkout/introduction).
       *
       * The booking is declined if there is a double booking conflict and you provide
       * one of these payment statuses: `UNDEFINED`, `NOT_PAID`, `REFUNDED`, or `EXEMPT`.
       */
      paymentStatus?: PaymentStatus$1;
      /**
       * When true  decline the booking if double booked.
       * @internal
       */
      declineDoubleBooking?: boolean | null;
  }
  /**
   * Confirms or declines multiple bookings.
   *
   *
   * See [Confirm Or Decline Booking](/bookings-v2/bookings-v2-and-confirmation/bookings-confirm-or-decline-booking)
   * for details about when a booking is confirmed or declined.
   * @param details - The bookings to confirm or decline.
   * @internal
   * @documentationMaturity preview
   * @requiredField details
   * @requiredField details.bookingId
   * @permissionId BOOKINGS.BOOKING_CONFIRM_OR_DECLINE
   * @adminMethod
   */
  function bulkConfirmOrDeclineBooking(details: BulkConfirmOrDeclineBookingRequestBookingDetails[], options?: BulkConfirmOrDeclineBookingOptions): Promise<BulkConfirmOrDeclineBookingResponse>;
  interface BulkConfirmOrDeclineBookingOptions {
      /**
       * Whether to return the confirmed or declined bookings entities.
       * Not supported yet, currently the entity is not returned.
       */
      returnEntity?: boolean;
  }
  /**
   * Creates a booking.
   *
   *
   * To create a booking for an appointment or a session of a class, pass the
   * relevant `slot` in the body of the request. You can use the
   * [Get Slot Availability](https://bo.wix.com/wix-docs/rest/bookings/availabilitycalendar---wip/get-slot-availability)
   * endpoint to check the availability of the session beforehand.
   *
   * To create a booking for the entire course, pass the relevant `schedule` in
   * the body of the request. You can use the
   * [Get Schedule Availability](https://bo.wix.com/wix-docs/rest/bookings/availabilitycalendar---wip/get-schedule-availability)
   * endpoint to check the availability of the course beforehand.
   *
   * Bookings are created with a status of `CREATED`. `CREATED` bookings don't
   * appear on the business calendar and don't affect a related schedule's
   * availability.
   *
   * If you create a booking for an existing session, we recommend that you
   * only pass `slot.sessionId`. Then, any specified slot details are
   * calculated.
   *
   * If you create a booking for a new session, we recommend to call
   * [Get Slot Availability](https://bo.wix.com/wix-docs/rest/bookings/availabilitycalendar---wip/get-slot-availability)
   * first. Then, pass the retrieved `availability.slot` object in the body of
   * the Create Booking request.
   *
   * If you create a booking for a course, we recommend that you pass only
   * `schedule.scheduleId` and not the entire `schedule` object. Then, all
   * schedule details are automatically calculated.
   *
   * When creating a booking you must pass either `participantsChoices` or
   * `totalParticipants`. If you pass `participantsChoices`, all of the
   * provided choices must exist for the service. Otherwise the call returns an
   * `INVALID_SERVICE_CHOICES` error.
   *
   * When creating a booking, you can pass a `selectedPaymentOption`. This specifies
   * which payment method the customer intends to use. But it's possible for
   * them to later use another supported payment method.
   *
   * After you have created the booking, you can use the
   * [Wix eCommerce APIs](https://bo.wix.com/wix-docs/rest/ecommerce/checkout/introduction)
   * for the [checkout](https://bo.wix.com/wix-docs/rest/ecommerce/checkout/create-checkout)
   * and [order](https://bo.wix.com/wix-docs/rest/ecommerce/checkout/create-order-from-checkout)
   * steps of the payment flow.
   * @internal
   * @documentationMaturity preview
   * @permissionId BOOKINGS.BOOKING_CREATE
   * @deprecated
   */
  function bookingsGatewayCreateBooking(options?: BookingsGatewayCreateBookingOptions): Promise<V2CreateBookingResponse>;
  interface BookingsGatewayCreateBookingOptions extends V2CreateBookingRequestBookableItemOneOf, V2CreateBookingRequestParticipantsInfoOneOf {
      /**
       * Information about the slot to create a booking for.
       * If you set `slot.location.locationType` to `CUSTOM`, the created slot's
       * location is set to `slot.location.formattedAddress` when provided.
       * Otherwise it's set to `contactDetails.fullAddress.formattedAddress`.
       */
      slot?: Slot;
      /** Information about the schedule to create a booking for. */
      schedule?: BookedSchedule$1;
      /** Contact details of the customer booking the service. */
      contactDetails?: ContactDetails$1;
      /**
       * Booking status.
       * One of:
       * - `"CREATED"` - The booking was created.
       * - `"UPDATED"` - The booking was updated.
       * - `"CONFIRMED"` - The booking has been confirmed and appears on the bookings calendar.
       * Booking can be manually confirmed using the Set As Confirmed endpoint.
       * Booking can be automatically confirmed when the following requirements are met:
       * + The service is configured as automatically confirmed.
       * + Invoking eCommerce checkout API and an order has been created.
       * - `"CANCELED"` - The booking has been canceled and synced to bookings calendar.
       * The booking can be canceled using cancel API.
       * - `"PENDING"` - The booking waiting to be confirmed or declined buy the owner and is synced to bookings calendar.
       * Bookings can be manually set as pending using setAsPending API, requires manage booking status permissions.
       * Booking can be automatically set as pending when the following requirements are met:
       * + The Service is configured as manually confirmed.
       * + Invoking the eCommerce checkout API and an order has been created.
       * - `"WAITING_LIST"` - The booking is pending on a waiting list.
       * Booking can be created with this status when invoking waiting list join API.
       * - `"DECLINED"` - The booking was declined by the owner and synced to bookings calendar.
       * Booking can be manually declined using decline API and requires manage booking permissions.
       * Booking can be automatically declined when the following requirements are met:
       * + Invoking eCommerce checkout API and the order declined event has been sent.
       * + Invoking eCommerce checkout API and order approved event has been sent, but the booking is offline and the booking causes a double booking.
       */
      status?: BookingStatus$1;
      /**
       * Additional custom fields of the booking form. The customer must provide
       * information for each field when booking the service. For example, that they
       * bring their own towels or whether they use a wheelchair.
       *
       * Max: 100 fields
       */
      additionalFields?: CustomFormField$1[];
      /**
       * Total number of participants. Available only when the service doesn't have
       * [variants](https://dev.wix.com/api/rest/wix-bookings/service-options-and-variants/introduction).
       *
       * Max: `20`
       */
      numberOfParticipants?: number | null;
      /**
       * Internal business note. Not visible to the customer.
       *
       * Max: 200 characters
       */
      internalBusinessNote?: string | null;
      /**
       * Payment option the customer intends to use.
       * Must be one of the payment options defined for the service, unless
       * you pass `flowControlSettings.skipSelectedPaymentOptionValidation` as `true`.
       */
      selectedPaymentOption?: SelectedPaymentOption$1;
      /**
       * Identifies the source (platform, actor and app) that created this booking.
       * This property of the booking cannot be changed.
       * The app_def_id and app_name will be resolved automatically.
       * TODO GAP See if we need this - might be able to get this data from the headers?
       */
      bookingSource?: BookingSource$1;
      /**
       * A user identifier of an external application user that initiated the book request.
       * Allows an external application to later identify its own bookings and correlate to its own internal users
       */
      externalUserId?: string | null;
      /** Information about a message to send to the customer. */
      participantNotification?: ParticipantNotification$1;
      /**
       * Whether to send an SMS reminder to the customer 24 hours before the
       * session starts. The phone number is taken from `contactDetails.phone`.
       *
       * Default: `true`.
       */
      sendSmsReminder?: boolean | null;
      /**
       * Information about whether specific procedures of the standard Wix Bookings
       * creation flow are changed. For example, whether the availability is
       * checked before creating the booking or if additional payment options are
       * accepted.
       */
      flowControlSettings?: CreateBookingRequestFlowControlSettings;
      /**
       * Total number of participants.
       * Provide when the service doesn't have
       * [variants](https://dev.wix.com/api/rest/wix-bookings/service-options-and-variants/introduction).
       * @internal
       */
      totalParticipants?: number;
      /**
       * Information about the service choices to book. Provide for services with
       * [variants](https://dev.wix.com/api/rest/wix-bookings/service-options-and-variants/introduction).
       * @internal
       */
      participantsChoices?: ParticipantChoices$1;
      /**
       * whether this booking availability should be checked with v1 or v2
       * @internal
       */
      v2Availability?: boolean | null;
  }
  /**
   * Cancels a booking.
   *
   *
   * The booking status changes to `CANCELED`.
   *
   * If the booking was for an appointment, the corresponding session is
   * deleted from the business calendar.
   *
   * If the booking was for a class or course, the participants are removed
   * from the class session or the course. But the course or class session
   * remain on the business calendar.
   *
   * You can pass a `participantNotification.message` to notify the customer of
   * the cancelation. You also need to pass `participantNotification.notifyParticipants`
   * as `true` to actually send the message.
   *
   * In case you want to cancel a booking on behalf of a customer, we recommend
   * to pass `flowControlSettings.ignoreCancellationPolicy` as `false`. This
   * ensures that the cancelation is validated against the service's cancelation
   * policy.
   * @param bookingId - ID of the booking to cancel.
   * @internal
   * @documentationMaturity preview
   * @requiredField bookingId
   * @requiredField options.revision
   * @permissionId BOOKINGS.BOOKING_CANCEL
   * @deprecated
   */
  function bookingsGatewayCancelBooking(bookingId: string, options?: BookingsGatewayCancelBookingOptions): Promise<V2CancelBookingResponse>;
  interface BookingsGatewayCancelBookingOptions {
      /**
       * Information about whether to notify the customer about the cancelation and
       * the message to send.
       */
      participantNotification?: ParticipantNotification$1;
      /**
       * Information about whether specific procedures of the standard Wix Bookings
       * cancelation flow are changed. For example, whether the you can cancel
       * a booking even though the cancelation policy doesn't allow it or whether
       * to issue a refund.
       * @internal
       */
      flowControlSettings?: V2CancelBookingRequestFlowControlSettings;
      /**
       * Revision number, which increments by 1 each time the booking is updated.
       * To prevent conflicting changes,
       * the current revision must be passed when managing the booking.
       */
      revision: string | null;
  }
  /**
   * Reschedules a booking to a different slot or session.
   *
   *
   * You can only reschedule bookings for appointments or classes, you can't
   * reschedule course bookings.
   *
   * The old session is removed from the calendar and the new session is
   * added.
   *
   * If you reschedule a booking for a class session the new session must be an
   * existing session for the same class.
   *
   * You can pass a `participantNotification.message` to notify the customer of
   * the rescheduling. You also need to pass `participantNotification.notifyParticipants`
   * as `true` to actually send the message.
   *
   * In case the service has
   * [variants](https://dev.wix.com/api/rest/wix-bookings/service-options-and-variants/introduction),
   * you can call this endpoint to update the booking's `totalParticipants` or `participantsChoices`. If you
   * provide `participantsChoices`, all of the provided choices must exist for
   * the service. Otherwise the call returns an `INVALID_SERVICE_CHOICES` error.
   * If you omit `participantsChoices` in the request, the existing choices are
   * kept and not replaced with an empty object.
   *
   * <!-- INTERNAL PERMISSION COMMENT:
   * You need to have the `BOOKINGS.NUMBER_OF_PARTICIPANTS_UPDATE` permission
   * to reschedule bookings including `participantsInfo`.
   * <!--END: INTERNAL PERMISSION COMMENT-->
   *
   * In case you want to reschedule a booking on behalf of a customer, we recommend
   * to pass `flowControlSettings.ignoreReschedulePolicy` as `false`. This
   * ensures that the rescheduling is validated against the service's rescheduling
   * policy.
   * @param bookingId - Id of the booking to reschedule.
   * @param slot - Information about the new slot.
   * @internal
   * @documentationMaturity preview
   * @requiredField bookingId
   * @requiredField options.revision
   * @requiredField slot
   * @permissionId BOOKINGS.BOOKING_RESCHEDULE
   * @deprecated
   */
  function bookingsGatewayRescheduleBooking(bookingId: string, slot: Slot, options?: BookingsGatewayRescheduleBookingOptions): Promise<V2RescheduleBookingResponse>;
  interface BookingsGatewayRescheduleBookingOptions extends V2RescheduleBookingRequestParticipantsInfoOneOf {
      /**
       * Revision number, which increments by 1 each time the booking is updated.
       * To prevent conflicting changes, the current revision must be passed when
       * managing the booking.
       */
      revision: string | null;
      /**
       * Information about whether to notify the customer about the rescheduling and
       * the message to send.
       */
      participantNotification?: ParticipantNotification$1;
      /**
       * Information about whether specific procedures of the standard Wix Bookings
       * rescheduling flow are changed. For example, whether the availability of
       * the new slot is checked before rescheduling the booking or if you can
       * reschedule the booking even though the rescheduling policy doesn't allow it.
       * @internal
       */
      flowControlSettings?: V2RescheduleBookingRequestFlowControlSettings;
      /**
       * Total number of participants. Available only for services with
       * [variants](https://dev.wix.com/api/rest/wix-bookings/service-options-and-variants/introduction).
       * Pass when all participants book the same variant.
       * @internal
       */
      totalParticipants?: number;
      /**
       * Information about the service choices to book. Available only for services with
       * [variants](https://dev.wix.com/api/rest/wix-bookings/service-options-and-variants/introduction).
       * Pass when not all participants book the same variant.
       * @internal
       */
      participantsChoices?: ParticipantChoices$1;
  }
  /**
   * Confirms a booking request and changes the booking status to `CONFIRMED`.
   *
   *
   * Calling this endpoint doesn't check whether a slot or schedule is still
   * available at this time.
   *
   * You can only confirm bookings for services that require the owner's manual
   * approval for bookings and that have a status of `PENDING`. You can read more about
   * [creating a service](https://dev.wix.com/api/rest/wix-bookings/services/service/create-service).
   *
   * For appointment services the slot may become unavailable, depending on the
   * [service's](https://dev.wix.com/api/rest/wix-bookings/services/service/service-object)
   * `policy.bookingApprovalPolicy.requestsAffectsAvailability`.
   *
   * Calling this endpoint also changes the
   * [session's](https://dev.wix.com/api/rest/wix-bookings/schedules-and-sessions/session/get-session)
   * `participants.approvalStatus` to `APPROVED`.
   *
   * You can pass a `participantNotification.message` to notify the customer of
   * the confirmation. You also need to pass `participantNotification.notifyParticipants`
   * as `true` to actually send the message.
   *
   * Bookings are automatically confirmed when the
   * service is configured to [automatically confirm](https://dev.wix.com/api/rest/wix-bookings/services/service/create-service)
   * bookings and the [eCommerce order](https://bo.wix.com/wix-docs/rest/ecommerce/checkout/create-order-from-checkout)
   * has been approved. The slot's or schedule's availabity is checked just
   * before confirming the booking as part of the automatic flow.
   * @param bookingId - ID of the booking to confirm.
   * @param revision - Revision number, which increments by 1 each time the booking is updated.
   * To prevent conflicting changes, the current revision must be passed when
   * managing the booking.
   * @internal
   * @documentationMaturity preview
   * @requiredField bookingId
   * @requiredField revision
   * @permissionId BOOKINGS.BOOKING_CONFIRM
   * @adminMethod
   * @deprecated
   */
  function bookingsGatewayConfirmBooking(bookingId: string, revision: string | null, options?: BookingsGatewayConfirmBookingOptions): Promise<V2ConfirmBookingResponse>;
  interface BookingsGatewayConfirmBookingOptions {
      /**
       * Information about whether to notify the customer about the confirmation and
       * the message to send.
       */
      participantNotification?: ParticipantNotification$1;
  }
  /**
   * Declines a `PENDING` booking request and changes the booking status to
   * `DECLINED`.
   *
   * Calling this endpoint also changes the
   * [session's](https://dev.wix.com/api/rest/wix-bookings/schedules-and-sessions/session/get-session)
   * `participants.approvalStatus` to `DECLINED`.
   *
   * You can only decline bookings for services that require the owner's manual
   * approval for bookings and that have a status of `PENDING`. You can read more about
   * [creating a service](https://dev.wix.com/api/rest/wix-bookings/services/service/create-service).
   *
   * You can pass a `participantNotification.message` to notify the customer of
   * the decline. You also need to pass `participantNotification.notifyParticipants`
   * as `true` to actually send the message.
   * @param bookingId - ID of the booking to decline.
   * @param revision - Revision number, which increments by 1 each time the booking is updated.
   * To prevent conflicting changes, the current revision must be passed when
   * managing the booking.
   * @internal
   * @documentationMaturity preview
   * @requiredField bookingId
   * @requiredField revision
   * @permissionId BOOKINGS.BOOKING_DECLINE
   * @adminMethod
   * @deprecated
   */
  function bookingsGatewayDeclineBooking(bookingId: string, revision: string | null, options?: BookingsGatewayDeclineBookingOptions): Promise<V2DeclineBookingResponse>;
  interface BookingsGatewayDeclineBookingOptions {
      /**
       * Information about whether to notify the customer about the decline and
       * the message to send.
       */
      participantNotification?: ParticipantNotification$1;
  }
  /**
   * Updates the number of participants for a booking.
   *
   *
   * You can only update the number of participants for class and course
   * bookings, you can't update it for appointment bookings.
   *
   * Calling this endpoint also changes the
   * [session's](https://dev.wix.com/api/rest/wix-bookings/schedules-and-sessions/session/get-session)
   * `totalNumberOfParticipants`.
   *
   * When updating the number of participants for a booking you must pass either
   * `participantsChoices` or `totalParticipants`. If you pass `participantsChoices`
   * for services that have
   * [variants](https://dev.wix.com/api/rest/wix-bookings/service-options-and-variants/introduction),
   * all of the provided choices must exist for the service. Otherwise, the
   * call returns an `INVALID_SERVICE_CHOICES` error.
   * @param bookingId - ID of the booking to update the number of participants for.
   * @internal
   * @documentationMaturity preview
   * @requiredField bookingId
   * @requiredField options.revision
   * @permissionId BOOKINGS.NUMBER_OF_PARTICIPANTS_UPDATE
   * @adminMethod
   * @deprecated
   */
  function bookingsGatewayUpdateNumberOfParticipants(bookingId: string, options?: BookingsGatewayUpdateNumberOfParticipantsOptions): Promise<V2UpdateNumberOfParticipantsResponse>;
  interface BookingsGatewayUpdateNumberOfParticipantsOptions extends V2UpdateNumberOfParticipantsRequestParticipantsInfoOneOf {
      /** Updated number of participants. */
      numberOfParticipants?: number | null;
      /**
       * Revision number, which increments by 1 each time the booking is updated.
       * To prevent conflicting changes, the current revision must be passed when
       * managing the booking.
       */
      revision: string | null;
      /**
       * Total number of participants. Available only for services with
       * [variants](https://dev.wix.com/api/rest/wix-bookings/service-options-and-variants/introduction).
       * Pass when all participants book the same variant.
       * @internal
       */
      totalParticipants?: number;
      /**
       * Information about the service choices to book. Available only for services with
       * [variants](https://dev.wix.com/api/rest/wix-bookings/service-options-and-variants/introduction).
       * Pass when not all participants book the same variant.
       * @internal
       */
      participantsChoices?: ParticipantChoices$1;
  }
  
  type bookingsV2Booking_universal_d_CommonIdentificationData = CommonIdentificationData;
  type bookingsV2Booking_universal_d_CommonIdentificationDataIdOneOf = CommonIdentificationDataIdOneOf;
  type bookingsV2Booking_universal_d_IdentificationDataIdentityType = IdentificationDataIdentityType;
  const bookingsV2Booking_universal_d_IdentificationDataIdentityType: typeof IdentificationDataIdentityType;
  type bookingsV2Booking_universal_d_CreateMultiServiceBookingRequest = CreateMultiServiceBookingRequest;
  type bookingsV2Booking_universal_d_CreateBookingFlowControlSettings = CreateBookingFlowControlSettings;
  type bookingsV2Booking_universal_d_CreateMultiServiceBookingResponse = CreateMultiServiceBookingResponse;
  type bookingsV2Booking_universal_d_MultiServiceBooking = MultiServiceBooking;
  type bookingsV2Booking_universal_d_BookingResult = BookingResult;
  type bookingsV2Booking_universal_d_RescheduleMultiServiceBookingRequest = RescheduleMultiServiceBookingRequest;
  type bookingsV2Booking_universal_d_V2Slot = V2Slot;
  type bookingsV2Booking_universal_d_LocationLocationType = LocationLocationType;
  const bookingsV2Booking_universal_d_LocationLocationType: typeof LocationLocationType;
  type bookingsV2Booking_universal_d_SlotSlotResource = SlotSlotResource;
  type bookingsV2Booking_universal_d_SlotLocation = SlotLocation;
  type bookingsV2Booking_universal_d_RescheduleMultiServiceBookingRequestRescheduleBookingInfo = RescheduleMultiServiceBookingRequestRescheduleBookingInfo;
  type bookingsV2Booking_universal_d_RescheduleMultiServiceBookingRequestRescheduleBookingInfoParticipantsInfoOneOf = RescheduleMultiServiceBookingRequestRescheduleBookingInfoParticipantsInfoOneOf;
  type bookingsV2Booking_universal_d_RescheduleBookingFlowControlSettings = RescheduleBookingFlowControlSettings;
  type bookingsV2Booking_universal_d_RescheduleMultiServiceBookingResponse = RescheduleMultiServiceBookingResponse;
  type bookingsV2Booking_universal_d_BookingRescheduled = BookingRescheduled;
  type bookingsV2Booking_universal_d_BookingRescheduledPreviousParticipantsInfoOneOf = BookingRescheduledPreviousParticipantsInfoOneOf;
  type bookingsV2Booking_universal_d_GetMultiServiceBookingAvailabilityRequest = GetMultiServiceBookingAvailabilityRequest;
  type bookingsV2Booking_universal_d_GetMultiServiceBookingAvailabilityResponse = GetMultiServiceBookingAvailabilityResponse;
  type bookingsV2Booking_universal_d_BookingPolicyViolations = BookingPolicyViolations;
  type bookingsV2Booking_universal_d_BookingPolicySettings = BookingPolicySettings;
  type bookingsV2Booking_universal_d_GetMultiServiceBookingAvailabilityResponseBookingInfo = GetMultiServiceBookingAvailabilityResponseBookingInfo;
  type bookingsV2Booking_universal_d_CancelMultiServiceBookingRequest = CancelMultiServiceBookingRequest;
  type bookingsV2Booking_universal_d_CancelBookingFlowControlSettings = CancelBookingFlowControlSettings;
  type bookingsV2Booking_universal_d_CancelMultiServiceBookingResponse = CancelMultiServiceBookingResponse;
  type bookingsV2Booking_universal_d_BookingCanceled = BookingCanceled;
  type bookingsV2Booking_universal_d_MarkMultiServiceBookingAsPendingRequest = MarkMultiServiceBookingAsPendingRequest;
  type bookingsV2Booking_universal_d_BookingInfo = BookingInfo;
  type bookingsV2Booking_universal_d_MarkBookingAsPendingFlowControlSettings = MarkBookingAsPendingFlowControlSettings;
  type bookingsV2Booking_universal_d_MarkMultiServiceBookingAsPendingResponse = MarkMultiServiceBookingAsPendingResponse;
  type bookingsV2Booking_universal_d_ConfirmMultiServiceBookingRequest = ConfirmMultiServiceBookingRequest;
  type bookingsV2Booking_universal_d_ConfirmBookingFlowControlSettings = ConfirmBookingFlowControlSettings;
  type bookingsV2Booking_universal_d_ConfirmMultiServiceBookingResponse = ConfirmMultiServiceBookingResponse;
  type bookingsV2Booking_universal_d_BookingConfirmed = BookingConfirmed;
  type bookingsV2Booking_universal_d_DeclineMultiServiceBookingRequest = DeclineMultiServiceBookingRequest;
  type bookingsV2Booking_universal_d_DeclineBookingFlowControlSettings = DeclineBookingFlowControlSettings;
  type bookingsV2Booking_universal_d_DeclineMultiServiceBookingResponse = DeclineMultiServiceBookingResponse;
  type bookingsV2Booking_universal_d_BookingDeclined = BookingDeclined;
  type bookingsV2Booking_universal_d_BulkGetMultiServiceBookingAllowedActionsRequest = BulkGetMultiServiceBookingAllowedActionsRequest;
  type bookingsV2Booking_universal_d_BulkGetMultiServiceBookingAllowedActionsResponse = BulkGetMultiServiceBookingAllowedActionsResponse;
  type bookingsV2Booking_universal_d_BulkCalculateAllowedActionsResult = BulkCalculateAllowedActionsResult;
  type bookingsV2Booking_universal_d_ItemMetadata = ItemMetadata;
  type bookingsV2Booking_universal_d_ApplicationError = ApplicationError;
  type bookingsV2Booking_universal_d_AllowedActions = AllowedActions;
  type bookingsV2Booking_universal_d_BulkActionMetadata = BulkActionMetadata;
  type bookingsV2Booking_universal_d_MarkAsMultiServiceBookingRequest = MarkAsMultiServiceBookingRequest;
  type bookingsV2Booking_universal_d_MarkAsMultiServiceBookingResponse = MarkAsMultiServiceBookingResponse;
  type bookingsV2Booking_universal_d_GetMultiServiceBookingRequest = GetMultiServiceBookingRequest;
  type bookingsV2Booking_universal_d_GetMultiServiceBookingResponse = GetMultiServiceBookingResponse;
  type bookingsV2Booking_universal_d_MultiServiceBookingMetadata = MultiServiceBookingMetadata;
  type bookingsV2Booking_universal_d_AddBookingsToMultiServiceBookingRequest = AddBookingsToMultiServiceBookingRequest;
  type bookingsV2Booking_universal_d_BookingIdAndRevision = BookingIdAndRevision;
  type bookingsV2Booking_universal_d_AddBookingsToMultiServiceBookingResponse = AddBookingsToMultiServiceBookingResponse;
  type bookingsV2Booking_universal_d_RemoveBookingsFromMultiServiceBookingRequest = RemoveBookingsFromMultiServiceBookingRequest;
  type bookingsV2Booking_universal_d_RemoveBookingsFromMultiServiceBookingResponse = RemoveBookingsFromMultiServiceBookingResponse;
  type bookingsV2Booking_universal_d_DomainEvent = DomainEvent;
  type bookingsV2Booking_universal_d_DomainEventBodyOneOf = DomainEventBodyOneOf;
  type bookingsV2Booking_universal_d_EntityCreatedEvent = EntityCreatedEvent;
  type bookingsV2Booking_universal_d_RestoreInfo = RestoreInfo;
  type bookingsV2Booking_universal_d_EntityUpdatedEvent = EntityUpdatedEvent;
  type bookingsV2Booking_universal_d_EntityDeletedEvent = EntityDeletedEvent;
  type bookingsV2Booking_universal_d_ActionEvent = ActionEvent;
  type bookingsV2Booking_universal_d_MessageEnvelope = MessageEnvelope;
  type bookingsV2Booking_universal_d_WebhooksIdentificationData = WebhooksIdentificationData;
  type bookingsV2Booking_universal_d_WebhooksIdentificationDataIdOneOf = WebhooksIdentificationDataIdOneOf;
  type bookingsV2Booking_universal_d_WebhookIdentityType = WebhookIdentityType;
  const bookingsV2Booking_universal_d_WebhookIdentityType: typeof WebhookIdentityType;
  type bookingsV2Booking_universal_d_BookingChanged = BookingChanged;
  type bookingsV2Booking_universal_d_CreateBookingRequest = CreateBookingRequest;
  type bookingsV2Booking_universal_d_CreateBookingResponse = CreateBookingResponse;
  type bookingsV2Booking_universal_d_UpdateBookingRequest = UpdateBookingRequest;
  type bookingsV2Booking_universal_d_UpdateBookingResponse = UpdateBookingResponse;
  type bookingsV2Booking_universal_d_LegacyCreateBookingRequest = LegacyCreateBookingRequest;
  type bookingsV2Booking_universal_d_LegacyCreateBookingResponse = LegacyCreateBookingResponse;
  type bookingsV2Booking_universal_d_BulkUpdateBookingRequest = BulkUpdateBookingRequest;
  type bookingsV2Booking_universal_d_MaskedBooking = MaskedBooking;
  type bookingsV2Booking_universal_d_BulkUpdateBookingResponse = BulkUpdateBookingResponse;
  type bookingsV2Booking_universal_d_BulkCreateBookingRequest = BulkCreateBookingRequest;
  type bookingsV2Booking_universal_d_CreateBookingInfo = CreateBookingInfo;
  type bookingsV2Booking_universal_d_BulkCreateBookingResponse = BulkCreateBookingResponse;
  type bookingsV2Booking_universal_d_BulkBookingResult = BulkBookingResult;
  type bookingsV2Booking_universal_d_RescheduleBookingRequest = RescheduleBookingRequest;
  type bookingsV2Booking_universal_d_RescheduleBookingRequestParticipantsInfoOneOf = RescheduleBookingRequestParticipantsInfoOneOf;
  type bookingsV2Booking_universal_d_RescheduleBookingResponse = RescheduleBookingResponse;
  type bookingsV2Booking_universal_d_BulkRescheduleBookingRequest = BulkRescheduleBookingRequest;
  type bookingsV2Booking_universal_d_BulkRescheduleBookingRequestBooking = BulkRescheduleBookingRequestBooking;
  type bookingsV2Booking_universal_d_SlotBookings = SlotBookings;
  type bookingsV2Booking_universal_d_BulkRescheduleBookingResponse = BulkRescheduleBookingResponse;
  type bookingsV2Booking_universal_d_BulkUpdateBookedScheduleRequest = BulkUpdateBookedScheduleRequest;
  type bookingsV2Booking_universal_d_BookingDetails = BookingDetails;
  type bookingsV2Booking_universal_d_BulkUpdateBookedScheduleResponse = BulkUpdateBookedScheduleResponse;
  type bookingsV2Booking_universal_d_QueryBookingsRequest = QueryBookingsRequest;
  type bookingsV2Booking_universal_d_QueryV2 = QueryV2;
  type bookingsV2Booking_universal_d_QueryV2PagingMethodOneOf = QueryV2PagingMethodOneOf;
  type bookingsV2Booking_universal_d_Sorting = Sorting;
  type bookingsV2Booking_universal_d_SortOrder = SortOrder;
  const bookingsV2Booking_universal_d_SortOrder: typeof SortOrder;
  type bookingsV2Booking_universal_d_Paging = Paging;
  type bookingsV2Booking_universal_d_CursorPaging = CursorPaging;
  type bookingsV2Booking_universal_d_QueryBookingsResponse = QueryBookingsResponse;
  type bookingsV2Booking_universal_d_PagingMetadataV2 = PagingMetadataV2;
  type bookingsV2Booking_universal_d_Cursors = Cursors;
  type bookingsV2Booking_universal_d_ConfirmRequest = ConfirmRequest;
  type bookingsV2Booking_universal_d_ConfirmResponse = ConfirmResponse;
  type bookingsV2Booking_universal_d_ConfirmBookingRequest = ConfirmBookingRequest;
  type bookingsV2Booking_universal_d_ConfirmBookingResponse = ConfirmBookingResponse;
  type bookingsV2Booking_universal_d_PartySizeRequest = PartySizeRequest;
  type bookingsV2Booking_universal_d_PartySizeRequestPartySizeForOneOf = PartySizeRequestPartySizeForOneOf;
  type bookingsV2Booking_universal_d_PartySizeResponse = PartySizeResponse;
  type bookingsV2Booking_universal_d_ConsistentQueryBookingsRequest = ConsistentQueryBookingsRequest;
  type bookingsV2Booking_universal_d_ConsistentQueryBookingsResponse = ConsistentQueryBookingsResponse;
  type bookingsV2Booking_universal_d_SetBookingSessionIdRequest = SetBookingSessionIdRequest;
  type bookingsV2Booking_universal_d_SetBookingSessionIdResponse = SetBookingSessionIdResponse;
  type bookingsV2Booking_universal_d_UpdateExtendedFieldsRequest = UpdateExtendedFieldsRequest;
  type bookingsV2Booking_universal_d_UpdateExtendedFieldsResponse = UpdateExtendedFieldsResponse;
  type bookingsV2Booking_universal_d_DeclineBookingRequest = DeclineBookingRequest;
  type bookingsV2Booking_universal_d_DeclineBookingResponse = DeclineBookingResponse;
  type bookingsV2Booking_universal_d_CancelBookingRequest = CancelBookingRequest;
  type bookingsV2Booking_universal_d_CancelBookingResponse = CancelBookingResponse;
  type bookingsV2Booking_universal_d_UpdateNumberOfParticipantsRequest = UpdateNumberOfParticipantsRequest;
  type bookingsV2Booking_universal_d_UpdateNumberOfParticipantsRequestParticipantsInfoOneOf = UpdateNumberOfParticipantsRequestParticipantsInfoOneOf;
  type bookingsV2Booking_universal_d_UpdateNumberOfParticipantsResponse = UpdateNumberOfParticipantsResponse;
  type bookingsV2Booking_universal_d_NumberOfParticipantsUpdated = NumberOfParticipantsUpdated;
  type bookingsV2Booking_universal_d_NumberOfParticipantsUpdatedPreviousParticipantsInfoOneOf = NumberOfParticipantsUpdatedPreviousParticipantsInfoOneOf;
  type bookingsV2Booking_universal_d_CalculateAllowedActionsRequest = CalculateAllowedActionsRequest;
  type bookingsV2Booking_universal_d_CalculateAllowedActionsResponse = CalculateAllowedActionsResponse;
  type bookingsV2Booking_universal_d_BulkCalculateAllowedActionsRequest = BulkCalculateAllowedActionsRequest;
  type bookingsV2Booking_universal_d_BulkCalculateAllowedActionsResponse = BulkCalculateAllowedActionsResponse;
  type bookingsV2Booking_universal_d_GetSlotAvailabilityRequest = GetSlotAvailabilityRequest;
  type bookingsV2Booking_universal_d_GetSlotAvailabilityResponse = GetSlotAvailabilityResponse;
  type bookingsV2Booking_universal_d_SlotAvailability = SlotAvailability;
  type bookingsV2Booking_universal_d_WaitingList = WaitingList;
  type bookingsV2Booking_universal_d_AvailableResources = AvailableResources;
  type bookingsV2Booking_universal_d_GetScheduleAvailabilityRequest = GetScheduleAvailabilityRequest;
  type bookingsV2Booking_universal_d_GetScheduleAvailabilityResponse = GetScheduleAvailabilityResponse;
  type bookingsV2Booking_universal_d_ScheduleAvailability = ScheduleAvailability;
  type bookingsV2Booking_universal_d_MarkBookingAsPendingRequest = MarkBookingAsPendingRequest;
  type bookingsV2Booking_universal_d_MarkBookingAsPendingResponse = MarkBookingAsPendingResponse;
  type bookingsV2Booking_universal_d_BookingMarkedAsPending = BookingMarkedAsPending;
  type bookingsV2Booking_universal_d_MigrationCheckIfClashesWithBlockedTimeRequest = MigrationCheckIfClashesWithBlockedTimeRequest;
  type bookingsV2Booking_universal_d_MsidAndBookingId = MsidAndBookingId;
  type bookingsV2Booking_universal_d_MigrationCheckIfClashesWithBlockedTimeResponse = MigrationCheckIfClashesWithBlockedTimeResponse;
  type bookingsV2Booking_universal_d_Clash = Clash;
  type bookingsV2Booking_universal_d_ConfirmOrDeclineBookingRequest = ConfirmOrDeclineBookingRequest;
  type bookingsV2Booking_universal_d_ConfirmOrDeclineBookingResponse = ConfirmOrDeclineBookingResponse;
  type bookingsV2Booking_universal_d_BulkConfirmOrDeclineBookingRequest = BulkConfirmOrDeclineBookingRequest;
  type bookingsV2Booking_universal_d_BulkConfirmOrDeclineBookingRequestBookingDetails = BulkConfirmOrDeclineBookingRequestBookingDetails;
  type bookingsV2Booking_universal_d_BulkConfirmOrDeclineBookingResponse = BulkConfirmOrDeclineBookingResponse;
  type bookingsV2Booking_universal_d_V2CreateBookingRequest = V2CreateBookingRequest;
  type bookingsV2Booking_universal_d_V2CreateBookingRequestBookableItemOneOf = V2CreateBookingRequestBookableItemOneOf;
  type bookingsV2Booking_universal_d_V2CreateBookingRequestParticipantsInfoOneOf = V2CreateBookingRequestParticipantsInfoOneOf;
  type bookingsV2Booking_universal_d_Slot = Slot;
  type bookingsV2Booking_universal_d_SlotResource = SlotResource;
  type bookingsV2Booking_universal_d_CreateBookingRequestFlowControlSettings = CreateBookingRequestFlowControlSettings;
  type bookingsV2Booking_universal_d_V2CreateBookingResponse = V2CreateBookingResponse;
  type bookingsV2Booking_universal_d_V2CancelBookingRequest = V2CancelBookingRequest;
  type bookingsV2Booking_universal_d_V2CancelBookingRequestFlowControlSettings = V2CancelBookingRequestFlowControlSettings;
  type bookingsV2Booking_universal_d_V2CancelBookingResponse = V2CancelBookingResponse;
  type bookingsV2Booking_universal_d_V2RescheduleBookingRequest = V2RescheduleBookingRequest;
  type bookingsV2Booking_universal_d_V2RescheduleBookingRequestParticipantsInfoOneOf = V2RescheduleBookingRequestParticipantsInfoOneOf;
  type bookingsV2Booking_universal_d_V2RescheduleBookingRequestFlowControlSettings = V2RescheduleBookingRequestFlowControlSettings;
  type bookingsV2Booking_universal_d_V2RescheduleBookingResponse = V2RescheduleBookingResponse;
  type bookingsV2Booking_universal_d_V2ConfirmBookingRequest = V2ConfirmBookingRequest;
  type bookingsV2Booking_universal_d_V2ConfirmBookingResponse = V2ConfirmBookingResponse;
  type bookingsV2Booking_universal_d_V2DeclineBookingRequest = V2DeclineBookingRequest;
  type bookingsV2Booking_universal_d_V2DeclineBookingResponse = V2DeclineBookingResponse;
  type bookingsV2Booking_universal_d_V2UpdateNumberOfParticipantsRequest = V2UpdateNumberOfParticipantsRequest;
  type bookingsV2Booking_universal_d_V2UpdateNumberOfParticipantsRequestParticipantsInfoOneOf = V2UpdateNumberOfParticipantsRequestParticipantsInfoOneOf;
  type bookingsV2Booking_universal_d_V2UpdateNumberOfParticipantsResponse = V2UpdateNumberOfParticipantsResponse;
  const bookingsV2Booking_universal_d_createMultiServiceBooking: typeof createMultiServiceBooking;
  type bookingsV2Booking_universal_d_CreateMultiServiceBookingOptions = CreateMultiServiceBookingOptions;
  const bookingsV2Booking_universal_d_rescheduleMultiServiceBooking: typeof rescheduleMultiServiceBooking;
  type bookingsV2Booking_universal_d_RescheduleMultiServiceBookingOptions = RescheduleMultiServiceBookingOptions;
  const bookingsV2Booking_universal_d_getMultiServiceBookingAvailability: typeof getMultiServiceBookingAvailability;
  const bookingsV2Booking_universal_d_cancelMultiServiceBooking: typeof cancelMultiServiceBooking;
  type bookingsV2Booking_universal_d_CancelMultiServiceBookingOptions = CancelMultiServiceBookingOptions;
  const bookingsV2Booking_universal_d_markMultiServiceBookingAsPending: typeof markMultiServiceBookingAsPending;
  type bookingsV2Booking_universal_d_MarkMultiServiceBookingAsPendingOptions = MarkMultiServiceBookingAsPendingOptions;
  const bookingsV2Booking_universal_d_confirmMultiServiceBooking: typeof confirmMultiServiceBooking;
  type bookingsV2Booking_universal_d_ConfirmMultiServiceBookingOptions = ConfirmMultiServiceBookingOptions;
  const bookingsV2Booking_universal_d_declineMultiServiceBooking: typeof declineMultiServiceBooking;
  type bookingsV2Booking_universal_d_DeclineMultiServiceBookingOptions = DeclineMultiServiceBookingOptions;
  const bookingsV2Booking_universal_d_bulkGetMultiServiceBookingAllowedActions: typeof bulkGetMultiServiceBookingAllowedActions;
  type bookingsV2Booking_universal_d_MarkAsMultiServiceBookingOptions = MarkAsMultiServiceBookingOptions;
  const bookingsV2Booking_universal_d_getMultiServiceBooking: typeof getMultiServiceBooking;
  const bookingsV2Booking_universal_d_addBookingsToMultiServiceBooking: typeof addBookingsToMultiServiceBooking;
  type bookingsV2Booking_universal_d_AddBookingsToMultiServiceBookingOptions = AddBookingsToMultiServiceBookingOptions;
  const bookingsV2Booking_universal_d_removeBookingsFromMultiServiceBooking: typeof removeBookingsFromMultiServiceBooking;
  type bookingsV2Booking_universal_d_RemoveBookingsFromMultiServiceBookingOptions = RemoveBookingsFromMultiServiceBookingOptions;
  const bookingsV2Booking_universal_d_createBooking: typeof createBooking;
  type bookingsV2Booking_universal_d_CreateBookingOptions = CreateBookingOptions;
  const bookingsV2Booking_universal_d_updateBooking: typeof updateBooking;
  type bookingsV2Booking_universal_d_UpdateBooking = UpdateBooking;
  type bookingsV2Booking_universal_d_UpdateBookingOptions = UpdateBookingOptions;
  const bookingsV2Booking_universal_d_legacyCreateBooking: typeof legacyCreateBooking;
  const bookingsV2Booking_universal_d_bulkUpdateBooking: typeof bulkUpdateBooking;
  const bookingsV2Booking_universal_d_bulkCreateBooking: typeof bulkCreateBooking;
  type bookingsV2Booking_universal_d_BulkCreateBookingOptions = BulkCreateBookingOptions;
  const bookingsV2Booking_universal_d_rescheduleBooking: typeof rescheduleBooking;
  type bookingsV2Booking_universal_d_RescheduleBookingOptions = RescheduleBookingOptions;
  const bookingsV2Booking_universal_d_bulkRescheduleBooking: typeof bulkRescheduleBooking;
  type bookingsV2Booking_universal_d_BulkRescheduleBookingOptions = BulkRescheduleBookingOptions;
  const bookingsV2Booking_universal_d_bulkUpdateBookedSchedule: typeof bulkUpdateBookedSchedule;
  type bookingsV2Booking_universal_d_BulkUpdateBookedScheduleOptions = BulkUpdateBookedScheduleOptions;
  const bookingsV2Booking_universal_d_query: typeof query;
  type bookingsV2Booking_universal_d_QueryOptions = QueryOptions;
  const bookingsV2Booking_universal_d_confirmBooking: typeof confirmBooking;
  type bookingsV2Booking_universal_d_ConfirmBookingOptions = ConfirmBookingOptions;
  type bookingsV2Booking_universal_d_PartySizeOptions = PartySizeOptions;
  const bookingsV2Booking_universal_d_consistentQuery: typeof consistentQuery;
  type bookingsV2Booking_universal_d_ConsistentQueryOptions = ConsistentQueryOptions;
  const bookingsV2Booking_universal_d_setBookingSessionId: typeof setBookingSessionId;
  type bookingsV2Booking_universal_d_SetBookingSessionIdOptions = SetBookingSessionIdOptions;
  const bookingsV2Booking_universal_d_updateExtendedFields: typeof updateExtendedFields;
  type bookingsV2Booking_universal_d_UpdateExtendedFieldsOptions = UpdateExtendedFieldsOptions;
  const bookingsV2Booking_universal_d_declineBooking: typeof declineBooking;
  type bookingsV2Booking_universal_d_DeclineBookingOptions = DeclineBookingOptions;
  const bookingsV2Booking_universal_d_cancelBooking: typeof cancelBooking;
  type bookingsV2Booking_universal_d_CancelBookingOptions = CancelBookingOptions;
  const bookingsV2Booking_universal_d_updateNumberOfParticipants: typeof updateNumberOfParticipants;
  type bookingsV2Booking_universal_d_UpdateNumberOfParticipantsOptions = UpdateNumberOfParticipantsOptions;
  const bookingsV2Booking_universal_d_bulkCalculateAllowedActions: typeof bulkCalculateAllowedActions;
  const bookingsV2Booking_universal_d_getSlotAvailability: typeof getSlotAvailability;
  type bookingsV2Booking_universal_d_GetSlotAvailabilityOptions = GetSlotAvailabilityOptions;
  const bookingsV2Booking_universal_d_getScheduleAvailability: typeof getScheduleAvailability;
  const bookingsV2Booking_universal_d_markBookingAsPending: typeof markBookingAsPending;
  type bookingsV2Booking_universal_d_MarkBookingAsPendingOptions = MarkBookingAsPendingOptions;
  const bookingsV2Booking_universal_d_confirmOrDeclineBooking: typeof confirmOrDeclineBooking;
  type bookingsV2Booking_universal_d_ConfirmOrDeclineBookingOptions = ConfirmOrDeclineBookingOptions;
  const bookingsV2Booking_universal_d_bulkConfirmOrDeclineBooking: typeof bulkConfirmOrDeclineBooking;
  type bookingsV2Booking_universal_d_BulkConfirmOrDeclineBookingOptions = BulkConfirmOrDeclineBookingOptions;
  const bookingsV2Booking_universal_d_bookingsGatewayCreateBooking: typeof bookingsGatewayCreateBooking;
  type bookingsV2Booking_universal_d_BookingsGatewayCreateBookingOptions = BookingsGatewayCreateBookingOptions;
  const bookingsV2Booking_universal_d_bookingsGatewayCancelBooking: typeof bookingsGatewayCancelBooking;
  type bookingsV2Booking_universal_d_BookingsGatewayCancelBookingOptions = BookingsGatewayCancelBookingOptions;
  const bookingsV2Booking_universal_d_bookingsGatewayRescheduleBooking: typeof bookingsGatewayRescheduleBooking;
  type bookingsV2Booking_universal_d_BookingsGatewayRescheduleBookingOptions = BookingsGatewayRescheduleBookingOptions;
  const bookingsV2Booking_universal_d_bookingsGatewayConfirmBooking: typeof bookingsGatewayConfirmBooking;
  type bookingsV2Booking_universal_d_BookingsGatewayConfirmBookingOptions = BookingsGatewayConfirmBookingOptions;
  const bookingsV2Booking_universal_d_bookingsGatewayDeclineBooking: typeof bookingsGatewayDeclineBooking;
  type bookingsV2Booking_universal_d_BookingsGatewayDeclineBookingOptions = BookingsGatewayDeclineBookingOptions;
  const bookingsV2Booking_universal_d_bookingsGatewayUpdateNumberOfParticipants: typeof bookingsGatewayUpdateNumberOfParticipants;
  type bookingsV2Booking_universal_d_BookingsGatewayUpdateNumberOfParticipantsOptions = BookingsGatewayUpdateNumberOfParticipantsOptions;
  namespace bookingsV2Booking_universal_d {
    export {
      Booking$1 as Booking,
      BookingParticipantsInfoOneOf$1 as BookingParticipantsInfoOneOf,
      MultiServiceBookingType$1 as MultiServiceBookingType,
      BookedEntity$1 as BookedEntity,
      BookedEntityItemOneOf$1 as BookedEntityItemOneOf,
      BookedSlot$1 as BookedSlot,
      BookedResource$1 as BookedResource,
      Location$1 as Location,
      LocationType$1 as LocationType,
      BookedSchedule$1 as BookedSchedule,
      ContactDetails$1 as ContactDetails,
      Address$1 as Address,
      AddressStreetOneOf$1 as AddressStreetOneOf,
      StreetAddress$1 as StreetAddress,
      AddressLocation$1 as AddressLocation,
      Subdivision$1 as Subdivision,
      CustomFormField$1 as CustomFormField,
      ValueType$1 as ValueType,
      BookingStatus$1 as BookingStatus,
      PaymentStatus$1 as PaymentStatus,
      SelectedPaymentOption$1 as SelectedPaymentOption,
      BookingSource$1 as BookingSource,
      Platform$1 as Platform,
      Actor$1 as Actor,
      ParticipantNotification$1 as ParticipantNotification,
      bookingsV2Booking_universal_d_CommonIdentificationData as CommonIdentificationData,
      bookingsV2Booking_universal_d_CommonIdentificationDataIdOneOf as CommonIdentificationDataIdOneOf,
      bookingsV2Booking_universal_d_IdentificationDataIdentityType as IdentificationDataIdentityType,
      FlowControlSettings$1 as FlowControlSettings,
      ExtendedFields$1 as ExtendedFields,
      ParticipantChoices$1 as ParticipantChoices,
      ServiceChoices$1 as ServiceChoices,
      ServiceChoice$1 as ServiceChoice,
      ServiceChoiceChoiceOneOf$1 as ServiceChoiceChoiceOneOf,
      MultiServiceBookingInfo$1 as MultiServiceBookingInfo,
      bookingsV2Booking_universal_d_CreateMultiServiceBookingRequest as CreateMultiServiceBookingRequest,
      bookingsV2Booking_universal_d_CreateBookingFlowControlSettings as CreateBookingFlowControlSettings,
      bookingsV2Booking_universal_d_CreateMultiServiceBookingResponse as CreateMultiServiceBookingResponse,
      bookingsV2Booking_universal_d_MultiServiceBooking as MultiServiceBooking,
      bookingsV2Booking_universal_d_BookingResult as BookingResult,
      bookingsV2Booking_universal_d_RescheduleMultiServiceBookingRequest as RescheduleMultiServiceBookingRequest,
      bookingsV2Booking_universal_d_V2Slot as V2Slot,
      bookingsV2Booking_universal_d_LocationLocationType as LocationLocationType,
      bookingsV2Booking_universal_d_SlotSlotResource as SlotSlotResource,
      bookingsV2Booking_universal_d_SlotLocation as SlotLocation,
      bookingsV2Booking_universal_d_RescheduleMultiServiceBookingRequestRescheduleBookingInfo as RescheduleMultiServiceBookingRequestRescheduleBookingInfo,
      bookingsV2Booking_universal_d_RescheduleMultiServiceBookingRequestRescheduleBookingInfoParticipantsInfoOneOf as RescheduleMultiServiceBookingRequestRescheduleBookingInfoParticipantsInfoOneOf,
      bookingsV2Booking_universal_d_RescheduleBookingFlowControlSettings as RescheduleBookingFlowControlSettings,
      bookingsV2Booking_universal_d_RescheduleMultiServiceBookingResponse as RescheduleMultiServiceBookingResponse,
      bookingsV2Booking_universal_d_BookingRescheduled as BookingRescheduled,
      bookingsV2Booking_universal_d_BookingRescheduledPreviousParticipantsInfoOneOf as BookingRescheduledPreviousParticipantsInfoOneOf,
      IdentificationData$1 as IdentificationData,
      IdentificationDataIdOneOf$1 as IdentificationDataIdOneOf,
      IdentityType$1 as IdentityType,
      bookingsV2Booking_universal_d_GetMultiServiceBookingAvailabilityRequest as GetMultiServiceBookingAvailabilityRequest,
      bookingsV2Booking_universal_d_GetMultiServiceBookingAvailabilityResponse as GetMultiServiceBookingAvailabilityResponse,
      bookingsV2Booking_universal_d_BookingPolicyViolations as BookingPolicyViolations,
      bookingsV2Booking_universal_d_BookingPolicySettings as BookingPolicySettings,
      bookingsV2Booking_universal_d_GetMultiServiceBookingAvailabilityResponseBookingInfo as GetMultiServiceBookingAvailabilityResponseBookingInfo,
      bookingsV2Booking_universal_d_CancelMultiServiceBookingRequest as CancelMultiServiceBookingRequest,
      bookingsV2Booking_universal_d_CancelBookingFlowControlSettings as CancelBookingFlowControlSettings,
      bookingsV2Booking_universal_d_CancelMultiServiceBookingResponse as CancelMultiServiceBookingResponse,
      bookingsV2Booking_universal_d_BookingCanceled as BookingCanceled,
      bookingsV2Booking_universal_d_MarkMultiServiceBookingAsPendingRequest as MarkMultiServiceBookingAsPendingRequest,
      bookingsV2Booking_universal_d_BookingInfo as BookingInfo,
      bookingsV2Booking_universal_d_MarkBookingAsPendingFlowControlSettings as MarkBookingAsPendingFlowControlSettings,
      bookingsV2Booking_universal_d_MarkMultiServiceBookingAsPendingResponse as MarkMultiServiceBookingAsPendingResponse,
      bookingsV2Booking_universal_d_ConfirmMultiServiceBookingRequest as ConfirmMultiServiceBookingRequest,
      bookingsV2Booking_universal_d_ConfirmBookingFlowControlSettings as ConfirmBookingFlowControlSettings,
      bookingsV2Booking_universal_d_ConfirmMultiServiceBookingResponse as ConfirmMultiServiceBookingResponse,
      bookingsV2Booking_universal_d_BookingConfirmed as BookingConfirmed,
      bookingsV2Booking_universal_d_DeclineMultiServiceBookingRequest as DeclineMultiServiceBookingRequest,
      bookingsV2Booking_universal_d_DeclineBookingFlowControlSettings as DeclineBookingFlowControlSettings,
      bookingsV2Booking_universal_d_DeclineMultiServiceBookingResponse as DeclineMultiServiceBookingResponse,
      bookingsV2Booking_universal_d_BookingDeclined as BookingDeclined,
      bookingsV2Booking_universal_d_BulkGetMultiServiceBookingAllowedActionsRequest as BulkGetMultiServiceBookingAllowedActionsRequest,
      bookingsV2Booking_universal_d_BulkGetMultiServiceBookingAllowedActionsResponse as BulkGetMultiServiceBookingAllowedActionsResponse,
      bookingsV2Booking_universal_d_BulkCalculateAllowedActionsResult as BulkCalculateAllowedActionsResult,
      bookingsV2Booking_universal_d_ItemMetadata as ItemMetadata,
      bookingsV2Booking_universal_d_ApplicationError as ApplicationError,
      bookingsV2Booking_universal_d_AllowedActions as AllowedActions,
      bookingsV2Booking_universal_d_BulkActionMetadata as BulkActionMetadata,
      bookingsV2Booking_universal_d_MarkAsMultiServiceBookingRequest as MarkAsMultiServiceBookingRequest,
      bookingsV2Booking_universal_d_MarkAsMultiServiceBookingResponse as MarkAsMultiServiceBookingResponse,
      bookingsV2Booking_universal_d_GetMultiServiceBookingRequest as GetMultiServiceBookingRequest,
      bookingsV2Booking_universal_d_GetMultiServiceBookingResponse as GetMultiServiceBookingResponse,
      bookingsV2Booking_universal_d_MultiServiceBookingMetadata as MultiServiceBookingMetadata,
      bookingsV2Booking_universal_d_AddBookingsToMultiServiceBookingRequest as AddBookingsToMultiServiceBookingRequest,
      bookingsV2Booking_universal_d_BookingIdAndRevision as BookingIdAndRevision,
      bookingsV2Booking_universal_d_AddBookingsToMultiServiceBookingResponse as AddBookingsToMultiServiceBookingResponse,
      bookingsV2Booking_universal_d_RemoveBookingsFromMultiServiceBookingRequest as RemoveBookingsFromMultiServiceBookingRequest,
      bookingsV2Booking_universal_d_RemoveBookingsFromMultiServiceBookingResponse as RemoveBookingsFromMultiServiceBookingResponse,
      bookingsV2Booking_universal_d_DomainEvent as DomainEvent,
      bookingsV2Booking_universal_d_DomainEventBodyOneOf as DomainEventBodyOneOf,
      bookingsV2Booking_universal_d_EntityCreatedEvent as EntityCreatedEvent,
      bookingsV2Booking_universal_d_RestoreInfo as RestoreInfo,
      bookingsV2Booking_universal_d_EntityUpdatedEvent as EntityUpdatedEvent,
      bookingsV2Booking_universal_d_EntityDeletedEvent as EntityDeletedEvent,
      bookingsV2Booking_universal_d_ActionEvent as ActionEvent,
      bookingsV2Booking_universal_d_MessageEnvelope as MessageEnvelope,
      bookingsV2Booking_universal_d_WebhooksIdentificationData as WebhooksIdentificationData,
      bookingsV2Booking_universal_d_WebhooksIdentificationDataIdOneOf as WebhooksIdentificationDataIdOneOf,
      bookingsV2Booking_universal_d_WebhookIdentityType as WebhookIdentityType,
      bookingsV2Booking_universal_d_BookingChanged as BookingChanged,
      bookingsV2Booking_universal_d_CreateBookingRequest as CreateBookingRequest,
      bookingsV2Booking_universal_d_CreateBookingResponse as CreateBookingResponse,
      bookingsV2Booking_universal_d_UpdateBookingRequest as UpdateBookingRequest,
      bookingsV2Booking_universal_d_UpdateBookingResponse as UpdateBookingResponse,
      bookingsV2Booking_universal_d_LegacyCreateBookingRequest as LegacyCreateBookingRequest,
      bookingsV2Booking_universal_d_LegacyCreateBookingResponse as LegacyCreateBookingResponse,
      bookingsV2Booking_universal_d_BulkUpdateBookingRequest as BulkUpdateBookingRequest,
      bookingsV2Booking_universal_d_MaskedBooking as MaskedBooking,
      bookingsV2Booking_universal_d_BulkUpdateBookingResponse as BulkUpdateBookingResponse,
      bookingsV2Booking_universal_d_BulkCreateBookingRequest as BulkCreateBookingRequest,
      bookingsV2Booking_universal_d_CreateBookingInfo as CreateBookingInfo,
      bookingsV2Booking_universal_d_BulkCreateBookingResponse as BulkCreateBookingResponse,
      bookingsV2Booking_universal_d_BulkBookingResult as BulkBookingResult,
      bookingsV2Booking_universal_d_RescheduleBookingRequest as RescheduleBookingRequest,
      bookingsV2Booking_universal_d_RescheduleBookingRequestParticipantsInfoOneOf as RescheduleBookingRequestParticipantsInfoOneOf,
      bookingsV2Booking_universal_d_RescheduleBookingResponse as RescheduleBookingResponse,
      bookingsV2Booking_universal_d_BulkRescheduleBookingRequest as BulkRescheduleBookingRequest,
      bookingsV2Booking_universal_d_BulkRescheduleBookingRequestBooking as BulkRescheduleBookingRequestBooking,
      bookingsV2Booking_universal_d_SlotBookings as SlotBookings,
      bookingsV2Booking_universal_d_BulkRescheduleBookingResponse as BulkRescheduleBookingResponse,
      bookingsV2Booking_universal_d_BulkUpdateBookedScheduleRequest as BulkUpdateBookedScheduleRequest,
      bookingsV2Booking_universal_d_BookingDetails as BookingDetails,
      bookingsV2Booking_universal_d_BulkUpdateBookedScheduleResponse as BulkUpdateBookedScheduleResponse,
      bookingsV2Booking_universal_d_QueryBookingsRequest as QueryBookingsRequest,
      bookingsV2Booking_universal_d_QueryV2 as QueryV2,
      bookingsV2Booking_universal_d_QueryV2PagingMethodOneOf as QueryV2PagingMethodOneOf,
      bookingsV2Booking_universal_d_Sorting as Sorting,
      bookingsV2Booking_universal_d_SortOrder as SortOrder,
      bookingsV2Booking_universal_d_Paging as Paging,
      bookingsV2Booking_universal_d_CursorPaging as CursorPaging,
      bookingsV2Booking_universal_d_QueryBookingsResponse as QueryBookingsResponse,
      bookingsV2Booking_universal_d_PagingMetadataV2 as PagingMetadataV2,
      bookingsV2Booking_universal_d_Cursors as Cursors,
      bookingsV2Booking_universal_d_ConfirmRequest as ConfirmRequest,
      bookingsV2Booking_universal_d_ConfirmResponse as ConfirmResponse,
      bookingsV2Booking_universal_d_ConfirmBookingRequest as ConfirmBookingRequest,
      bookingsV2Booking_universal_d_ConfirmBookingResponse as ConfirmBookingResponse,
      bookingsV2Booking_universal_d_PartySizeRequest as PartySizeRequest,
      bookingsV2Booking_universal_d_PartySizeRequestPartySizeForOneOf as PartySizeRequestPartySizeForOneOf,
      bookingsV2Booking_universal_d_PartySizeResponse as PartySizeResponse,
      bookingsV2Booking_universal_d_ConsistentQueryBookingsRequest as ConsistentQueryBookingsRequest,
      bookingsV2Booking_universal_d_ConsistentQueryBookingsResponse as ConsistentQueryBookingsResponse,
      bookingsV2Booking_universal_d_SetBookingSessionIdRequest as SetBookingSessionIdRequest,
      bookingsV2Booking_universal_d_SetBookingSessionIdResponse as SetBookingSessionIdResponse,
      bookingsV2Booking_universal_d_UpdateExtendedFieldsRequest as UpdateExtendedFieldsRequest,
      bookingsV2Booking_universal_d_UpdateExtendedFieldsResponse as UpdateExtendedFieldsResponse,
      bookingsV2Booking_universal_d_DeclineBookingRequest as DeclineBookingRequest,
      bookingsV2Booking_universal_d_DeclineBookingResponse as DeclineBookingResponse,
      bookingsV2Booking_universal_d_CancelBookingRequest as CancelBookingRequest,
      bookingsV2Booking_universal_d_CancelBookingResponse as CancelBookingResponse,
      bookingsV2Booking_universal_d_UpdateNumberOfParticipantsRequest as UpdateNumberOfParticipantsRequest,
      bookingsV2Booking_universal_d_UpdateNumberOfParticipantsRequestParticipantsInfoOneOf as UpdateNumberOfParticipantsRequestParticipantsInfoOneOf,
      bookingsV2Booking_universal_d_UpdateNumberOfParticipantsResponse as UpdateNumberOfParticipantsResponse,
      bookingsV2Booking_universal_d_NumberOfParticipantsUpdated as NumberOfParticipantsUpdated,
      bookingsV2Booking_universal_d_NumberOfParticipantsUpdatedPreviousParticipantsInfoOneOf as NumberOfParticipantsUpdatedPreviousParticipantsInfoOneOf,
      bookingsV2Booking_universal_d_CalculateAllowedActionsRequest as CalculateAllowedActionsRequest,
      bookingsV2Booking_universal_d_CalculateAllowedActionsResponse as CalculateAllowedActionsResponse,
      bookingsV2Booking_universal_d_BulkCalculateAllowedActionsRequest as BulkCalculateAllowedActionsRequest,
      bookingsV2Booking_universal_d_BulkCalculateAllowedActionsResponse as BulkCalculateAllowedActionsResponse,
      bookingsV2Booking_universal_d_GetSlotAvailabilityRequest as GetSlotAvailabilityRequest,
      bookingsV2Booking_universal_d_GetSlotAvailabilityResponse as GetSlotAvailabilityResponse,
      bookingsV2Booking_universal_d_SlotAvailability as SlotAvailability,
      bookingsV2Booking_universal_d_WaitingList as WaitingList,
      bookingsV2Booking_universal_d_AvailableResources as AvailableResources,
      bookingsV2Booking_universal_d_GetScheduleAvailabilityRequest as GetScheduleAvailabilityRequest,
      bookingsV2Booking_universal_d_GetScheduleAvailabilityResponse as GetScheduleAvailabilityResponse,
      bookingsV2Booking_universal_d_ScheduleAvailability as ScheduleAvailability,
      bookingsV2Booking_universal_d_MarkBookingAsPendingRequest as MarkBookingAsPendingRequest,
      bookingsV2Booking_universal_d_MarkBookingAsPendingResponse as MarkBookingAsPendingResponse,
      bookingsV2Booking_universal_d_BookingMarkedAsPending as BookingMarkedAsPending,
      bookingsV2Booking_universal_d_MigrationCheckIfClashesWithBlockedTimeRequest as MigrationCheckIfClashesWithBlockedTimeRequest,
      bookingsV2Booking_universal_d_MsidAndBookingId as MsidAndBookingId,
      bookingsV2Booking_universal_d_MigrationCheckIfClashesWithBlockedTimeResponse as MigrationCheckIfClashesWithBlockedTimeResponse,
      bookingsV2Booking_universal_d_Clash as Clash,
      bookingsV2Booking_universal_d_ConfirmOrDeclineBookingRequest as ConfirmOrDeclineBookingRequest,
      bookingsV2Booking_universal_d_ConfirmOrDeclineBookingResponse as ConfirmOrDeclineBookingResponse,
      bookingsV2Booking_universal_d_BulkConfirmOrDeclineBookingRequest as BulkConfirmOrDeclineBookingRequest,
      bookingsV2Booking_universal_d_BulkConfirmOrDeclineBookingRequestBookingDetails as BulkConfirmOrDeclineBookingRequestBookingDetails,
      bookingsV2Booking_universal_d_BulkConfirmOrDeclineBookingResponse as BulkConfirmOrDeclineBookingResponse,
      bookingsV2Booking_universal_d_V2CreateBookingRequest as V2CreateBookingRequest,
      bookingsV2Booking_universal_d_V2CreateBookingRequestBookableItemOneOf as V2CreateBookingRequestBookableItemOneOf,
      bookingsV2Booking_universal_d_V2CreateBookingRequestParticipantsInfoOneOf as V2CreateBookingRequestParticipantsInfoOneOf,
      bookingsV2Booking_universal_d_Slot as Slot,
      bookingsV2Booking_universal_d_SlotResource as SlotResource,
      bookingsV2Booking_universal_d_CreateBookingRequestFlowControlSettings as CreateBookingRequestFlowControlSettings,
      bookingsV2Booking_universal_d_V2CreateBookingResponse as V2CreateBookingResponse,
      bookingsV2Booking_universal_d_V2CancelBookingRequest as V2CancelBookingRequest,
      bookingsV2Booking_universal_d_V2CancelBookingRequestFlowControlSettings as V2CancelBookingRequestFlowControlSettings,
      bookingsV2Booking_universal_d_V2CancelBookingResponse as V2CancelBookingResponse,
      bookingsV2Booking_universal_d_V2RescheduleBookingRequest as V2RescheduleBookingRequest,
      bookingsV2Booking_universal_d_V2RescheduleBookingRequestParticipantsInfoOneOf as V2RescheduleBookingRequestParticipantsInfoOneOf,
      bookingsV2Booking_universal_d_V2RescheduleBookingRequestFlowControlSettings as V2RescheduleBookingRequestFlowControlSettings,
      bookingsV2Booking_universal_d_V2RescheduleBookingResponse as V2RescheduleBookingResponse,
      bookingsV2Booking_universal_d_V2ConfirmBookingRequest as V2ConfirmBookingRequest,
      bookingsV2Booking_universal_d_V2ConfirmBookingResponse as V2ConfirmBookingResponse,
      bookingsV2Booking_universal_d_V2DeclineBookingRequest as V2DeclineBookingRequest,
      bookingsV2Booking_universal_d_V2DeclineBookingResponse as V2DeclineBookingResponse,
      bookingsV2Booking_universal_d_V2UpdateNumberOfParticipantsRequest as V2UpdateNumberOfParticipantsRequest,
      bookingsV2Booking_universal_d_V2UpdateNumberOfParticipantsRequestParticipantsInfoOneOf as V2UpdateNumberOfParticipantsRequestParticipantsInfoOneOf,
      bookingsV2Booking_universal_d_V2UpdateNumberOfParticipantsResponse as V2UpdateNumberOfParticipantsResponse,
      bookingsV2Booking_universal_d_createMultiServiceBooking as createMultiServiceBooking,
      bookingsV2Booking_universal_d_CreateMultiServiceBookingOptions as CreateMultiServiceBookingOptions,
      bookingsV2Booking_universal_d_rescheduleMultiServiceBooking as rescheduleMultiServiceBooking,
      bookingsV2Booking_universal_d_RescheduleMultiServiceBookingOptions as RescheduleMultiServiceBookingOptions,
      bookingsV2Booking_universal_d_getMultiServiceBookingAvailability as getMultiServiceBookingAvailability,
      bookingsV2Booking_universal_d_cancelMultiServiceBooking as cancelMultiServiceBooking,
      bookingsV2Booking_universal_d_CancelMultiServiceBookingOptions as CancelMultiServiceBookingOptions,
      bookingsV2Booking_universal_d_markMultiServiceBookingAsPending as markMultiServiceBookingAsPending,
      bookingsV2Booking_universal_d_MarkMultiServiceBookingAsPendingOptions as MarkMultiServiceBookingAsPendingOptions,
      bookingsV2Booking_universal_d_confirmMultiServiceBooking as confirmMultiServiceBooking,
      bookingsV2Booking_universal_d_ConfirmMultiServiceBookingOptions as ConfirmMultiServiceBookingOptions,
      bookingsV2Booking_universal_d_declineMultiServiceBooking as declineMultiServiceBooking,
      bookingsV2Booking_universal_d_DeclineMultiServiceBookingOptions as DeclineMultiServiceBookingOptions,
      bookingsV2Booking_universal_d_bulkGetMultiServiceBookingAllowedActions as bulkGetMultiServiceBookingAllowedActions,
      bookingsV2Booking_universal_d_MarkAsMultiServiceBookingOptions as MarkAsMultiServiceBookingOptions,
      bookingsV2Booking_universal_d_getMultiServiceBooking as getMultiServiceBooking,
      bookingsV2Booking_universal_d_addBookingsToMultiServiceBooking as addBookingsToMultiServiceBooking,
      bookingsV2Booking_universal_d_AddBookingsToMultiServiceBookingOptions as AddBookingsToMultiServiceBookingOptions,
      bookingsV2Booking_universal_d_removeBookingsFromMultiServiceBooking as removeBookingsFromMultiServiceBooking,
      bookingsV2Booking_universal_d_RemoveBookingsFromMultiServiceBookingOptions as RemoveBookingsFromMultiServiceBookingOptions,
      bookingsV2Booking_universal_d_createBooking as createBooking,
      bookingsV2Booking_universal_d_CreateBookingOptions as CreateBookingOptions,
      bookingsV2Booking_universal_d_updateBooking as updateBooking,
      bookingsV2Booking_universal_d_UpdateBooking as UpdateBooking,
      bookingsV2Booking_universal_d_UpdateBookingOptions as UpdateBookingOptions,
      bookingsV2Booking_universal_d_legacyCreateBooking as legacyCreateBooking,
      bookingsV2Booking_universal_d_bulkUpdateBooking as bulkUpdateBooking,
      bookingsV2Booking_universal_d_bulkCreateBooking as bulkCreateBooking,
      bookingsV2Booking_universal_d_BulkCreateBookingOptions as BulkCreateBookingOptions,
      bookingsV2Booking_universal_d_rescheduleBooking as rescheduleBooking,
      bookingsV2Booking_universal_d_RescheduleBookingOptions as RescheduleBookingOptions,
      bookingsV2Booking_universal_d_bulkRescheduleBooking as bulkRescheduleBooking,
      bookingsV2Booking_universal_d_BulkRescheduleBookingOptions as BulkRescheduleBookingOptions,
      bookingsV2Booking_universal_d_bulkUpdateBookedSchedule as bulkUpdateBookedSchedule,
      bookingsV2Booking_universal_d_BulkUpdateBookedScheduleOptions as BulkUpdateBookedScheduleOptions,
      bookingsV2Booking_universal_d_query as query,
      bookingsV2Booking_universal_d_QueryOptions as QueryOptions,
      bookingsV2Booking_universal_d_confirmBooking as confirmBooking,
      bookingsV2Booking_universal_d_ConfirmBookingOptions as ConfirmBookingOptions,
      bookingsV2Booking_universal_d_PartySizeOptions as PartySizeOptions,
      bookingsV2Booking_universal_d_consistentQuery as consistentQuery,
      bookingsV2Booking_universal_d_ConsistentQueryOptions as ConsistentQueryOptions,
      bookingsV2Booking_universal_d_setBookingSessionId as setBookingSessionId,
      bookingsV2Booking_universal_d_SetBookingSessionIdOptions as SetBookingSessionIdOptions,
      bookingsV2Booking_universal_d_updateExtendedFields as updateExtendedFields,
      bookingsV2Booking_universal_d_UpdateExtendedFieldsOptions as UpdateExtendedFieldsOptions,
      bookingsV2Booking_universal_d_declineBooking as declineBooking,
      bookingsV2Booking_universal_d_DeclineBookingOptions as DeclineBookingOptions,
      bookingsV2Booking_universal_d_cancelBooking as cancelBooking,
      bookingsV2Booking_universal_d_CancelBookingOptions as CancelBookingOptions,
      bookingsV2Booking_universal_d_updateNumberOfParticipants as updateNumberOfParticipants,
      bookingsV2Booking_universal_d_UpdateNumberOfParticipantsOptions as UpdateNumberOfParticipantsOptions,
      bookingsV2Booking_universal_d_bulkCalculateAllowedActions as bulkCalculateAllowedActions,
      bookingsV2Booking_universal_d_getSlotAvailability as getSlotAvailability,
      bookingsV2Booking_universal_d_GetSlotAvailabilityOptions as GetSlotAvailabilityOptions,
      bookingsV2Booking_universal_d_getScheduleAvailability as getScheduleAvailability,
      bookingsV2Booking_universal_d_markBookingAsPending as markBookingAsPending,
      bookingsV2Booking_universal_d_MarkBookingAsPendingOptions as MarkBookingAsPendingOptions,
      bookingsV2Booking_universal_d_confirmOrDeclineBooking as confirmOrDeclineBooking,
      bookingsV2Booking_universal_d_ConfirmOrDeclineBookingOptions as ConfirmOrDeclineBookingOptions,
      bookingsV2Booking_universal_d_bulkConfirmOrDeclineBooking as bulkConfirmOrDeclineBooking,
      bookingsV2Booking_universal_d_BulkConfirmOrDeclineBookingOptions as BulkConfirmOrDeclineBookingOptions,
      bookingsV2Booking_universal_d_bookingsGatewayCreateBooking as bookingsGatewayCreateBooking,
      bookingsV2Booking_universal_d_BookingsGatewayCreateBookingOptions as BookingsGatewayCreateBookingOptions,
      bookingsV2Booking_universal_d_bookingsGatewayCancelBooking as bookingsGatewayCancelBooking,
      bookingsV2Booking_universal_d_BookingsGatewayCancelBookingOptions as BookingsGatewayCancelBookingOptions,
      bookingsV2Booking_universal_d_bookingsGatewayRescheduleBooking as bookingsGatewayRescheduleBooking,
      bookingsV2Booking_universal_d_BookingsGatewayRescheduleBookingOptions as BookingsGatewayRescheduleBookingOptions,
      bookingsV2Booking_universal_d_bookingsGatewayConfirmBooking as bookingsGatewayConfirmBooking,
      bookingsV2Booking_universal_d_BookingsGatewayConfirmBookingOptions as BookingsGatewayConfirmBookingOptions,
      bookingsV2Booking_universal_d_bookingsGatewayDeclineBooking as bookingsGatewayDeclineBooking,
      bookingsV2Booking_universal_d_BookingsGatewayDeclineBookingOptions as BookingsGatewayDeclineBookingOptions,
      bookingsV2Booking_universal_d_bookingsGatewayUpdateNumberOfParticipants as bookingsGatewayUpdateNumberOfParticipants,
      bookingsV2Booking_universal_d_BookingsGatewayUpdateNumberOfParticipantsOptions as BookingsGatewayUpdateNumberOfParticipantsOptions,
    };
  }
  
  interface BookingsAppSettings {
      /** @readonly */
      _id?: string | null;
      /** @readonly */
      revision?: string | null;
      /** @readonly */
      _createdDate?: Date | null;
      /** @readonly */
      _updatedDate?: Date | null;
      /**
       * Cart checkout settings
       * @readonly
       */
      cartCheckout?: CartCheckout;
  }
  interface CartCheckout {
      /** Whether the cart checkout feature is enabled */
      enabled?: boolean | null;
  }
  interface GetBookingsAppSettingsRequest {
  }
  interface GetBookingsAppSettingsResponse {
      /** Settings for the Bookings app */
      bookingsAppSettings?: BookingsAppSettings;
  }
  /**
   * Retrieves the settings for the Wix Bookings app
   * @internal
   * @documentationMaturity preview
   * @permissionId BOOKINGS.APP_SETTINGS_READ
   * @adminMethod
   */
  function getBookingsAppSettings(): Promise<GetBookingsAppSettingsResponse>;
  
  type bookingsV2BookingsAppSettings_universal_d_BookingsAppSettings = BookingsAppSettings;
  type bookingsV2BookingsAppSettings_universal_d_CartCheckout = CartCheckout;
  type bookingsV2BookingsAppSettings_universal_d_GetBookingsAppSettingsRequest = GetBookingsAppSettingsRequest;
  type bookingsV2BookingsAppSettings_universal_d_GetBookingsAppSettingsResponse = GetBookingsAppSettingsResponse;
  const bookingsV2BookingsAppSettings_universal_d_getBookingsAppSettings: typeof getBookingsAppSettings;
  namespace bookingsV2BookingsAppSettings_universal_d {
    export {
      bookingsV2BookingsAppSettings_universal_d_BookingsAppSettings as BookingsAppSettings,
      bookingsV2BookingsAppSettings_universal_d_CartCheckout as CartCheckout,
      bookingsV2BookingsAppSettings_universal_d_GetBookingsAppSettingsRequest as GetBookingsAppSettingsRequest,
      bookingsV2BookingsAppSettings_universal_d_GetBookingsAppSettingsResponse as GetBookingsAppSettingsResponse,
      bookingsV2BookingsAppSettings_universal_d_getBookingsAppSettings as getBookingsAppSettings,
    };
  }
  
  interface PriceInfo extends PriceInfoTotalPriceOneOf {
      /**
       * Calculated total price. Available only when the
       * [service](https://dev.wix.com/docs/sdk/backend-modules/bookings/services/get-service)'s
       * price has been set up as a numerical value in the
       * `schedule.rate.labeledPriceOptions` object.
       */
      calculatedPrice?: number;
      /**
       * Description of the total price. __Deprecated.__ Use `priceDescriptionInfo.original` instead.
       * `priceDescription` will be removed on March 31, 2025.
       * @deprecated Description of the total price. Available only when the
       * [service](https://dev.wix.com/api/rest/wix-bookings/services/service/create-service)'s
       * price has been set up as a text value in the
       * [`schedule.rate.priceText`](https://dev.wix.com/api/rest/wix-bookings/schedules-and-sessions/schedule/schedule-object) property.
       * @replacedBy price_description_info.original
       * @targetRemovalDate 2025-01-10
       */
      priceDescription?: string;
      /**
       * Description of the total price. Available only when the [service](https://dev.wix.com/docs/sdk/backend-modules/bookings/services/get-service)'s
       * `payment.rateType` is set to `CUSTOM`.
       */
      priceDescriptionInfo?: PriceDescriptionInfo;
      /** List of line items, including the number of participants and the price per participant. */
      bookingLineItems?: BookingLineItem[];
      /**
       * Total deposit the customer must pay when booking the service.
       *
       * Available when: The service includes a deposit.
       */
      deposit?: number | null;
      /**
       * 3-letter currency code in
       * [ISO-4217 alphabetic](https://en.wikipedia.org/wiki/ISO_4217#Active_codes) format.
       * @internal
       */
      currency?: string | null;
  }
  /** @oneof */
  interface PriceInfoTotalPriceOneOf {
      /**
       * Calculated total price. Available only when the
       * [service](https://dev.wix.com/docs/sdk/backend-modules/bookings/services/get-service)'s
       * price has been set up as a numerical value in
       * `schedule.rate.labeledPriceOptions`.
       *
       */
      calculatedPrice?: number;
      /**
       * Description of the total price. __Deprecated.__ Use `priceDescriptionInfo.original` instead.
       * `priceDescription` will be removed on March 31, 2025.
       * @deprecated Description of the total price. Available only when the
       * [service](https://dev.wix.com/api/rest/wix-bookings/services/service/create-service)'s
       * price has been set up as a text value in the
       * [`schedule.rate.priceText`](https://dev.wix.com/api/rest/wix-bookings/schedules-and-sessions/schedule/schedule-object) property.
       * @replacedBy price_description_info.original
       * @targetRemovalDate 2025-01-10
       */
      priceDescription?: string;
      /**
       * Description of the total price. Available only when the [service](https://dev.wix.com/docs/sdk/backend-modules/bookings/services/get-service)'s
       * `payment.rateType` is set to `CUSTOM`.
       */
      priceDescriptionInfo?: PriceDescriptionInfo;
  }
  interface BookingLineItem {
      /**
       * Service ID.
       *
       * Required when not using Wix Booking's default pricing logic.
       */
      serviceId?: string | null;
      /** Resource ID. Required for services of type appointment or class. */
      resourceId?: string | null;
      /**
       * Custom choices. Choices are specific values for an option the customer can choose to book.
       * For example, the option `ageGroup` may have these choices: `child`, `student`, `adult`, and `senior`.
       * Each choice may have a different price.
       */
      choices?: ServiceChoice[];
      /** Number of participants for the line item. */
      numberOfParticipants?: number | null;
      /**
       * Price per participant for the line item.
       * @readonly
       */
      pricePerParticipant?: number | null;
  }
  interface ServiceChoice extends ServiceChoiceChoiceOneOf {
      /**
       * Value for one of the choices in the `CustomServiceOption.choices` list.
       * Choices are specific values for an option the customer can choose to book. For example,
       * the option `ageGroup` may have these choices: `child`, `student`, `adult`, and `senior`.
       * Each choice may have a different price.
       */
      custom?: string;
      /**
       * ID of the corresponding option for the choice. For example, the choice `child`
       * could correspond to the option `ageGroup`. In this case, `optionId` is the ID
       * for the `ageGroup` option.
       */
      optionId?: string;
  }
  /** @oneof */
  interface ServiceChoiceChoiceOneOf {
      /**
       * Value for one of the choices in the `CustomServiceOption.choices` list.
       * Choices are specific values for an option the customer can choose to book. For example,
       * the option `ageGroup` may have these choices: `child`, `student`, `adult`, and `senior`.
       * Each choice may have a different price.
       */
      custom?: string;
  }
  interface PriceDescriptionInfo {
      /** Price description in the site's [primary language](https://dev.wix.com/docs/sdk/frontend-modules/window/multilingual/site-languages). */
      original?: string;
      /** Translated price description. Available if the customer booked in a language other than the site's [primary language](https://dev.wix.com/docs/sdk/frontend-modules/window/multilingual/site-languages). */
      translated?: string | null;
  }
  interface PreviewPriceRequest {
      /** List of line items to preview the price for. */
      bookingLineItems: BookingLineItem[];
  }
  interface PreviewPriceResponse {
      /** Information about each line item's price and the estimated total price based on the line items. */
      priceInfo?: PriceInfo;
  }
  interface CalculatePriceRequest {
      /** Booking to calculate the price for. */
      booking: Booking;
  }
  /** The booking object, version 2. */
  interface Booking extends BookingParticipantsInfoOneOf {
      /** Total number of participants. Available only when the booking includes a single service variant. */
      totalParticipants?: number;
      /**
       * Information about the booked service choices and participants.
       * Available only when the booking includes multiple service variants.
       */
      participantsChoices?: ParticipantChoices;
      /**
       * Booking ID.
       * @readonly
       */
      _id?: string | null;
      /** An object describing the slot or schedule that was booked. */
      bookedEntity?: BookedEntity;
      /** Contact details of the site visitor or member making the booking. */
      contactDetails?: ContactDetails;
      /** Additional custom fields submitted with the booking form. */
      additionalFields?: CustomFormField[];
      /**
       * Number of participants.
       * @internal
       */
      numberOfParticipants?: number | null;
      /**
       * Internal business note
       * @internal
       * @deprecated
       */
      internalBusinessNote?: string | null;
      /**
       * Booking status.
       * One of:
       * - `"CREATED"` - The booking was created.
       * - `"UPDATED"` - The booking was updated.
       * - `"CONFIRMED"` - The booking was confirmed and appears on the bookings calendar. A booking can be manually confirmed using the [`confirmOrDecline()`](https://www.wix.com/velo/reference/wix-bookings-v2/bookings/confirmordeclinebooking) API. A booking can be automatically confirmed when the following requirements are met:
       *     + The service is configured as automatically confirmed.
       *     + The system invoked the eCommerce checkout API and created an order.
       * - `"CANCELED"` - The booking has been canceled and synced to the bookings calendar.
       * The booking can be canceled using [`cancelBooking()`](https://www.wix.com/velo/reference/wix-bookings-v2/bookings/cancelbooking) API.
       * - `"PENDING"` - The booking is waiting to be confirmed or declined by the owner and the booking is synced to the bookings calendar.
       * Bookings can be manually set as `PENDING` using the `setAsPending()` API, by those with Manage Booking Status permissions scopes.
       * Bookings can be automatically set as `PENDING` when the following requirements are met:
       *     + The service is configured as manually confirmed.
       *     + Invoking the eCommerce checkout API and an order has been created.
       * - `"WAITING_LIST"` - The booking is on a waiting list.
       * - `"DECLINED"` - The booking was declined by the owner and synced to the Bookings calendar. Bookings can be manually declined using the [`declineBooking()`](https://www.wix.com/velo/reference/wix-bookings-v2/bookings/declinebooking) API by those with Manage Booking Status permission scopes. Bookings can be automatically declined when one of the following requirements are met:
       *     + Invoking the `eCommerce checkout` API and the order declined event has been sent.
       *     + Invoking the `eCommerce checkout` API and order approved event has been sent, but the booking is offline and the booking causes a double booking.
       */
      status?: BookingStatus;
      /**
       * Payment status.
       * One of:
       * - `"NOT_PAID"` The booking is not paid for.
       * - `"PAID"` The booking is fully paid.
       * - `"PARTIALLY_PAID"` The booking is partially paid.
       * - `"REFUNDED"` The booking is refunded.
       * - `"EXEMPT"` The booking is free of charge.
       */
      paymentStatus?: PaymentStatus;
      /**
       * Selected payment option.
       *
       * Supported values: `"OFFLINE"`, `"ONLINE"`, `"MEMBERSHIP"`, `"MEMBERSHIP_OFFLINE"`.
       *
       * One of the payment options offered by the service, or another option if `skipSelectedPaymentOptionValidation` is `true`.
       * When undefined, the payment option is resolved by the service configuration on checkout.
       */
      selectedPaymentOption?: SelectedPaymentOption;
      /**
       * Date and time the booking was created.
       * @readonly
       */
      _createdDate?: Date | null;
      /** External ID provided by the client app on creation. */
      externalUserId?: string | null;
      /**
       * An object describing the platform and application that made the booking.
       * @internal
       */
      bookingSource?: BookingSource;
      /**
       * The last notification used by Cancel, Confirm, Decline, or Reschedule Booking.
       * @internal
       * @deprecated
       */
      participantNotification?: ParticipantNotification;
      /**
       * When value is set to True, an SMS reminder would be sent to the phone number specified in the ContactDetails, 24 hours before the session starts.
       * @internal
       * @deprecated
       */
      sendSmsReminder?: boolean | null;
      /** Revision number to be used when updating, rescheduling, or cancelling the booking. Revision number, which increments by 1 each time the booking is updated, rescheduled, or canceled. To prevent conflicting changes,the current revision must be passed when updating the booking. */
      revision?: string | null;
      /**
       * ID of the creator of the Booking.
       * If `appId` and another ID are present, the other ID takes precedence.
       * @readonly
       */
      createdBy?: IdentificationData;
      /**
       * The start date of this booking. For a slot, this is the start date of the slot. For a schedule, this is the start date of the first session.
       * @readonly
       */
      startDate?: Date | null;
      /**
       * The end date of this booking. For a slot, this is the end date of the slot. For a schedule, this is the end date of the last session.
       * @readonly
       */
      endDate?: Date | null;
      /**
       * Sets the booking flow behavior. Some behaviors require permissions.
       * @internal
       */
      flowControlSettings?: FlowControlSettings;
      /**
       * Date and time the booking was updated.
       * @readonly
       */
      _updatedDate?: Date | null;
      /**
       * Custom field data for this object. Extended fields must be configured in the app dashboard before they can be accessed with API calls.
       * For usage of extended fields with [Wix Forms](https://dev.wix.com/docs/rest/crm/forms/form-schema-api/introduction-to-forms), after configuring your form custom fields, pass the form field values under the `_user_fields` namespace.
       * For example, if you have a custom form field named `age`, pass it as `"extendedFields":{"_user_fields": { "age": 22 }}`.
       */
      extendedFields?: ExtendedFields;
      /**
       * Whether this booking overlaps another existing confirmed booking. Returned when: `true`
       * @readonly
       */
      doubleBooked?: boolean | null;
      /**
       * whether this booking availability should be checked with v1 or v2
       * @internal
       */
      v2Availability?: boolean | null;
      /**
       * Multi service booking info of which the booking is part of.
       * @internal
       * @readonly
       */
      multiServiceBookingInfo?: MultiServiceBookingInfo;
      /**
       * The date this booking was canceled on
       * @internal
       * @readonly
       */
      canceledDate?: Date | null;
      /**
       * whether this booking availability should be checked with v1 or v2
       * @internal
       */
      v2AvailabilityProxy?: boolean | null;
      /**
       * Having booking language means that the booking was made in a secondary language, having no booking.language implies that the booking was made using the main language
       * @internal
       */
      language?: string | null;
  }
  /** @oneof */
  interface BookingParticipantsInfoOneOf {
      /** Total number of participants. Available only when the booking includes a single service variant. */
      totalParticipants?: number;
      /**
       * Information about the booked service choices and participants.
       * Available only when the booking includes multiple service variants.
       */
      participantsChoices?: ParticipantChoices;
  }
  enum MultiServiceBookingType {
      /**
       * Multi service booking will be considered available if its bookings are
       * available as returned from ListMultiServiceAvailabilityTimeSlots API.
       * See [List Multi Service Availability Time Slots] (url) documentation // todo: complete url
       */
      SEQUENTIAL_BOOKINGS = "SEQUENTIAL_BOOKINGS",
      /**
       * Multi service booking will be considered available if each of its bookings is available separately.
       * Not supported yet
       */
      SEPARATE_BOOKINGS = "SEPARATE_BOOKINGS",
      /** Not supported yet */
      PARALLEL_BOOKINGS = "PARALLEL_BOOKINGS"
  }
  interface BookedEntity extends BookedEntityItemOneOf {
      /** The booked slot, once booked becomes a session, The booking is automatically assigned to the session if it already exists, or creates a session if one doesn't already exist. */
      slot?: BookedSlot;
      /** The booked schedule. The booking is automatically assigned to the schedule's sessions. */
      schedule?: BookedSchedule;
      /**
       * Session title at the time of booking.
       * If session doesn't exist at the time of the booking, service name is used.
       * @readonly
       */
      title?: string | null;
      /**
       * If the user made the booking in a secondary language, this field will contain the translated title.
       * @internal
       * @readonly
       */
      titleTranslated?: string | null;
      /**
       * List of tags for the booking.
       * System-assigned tags for sessions and schedules are:
       * + "INDIVIDUAL" Appointments, including appointments with more than 1 participant.
       * + "GROUP" Individual classes.
       * + "COURSE" Courses.
       */
      tags?: string[] | null;
  }
  /** @oneof */
  interface BookedEntityItemOneOf {
      /** The booked slot, once booked becomes a session, The booking is automatically assigned to the session if it already exists, or creates a session if one doesn't already exist. */
      slot?: BookedSlot;
      /** The booked schedule. The booking is automatically assigned to the schedule's sessions. */
      schedule?: BookedSchedule;
  }
  interface BookedSlot {
      /**
       * ID of the underlying session when session is a single session or generated from a recurring session.
       * If `sessionId` is defined in the `Create Booking` request, the `startDate`, `endDate`, `timezone`, `resource`, and `location` fields are ignored and populated from the existing session's information.
       */
      sessionId?: string | null;
      /** Service ID. */
      serviceId?: string;
      /** Schedule ID. Required. */
      scheduleId?: string;
      /**
       * Calendar 3 event ID
       * If not empty, on all write flows (create / update) gets priority over session_id.
       * so if both session_id and event_id are provided, the session_id that will be set on the booking will be based on the event_id.
       * Otherwise, if event_id is empty on write flow,
       */
      eventId?: string | null;
      /**
       * The start time of this slot in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339)
       * format.
       */
      startDate?: string | null;
      /**
       * The end time of this slot in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339)
       * format.
       */
      endDate?: string | null;
      /** The timezone according to which the slot was shown to the user when booking, and should be shown in future. */
      timezone?: string | null;
      /**
       * The enriched resource assigned to the slot, can be either the requested resource or the resource chosen by the system.
       * When populated, the given resource will be booked according to it's availability.
       * When empty, If `skip_availability_validation` is `false`, a random available resource will be assigned to the slot upon confirmation,
       * otherwise one of the service resources will be assigned to the slot randomly upon confirmation.
       * This resource is the slot primary resource.
       */
      resource?: BookedResource;
      /** Location where the slot's session takes place. */
      location?: Location;
      /**
       * Optional.
       * In addition to the `resource` field, these are the additional enriched resources that are assigned to the slot.
       * For example the room, equipment or the additional staff member that are assigned to the slot.
       * @internal
       */
      additionalResources?: BookedResource[];
  }
  interface BookedResource {
      /** Booked resource ID. */
      _id?: string;
      /** Resource's name at the time of booking. */
      name?: string | null;
      /**
       * Resource's name translated to the language the booking was made in if applicable.
       * @internal
       * @readonly
       */
      nameTranslated?: string | null;
      /** Resource's email at the time of booking. */
      email?: string | null;
      /** Resource's schedule ID. */
      scheduleId?: string | null;
      /**
       * Indicates whether the resource was specifically requested or should be auto selected by the Server.
       * The value will be true if the resource was explicitly given in the request, otherwise false.
       * @internal
       * @readonly
       */
      explicitlyRequested?: boolean | null;
      /**
       * Resource's type.
       * @internal
       * @readonly
       */
      type?: string | null;
  }
  interface Location {
      /**
       * Business location ID. Available only for locations that are business locations,
       * meaning the `location_type` is `"OWNER_BUSINESS"`.
       */
      _id?: string | null;
      /** Location name. */
      name?: string | null;
      /** The full address of this location. */
      formattedAddress?: string | null;
      /** The full translated address of this location. */
      formattedAddressTranslated?: string | null;
      /**
       * Location type.
       *
       * - `"OWNER_BUSINESS"`: The business address, as set in the sites general settings.
       * - `"OWNER_CUSTOM"`: The address as set when creating the service.
       * - `"CUSTOM"`: The address as set for the individual session.
       */
      locationType?: LocationType;
  }
  enum LocationType {
      UNDEFINED = "UNDEFINED",
      OWNER_BUSINESS = "OWNER_BUSINESS",
      OWNER_CUSTOM = "OWNER_CUSTOM",
      CUSTOM = "CUSTOM"
  }
  interface BookedSchedule {
      /** Schedule ID. */
      scheduleId?: string;
      /** Booked service ID. */
      serviceId?: string | null;
      /**
       * Location where the schedule's sessions take place. Read only.
       * @readonly
       */
      location?: Location;
      /** The timezone according to which the slot was shown to the user when booking, and should be shown in future. */
      timezone?: string | null;
      /**
       * The start time of the first session in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339)
       * format. Required.
       * @readonly
       */
      firstSessionStart?: string | null;
      /**
       * The end time of the last session in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339)
       * format. Required.
       * @readonly
       */
      lastSessionEnd?: string | null;
  }
  interface ContactDetails {
      /** Contact's ID. */
      contactId?: string | null;
      /** Contact's first name. When populated from a standard booking form, this property corresponds to the **Name** field. */
      firstName?: string | null;
      /** Contact's last name. */
      lastName?: string | null;
      /** Contact's email, used to create a new contact or get existing one from the [Contacts API](https://www.wix.com/velo/reference/wix-crm/contacts). Used to validate coupon usage limitations per contact. If not passed, the coupon usage limitation will not be enforced. (Coupon usage limitation validation is not supported yet). */
      email?: string | null;
      /** Contact's phone number. */
      phone?: string | null;
      /** Contact's full address. */
      fullAddress?: Address;
      /**
       * Contact's time zone.
       * @deprecated
       */
      timeZone?: string | null;
      /** Contact's country in [ISO 3166-1 alpha-2 code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format. */
      countryCode?: string | null;
  }
  /** Physical address */
  interface Address extends AddressStreetOneOf {
      /** Street name, number and apartment number. */
      streetAddress?: StreetAddress;
      /** Main address line, usually street and number, as free text. */
      addressLine?: string | null;
      /** Country code. */
      country?: string | null;
      /** Subdivision. Usually state, region, prefecture or province code, according to [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). */
      subdivision?: string | null;
      /** City name. */
      city?: string | null;
      /** Zip/postal code. */
      postalCode?: string | null;
      /** Free text providing more detailed address info. Usually contains Apt, Suite, and Floor. */
      addressLine2?: string | null;
      /** A string containing the full address of this location. */
      formattedAddress?: string | null;
      /** Free text to help find the address. */
      hint?: string | null;
      /** Coordinates of the physical address. */
      geocode?: AddressLocation;
      /** Country full name. */
      countryFullname?: string | null;
      /** Multi-level subdivisions from top to bottom. */
      subdivisions?: Subdivision[];
  }
  /** @oneof */
  interface AddressStreetOneOf {
      /** Street name, number and apartment number. */
      streetAddress?: StreetAddress;
      /** Main address line, usually street and number, as free text. */
      addressLine?: string | null;
  }
  interface StreetAddress {
      /** Street number. */
      number?: string;
      /** Street name. */
      name?: string;
      /** Apartment number. */
      apt?: string;
  }
  interface AddressLocation {
      /** Address latitude. */
      latitude?: number | null;
      /** Address longitude. */
      longitude?: number | null;
  }
  interface Subdivision {
      /** Subdivision code. Usually state, region, prefecture or province code, according to [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). */
      code?: string;
      /** Subdivision full name. */
      name?: string;
  }
  interface CustomFormField {
      /** ID of the form field as defined in the form. */
      _id?: string;
      /** Value that was submitted for this field. */
      value?: string | null;
      /**
       * Form field's label at the time of submission.
       * @readonly
       */
      label?: string | null;
      /**
       * Form field value's type at the time of submission.
       *
       * Supported values: `"SHORT_TEXT"`, `"LONG_TEXT"`, `"CHECK_BOX"`
       */
      valueType?: ValueType;
  }
  enum ValueType {
      /** Short text. This is the default value type. */
      SHORT_TEXT = "SHORT_TEXT",
      /** Long text */
      LONG_TEXT = "LONG_TEXT",
      /** a text that represent the check box value: if selected the value is "true", otherwise "false". */
      CHECK_BOX = "CHECK_BOX"
  }
  /** Booking status. */
  enum BookingStatus {
      CREATED = "CREATED",
      CONFIRMED = "CONFIRMED",
      CANCELED = "CANCELED",
      PENDING = "PENDING",
      DECLINED = "DECLINED",
      WAITING_LIST = "WAITING_LIST"
  }
  /**
   * Payment status.
   * Automatically updated when using eCom checkout APIs.
   */
  enum PaymentStatus {
      UNDEFINED = "UNDEFINED",
      NOT_PAID = "NOT_PAID",
      PAID = "PAID",
      /** not supported yet. */
      PARTIALLY_PAID = "PARTIALLY_PAID",
      /** not supported yet */
      REFUNDED = "REFUNDED",
      EXEMPT = "EXEMPT"
  }
  /**
   * The selected payment option.
   * One of the payment options offered by the service.
   * This field is be set when the user selects an option during booking.
   * If left undefined, the payment option is resolved by the service configuration on checkout.
   */
  enum SelectedPaymentOption {
      UNDEFINED = "UNDEFINED",
      OFFLINE = "OFFLINE",
      ONLINE = "ONLINE",
      MEMBERSHIP = "MEMBERSHIP",
      /** Payment can only be done using a membership and must be manually redeemed in the dashboard by the site owner. */
      MEMBERSHIP_OFFLINE = "MEMBERSHIP_OFFLINE"
  }
  interface BookingSource {
      /** Platform from which a booking was created */
      platform?: Platform;
      /** Actor that created this booking. */
      actor?: Actor;
      /**
       * Wix site ID of the application that created the booking.
       * @readonly
       */
      appDefId?: string | null;
      /**
       * Name of the application that created the booking, as saved in Wix Developers Center at the time of booking.
       * @readonly
       */
      appName?: string | null;
  }
  enum Platform {
      UNDEFINED_PLATFORM = "UNDEFINED_PLATFORM",
      WEB = "WEB",
      MOBILE_APP = "MOBILE_APP"
  }
  enum Actor {
      UNDEFINED_ACTOR = "UNDEFINED_ACTOR",
      BUSINESS = "BUSINESS",
      CUSTOMER = "CUSTOMER"
  }
  interface ParticipantNotification {
      /**
       * Whether to send the message about the changes to the customer.
       *
       * Default: `false`
       */
      notifyParticipants?: boolean;
      /** Custom message to send to the participants about the changes to the booking. */
      message?: string | null;
      /**
       * Optional additional metadata.
       * Supported only in V3 APIs.
       * @internal
       */
      metadata?: Record<string, string>;
  }
  interface IdentificationData extends IdentificationDataIdOneOf {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
      /** ID of of a contact in the site's [CRM by Ascend](https://www.wix.com/ascend/crm) system. */
      contactId?: string | null;
      /**
       * @internal
       * @readonly
       */
      identityType?: IdentityType;
  }
  /** @oneof */
  interface IdentificationDataIdOneOf {
      /** ID of a site visitor that has not logged in to the site. */
      anonymousVisitorId?: string;
      /** ID of a site visitor that has logged in to the site. */
      memberId?: string;
      /** ID of a Wix user (site owner, contributor, etc.). */
      wixUserId?: string;
      /** ID of an app. */
      appId?: string;
  }
  enum IdentityType {
      UNKNOWN = "UNKNOWN",
      ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
      MEMBER = "MEMBER",
      WIX_USER = "WIX_USER",
      APP = "APP"
  }
  interface FlowControlSettings {
      /**
       * When true, skips the service defined booking-window in the booking policy.
       * Requires BOOKINGS.IGNORE_BOOKING_POLICY permissions.
       * private because it's confusing to external users - collides with skip_availability_validation
       * and yet, clients send it (though always with skip_availability_validation=true) so we're not just removing it
       * When removing, we need to use proto's `reserved` field
       * @internal
       * @deprecated
       */
      ignoreBookingWindow?: boolean;
      /**
       * When true, skips availability checking and allows booking.
       * Requires BOOKINGS.OVERRIDE_AVAILABILITY permissions.
       */
      skipAvailabilityValidation?: boolean;
      /**
       * When true, allows booking a confirmation-required service without requiring confirmation.
       * Requires BOOKINGS.IGNORE_BOOKING_POLICY permissions.
       */
      skipBusinessConfirmation?: boolean;
      /**
       * When true, skips selected payment option checking as defined in `selectedPaymentOption` field
       * and allows booking.
       * Requires BOOKINGS.MANAGE_PAYMENTS permissions.
       */
      skipSelectedPaymentOptionValidation?: boolean;
      /** When true, refunds the booking's payment when the booking is canceled. */
      withRefund?: boolean | null;
  }
  interface ExtendedFields {
      /**
       * Data Extensions extended fields expressed as a set of key-value pairs:
       *
       * `key:value`
       *
       * + `key` is the namespace, type `string`.
       * + `value` is the data of the extended fields data, type `struct`.
       */
      namespaces?: Record<string, Record<string, any>>;
  }
  interface ParticipantChoices {
      /** Information about the booked service choices. Includes the number of participants. */
      serviceChoices?: ServiceChoices[];
  }
  interface ServiceChoices {
      /** Number of participants for this variant. */
      numberOfParticipants?: number | null;
      /** Service choices for these participants. */
      choices?: ServiceChoice[];
  }
  interface MultiServiceBookingInfo {
      /**
       * Multi service booking ID.
       * @readonly
       */
      _id?: string | null;
      /** Multi service booking type. */
      type?: MultiServiceBookingType;
  }
  interface CalculatePriceResponse {
      /** Information about each line item's price and the actual total base price. */
      priceInfo?: PriceInfo;
  }
  /**
   * Previews the base price for a set of line items belonging to the same service
   * before a potential booking is actually created.
   *
   *
   *
   * The returned price preview information about each line
   * item's price and sums up each line item's price.
   *
   * The previewed price is not the actual price that will be used to charge the customer.
   * `Preview Price` only estimates the base price by adding up the price
   * of each line item before
   * the booking is actually created.
   *
   * Use [`Calculate Price`](https://www.wix.com/velo/reference/wix-bookings-v2/pricing/calculateprice) to get the base price
   * after the booking is created.
   *
   * Passing line items that belong to different services results in an error.
   *
   * ## Calculating the previewed price
   *
   * Wix Bookings has its own default pricing logic for previewing the price. You must
   * pass the `serviceId` in the `slot`
   * or `schedule` object to `previewPrice()`.
   *
   * You cannot call `previewPrice()` if you have customized Bookings pricing logic using the
   * [BookingsCustomPricing](https://dev.wix.com/docs/velo/api-reference/wix-bookings-v2/service-plugins-spis/bookings-custom-pricing/introduction) service plugin. Calling `previewPrice` if custom pricing
   * logic has been implemented for the site results in an error.
   * @param bookingLineItems - List of line items to preview the price for.
   * @public
   * @documentationMaturity preview
   * @requiredField bookingLineItems
   * @permissionId BOOKINGS.PRICE_PREVIEW
   */
  function previewPrice(bookingLineItems: BookingLineItem[]): Promise<PreviewPriceResponse>;
  /**
   * Calculates the base price of a booking.
   *
   *
   *
   * You can call `calculatePrice()` after a booking is created. The returned calculated price includes information about each line
   * item's price and the booking's total price.
   *
   * You can use `previewPrice()` to get the base price
   * before a booking is created.
   *
   * The calculated price is the base price that will be used as a basis for charging the customer.
   * During checkout, additional taxes
   * and fees might be added to this base price.
   *
   * ## Calculating the price
   *
   * Wix Bookings has its own default pricing logic for calculating the price. When
   * using Wix Bookings' default pricing logic, you must pass the `serviceId` in the `slot`
   * or `schedule` object to `calculatePrice()`.
   *
   * Alternatively you can customize the pricing logic using the
   * [BookingsCustomPricing](https://dev.wix.com/docs/velo/api-reference/wix-bookings-v2/service-plugins-spis/bookings-custom-pricing/introduction) service plugin.
   * If you integrate with a pricing provider, the customized pricing logic becomes
   * the default logic. This means that, if the Custom Pricing service plugin is implemented,
   * when calling `calculatePrice()`,
   * the customized logic is used instead.
   * @param booking - Booking to calculate the price for.
   * @public
   * @documentationMaturity preview
   * @requiredField booking
   * @permissionId BOOKINGS.PRICE_CALCULATE
   */
  function calculatePrice(booking: Booking): Promise<CalculatePriceResponse>;
  
  type bookingsV2PriceInfo_universal_d_PriceInfo = PriceInfo;
  type bookingsV2PriceInfo_universal_d_PriceInfoTotalPriceOneOf = PriceInfoTotalPriceOneOf;
  type bookingsV2PriceInfo_universal_d_BookingLineItem = BookingLineItem;
  type bookingsV2PriceInfo_universal_d_ServiceChoice = ServiceChoice;
  type bookingsV2PriceInfo_universal_d_ServiceChoiceChoiceOneOf = ServiceChoiceChoiceOneOf;
  type bookingsV2PriceInfo_universal_d_PriceDescriptionInfo = PriceDescriptionInfo;
  type bookingsV2PriceInfo_universal_d_PreviewPriceRequest = PreviewPriceRequest;
  type bookingsV2PriceInfo_universal_d_PreviewPriceResponse = PreviewPriceResponse;
  type bookingsV2PriceInfo_universal_d_CalculatePriceRequest = CalculatePriceRequest;
  type bookingsV2PriceInfo_universal_d_Booking = Booking;
  type bookingsV2PriceInfo_universal_d_BookingParticipantsInfoOneOf = BookingParticipantsInfoOneOf;
  type bookingsV2PriceInfo_universal_d_MultiServiceBookingType = MultiServiceBookingType;
  const bookingsV2PriceInfo_universal_d_MultiServiceBookingType: typeof MultiServiceBookingType;
  type bookingsV2PriceInfo_universal_d_BookedEntity = BookedEntity;
  type bookingsV2PriceInfo_universal_d_BookedEntityItemOneOf = BookedEntityItemOneOf;
  type bookingsV2PriceInfo_universal_d_BookedSlot = BookedSlot;
  type bookingsV2PriceInfo_universal_d_BookedResource = BookedResource;
  type bookingsV2PriceInfo_universal_d_Location = Location;
  type bookingsV2PriceInfo_universal_d_LocationType = LocationType;
  const bookingsV2PriceInfo_universal_d_LocationType: typeof LocationType;
  type bookingsV2PriceInfo_universal_d_BookedSchedule = BookedSchedule;
  type bookingsV2PriceInfo_universal_d_ContactDetails = ContactDetails;
  type bookingsV2PriceInfo_universal_d_Address = Address;
  type bookingsV2PriceInfo_universal_d_AddressStreetOneOf = AddressStreetOneOf;
  type bookingsV2PriceInfo_universal_d_StreetAddress = StreetAddress;
  type bookingsV2PriceInfo_universal_d_AddressLocation = AddressLocation;
  type bookingsV2PriceInfo_universal_d_Subdivision = Subdivision;
  type bookingsV2PriceInfo_universal_d_CustomFormField = CustomFormField;
  type bookingsV2PriceInfo_universal_d_ValueType = ValueType;
  const bookingsV2PriceInfo_universal_d_ValueType: typeof ValueType;
  type bookingsV2PriceInfo_universal_d_BookingStatus = BookingStatus;
  const bookingsV2PriceInfo_universal_d_BookingStatus: typeof BookingStatus;
  type bookingsV2PriceInfo_universal_d_PaymentStatus = PaymentStatus;
  const bookingsV2PriceInfo_universal_d_PaymentStatus: typeof PaymentStatus;
  type bookingsV2PriceInfo_universal_d_SelectedPaymentOption = SelectedPaymentOption;
  const bookingsV2PriceInfo_universal_d_SelectedPaymentOption: typeof SelectedPaymentOption;
  type bookingsV2PriceInfo_universal_d_BookingSource = BookingSource;
  type bookingsV2PriceInfo_universal_d_Platform = Platform;
  const bookingsV2PriceInfo_universal_d_Platform: typeof Platform;
  type bookingsV2PriceInfo_universal_d_Actor = Actor;
  const bookingsV2PriceInfo_universal_d_Actor: typeof Actor;
  type bookingsV2PriceInfo_universal_d_ParticipantNotification = ParticipantNotification;
  type bookingsV2PriceInfo_universal_d_IdentificationData = IdentificationData;
  type bookingsV2PriceInfo_universal_d_IdentificationDataIdOneOf = IdentificationDataIdOneOf;
  type bookingsV2PriceInfo_universal_d_IdentityType = IdentityType;
  const bookingsV2PriceInfo_universal_d_IdentityType: typeof IdentityType;
  type bookingsV2PriceInfo_universal_d_FlowControlSettings = FlowControlSettings;
  type bookingsV2PriceInfo_universal_d_ExtendedFields = ExtendedFields;
  type bookingsV2PriceInfo_universal_d_ParticipantChoices = ParticipantChoices;
  type bookingsV2PriceInfo_universal_d_ServiceChoices = ServiceChoices;
  type bookingsV2PriceInfo_universal_d_MultiServiceBookingInfo = MultiServiceBookingInfo;
  type bookingsV2PriceInfo_universal_d_CalculatePriceResponse = CalculatePriceResponse;
  const bookingsV2PriceInfo_universal_d_previewPrice: typeof previewPrice;
  const bookingsV2PriceInfo_universal_d_calculatePrice: typeof calculatePrice;
  namespace bookingsV2PriceInfo_universal_d {
    export {
      bookingsV2PriceInfo_universal_d_PriceInfo as PriceInfo,
      bookingsV2PriceInfo_universal_d_PriceInfoTotalPriceOneOf as PriceInfoTotalPriceOneOf,
      bookingsV2PriceInfo_universal_d_BookingLineItem as BookingLineItem,
      bookingsV2PriceInfo_universal_d_ServiceChoice as ServiceChoice,
      bookingsV2PriceInfo_universal_d_ServiceChoiceChoiceOneOf as ServiceChoiceChoiceOneOf,
      bookingsV2PriceInfo_universal_d_PriceDescriptionInfo as PriceDescriptionInfo,
      bookingsV2PriceInfo_universal_d_PreviewPriceRequest as PreviewPriceRequest,
      bookingsV2PriceInfo_universal_d_PreviewPriceResponse as PreviewPriceResponse,
      bookingsV2PriceInfo_universal_d_CalculatePriceRequest as CalculatePriceRequest,
      bookingsV2PriceInfo_universal_d_Booking as Booking,
      bookingsV2PriceInfo_universal_d_BookingParticipantsInfoOneOf as BookingParticipantsInfoOneOf,
      bookingsV2PriceInfo_universal_d_MultiServiceBookingType as MultiServiceBookingType,
      bookingsV2PriceInfo_universal_d_BookedEntity as BookedEntity,
      bookingsV2PriceInfo_universal_d_BookedEntityItemOneOf as BookedEntityItemOneOf,
      bookingsV2PriceInfo_universal_d_BookedSlot as BookedSlot,
      bookingsV2PriceInfo_universal_d_BookedResource as BookedResource,
      bookingsV2PriceInfo_universal_d_Location as Location,
      bookingsV2PriceInfo_universal_d_LocationType as LocationType,
      bookingsV2PriceInfo_universal_d_BookedSchedule as BookedSchedule,
      bookingsV2PriceInfo_universal_d_ContactDetails as ContactDetails,
      bookingsV2PriceInfo_universal_d_Address as Address,
      bookingsV2PriceInfo_universal_d_AddressStreetOneOf as AddressStreetOneOf,
      bookingsV2PriceInfo_universal_d_StreetAddress as StreetAddress,
      bookingsV2PriceInfo_universal_d_AddressLocation as AddressLocation,
      bookingsV2PriceInfo_universal_d_Subdivision as Subdivision,
      bookingsV2PriceInfo_universal_d_CustomFormField as CustomFormField,
      bookingsV2PriceInfo_universal_d_ValueType as ValueType,
      bookingsV2PriceInfo_universal_d_BookingStatus as BookingStatus,
      bookingsV2PriceInfo_universal_d_PaymentStatus as PaymentStatus,
      bookingsV2PriceInfo_universal_d_SelectedPaymentOption as SelectedPaymentOption,
      bookingsV2PriceInfo_universal_d_BookingSource as BookingSource,
      bookingsV2PriceInfo_universal_d_Platform as Platform,
      bookingsV2PriceInfo_universal_d_Actor as Actor,
      bookingsV2PriceInfo_universal_d_ParticipantNotification as ParticipantNotification,
      bookingsV2PriceInfo_universal_d_IdentificationData as IdentificationData,
      bookingsV2PriceInfo_universal_d_IdentificationDataIdOneOf as IdentificationDataIdOneOf,
      bookingsV2PriceInfo_universal_d_IdentityType as IdentityType,
      bookingsV2PriceInfo_universal_d_FlowControlSettings as FlowControlSettings,
      bookingsV2PriceInfo_universal_d_ExtendedFields as ExtendedFields,
      bookingsV2PriceInfo_universal_d_ParticipantChoices as ParticipantChoices,
      bookingsV2PriceInfo_universal_d_ServiceChoices as ServiceChoices,
      bookingsV2PriceInfo_universal_d_MultiServiceBookingInfo as MultiServiceBookingInfo,
      bookingsV2PriceInfo_universal_d_CalculatePriceResponse as CalculatePriceResponse,
      bookingsV2PriceInfo_universal_d_previewPrice as previewPrice,
      bookingsV2PriceInfo_universal_d_calculatePrice as calculatePrice,
    };
  }
  
  export { bookingsV2BookingsAppSettings_universal_d as appSettings, bookingsV2Attendance_universal_d as attendance, bookingsAvailabilityV1SlotAvailability_universal_d as availabilityCalendar, bookingsAvailabilityV2TimeSlotAvailabilityTimeSlots_universal_d as availabilityTimeSlots, bookingsFeesV1BookingFee_universal_d as bookingFees, bookingsV1BookingPolicy_universal_d as bookingPolicies, bookingsPolicySnapshotsV1BookingPolicySnapshot_universal_d as bookingPolicySnapshots, bookingsV2Booking_universal_d as bookings, bookingsAvailabilityV2TimeSlotEventTimeSlots_universal_d as eventTimeSlots, bookingsReaderV2ExtendedBooking_universal_d as extendedBookings, bookingsCalendarV2ExternalCalendar_universal_d as externalCalendars, bookingsAvailabilityV2TimeSlotMultiServiceAvailabilityTimeSlots_universal_d as multiServiceAvailabilityTimeSlots, bookingsV2PriceInfo_universal_d as pricing, bookingsResourcesV2ResourceType_universal_d as resourceTypes, bookingsResourcesV2Resource_universal_d as resources, bookingsAvailabilityV2TimeSlot_universal_d as serviceAvailability, bookingsCatalogV1ServiceOptionsAndVariants_universal_d as serviceOptionsAndVariants, bookingsServicesV2Service_universal_d as services, bookingsStaffV1StaffMember_universal_d as staffMembers };
}
